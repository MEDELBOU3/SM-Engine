<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Advanced 3D Editor</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/remixicon/fonts/remixicon.css">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Outlined" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <!--Mirror librarys-->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/theme/monokai.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/hint/show-hint.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/fold/foldgutter.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/theme/monokai.min.css">
     <!--Nanite-->
     <script src="https://threejs.org/examples/jsm/utils/BufferGeometryUtils.js"></script>
     <script src="https://threejs.org/examples/jsm/modifiers/SimplifyModifier.js"></script>
     <script src="https://unpkg.com/three@0.126.0/examples/js/modifiers/SubdivisionModifier.js"></script>
    
    <!--Coding librarys-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/javascript/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/xml/xml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/css/css.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/edit/closebrackets.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/edit/matchbrackets.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/hint/show-hint.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/hint/javascript-hint.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/fold/foldcode.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/fold/foldgutter.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/fold/brace-fold.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tern/0.24.3/tern.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/acorn/8.7.0/acorn.min.js"></script>
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.css">


    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon-es/0.20.0/cannon-es.min.js"></script>
    <script src="https://unpkg.com/three@0.155.0/examples/js/renderers/WebGPURenderer.js"></script>
    <script async src="https://threejs.org/examples/js/libs/ammo.wasm.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/three@0.149.0/build/three.min.js"></script>
     <script src="https://cdn.jsdelivr.net/npm/three@0.149.0/examples/js/utils/BufferGeometryUtils.js"></script>

    <link href='https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css' rel='stylesheet'>
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/preview.css">
    <link rel="stylesheet" href="css/tools.css">
    <link rel="stylesheet" href="css/search.css">
    <link rel="stylesheet" href="css/gui.css">
    <link rel="stylesheet" href="css/assets-panel.css">
    <link rel="stylesheet" href="css/code-editor.css">
    <link rel="stylesheet" href="css/meuni-bar.css">
    <link rel="stylesheet" href="css/timeline.css">
    <link rel="stylesheet" href="css/stor.css">
    <link rel="stylesheet" href="css/sound-editor.css">
    <link rel="stylesheet" href="css/2d-editor.css">
</head>
<body>
    
    <div class="editor-container">
       
        <div id="toggle-status" class="toolbar-group">
               
        </div>
        <div class="sidebar" id="2D-Controls" style="display: none;">
           <button class="tool-btn" id="coloring2D">
            <i class="fas fa-bars"></i>
           </button>
        </div>

        <!-- Top Toolbar -->
        <div class="sidebar" id="3D-Controls">
            <button class="tool-btn" id="toggle-lock" title="Toggle Lock">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                   <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                   <path d="M7 11V7a5 5 0 0 1 9.9-1"></path> <!-- Slightly open shackle -->
                </svg>
            </button>

            <button class="tool-btn" id="toggle-selection" title="Toggle Selection Focus">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="3"></circle>
            <path d="M8 12H5"></path>
            <path d="M19 12h-3"></path>
            <path d="M12 8V5"></path>
            <path d="M12 19v-3"></path>
            <!-- Small toggle arrows -->
            <path d="M7 10l-2 -2l2 -2"></path>
            <path d="M17 14l2 2l-2 2"></path>
        </svg>
    </button>

    <button class="tool-btn" id="guiControls" title="GUI Controls">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
            <circle cx="12" cy="12" r="3"></circle>
        </svg>
    </button>

    <button class="tool-btn" id="toggle-editor" title="Toggle Editor">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="16 18 22 12 16 6"></polyline>
            <polyline points="8 6 2 12 8 18"></polyline>
            <line x1="12" y1="4" x2="12" y2="20"></line> <!-- Visual separator, can be changed to represent merge -->
        </svg>
    </button>

    <button class="tool-btn" id="preview-button" title="Preview">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M6 9H4.5a2.5 2.5 0 0 0-2.5 2.5V15a2.5 2.5 0 0 0 2.5 2.5H6"></path>
            <path d="M18 9h1.5a2.5 2.5 0 0 1 2.5 2.5V15a2.5 2.5 0 0 1-2.5 2.5H18"></path>
            <path d="M15 12H9"></path>
            <path d="M12 9v6"></path>
            <rect x="3" y="6" width="18" height="12" rx="2"></rect>
        </svg>
    </button>

    <button class="tool-btn" id="translate" title="Translate">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="5 9 2 12 5 15"></polyline>
            <polyline points="9 5 12 2 15 5"></polyline>
            <polyline points="15 19 12 22 9 19"></polyline>
            <polyline points="19 9 22 12 19 15"></polyline>
            <line x1="2" y1="12" x2="22" y2="12"></line>
            <line x1="12" y1="2" x2="12" y2="22"></line>
        </svg>
    </button>

    <button class="tool-btn" id="rotate" title="Rotate">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21.5 2v6h-6"></path>
            <path d="M2.5 22V16h6"></path>
            <path d="M2 12a10 10 0 0 1 10-10c1.67 0 3.24.4 4.66 1.11"></path>
            <path d="M22 12a10 10 0 0 1-10 10c-1.67 0-3.24-.4-4.66-1.11"></path>
        </svg>
    </button>

    <button class="tool-btn" id="scale" title="Scale">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 3l-6 6m6 0V3m0 0H15"></path>
            <path d="M3 21l6-6m-6 0v6m0 0h6"></path>
            <path d="M21 21l-6-6m6 0v-6m0 0h-6"></path>
            <path d="M3 3l6 6m-6 0V3m0 0h6"></path>
        </svg>
    </button>

    <button class="tool-btn" id="transform-all" title="Transform (T)">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <!-- Translate Axes -->
        <line x1="12" y1="2" x2="12" y2="22"></line>
        <line x1="2" y1="12" x2="22" y2="12"></line>
        <!-- Arrowheads for translate -->
        <polyline points="12 2 10 4"></polyline> <polyline points="12 2 14 4"></polyline> <!-- Top -->
        <polyline points="22 12 20 10"></polyline><polyline points="22 12 20 14"></polyline> <!-- Right -->
        <!-- Scale handles (small squares) -->
        <rect x="10.5" y="0.5" width="3" height="3" rx="0.5"></rect>
        <rect x="20.5" y="10.5" width="3" height="3" rx="0.5"></rect>
        <rect x="10.5" y="20.5" width="3" height="3" rx="0.5"></rect>
        <rect x="0.5" y="10.5" width="3" height="3" rx="0.5"></rect>
        <!-- Rotate Arc (simplified) -->
        <path d="M19.07 4.93a10 10 0 0 0-14.14 0"></path>
        <polyline points="19.07 4.93 19.07 8.93 15.07 8.93"></polyline> <!-- Arrow for arc -->
    </svg>
</button>
    <button class="tool-btn" id="materialsEditor" title="Materials Editor">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M12 2.69l.94-2.11A2 2 0 0 1 14.82.36L16.5 2.5l2.04-.08a2 2 0 0 1 1.96 1.96l-.08 2.04 2.14 1.68a2 2 0 0 1 .18 2.81L19.31 12l2.11.94a2 2 0 0 1 .36 1.82L19.5 16.5l.08 2.04a2 2 0 0 1-1.96 1.96l-2.04.08-1.68 2.14a2 2 0 0 1-2.81.18L12 19.31l-.94 2.11a2 2 0 0 1-1.82.36L7.5 19.5l-2.04.08a2 2 0 0 1-1.96-1.96l.08-2.04-2.14-1.68a2 2 0 0 1-.18-2.81L4.69 12l-2.11-.94a2 2 0 0 1-.36-1.82L4.5 7.5l-.08-2.04a2 2 0 0 1 1.96-1.96l2.04-.08 1.68-2.14a2 2 0 0 1 2.81-.18L12 2.69z"></path>
            <path d="M12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"></path>
             <!-- Paint drip -->
            <path d="M9 18c0 1.1.9 2 2 2s2-.9 2-2v-1a1 1 0 0 1 1-1h0a1 1 0 0 1 1 1v3"></path>
        </svg>
    </button>

    <button class="tool-btn" id="addSculptingSphere" title="Sculpt">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M12 19l7-7 3 3-7 7-3-3z"></path>
            <path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path>
            <path d="M2 2l7.586 7.586"></path>
            <circle cx="11" cy="11" r="2"></circle>
        </svg>
    </button>
    

    <button class="tool-btn" id="snow-controls" title="Snow Controls">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <!-- Snowflake -->
            <line x1="12" y1="2" x2="12" y2="22"></line>
            <line x1="2" y1="12" x2="22" y2="12"></line>
            <line x1="5.64" y1="5.64" x2="18.36" y2="18.36"></line>
            <line x1="5.64" y1="18.36" x2="18.36" y2="5.64"></line>
            <!-- Snowflake arms -->
            <polyline points="12 2 10 4"></polyline>
            <polyline points="12 2 14 4"></polyline>
            <polyline points="12 22 10 20"></polyline>
            <polyline points="12 22 14 20"></polyline>
            <polyline points="2 12 4 10"></polyline>
            <polyline points="2 12 4 14"></polyline>
            <polyline points="22 12 20 10"></polyline>
            <polyline points="22 12 20 14"></polyline>
            <!-- Particles -->
            <circle cx="5" cy="8" r="0.5" fill="currentColor"></circle>
            <circle cx="19" cy="16" r="0.5" fill="currentColor"></circle>
            <circle cx="7" cy="18" r="1" fill="currentColor"></circle>
            <circle cx="17" cy="5" r="1" fill="currentColor"></circle>
            <circle cx="10" cy="14" r="0.5" fill="currentColor"></circle>
            <circle cx="14" cy="9" r="0.5" fill="currentColor"></circle>
        </svg>
    </button>

    <button class="tool-btn" id="lightControls" title="Light Controls">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="5"></circle>
            <line x1="12" y1="1" x2="12" y2="3"></line>
            <line x1="12" y1="21" x2="12" y2="23"></line>
            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
            <line x1="1" y1="12" x2="3" y2="12"></line>
            <line x1="21" y1="12" x2="23" y2="12"></line>
            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
        </svg>
    </button>

    <button class="tool-btn" id="cameraControls" title="Camera Controls">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M23 7l-7 5 7 5V7z"></path>
            <rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect>
        </svg>
    </button>

    <button class="tool-btn" id="togglePreview" title="Toggle Preview">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
            <circle cx="12" cy="12" r="3"></circle>
        </svg>
    </button>

    <button class="tool-btn" id="physicsControls" title="Physics Controls">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="1"></circle>
            <path d="M19.07 4.93a10 10 0 0 0-14.14 0"></path>
            <path d="M4.93 19.07a10 10 0 0 0 14.14 0"></path>
            <ellipse transform="rotate(45 12 12)" cx="12" cy="12" rx="10" ry="4"></ellipse>
            <ellipse transform="rotate(-45 12 12)" cx="12" cy="12" rx="10" ry="4"></ellipse>
        </svg>
    </button>

    <button class="tool-btn" id="modelingControls" title="Modeling Controls">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path>
            <polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline>
            <line x1="12" y1="22.08" x2="12" y2="12"></line>
        </svg>
    </button>

    <button class="tool-btn" id="drawingControls" title="Drawing Controls">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <!-- Original was fine, this is an alternative outline version -->
            <path d="M12 19l7-7 3 3-7 7-3-3z"></path> <!-- Pen tip -->
            <path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path> <!-- Pen body -->
            <path d="M2 2l7.586 7.586"></path> <!-- Line from tip -->
        </svg>
        <!-- Or keep your original if you prefer its style -->
        <!-- <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24"><path fill="currentColor" d="M1.999 15V2h13v5h-2V4h-9v9h3v2zm6 5V8h12v5.5h-2V10h-8v8h3.5v2zm8.778 3.684L13.41 13.378l10.258 3.407l-4.656 2.227z"/></svg> -->
    </button>

    <button class="tool-btn" id="soundControls" title="Sound Controls">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
            <path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>
            <path d="M19.07 4.93a10 10 0 0 1 0 14.14"></path>
        </svg>
    </button>
</div>
    
        <div class="toolbar">
           <style>
    /* Add this CSS to your stylesheet */
    .logo {
        display: flex;
        align-items: center;
        gap: 12px; /* Space between icon and text */
        color: #E0E0E0;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        font-weight: 600;
        font-size: 20px;
        text-decoration: none;
        cursor: pointer;
    }

    .logo__svg {
        width: 42px; /* A good, balanced size for a header logo */
        height: 42px;
        /* A simple, performant drop shadow for depth */
        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.25));
    }

    .logo__text {
        letter-spacing: 0.5px;
    }

    .logo__text-pro {
        font-size: 0.5em;
        vertical-align: super;
        margin-left: 2px;
        color: #999; /* A more subtle trademark color */
        font-weight: 400;
    }
</style>

<div class="logo">
    <svg class="logo__svg" viewBox="0 0 70 70" xmlns="http://www.w3.org/2000/svg">
        <defs>
            <!-- Gradient for the main fill of the logo shape -->
            <linearGradient id="logoMainFill" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" stop-color="#2c3e50" /> <!-- Deep Slate Blue -->
                <stop offset="100%" stop-color="#1c2833" /> <!-- Darker Slate -->
            </linearGradient>

            <!-- Gradient for the outer stroke (border) -->
            <linearGradient id="logoOuterStroke" x1="0%" y1="100%" x2="100%" y2="0%">
                <stop offset="0%" stop-color="#4e5b6b" />
                <stop offset="100%" stop-color="#7e8c9d" />
            </linearGradient>
            
            <!-- A sharp, bright gradient for the inner highlight to create a 3D bevel effect -->
            <linearGradient id="logoInnerHighlight" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" stop-color="#66b3ff" /> <!-- Light Blue -->
                <stop offset="100%" stop-color="#89cff0" /> <!-- Lighter Sky Blue -->
            </linearGradient>
        </defs>

        <!-- The single, continuous path that defines your logo's unique shape -->
        <path fill="url(#logoMainFill)" 
              stroke="url(#logoOuterStroke)" 
              stroke-width="2" 
              stroke-linejoin="round"
              d="M10 60 L10 15 L20 10 L35 10 L45 10 L60 10 L60 55 L55 60 L35 60 L30 55 L30 35 L40 30 L40 15 L35 10 M30 35 L40 30" />
        
        <!-- 
          Inner path for the 3D highlight. This is slightly inset from the main path.
          It gives a sharp, clean bevel effect without a slow filter.
        -->
        <path fill="none"
              stroke="url(#logoInnerHighlight)"
              stroke-width="1.5"
              stroke-linejoin="round"
              opacity="0.8"
              d="M12 58 L12 16 L21 12 L35 12 L44 12 L58 12 L58 54 L54 58 L35 58 L32 54 L32 36 L39 32 L39 16" />
    </svg>
    
</div>
            <div class="toolbar-group">
                <button class="tool-button" id="newScene">
                    <i class="fas fa-file"></i> New
                </button>
                <button class="tool-button" id="saveScene">
                    <i class="fas fa-save"></i> Save
                </button>
                <button class="tool-button" id="loadScene">
                    <i class="fas fa-folder-open"></i> Load
                </button>
                <button class="tool-button" onclick="toggleAssetsPanel()">
                    Assets
                </button>
                <button class="tool-button">Export</button>
                <button class="tool-button" id="toggle-inspector">
                    Inspector
                </button>
            </div>
            <div class="toolbar-group">
                <button class="tool-button" id="menuButton" style="background-color: #555; margin: 8px auto; width: 25px; height: 25px;">
                    <i class="fas fa-bars"></i>
                </button>
                <div id="submenuMainBar" class="submenu-main-bar">
                    <div class="menu-item-br" data-submenu="fileMenu">File</div>
                    <div class="menu-item-br" data-submenu="editMenu">Edit</div>
                    <div class="menu-item-br" data-submenu="helpMenu">Help</div>
                </div>
        
                <!-- Child Submenus -->
                <div id="fileMenu" class="child-submenu">
                    <div>New</div>
                    <div>Open</div>
                    <div>Save</div>
                    <div>Export</div>
                </div>
        
                <div id="editMenu" class="child-submenu">
                    <div>Undo</div>
                    <div>Redo</div>
                    <div>Copy</div>
                    <div>Paste</div>
                </div>
        
                <div id="helpMenu" class="child-submenu">
                    <div>Documentation</div>
                    <div>About</div>
                    <div>Support</div>
                </div>

                <button id="toggleContainerButton" class="tool-button" style="background-color: #555;  cursor: pointer; margin: 8px auto; width: 25px; height: 25px;">
                    <svg id="toggle-status" style="justify-content: center; align-items: center; " xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 25 25">
                        <path id="icon-path" d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1-13h2v6h-2z" fill="#00bcd4"/>
                    </svg>
                </button>
                <button class="tool-button" id="toggle-3d-mode" >3D</button>
                <button class="tool-button" id="toggle-2d-mode">2D</button>

            </div>

            <div id="toolbar-group-shapes" class="tool-button">
                <button class="tool-button" id="shapeButton">
                   Shapes
                </button>
                <div id="shapeMenu" class="menu">
                    <button id="addCube"><i class='bx bx-cube-alt'></i> Cube</button>
                    <button id="addPlane"><i class="fas fa-square"></i> Plane</button>
                    <button id="addTerrain"><i class="fas fa-border-all"></i> Terrain</button>
                    <button id="addSphere"><i class="fas fa-circle"></i> Sphere</button>
                    <button id="addCylinder"><i class='bx bx-cylinder'></i> Cylinder</button>
                    <button id="addRectangularPrism"><i class='bx bx-cuboid'></i> Prism</button>
                    <button id="addPyramid"><i class='bx bxs-pyramid'></i> Pyramid</button>
                    <button id="addTorus"><i class="fas fa-ring"></i> Torus</button>
                    <button class="tool-button" id="addCone">
                        <svg width="16" height="16" viewBox="0 0 24 24" style="margin-right:6px">
                           <path d="M12 3L3 21H21L12 3Z" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round"/>
                           <ellipse cx="12" cy="18" rx="6" ry="2" stroke="currentColor" stroke-width="1.5"/>
                        </svg>
                        Cone
                    </button>
                    <button id="addRoundedBox"><i class='bx bx-cube'></i> Rounded Box</button>
                    <button id="addIcosahedron"><i class="fas fa-gem"></i> Icosahedron</button>
                    <button id="addTorusKnot">
                        <svg width="16" height="16" viewBox="0 0 24 24" style="margin-right:6px">
                            <path d="M12 3C15 3 21 6 21 12C21 18 15 21 12 21C9 21 3 18 3 12C3 6 9 3 12 3Z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="M12 3C15 9 15 15 12 21" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                            <path d="M12 3C9 9 9 15 12 21" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                        </svg>
                        Torus Knot
                    </button>
                </div>
            </div>
            <script>

                document.addEventListener("DOMContentLoaded", function () {
                    const menuButton = document.getElementById("menuButton");
                    const submenuMainBar = document.getElementById("submenuMainBar");
                    const menuItems = document.querySelectorAll(".menu-item-br");
                    const childSubmenus = document.querySelectorAll(".child-submenu");

                    const shapeButton = document.getElementById('shapeButton');
                    const shapeMenu = document.getElementById('shapeMenu');

                    const cameraButton = document.getElementById('cameraTools');
                    const cameraMenu = document.getElementById('cameraMenu');

                    // Toggle main menu
                    if (menuButton && submenuMainBar) {
                        menuButton.addEventListener("click", function (e) {
                            submenuMainBar.classList.toggle("active");
                            e.stopPropagation();
                        });
                    }

                    // Handle menu item hover (submenu inside main bar)
                    if (menuItems.length > 0) {
                        menuItems.forEach(item => {
            item.addEventListener("mouseenter", function () {
                closeChildMenus();
                const submenuId = this.getAttribute("data-submenu");
                const targetSubmenu = document.getElementById(submenuId);
                if (targetSubmenu) {
                    targetSubmenu.classList.add("active");

                    // Position submenu relative to parent item
                    const rect = this.getBoundingClientRect();
                    targetSubmenu.style.top = `${rect.top}px`;
                    targetSubmenu.style.left = `${rect.right + 5}px`;
                }
            });
        });
    }

    // Toggle shape menu
    if (shapeButton && shapeMenu) {
        shapeButton.addEventListener('click', function (event) {
            event.stopPropagation();
            shapeMenu.classList.toggle('show');
        });
    }

    // Toggle camera menu
    if (cameraButton && cameraMenu) {
        cameraButton.addEventListener('click', function (event) {
            event.stopPropagation();
            cameraMenu.classList.toggle('show');
        });
    }

    // Prevent closing when clicking inside submenu main bar
    if (submenuMainBar) {
        submenuMainBar.addEventListener("click", function (e) {
            e.stopPropagation();
        });
    }

    // Close all menus when clicking outside
    document.addEventListener("click", function (e) {
        if (!e.target.closest('.toolbar-group')) {
            if (submenuMainBar) submenuMainBar.classList.remove("active");
            closeChildMenus();
        }

        if (shapeMenu && shapeMenu.classList.contains('show')) {
            shapeMenu.classList.remove('show');
        }

        if (cameraMenu && cameraMenu.classList.contains('show')) {
            cameraMenu.classList.remove('show');
        }
    });

    // Helper function: close all child submenus
    function closeChildMenus() {
        if (childSubmenus.length > 0) {
            childSubmenus.forEach(submenu => {
                submenu.classList.remove("active");
            });
        }
    }
});

            </script>
            <div class="toolbar-group">
                <button class="tool-button" id="addLight">
                     Light
                </button>
                <button class="tool-button" id="addCameraInit">
                     Camera
                </button>
            </div>
            <div id="toolbar-group-camera">
                <button  id="cameraTools" title="camera controls" class="camera-tool-button" style="background-color: transparent; font-size: 10px; padding: 3px 5px; border: none; outline: none; color: #fff;">
                    <i class="fas fa-info-circle"></i> Camera
                </button>
                <div id="cameraMenu" class="menu">
                    <button class="tool-button" id="addPointBtn">
                        <i class="fa-solid fa-bezier-curve"></i> Add Point
                    </button>
                    <button class="tool-button" id="startCameraBtn">
                        <i class="fa-solid fa-person-walking-arrow-loop-left"></i> Start Camera
                    </button>
                    <button class="tool-button" id="toggleLookAtBtn">
                        <i class="fas fa-eye"></i> Toggle Look At
                    </button>
                    <button  class="tool-button" id="toggleEditBtn">Enable Edit
                    </button>
                    <button class="tool-button" id="startRecordingBtn">
                        <i class='bx bxs-video-recording'></i> Start Recording
                    </button>
                    <button class="tool-button" id="stopRecordingBtn">
                        <i class='bx bx-stop-circle'></i> Stop Recording
                    </button>
                </div>
            </div>
            <div class="toolbar-group">
                <div id="statusBar" style="max-width: 80px; font-size: 12px;">
                    <span id="recordingStatus" title="Recording Stopped">
                     <!-- Icon for STOPPED state (default) -->
                    <span id="recordingTimer" style="font-size: 13px; color: red;">00:00</span>
                </div>
            </div>

            <style>   
                #recordingStatus {
                    display: inline-flex; /* To align SVG correctly if it has descendants */
                    align-items: center;
                }

                .status-icon {
                   /* SVG inherits color from parent by default if stroke/fill is 'currentColor' */
                   /* For the active icon, fill is hardcoded to red */
                   vertical-align: middle; /* Helps with inline alignment */
                }

                #recordingTimer {
                   font-size: 0.9em;
                }
            </style>
           <!--
            <div class="toolbar-group">
                <div  class="tool-button-status" id="statusBar">
                    <span id="recordingStatus">
                        Reco: Stop
                    </span>
                    <span id="recordingTimer">00:00</span>
                </div>
            </div>
            -->
            <div class="toolbar-group">
                <button class="tool-button"  id="node-editor-toggle">Node</button>
            </div>

            <div class="tool-button" id="node-editor-button-grp">
                
            </div>

            <div class="toolbar-group">
                <button class="tool-button"  id="toggleAnimator">Animator</button>
            </div>
            <div class="toolbar-group">
                <button class="tool-button" id="toggle-animator-btn">Open Animator</button>
            </div>
            <div class="toolbar-group">
                <button id="siteModalBtn" class="tool-button">Stor</button>
            </div>

            <button class="tool-button" id="renderingBTN">
                rendering
            </button>

            <div class="mini-dropdown" id="renderingMenu">
                <button id="toggleCleanRender">Clean Render</button>
                 <!-- Add more options here if needed -->
            </div>

        </div>
        <script src="js/stor.js"></script>
        <!-- Left Panel - Hierarchy -->
        <div id="hierarchy-panel"  class="hierarchy-panel">
            <div class="panel-header" style="cursor: pointer;">
                <i class="fas fa-sitemap" ></i> Hierarchy 
                <select id="hierarchyViewMode" style="margin-top: 5px; margin-left: 9px; width: 45%;">
                    <option value="tree">üìÅ Tree View</option>
                    <option value="flat">üìã Flat View</option>
                    <option value="type">üß† Type View</option>
                </select>
                <span class="expand-button"  style="margin-left: 9px; margin-right: 20px;">
                    ‚ñº
                </span>
            </div>
            <div class="panel-content" style="padding: 0;  height: 100%; overflow-y: auto;">
                <div class="hierarchy-search">
                    <input type="text" id="hierarchy-search-input" placeholder="Search objects...">
                    <button id="hierarchy-search-clear">√ó</button>
                </div>

                <div class="hierarchy-content" id="hierarchy-content">
                    <!-- Hierarchy items will be added here dynamically -->
                </div>
            </div>
            <div class="panel-header">
                <i class="fa-solid fa-paint-brush"></i> Brush Model Settings
                <span class="expand-button"  style="margin-left: 30px;">‚ñº</span>
            </div>
            <div class="panel-content" style="padding: 0; height: 100%;">
                <div id="brush-panel" >
                    <div class="brush-controls" >
                        <label>Brush Size</label>
                        <input type="range" id="brush-size" min="0.5" max="10" step="0.1" value="2">

                        <label>Density</label>
                        <input type="range" id="brush-density" min="1" max="20" value="5">

                        <label>Upload Model</label>
                        <input type="file" id="model-upload" accept=".glb,.gltf">
                    
                    <div class="brush-actions" style="margin: 10px auto;  display: flex;">
                        <button class="brush-button" onclick="brushSystem.undo()">Undo</button>
                        <button class="brush-button" onclick="brushSystem.redo()">Redo</button>
                    </div>
                </div>
            </div>
            </div>
               
            <div class="resize-handle-hierarchy"></div>
        </div>

        <!-- Main Viewport -->
        <div class="editor-scene" style=" width: 80%; height: 100%; right: 0;">
            <div id="renderer-container" class="renderer-container">
                <div id="render-container" class="axis-controls-container">
                    <div id="axis-controls" class="axis-controls">
                        <div class="axis-button" id="axis-x" onclick="setCameraView('x')">X</div>
                        <div class="axis-button" id="axis-y" onclick="setCameraView('y')">Y</div>
                        <div class="axis-button" id="axis-z" onclick="setCameraView('z')">Z</div>
                        <div class="axis-button" id="top" onclick="setCameraView('top')"><i class="fa-solid fa-arrow-up-long"></i></div>
                        <div class="axis-button" id="bottom" onclick="setCameraView('bottom')"><i class="fa-solid fa-arrow-down"></i></div>
                        <div class="axis-button" id="diagonal" onclick="setCameraView('diagonal')"><i class="fa-solid fa-square-arrow-up-right"></i></div>
                    </div> 
                </div>
            </div>
        </div>
        <div class="render-preview-window" id="previewWindow">
            <div class="preview-header">
                <div class="preview-title">Render Preview</div>
                <button class="close-preview" id="closePreview">√ó</button>
            </div>
           <canvas class="preview-canvas" id="previewCanvas" width="400" height="300"></canvas>
        </div>

        <!--<div class="viewport" id="viewportRenderer"></div>-->
            
        <canvas id="selectionCanvas" style="
            position: absolute;
            top: 0;
            left: 0;
            z-index: 10;
            pointer-events: none;
        "></canvas>

        <!-- Right Panel - Inspector -->
        <div id="inspector-panel" class="inspector-panel">
            
            <div class="panel-header">
                <i class="fas fa-info-circle"></i> Inspector
                <span class="expand-button">‚ñº</span>
            </div>

            <div class="search-group">
                <input type="text" id="search-input" class="search-input" placeholder="Search..." />
            </div>
        
            <div class="property-group1" id="GuiContainer" style="display: none;">
                <div id="gui-container">
                   <!--Gui Interface-->
                </div>
            </div>
            <div class="property-group">
                <h3>Transform</h3>
                <div class="property-row">
                    <span class="property-label">Pos</span>
                    <div class="vector-inputs">
                        <input type="number" class="property-input" id="posX" step="0.1">
                        <input type="number" class="property-input" id="posY" step="0.1">
                        <input type="number" class="property-input" id="posZ" step="0.1">
                    </div>
                </div>
                <div class="property-row">
                    <span class="property-label">Rot</span>
                    <div class="vector-inputs">
                        <input type="number" class="property-input" id="rotX" step="0.1">
                        <input type="number" class="property-input" id="rotY" step="0.1">
                        <input type="number" class="property-input" id="rotZ" step="0.1">
                    </div>
                </div>
                <div class="property-row">
                    <span class="property-label">Scl</span>
                    <div class="vector-inputs">
                        <input type="number" class="property-input" id="scaleX" step="0.1">
                        <input type="number" class="property-input" id="scaleY" step="0.1">
                        <input type="number" class="property-input" id="scaleZ" step="0.1">
                    </div>
                </div>
                <div class="precision-controls">
                    <!--The content will be add automaticly -->
                </div>
            </div>
            <div class="inspector-2d" id="inspector2D" style="display: none; padding: 8px;">
                <div class="panel-header">
                    <i class="fas fa-info-circle"></i> 2D painting brush
                    <span class="expand-button">‚ñº</span>
                </div>
                <div class="control-group">
                    <label for="brushColor">Brush Color:</label>
                    <input type="color" id="brushColor" value="#ffffff" />
                </div>
                <div class="slider-container">
                   <label for="brushSize">Brush Size:</label>
                   <input type="range" id="brushSize" min="1" max="20" value="3" />
                </div>
                <button class="panel-button" id="clearCanvasBtn">Clear Canvas</button>
                <button class="panel-button" id="undoBtn">Undo</button>
            </div>
            <div class="physics-controls" id="physics-controls" style="display: none;">
                <h3>Physics Forces</h3>
                <button class="panel-button" id="apply-physics" >Apply Physics</button>
                <div class="control-group">
                    <div class="slider-container">
                        <label>Gravity:</label>
                        <input type="range" id="gravity-strength" min="-20" max="20" value="-9.81" step="0.1">
                        <span id="gravity-value">-9.81</span>
                    </div>
                </div>
            
                <!-- ÿ•ÿ∂ÿßŸÅÿ© ÿÆÿµÿßÿ¶ÿµ ÿßŸÑŸÅŸäÿ≤Ÿäÿßÿ° ŸÑŸÑŸÉÿßÿ¶ŸÜÿßÿ™ -->
                <div class="control-group">
                    <h4>Object Physics Properties</h4>
                    <div class="slider-container">
                        <label>Mass:</label>
                        <input type="range" id="mass" min="0" max="20" value="5" step="0.1">
                        <span id="mass-value">5</span>
                    </div>
                    <div class="slider-container">
                        <label>Friction:</label>
                        <input type="range" id="friction" min="0" max="1" value="0.9" step="0.01">
                        <span id="friction-value">0.9</span>
                    </div>
                    <div class="slider-container">
                        <label>Restitution (Bounciness):</label>
                        <input type="range" id="restitution" min="0" max="1" value="0.7" step="0.01">
                        <span id="restitution-value">0.7</span>
                    </div>
                </div>
            
                <!-- ÿ•ÿ∂ÿßŸÅÿ© ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿ™ÿµÿßÿØŸÖ -->
                <div class="control-group">
                    <h4>Collision Settings</h4>
                    <label>Collision Group:</label>
                    <select id="collision-group">
                        <option value="1">Default (1)</option>
                        <option value="4" selected>Dynamic Objects (4)</option>
                        <option value="8">Kinematic (8)</option>
                        <option value="16">Wind Affected (16)</option>
                    </select>
            
                    <label>Collision Mask:</label>
                    <div>
                        <input type="checkbox" id="mask-default" value="1" checked> Default (1)<br>
                        <input type="checkbox" id="mask-terrain" value="2" checked> Terrain (2)<br>
                        <input type="checkbox" id="mask-dynamic" value="4" checked> Dynamic Objects (4)<br>
                        <input type="checkbox" id="mask-kinematic" value="8"> Kinematic (8)<br>
                        <input type="checkbox" id="mask-wind" value="16"> Wind Affected (16)
                    </div>
                </div>
            
                <div class="control-group">
                    <h4>Wind Zone</h4>
                    <div class="slider-container">
                        <label>Strength:</label>
                        <input type="range" id="wind-strength" min="0" max="50" value="10" step="0.1">
                        <span id="wind-value">10</span>
                    </div>
                    <div class="slider-container">
                        <label>Radius:</label>
                        <input type="range" id="wind-radius" min="1" max="50" value="10" step="0.5">
                        <span id="radius-value">10</span>
                    </div>
                </div>
                <div class="force-buttons">
                    <button class="force-button" id="add-wind">Add Wind Zone</button>
                    <button class="force-button" id="add-vortex">Add Vortex</button>
                </div>
            
                <div class="card">
                    <h2>Cloth Physics Controls</h2>
                    <div id="controls">
                        <button class="panel-button" id="addCloth">Add cloth</button>
                        <button class="panel-button" id="toggleWind">Change Wind</button>
                        <button class="panel-button" id="removeCloth">Remove cloth</button>
                    </div>
                </div>

                <div id="physics-clothing-panel" class="gui-panel">
                   <div class="panel-header">
                      <h3>Physics Clothing</h3>
                      <span class="expand-button">‚ñº</span>
                   </div>

                   <div id="physics-status-text" class="status-text">
                      <div class="control-group">
                        <label><span>Width:</span><span id="cloth-width-val">7</span></label>
                        <input type="range" id="cloth-width-slider" min="2" max="20" value="7" step="0.5">
                    </div>
                    <div class="control-group">
                       <label><span>Height:</span><span id="cloth-height-val">5</span></label>
                       <input type="range" id="cloth-height-slider" min="2" max="20" value="5" step="0.5">
                    </div>
                    <div class="control-group">
                        <label><span>Segments:</span><span id="cloth-segments-val">30</span></label>
                        <input type="range" id="cloth-segments-slider" min="10" max="60" value="30" step="1">
                    </div>
                    <div class="control-group">
                        <button id="drape-cloth-btn">Drape New Cloth Over Selection</button>
                        <button id="make-collider-btn">Make Selection a Collider</button>
                        <button id="remove-physics-btn" style="background-color:#c82333;">Remove Physics from Selection</button>
                    </div>
                   </div>
    
                </div>
            </div> 


            <style>
                .card { width: 100%; padding: 5px;  }
                .slider-container { margin-bottom: 15px; }
                .label { display: flex; justify-content: space-between; }
                .separator { border-top: 1px solid #ddd; margin: 15px 0; }
                .switch { cursor: pointer; }
            </style>
           


            <script>
                document.getElementById('apply-physics').addEventListener('click', () => {
    // ŸÇÿ±ÿßÿ°ÿ© ÿßŸÑŸÇŸäŸÖ ŸÖŸÜ ÿßŸÑŸÖÿØÿÆŸÑÿßÿ™
    const mass = parseFloat(document.getElementById('mass').value);
    const friction = parseFloat(document.getElementById('friction').value);
    const restitution = parseFloat(document.getElementById('restitution').value);
    const collisionGroup = parseInt(document.getElementById('collision-group').value);

    // ÿ≠ÿ≥ÿßÿ® Collision Mask ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑŸÄ checkboxes
    let collisionMask = 0;
    if (document.getElementById('mask-default').checked) collisionMask |= physicsManager.collisionGroups.DEFAULT;
    if (document.getElementById('mask-terrain').checked) collisionMask |= physicsManager.collisionGroups.TERRAIN;
    if (document.getElementById('mask-dynamic').checked) collisionMask |= physicsManager.collisionGroups.DYNAMIC_OBJECTS;
    if (document.getElementById('mask-kinematic').checked) collisionMask |= physicsManager.collisionGroups.KINEMATIC;
    if (document.getElementById('mask-wind').checked) collisionMask |= physicsManager.collisionGroups.WIND_AFFECTED;

    // ÿ™ÿ∑ÿ®ŸäŸÇ ÿßŸÑŸÅŸäÿ≤Ÿäÿßÿ° ÿπŸÑŸâ ÿßŸÑŸÉÿßÿ¶ŸÜ ÿßŸÑŸÖÿÆÿ™ÿßÿ±
    if (selectedObject && !selectedObject.userData.physicsBody) {
        physicsManager.addPhysicsToObject(selectedObject, {
            mass: mass,
            friction: friction,
            restitution: restitution,
            group: collisionGroup,
            mask: collisionMask
        });
        console.log("Physics applied to", selectedObject.name, "with values:", {
            mass, friction, restitution, collisionGroup, collisionMask
        });
    } else if (selectedObject && selectedObject.userData.physicsBody) {
        console.warn("Physics already applied to", selectedObject.name);
    } else {
        console.warn("No object selected.");
    }

    // ÿ™ÿ∑ÿ®ŸäŸÇ ÿ£Ÿà ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÅŸäÿ≤Ÿäÿßÿ° ŸÑŸÑÿ™ÿ∂ÿßÿ±Ÿäÿ≥
    if (terrain) {
        applyPhysicsToTerrain();
        console.log("Physics applied/updated for terrain");
    } else {
        console.warn("No terrain found in the scene.");
    }
});

function applyPhysicsToTerrain() {
    const width = 50;
    const height = 50;
    const widthSegments = 100;
    const heightSegments = 100;

    if (terrain.userData.physicsBody) {
        world.removeBody(terrain.userData.physicsBody);
    }

    const vertices = terrain.geometry.attributes.position.array;
    const matrix = [];

    for (let z = 0; z <= heightSegments; z++) {
        const row = [];
        for (let x = 0; x <= widthSegments; x++) {
            const index = (z * (widthSegments + 1) + x) * 3 + 1;
            row.push(vertices[index]);
        }
        matrix.push(row);
    }

    const heightfieldShape = new CANNON.Heightfield(matrix, {
        elementSize: width / widthSegments
    });

    const heightfieldBody = new CANNON.Body({
        mass: 0, // ÿ´ÿßÿ®ÿ™ (static)
        shape: heightfieldShape,
        material: physicsManager.materials.default,
        collisionFilterGroup: physicsManager.collisionGroups.TERRAIN,
        collisionFilterMask: physicsManager.collisionGroups.DEFAULT | physicsManager.collisionGroups.DYNAMIC_OBJECTS
    });

    heightfieldBody.position.set(-width / 2, 0, height / 2);
    heightfieldBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);

    world.addBody(heightfieldBody);
    terrain.userData.physicsBody = heightfieldBody;
}

                document.addEventListener('DOMContentLoaded', () => {
                    // ÿ™ÿ≠ÿØŸäÿ´ ŸÇŸäŸÖ ÿßŸÑÿπÿ±ÿ∂ ŸÑŸÄ Mass
                    const massInput = document.getElementById('mass');
                    const massValue = document.getElementById('mass-value');
                    massInput.addEventListener('input', () => {
                      massValue.textContent = massInput.value;
                    });

                    // ÿ™ÿ≠ÿØŸäÿ´ ŸÇŸäŸÖ ÿßŸÑÿπÿ±ÿ∂ ŸÑŸÄ Friction
                    const frictionInput = document.getElementById('friction');
                    const frictionValue = document.getElementById('friction-value');
                    frictionInput.addEventListener('input', () => {
                        frictionValue.textContent = frictionInput.value;
                    });
       
                    // ÿ™ÿ≠ÿØŸäÿ´ ŸÇŸäŸÖ ÿßŸÑÿπÿ±ÿ∂ ŸÑŸÄ Restitution
                    const restitutionInput = document.getElementById('restitution');
                    const restitutionValue = document.getElementById('restitution-value');
                    restitutionInput.addEventListener('input', () => {
                        restitutionValue.textContent = restitutionInput.value;
                    });

                    // Gravity listener (ŸÖŸàÿ¨ŸàÿØ ÿ®ÿßŸÑŸÅÿπŸÑÿå ŸÑŸÉŸÜ ŸÜÿ∂ŸÖŸÜ ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿπÿ±ÿ∂)
                    const gravityInput = document.getElementById('gravity-strength');
                    const gravityValue = document.getElementById('gravity-value');
                    gravityInput.addEventListener('input', (e) => {
                        const value = parseFloat(e.target.value);
                        world.gravity.set(0, value, 0);
                        gravityValue.textContent = value.toFixed(2);
                    });
                });

                
                function applyPhysicsToSelectedObject(object) {
                    const shape = getCannonShapeFromObject(object);
                    if (!shape) {
                        console.error("Unable to determine physics shape for object.");
                        return;
                    }

                    const body = new CANNON.Body({
                        mass: 5, // Set mass to make it fall
                        shape: shape,
                        position: new CANNON.Vec3(object.position.x, object.position.y, object.position.z),
                        quaternion: new CANNON.Quaternion(object.quaternion.x, object.quaternion.y, object.quaternion.z, object.quaternion.w),
                    });
               
                    world.addBody(body);
                    object.userData.physicsBody = body;
                }

                // Function to determine the appropriate CANNON.js shape
                function getCannonShapeFromObject(object) {
                    if (object.geometry instanceof THREE.BoxGeometry) {
                        const size = new THREE.Vector3();
                        object.geometry.computeBoundingBox();
                        object.geometry.boundingBox.getSize(size);
                        return new CANNON.Box(new CANNON.Vec3(size.x / 2, size.y / 2, size.z / 2));
                    }
                    if (object.geometry instanceof THREE.SphereGeometry) {
                      return new CANNON.Sphere(object.geometry.parameters.radius);
                    }
                    return null;
                }

            </script>
            <div class="viewport-container" style="display: none;">                
                <div class="model-preview-container">
                <canvas id="preview-canvas"></canvas>
                <div class="model-info">
                <span class="model-name"></span>
                <div class="model-stats"></div>
            </div>

            </div>
           </div>

           <div class="sound-controls-meter" id="sound-controls-meter" style=" display: none;">
    <div class="meter-section"> <!-- PARENT of the two .meter-group -->
        <div class="meter-group">  <!-- Meter Group 1 (e.g., Input Meters) -->
            <h3 class="meter-title">Input Meters</h3>
            <div class="meter-container">
                <div class="meter-fill" id="leftMeter"></div>
            </div>
            <div class="meter-container">
                <div class="meter-fill" id="rightMeter"></div>
            </div>
        </div>

        <div class="meter-group">  <!-- Meter Group 2 (e.g., Master Output) -->
            <h3 class="meter-title">Master Output</h3>
            <div class="meter-container">
                <div class="meter-fill" id="masterMeter"></div>
            </div>
        </div>
    </div>
</div>
          

        <div class="sound-controls-header-vis"  id="sound-controls-vis"  style="display: none;">
            <main class="main-content-sound">
                <div class="visualization-container">
                    <div class="viz-panel">
                        <div class="viz-header">Spectrum Analyzer</div>
                        <canvas id="spectrumCanvas" width="600" height="200"></canvas>
                    </div>
                    <div class="viz-panel">
                        <div class="viz-header">Waveform & Vectorscope</div>
                        <canvas id="waveformCanvas" width="600" height="200"></canvas>
                    </div>
                    <div class="viz-panel">
                        <div class="viz-header">Phase Correlation</div>
                        <canvas id="phaseCanvas" width="600" height="200"></canvas>
                    </div>
                </div>
    
                <div class="effect-rack">
                    <div class="effect-module">
                        <div class="effect-header">
                            <span class="effect-title">Parametric EQ</span>
                            <button class="btn" id="eqToggle">On</button>
                        </div>
                        <canvas id="eqCanvas" height=" 180"></canvas>
                        <div class="eq-controls" style="display: flex; flex-wrap: wrap; gap: 15px;"></div>
                    </div>
    
                    <div class="effect-module">
                        <div class="effect-header">
                            <span class="effect-title">Dynamics Processor</span>
                            <button class="btn" id="dynToggle">On</button>
                        </div>
                        <canvas id="dynamicsCanvas" height=" 180"></canvas>
                        <div class="dynamics-controls"></div>
                    </div>
    
                    <div class="effect-module">
                        <div class="effect-header">
                            <span class="effect-title">Reverb</span>
                            <button class="btn" id="reverbToggle">On</button>
                        </div>
                        <div class="reverb-controls"></div>
                    </div>
                </div>
            </main>
           </div>

           

            
        <div class="modeling-tools" id="modelingTools" style="display: none;">
            <div class="panel-header">
                <span>Mesh Manipulation Tools</span>
                <span class="expand-button" style="margin-left: 9px;">
                    ‚ñº
                </span>
            </div>
            <div class="panel-content">
               
                
                <div class="selection-controls">
                    <button id="toggle-modeling" class="panel-button">Modeling Mode</button>
                    <div class="button-container">
                        <button id="select-vertex" class="panel-button-tool" disabled>
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <path d="M4 6L12 4L20 6L20 14L12 16L4 14L4 6Z" fill="none" stroke="currentColor" stroke-width="2"/>
                                <path d="M4 6L12 8L20 6" fill="none" stroke="currentColor" stroke-width="2"/>
                                <path d="M12 8L12 16" fill="none" stroke="currentColor" stroke-width="2"/>
                                <circle cx="12" cy="8" r="1" fill="red"/>
                            </svg>
                        </button>
                    
                        <button id="select-edge" class="panel-button-tool" disabled>
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <path d="M4 6L12 4L20 6L20 14L12 16L4 14L4 6Z" fill="none" stroke="currentColor" stroke-width="2"/>
                                <path d="M4 6L12 8L20 6" fill="none" stroke="currentColor" stroke-width="2"/>
                                <path d="M12 8L12 16" fill="none" stroke="currentColor" stroke-width="2"/>
                                <line x1="4" y1="6" x2="12" y2="8" stroke="blue" stroke-width="2"/>
                                <line x1="12" y1="8" x2="20" y2="6" stroke="blue" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <button id="select-face" class="panel-button-tool" disabled>
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <path d="M4 6L12 4L20 6L20 14L12 16L4 14L4 6Z" fill="none" stroke="currentColor" stroke-width="2"/>
                                <path d="M4 6L12 8L20 6" fill="none" stroke="currentColor" stroke-width="2"/>
                                <path d="M12 8L12 16" fill="none" stroke="currentColor" stroke-width="2"/>
                                <rect x="8" y="10" width="6" height="6" fill="green"/>
                            </svg>
                        </button>
                        <button onclick="mergeActiveGeometry()">üîó Merge Vertices</button>
                        <button onclick="applySubdivision(2)">ü™Ñ Subdivide Geometry</button>
                    </div>

                    <div id="controls">
                        <h3>Building</h3>
                        <label class="control-label">Width : <input type="number" id="building-width" value="5"></label>
                        <label class="control-label"> Height : <input type="number" id="building-height" value="10"></label>
                        <label class="control-label">Depth : <input type="number" id="building-depth" value="5"></label>
                    </div>
                </div>

                <div>
                    <label>Vertex Size:</label>
                    <input type="range" id="vertexSizeSlider" min="0.1" max="2" step="0.1" value="0.5">
                </div>
                <div>
                    <label>Edge Thickness:</label>
                    <input type="range" id="edgeThicknessSlider" min="1" max="5" step="1" value="2">
                </div>
                <div>
                    <label>Subdivision Levels:</label>
                    <input type="range" id="subdivisionLevelsSlider" min="0" max="4" step="1" value="1">
                </div>
                <div>
                    <label>Face Opacity:</label>
                    <input type="range" id="faceOpacitySlider" min="0" max="1" step="0.1" value="0.5">
                </div>

                <div class="tool-separator"></div>

                <div class="tool-section">
                    <h4>Operations</h4>
                    <div class="button-container">
                         <button id="tool-extrude" class="panel-button-tool" title="Extrude Selection (E)" disabled>
                              <svg> <!-- Placeholder SVG for Extrude -->
                                  <rect x="4" y="4" width="16" height="8" stroke="currentColor" fill="none"/>
                                  <rect x="6" y="14" width="12" height="6" stroke="currentColor" fill="lightblue"/>
                                   <line x1="4" y1="12" x2="6" y2="14" stroke="currentColor"/>
                                   <line x1="20" y1="12" x2="18" y2="14" stroke="currentColor"/>
                              </svg>
                              
                          </button>
                
                            <button id="tool-bevel" class="panel-button-tool" title="Bevel Edges/Vertices (Ctrl+B)" disabled>
                               <svg> 
                                  <polygon points="4,4 20,4 20,20 4,20" stroke="currentColor" fill="none"/>
                                  <polygon points="6,6 18,6 18,18 6,18" stroke="lightblue" fill="none" stroke-width="2"/>
                               </svg>
                            </button>
                           
                            <button id="tool-loopcut" class="panel-button-tool" title="Insert Edge Loop (Ctrl+R)" disabled>
                                <svg> <!-- Placeholder SVG for Loop Cut -->
                                   <rect x="4" y="4" width="16" height="16" stroke="currentColor" fill="none"/>
                                   <line x1="4" y1="12" x2="20" y2="12" stroke="lightblue" stroke-width="2"/>
                                   <line x1="12" y1="4" x2="12" y2="20" stroke="lightgray" stroke-dasharray="4"/>
                                </svg>
                            </button>
                            <button id="tool-inset" class="panel-button-tool poly-tool" title="Inset Faces (I)" disabled>
                                <svg viewBox="0 0 24 24" width="24" height="24"><path fill="none" stroke="currentColor" stroke-width="1.5" d="M4 4h16v16H4z M8 8h8v8H8z"/></svg>
                            
                            </button>
                            <!-- Add Bridge button (placeholder) -->
                            <button id="tool-bridge" class="panel-button-tool poly-tool" title="Bridge Edge Loops" disabled>
                                <svg viewBox="0 0 24 24" width="24" height="24"><path fill="none" stroke="currentColor" stroke-width="1.5" d="M5 5h3v14H5z M16 5h3v14h-3z M8 6h8 M8 18h8"/></svg>
            
                            </button>
                            <!-- Add more tool buttons here -->
                            <button id="tool-spin" class="panel-button-tool poly-tool" title="Spin (Select Profile First)">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path 
                                        d="M19 12C19 15.866 15.866 19 12 19C8.13401 19 5 15.866 5 12C5 8.13401 8.13401 5 12 5" 
                                        stroke="#E0E0E0" 
                                        stroke-width="2" 
                                        stroke-linecap="round"
                                    />
                                    <path d="M12 5L10 3M12 5L14 3" stroke="#E0E0E0" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                    <path d="M12 2V22" stroke="#E0E0E0" stroke-width="1.5" stroke-linecap="round" stroke-dasharray="2 2"/>
                                    <ellipse cx="12" cy="12" rx="7" ry="2.5" stroke="#E0E0E0" stroke-width="1.5" opacity="0.6"/>
                                </svg>
                            </button>
                            <div id="spin-options" class="tool-options" style="display: none;">
                                <script>

                                </script>
                                <h4>Spin Tool</h4>
                                <div class="panel-row">
                                    <label for="spinStepsSlider">Steps:</label>
                                    <span id="spinStepsValue">12</span>
                                </div>
                                <input type="range" min="3" max="64" value="12" class="slider" id="spinStepsSlider">

                                <div class="panel-row">
                                    <label for="spinAngleSlider">Angle:</label>
                                    <span id="spinAngleValue">360</span>¬∞
                                </div>
                                <input type="range" min="0" max="360" value="360" class="slider" id="spinAngleSlider">

                                <div class="panel-row">
                                   <button id="spin-apply-button" class="panel-button">Apply</button>
                                   <button id="spin-cancel-button" class="panel-button">Cancel</button>
                                </div>
                                <p class="tool-instructions" id="spin-instructions"></p>
                            </div>
                          
                    </div>
                </div>

                <div class="tool-separator"></div>

                <!-- 3. PRECISION / SNAPPING -->
                <div class="tool-section">
                    <h4>Snapping</h4>
                    <div class="snapping-controls button-container">
                         <button id="toggle-snapping" class="panel-button" title="Toggle Snapping (Shift+Tab)" style="min-width:80px;">Snap OFF</button>
                         <select id="snap-type-select" class="panel-select" disabled>
                             <option value="grid">Grid</option>
                             <option value="vertex">Vertex</option>
                             <option value="edge">Edge</option>
                             <option value="face">Face</option>
                         </select>
                         <label style="margin-left: 5px;">Grid: <input type="number" id="grid-snap-size" value="0.5" step="0.1" style="width: 45px;" disabled></label>
                    </div>
               </div>
        
               <div class="tool-separator"></div>
        
              <!-- 4. ARCHITECTURE TOOLS (Can keep or merge if desired) -->
              <div class="tool-section">
                  <h4>Architecture</h4>
                   <div class="button-container">
                       <button id="tool-wall" class="panel-button-tool arch-tool" ...>
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                 <rect x="4" y="4" width="16" height="16" stroke="currentColor" fill="none"/>
                                 <line x1="4" y1="12" x2="20" y2="12" stroke="lightblue"/>
                                 <line x1="12" y1="4" x2="12" y2="20" stroke="lightgray"/>
                            </svg>
                       </button>
                       <button id="tool-place-door" class="panel-button-tool arch-tool" ...>
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                 <rect x="4" y="4" width="16" height="16" stroke="currentColor" fill="none"/>
                                 <line x1="4" y1="12" x2="20" y2="12" stroke="lightblue"/>
                                 <line x1="12" y1="4" x2="12" y2="20" stroke="lightgray"/>
                                 <rect x="10" y="4" width="4" height="8" fill="#ccc"/>
                            </svg>
                       </button>
                       <button id="tool-place-window" class="panel-button-tool arch-tool" ...>
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                 <rect x="4" y="4" width="16" height="16" stroke="currentColor" fill="none"/>
                                 <line x1="4" y1="12" x2="20" y2="12" stroke="lightblue"/>
                                 <line x1="12" y1="4" x2="12" y2="20" stroke="lightgray"/>
                                 <rect x="10" y="4" width="4" height="8" fill="#ccc"/>
                            </svg>
                       </button>
                       <button id="tool-stairs" class="panel-button-tool arch-tool" ...>
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                 <rect x="4" y="4" width="16" height="16" stroke="currentColor" fill="none"/>
                                 <line x1="4" y1="12" x2="20" y2="12" stroke="lightblue"/>
                                 <line x1="12" y1="4" x2="12" y2="20" stroke="lightgray"/>
                                 <path d="M10 14 L10 20 L14 20 L14 14 Z" fill="#ccc"/>
                            </svg>
                       </button>
                       <button id="tool-measure" class="panel-button-tool arch-tool" ...>
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                 <line x1="4" y1="12" x2="20" y2="12" stroke="currentColor"/>
                                 <line x1="12" y1="4" x2="12" y2="20" stroke="currentColor"/>
                                 <text x="10" y="10" fill="#000">M</text>
                            </svg>
                        </button>
                        <button id="tool-roof" class="panel-button-tool arch-tool">
                            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                               <path d="M12 2 L2 10 L4 10 L4 14 L20 14 L20 10 L22 10 Z M6 16 H18 V20 H6 Z"></path>
                               <path d="M12 2L2 10.8L4.1 10.8L4.1 13L19.9 13L19.9 10.8L22 10.8L12 2Z"></path>
                            </svg>
                        </button>

                        <button id="tool-room" class="panel-button-tool arch-tool">
                            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                               <path fill-rule="evenodd" clip-rule="evenodd" d="M3 5 C3 3.89543 3.89543 3 5 3 H19 C20.1046 3 21 3.89543 21 5 V19 C21 20.1046 20.1046 21 19 21 H5 C3.89543 21 3 20.1046 3 19 V5 Z M8 19 V12 H16 V19 H8 Z"></path>
                               <path d="M4 4h16v16H4V4zm2 2v12h12V6H6z"></path>
                            </svg>
                        </button>

                        <button id="tool-curved-wall" class="panel-button-tool arch-tool">
                            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                                <path d="M4 4 C4 4 12 4 16 8 C20 12 20 20 20 20 L17 20 C17 20 17 13 14 10 C11 7 4 7 4 7 Z"></path>
                               <path d="M4 20 C10 4 14 4 20 20 H17 C13 8 11 8 7 20 H4 Z"></path>
                            </svg>
                        </button>

                        <button id="tool-terrain" class="panel-button-tool arch-tool">
                            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                               <path d="M2 18 Q5 12 8 18 Q11 12 14 18 L14 14 Q17 8 20 14 L22 14 L22 20 L2 20 Z"></path>
                               <path d="M2 20 L7 14 L12 18 L17 12 L22 20 Z"></path> 
                            </svg>
                        </button>
                        <button id="tool-window-presets" class="panel-button-tool arch-tool">
                            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                                <path d="M4 5 H10 V11 H4 Z M11 5 H17 V11 H11 Z M4 12 H10 V18 H4 Z M11 12 H17 V18 H11 Z M19 7 H22 V9 H19Z M19 11 H22 V13 H19Z M19 15 H22 V17 H19Z"></path>
                            </svg>
                        </button>
                        <button id="tool-structure-synth" class="panel-button-tool arch-tool">
                            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                                <!-- Simple icon: Pencil drawing a shape outline -->
                                <path d="M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.13,5.12L18.88,8.87M3,17.25V21H6.75L17.81,9.94L14.06,6.19L3,17.25Z"/>
                                <path d="M7 2H17V4H7V2Z M5 4H7V6H5V4Z M17 4H19V6H17V4Z M5 6V12H3V6H5Z M19 6V12H21V6H19Z M5 12H7V14H5V12Z M17 12H19V14H17V12Z M7 14H17V16H7V14Z"/>
                            </svg>
                        </button>
                        <button id="tool-shell" class="panel-button-tool modeling-tool">
                            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                                <!-- Icon representing a hollowed cube or shell -->
                                <path d="M19 3H5c-1.11 0-2 .89-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.11-.9-2-2-2zm-2 12H7V9h10v6zm-2-4h-2v2h2v-2zm-4 0H9v2h2v-2zM7 7h10v1H7V7z M5 5h14v1.5H5V5z M5 19v-1.5h14V19H5z"/>
                                <path d="M12 10.5 A1.5 1.5 0 0 0 10.5 12 A1.5 1.5 0 0 0 12 13.5 A1.5 1.5 0 0 0 13.5 12 A1.5 1.5 0 0 0 12 10.5 M12 7 C9.24 7 7 9.24 7 12 C7 14.76 9.24 17 12 17 C14.76 17 17 14.76 17 12 C17 9.24 14.76 7 12 7 Z"/>
                            </svg>
                        </button>
                          <button id="tool-boolean-subtract" class="panel-button-tool modeling-tool">
                            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                               <!-- Icon: Cube with a circular/spherical cutout -->
                               <path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 15c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5z"/>
                               <path d="M12,9A3,3 0 0,0 9,12A3,3 0 0,0 12,15A3,3 0 0,0 15,12A3,3 0 0,0 12,9Z" opacity="0.5"/>
                            </svg>
                        </button>
                        <style>
                            .arch-tool svg,  .modeling-tool svg {
                                fill: rgb(245, 243, 243); /* Explicitly set icon fill to white */
                            }
                        </style>
                    
                  </div>
                    <div id="arch-selection-tools" class="panel">
                        <h4>Architecture Selection</h4>
                        <button class="panel-button" id="select-all-walls">Select All Walls</button>
                        <button class="panel-button" id="select-all-doors">Select All Doors</button>
                        <button class="panel-button" id="select-all-windows">Select All Windows</button>
                        <button class="panel-button" id="select-all-arch">Select All Arch</button>
                        <button class="panel-button" id="delete-selected-arch" disabled>Delete Selected Arch</button>
                    </div>
                    <div class="tool-options" id="wall-options" style="display: none;">
                        <h4>Wall Options</h4>
                        <label for="wallHeightInput">Height:</label>
                        <input type="number" id="wallHeightInput" class="panel-input" value="2.5" step="0.1"><br>
                        <label for="wallThicknessInput">Thickness:</label>
                        <input type="number" id="wallThicknessInput" class="panel-input" value="0.2" step="0.05">
                    </div>
                 
                   <div class="tool-options" id="door-options" style="display: none;">
                        <h4>Door Options</h4>
                        <label for="doorWidthInput">Width:</label>
                        <input type="number" id="doorWidthInput" class="panel-input" value="0.9" step="0.1"><br>
                        <label for="doorHeightInput">Height:</label>
                        <input type="number" id="doorHeightInput" class="panel-input" value="2.1" step="0.1"><br>
                        <label for="doorDepthInput">Depth (Thickness):</label>
                        <input type="number" id="doorDepthInput" class="panel-input" value="0.1" step="0.05">
                   </div>
                   <div class="tool-options" id="window-options" style="display: none;">
                        <h4>Window Options</h4>
                        <label for="windowWidthInput">Width:</label>
                        <input type="number" id="windowWidthInput" class="panel-input" value="1.2" step="0.1"><br>
                        <label for="windowHeightInput">Height:</label>
                        <input type="number" id="windowHeightInput" class="panel-input" value="1.0" step="0.1"><br>
                        <label for="windowDepthInput">Depth (Thickness):</label>
                        <input type="number" id="windowDepthInput" class="panel-input" value="0.1" step="0.05">
                    </div>
                    <div class="tool-options" id="stairs-options" style="display: none;">
                        <h4>Stair Options</h4>
                        <label for="stairWidthInput">Width:</label>
                        <input type="number" id="stairWidthInput" class="panel-input" value="1.0" step="0.1"><br>
                        <label for="stairTotalHeightInput">Total Height:</label>
                        <input type="number" id="stairTotalHeightInput" class="panel-input" value="2.5" step="0.1"><br>
                        <label for="stairStepHeightInput">Step Height:</label>
                        <input type="number" id="stairStepHeightInput" class="panel-input" value="0.18" step="0.01"><br>
                        <label for="stairStepDepthInput">Step Depth:</label>
                        <input type="number" id="stairStepDepthInput" class="panel-input" value="0.25" step="0.01">
                    </div>

                    <div id="roof-options" class="tool-options" style="display:none;">
                        <h4>Roof Options</h4>
                        <label for="roofTypeSelect">Type:</label>
                        <select id="roofTypeSelect">
                            <option value="flat">Flat</option>
                            <option value="gable">Gable (Simple)</option>
                            <!-- <option value="hip">Hip</option> -->
                        </select><br>
                        <label for="roofHeightInput">Height/Eave (m):</label>
                        <input type="number" id="roofHeightInput" value="2.5" step="0.1"><br>
                        <label for="roofOverhangInput">Overhang (m):</label>
                        <input type="number" id="roofOverhangInput" value="0.3" step="0.1"><br>
                        <label for="roofPitchInput">Pitch (degrees, for Gable):</label>
                        <input type="number" id="roofPitchInput" value="30" step="1">
                        <p>Click to define roof footprint points. Right-click to finish.</p>
                    </div>

                    <!-- Room Tool Options -->
                    <div id="room-options" class="tool-options" style="display:none;">
                        <h4>Room Options</h4>
                        <label for="roomHeightInput">Wall Height (m):</label>
                        <input type="number" id="roomHeightInput" value="2.5" step="0.1"><br>
                        <label for="roomWallThicknessInput">Wall Thickness (m):</label>
                        <input type="number" id="roomWallThicknessInput" value="0.2" step="0.1"><br>
                        <input type="checkbox" id="roomAddFloorCheckbox" checked> <label for="roomAddFloorCheckbox">Add Floor</label><br>
                        <input type="checkbox" id="roomAddCeilingCheckbox"> <label for="roomAddCeilingCheckbox">Add Ceiling</label>
                        <p>Click 2 points to define a rectangular room. Right-click to cancel.</p>
                    </div>

                    <!-- Curved Wall Tool Options -->
                    <div id="curved-wall-options" class="tool-options" style="display:none;">
                        <h4>Curved Wall Options</h4>
                        <label for="curvedWallHeightInput">Height (m):</label>
                        <input type="number" id="curvedWallHeightInput" value="2.5" step="0.1"><br>
                        <label for="curvedWallThicknessInput">Thickness (m):</label>
                        <input type="number" id="curvedWallThicknessInput" value="0.2" step="0.1"><br>
                        <label for="curveSegmentsInput">Segments:</label>
                        <input type="number" id="curveSegmentsInput" value="20" step="1">
                        <p>Click 3 points for a quadratic curve (start, control, end). Right-click to finish.</p>
                    </div>

                    <!-- Terrain Tool Options -->
                    <div id="terrain-options" class="tool-options" style="display:none;">
                        <h4>Terrain Options (Simple Plane)</h4>
                        <label for="terrainWidthInput">Width (m):</label>
                        <input type="number" id="terrainWidthInput" value="20" step="1"><br>
                        <label for="terrainDepthInput">Depth (m):</label>
                        <input type="number" id="terrainDepthInput" value="20" step="1"><br>
                        <label for="terrainWidthSegmentsInput">Width Segments:</label>
                        <input type="number" id="terrainWidthSegmentsInput" value="10" step="1"><br>
                        <label for="terrainDepthSegmentsInput">Depth Segments:</label>
                        <input type="number" id="terrainDepthSegmentsInput" value="10" step="1">
                        <p>Click to place center of terrain plane. Right-click to cancel.</p>
                    </div>

                    <!-- Window Presets UI Placeholder -->
                    <div id="window-presets-panel" class="tool-options" style="display:none; border: 1px solid #ccc; padding: 10px; background: white; position:absolute; top: 100px; left: 200px; z-index:1001;">
                        <h4>Window Presets</h4>
                        <p>Select a preset:</p>
                        <button onclick="applyWindowPreset({width: 1.0, height: 1.2, sill: 0.9, depth: 0.15})">Standard (1.0x1.2)</button><br>
                        <button onclick="applyWindowPreset({width: 0.6, height: 0.8, sill: 1.1, depth: 0.15})">Small (0.6x0.8)</button><br>
                        <button onclick="applyWindowPreset({width: 1.5, height: 1.0, sill: 1.0, depth: 0.15})">Wide (1.5x1.0)</button><br>
                        <button onclick="document.getElementById('window-presets-panel').style.display='none';">Close</button>
                    </div>
        
        <script>
        let currentWindowPreset = null;

        function applyWindowPreset(preset) {
            currentWindowPreset = preset;
            console.log("Window preset selected:", preset);
            // You might want to visually indicate the active preset
            // And potentially update the window tool's input fields if they are visible
            const doorWidthInput = document.getElementById('windowWidthInput');
            const doorHeightInput = document.getElementById('windowHeightInput');
            const doorDepthInput = document.getElementById('windowDepthInput');
            const sillHeightInput = document.getElementById('windowSillHeightInput');

            if (doorWidthInput) doorWidthInput.value = preset.width;
            if (doorHeightInput) doorHeightInput.value = preset.height;
            if (doorDepthInput) doorDepthInput.value = preset.depth;
            if (sillHeightInput) sillHeightInput.value = preset.sill;

            alert(`Preset selected: ${preset.width}x${preset.height}. Activate Window tool to place.`);
            document.getElementById('window-presets-panel').style.display='none';
        }
    </script>
</div>

               <div class="tool-separator"></div>
        
               <!-- 5. SPLINE TOOLS -->
               <div class="tool-section">
                    <h4>Splines</h4>
                    <div class="spline-controls button-container">
                        <button id="spline-draw-profile" class="panel-button spline-tool" title="Draw 2D Profile Shape" disabled>Draw Profile</button>
                        <button id="spline-draw-path" class="panel-button spline-tool" title="Draw 3D Path Curve" disabled>Draw Path</button>
                        <!-- TODO: Need UI to SELECT active profile/path -->
                        <select id="active-profile-select" class="panel-select" disabled><option value="">--Select Profile--</option></select>
                        <select id="active-path-select" class="panel-select" disabled><option value="">--Select Path--</option></select>
                         <button id="spline-extrude" class="panel-button spline-tool" title="Extrude Profile along Path" disabled>Extrude</button>
                         <!-- Add Loft, Revolve etc. buttons -->
                     </div>
                </div>
        
                <div class="tool-separator"></div>
        
              <!-- 6. MODIFIER STACK -->
               <div class="tool-section" id="modifiers-panel" style="display: none;"> <!-- Hide initially, show when an object is selected -->
                   <h4>Modifiers</h4>
                   <div id="modifier-list-container">
                       <!-- Modifiers will be added here dynamically -->
                       <!-- Example Modifier Entry Structure (generated by JS): -->
                       
                       <div class="modifier-entry" data-modifier-index="0">
                            <input type="checkbox" class="mod-active" checked>
                            <span class="mod-name">Solidify</span>
                            <span class="mod-expand">‚ñº</span>
                            <button class="mod-remove">X</button>
                            <div class="mod-settings" style="display: none;">
                                 <label>Thickness: <input type="number" class="mod-param" data-param="thickness" value="0.1"></label>
                                 ... other params
                            </div>
                       </div>
                       
                    </div>
                   <div class="add-modifier-controls">
                       <select id="add-modifier-select" class="panel-select">
                           <option value="">-- Add Modifier --</option>
                           <option value="solidify">Solidify</option>
                           <option value="array">Array</option>
                            <option value="bevel">Bevel</option>
                           <option value="subdivision">Subdivision</option>
                           <!-- <option value="mirror">Mirror</option> -->
                            <!-- <option value="boolean">Boolean</option> -->
                           <!-- Add more when implemented -->
                       </select>
                       <button id="add-modifier-button" class="panel-button">+</button>
                   </div>
                   <div>
                        <button id="apply-modifiers-button" class="panel-button" title="Bake modifiers into base mesh">Apply All</button>
                    </div>
               </div>
        
        
               <div class="tool-separator"></div>
        
                <!-- Your original 'Building' section if needed -->
                <div id="building-controls-placeholder" style="display: none;"> <!-- Example placeholder -->
                    <h3>Building</h3>
                     <label>Width : <input type="number" id="building-width" value="5"></label>
                    <label>Height : <input type="number" id="building-height" value="10"></label>
                    <label>Depth : <input type="number" id="building-depth" value="5"></label>
                </div>
         
            </div>
        </div>

            <style>
                .modeling-tools .tool-section { margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #555;}
                .modeling-tools .button-container { display: flex; flex-wrap: wrap; gap: 5px; margin-top: 5px;}
                .panel-button-tool svg { display: block; margin-bottom: 2px; } /* Adjust icon layout */
                .tool-separator { height: 1px; background-color: #444; margin: 10px 0; }
                .active-tool { background-color: #57a !important; color: white; } /* Highlight active tool */
                .tool-options { background-color: #404040; padding: 8px; margin-top: 8px; border-radius: 4px; }
                .panel-select { background-color: #555; color: white; border: 1px solid #777; padding: 3px; border-radius: 3px;}
                /* Modifier List Styling */
                #modifier-list-container { max-height: 200px; overflow-y: auto; margin-bottom: 10px; background: #3a3a3a; padding: 5px; border-radius: 3px;}
                .modifier-entry { display: flex; align-items: center; background: #484848; padding: 4px; margin-bottom: 3px; border-radius: 3px; flex-wrap: wrap; }
                .modifier-entry > span { margin: 0 5px; cursor: default; }
                .modifier-entry .mod-name { font-weight: bold; flex-grow: 1; }
                .modifier-entry .mod-expand, .modifier-entry .mod-remove { cursor: pointer; padding: 0 5px; background: #555; border: none; color: white; border-radius: 3px; margin-left: 5px;}
                .modifier-entry .mod-remove { background: #a55; }
                .mod-settings { width: 100%; background: #404040; padding: 8px; margin-top: 5px; border-radius: 3px; border-top: 1px solid #555;}
                .mod-settings label { display: block; margin-bottom: 4px; }
                .mod-settings input[type=number] { width: 60px; }
            </style>


            <div class="panel" id="lights" style="display: none;">
                <div class="panel-header">
                    <span>Lights</span>
                    <span class="expand-button">‚ñº</span>
                </div>
                <div class="panel-content">
                    <!-- Add this button to your HTML -->
                    <button id="toggle-lighting" class="panel-button">Enable Advanced Lighting</button>
                    <div class="control-group">

                        <button id="addPointLight" class="panel-button" title="Add Point Light">
                            <svg viewBox="0 0 24 24" fill="none" stroke="gold" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" width="24" height="24">
                               <circle cx="12" cy="12" r="4" fill="gold"></circle>
                               <path d="M12 2v2M12 20v2M2 12h2M20 12h2M4.2 4.2l1.4 1.4M18.4 18.4l1.4 1.4M4.2 19.8l1.4-1.4M18.4 5.6l1.4-1.4" />
                            </svg>
                        </button>
                        <button id="addSunLight" class="panel-button" title="Add Sun Light">
                            <svg viewBox="0 0 24 24" fill="none" stroke="orange" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" width="24" height="24">
                               <circle cx="12" cy="12" r="5" fill="orange" />
                               <path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42" />
                            </svg>
                        </button>
                        <button id="addSpotLight" class="panel-button" title="Add Spot Light">
                            <svg viewBox="0 0 24 24" fill="none" stroke="#ffa500" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" width="24" height="24">
                                <path d="M12 3v7l6 6M12 3L6 9l6 6" fill="#ffa500" opacity="0.4"/>
                               <circle cx="12" cy="3" r="1.5" fill="#ffa500" />
                            </svg>
                        </button>
                        <button id="addAreaLight" class="panel-button" title="Add Area Light">
                            <svg viewBox="0 0 24 24" fill="none" stroke="#33ccff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" width="24" height="24">
                                <rect x="5" y="5" width="14" height="10" fill="#33ccff" opacity="0.3" />
                                <path d="M5 5h14v10H5z" />
                            </svg>
                        </button>
                        <button id="addDirectionalLight" class="panel-button" title="Add Directional Light">
                            <svg viewBox="0 0 24 24" fill="none" stroke="#ffcc00" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" width="24" height="24">
                               <path d="M2 12h20M16 6l6 6-6 6" />
                            </svg>
                        </button>
                        <button id="addHemisphereLight" class="panel-button" title="Add Hemisphere Light">
                            <svg viewBox="0 0 24 24" fill="none" stroke="#66ccff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" width="24" height="24">
                               <path d="M4 12a8 8 0 0116 0z" fill="#66ccff" opacity="0.4"/>
                               <path d="M2 12h20" />
                            </svg>
                        </button>
                        <button id="addLensflareLight" class="panel-button"  title="Add Lens Flare">
                            <svg viewBox="0 0 24 24" fill="none" stroke="cyan" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" width="24" height="24">
                                <circle cx="12" cy="12" r="2" fill="cyan" />
                                <circle cx="6" cy="12" r="1" fill="cyan" />
                                <circle cx="18" cy="12" r="1" fill="cyan" />
                                <circle cx="9" cy="12" r="0.5" fill="cyan" />
                                <circle cx="15" cy="12" r="0.5" fill="cyan" />
                            </svg>
                        </button>
                        <button id="addVolumetricLight" class="panel-button" title="Add Volumetric Light">
                            <svg viewBox="0 0 24 24" fill="none" stroke="violet" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" width="24" height="24">
                                <path d="M12 3v18" stroke-dasharray="2 2"/>
                                <path d="M6 21h12l-6-6z" fill="violet" opacity="0.3"/>
                                <circle cx="12" cy="3" r="1" fill="violet" />
                            </svg>
                        </button>
                    </div>
                    
                    <!-- Light Controls -->
                    <div class="light-controls">
                        <div class="control-group">
                            <label class="control-label">Light Intensity</label>
                            <input type="range" id="lightIntensity" min="0" max="2" step="0.1" value="1">
                        </div>
                        <div class="control-group">
                            <label class="control-label">Light Color</label>
                            <input type="color" id="lightColor" value="#ffffff">
                        </div>
                    </div>
                </div>
            </div>

            <div class="panel" id="Cameras" style="display: none;">
                <div class="panel-header">
                    <span>Camera</span>
                    <span class="expand-button">‚ñº</span>
                </div>
                <div class="panel-content">
                    
                    
                    <div class="button-container">
                        <!-- Add Camera (Standard Camera) -->
                        <button id="addCamera" class="panel-button-tool" title="Add Perspective Camera">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
        <g fill="none" stroke="#E0E0E0" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
            <!-- Body -->
            <rect x="3" y="7" width="18" height="11" rx="2"/>
            <!-- Lens -->
            <circle cx="12" cy="12.5" r="3.5"/>
            <circle cx="12" cy="12.5" r="1.5" fill="#E0E0E0"/> <!-- Lens highlight -->
            <!-- Viewfinder -->
            <path d="M8 7L9.5 5h5L16 7"/>
            <!-- Optional: Small button/detail -->
            <circle cx="18" cy="9.5" r="1" fill="#E0E0E0"/>
        </g>
        <!-- Add symbol (Green Accent) -->
        <g fill="none" stroke="#4CAF50" stroke-width="1.5" stroke-linecap="round">
            <line x1="19" y1="17" x2="23" y2="17"/>
            <line x1="21" y1="15" x2="21" y2="19"/>
        </g>
    </svg>
</button>
                    
                        <!-- Add Camera Orto (Orthographic Camera) -->
                        <button id="addCameraOrto" class="panel-button-tool" title="Add Ortho Camera">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
        <g fill="none" stroke="#E0E0E0" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
            <!-- Body -->
            <rect x="3" y="7" width="18" height="11" rx="2"/>
            <!-- Orthographic Projection Lines (front view) -->
            <rect x="8" y="10" width="8" height="5" rx="1" stroke-dasharray="2 2"/>
            <line x1="8" y1="10" x2="5" y2="8.5"/>
            <line x1="16" y1="10" x2="19" y2="8.5"/>
            <line x1="8" y1="15" x2="5" y2="16.5"/>
            <line x1="16" y1="15" x2="19" y2="16.5"/>
            <!-- Viewfinder -->
            <path d="M8 7L9.5 5h5L16 7"/>
        </g>
        <!-- Add symbol (Green Accent) -->
        <g fill="none" stroke="#4CAF50" stroke-width="1.5" stroke-linecap="round">
            <line x1="19" y1="17" x2="23" y2="17"/>
            <line x1="21" y1="15" x2="21" y2="19"/>
        </g>
    </svg>
</button>
                    
                        <!-- Add Cube Camera (Cubic/Panoramic Camera) -->
                        <button id="addCubeCamera" class="panel-button-tool" title="Add Cube Camera">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <g fill="none" stroke="#E0E0E0" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                                    <!-- Isometric Cube -->
                                    <path d="M12 4L19 8L19 16L12 20L5 16L5 8L12 4Z"/> <!-- Outer shape -->
                                    <line x1="12" y1="4" x2="12" y2="9.5"/>      <!-- Top center to middle -->
                                    <line x1="5" y1="8" x2="12" y2="9.5"/>       <!-- Left corner to middle -->
                                    <line x1="19" y1="8" x2="12" y2="9.5"/>      <!-- Right corner to middle -->
                                    <!-- Small lens indication on front-facing part -->
                                    <circle cx="12" cy="13.5" r="1.5" fill="#E0E0E0" stroke-width="1"/>
                                </g>
                                <!-- Add symbol (Green Accent) -->
                                <g fill="none" stroke="#4CAF50" stroke-width="1.5" stroke-linecap="round">
                                   <line x1="19" y1="17" x2="23" y2="17"/>
                                   <line x1="21" y1="15" x2="21" y2="19"/>
                                </g>
                            </svg>
                        </button>
                    

                        <!-- Add Stereo Camera (Dual Lens) -->
                        <button id="addStereoCamera" class="panel-button-tool" title="Add Stereo Camera">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <g fill="none" stroke="#E0E0E0" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                                     <!-- Body -->
                                    <rect x="3" y="7" width="18" height="11" rx="2"/>
                                    <!-- Two Lenses -->
                                    <circle cx="8.5" cy="12.5" r="2.5"/>
                                    <circle cx="8.5" cy="12.5" r="1" fill="#E0E0E0"/> <!-- Lens highlight -->
                                    <circle cx="15.5" cy="12.5" r="2.5"/>
                                    <circle cx="15.5" cy="12.5" r="1" fill="#E0E0E0"/> <!-- Lens highlight -->
                                    <!-- Viewfinder -->
                                    <path d="M8 7L9.5 5h5L16 7"/>
                                </g>
                                <!-- Add symbol (Green Accent) -->
                                <g fill="none" stroke="#4CAF50" stroke-width="1.5" stroke-linecap="round">
                                    <line x1="19" y1="17" x2="23" y2="17"/>
                                    <line x1="21" y1="15" x2="21" y2="19"/>
                                 </g>
                            </svg>
                        </button>
                    </div>
                    <div class="input-group">
                        <label id="cameraFOV">FOV</label>
                        <input type="number" value="60">
                    </div>

                    <div class="camera-special-controls">

                    </div>
                    
                    <!-- Camera list will be inserted here -->
                </div>
            </div>

            <div class="panel" id="drawingMode" style="display: none;">
                <div class="panel-header">
                    <span>Drawing</span>
                    <span class="expand-button">‚ñº</span>
                </div>
                <div class="panel-content">
                    <div class="button-container">
                        <!-- Draw Mode (F) -->
                        <button class="panel-button-tool" id="toggle-draw" title="Draw Mode (F)">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Pencil/Brush -->
                                <path d="M6 18L18 6" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Tip -->
                                <path d="M16 8L18 6L20 8" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Subtle 'F' hint (optional) -->
                                <path d="M8 16H10M8 14H9" fill="none" stroke="#ffffff" stroke-width="1"/>
                            </svg>
                        </button>
                    
                        <!-- Extrude Mode (E) -->
                        <button class="panel-button-tool" id="toggle-extrude" title="Extrude Mode (E)">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Base shape -->
                                <rect x="8" y="14" width="8" height="4" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Extruded top -->
                                <rect x="8" y="6" width="8" height="4" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Connecting lines -->
                                <path d="M8 14L8 10M16 14L16 10" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Up arrow -->
                                <path d="M12 10L12 6L14 8" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Clear (L) -->
                        <button class="panel-button-tool" id="clear" title="Clear (L)">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Eraser -->
                                <rect x="6" y="12" width="12" height="6" rx="2" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Clearing lines -->
                                <path d="M8 14L16 14M8 16L16 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Subtle 'L' hint (optional) -->
                                <path d="M18 12V16" fill="none" stroke="#ffffff" stroke-width="1"/>
                            </svg>
                        </button>
                    </div>
                    <div class="slider-container">
                        <input type="range" id="brush-" min="0.1" max="2" step="0.1" value="0.5">
                        <span>Brush Size: 0.5</span>
                    </div>
                    <div class="slider-container">
                        <input type="range" id="snapping" min="0" max="1" step="0.1" value="0.3">
                        <span>Snapping: 0.3</span>
                    </div>
                    <div class="slider-container">
                        <input type="range" id="extrude-height" min="0.1" max="5" step="0.1" value="1">
                        <span>Extrude: 1.0</span>
                    </div>
                </div>
                <div style="background-color: #e74c3c; padding: 4px;  margin: 10px auto; margin-right: 10px; margin-left: 10px;" class="status" id="status">Ready</div>
            </div>
        

            <!-- Material Editor Panel -->
            <div class="material-editor" id="material-editor"  style="display: none;">
                <div class="panel-header">Material Editor</div>
                <div class="property-group">
                    <div class="property-row">
                        <span class="property-label">Color</span>
                        <input type="color" class="property-input" id="materialColor">
                    </div>
                    <div class="property-row">
                        <span class="property-label">Metalness</span>
                        <input type="range" class="property-input" id="materialMetalness" min="0" max="1" step="0.1">
                    </div>
                    <div class="property-row">
                        <span class="property-label">Roughness</span>
                        <input type="range" class="property-input" id="materialRoughness" min="0" max="1" step="0.1">
                    </div>
                    <div class="property-row">
                        <label for="materialOpacity">Opacity:</label>
                        <input type="range" id="materialOpacity" min="0" max="1" step="0.01" value="1">

                        <label for="materialTexture">Texture:</label>
                        <input type="file" id="materialTexture" accept="image/*">
                    </div>
                    <div class="property-row">
                        <h3>MTXT</h3>
                        <div id="materialTextures" style=" margin: 10px auto; width: 100%; height: auto;">

                        </div>
                    </div>
                </div>
            </div>
            <div class="controls" id="snow-sittings" style="display: none;">
                    <div class="panel-header">Advanced Snow System</div>
                    <div class="property-group">
                        <button class="panel-button" id="toggleSnow">Toggle Snow</button>

                        <!-- Snow Mode Selection -->
                        <div class="control-group">
                            <label>Snow Mode:</label>
                            <select id="snowMode">
                                <option value="normal">Normal Falling</option>
                                <option value="vortex">Vortex</option>
                            </select>
                        </div>

                        <div class="control-group">
                            <label>Density: <span id="densityValue">1000</span></label>
                            <input type="range" id="density" min="100" max="5000" value="1000">
                        </div>
                        <div class="control-group">
                            <label>Size: <span id="sizeValue">0.1</span></label>
                            <input type="range" id="size" min="0.01" max="0.5" value="0.1" step="0.01">
                        </div>
                        <div class="control-group">
                            <label>Speed: <span id="speedValue">1</span></label>
                            <input type="range" id="speed" min="0.1" max="5" value="1" step="0.1">
                        </div>
                        <div class="control-group">
                            <label>Wind: <span id="windValue">0</span></label>
                            <input type="range" id="wind" min="-5" max="5" value="0" step="0.1">
                        </div>
                        <div class="control-group">
                            <label>Turbulence: <span id="turbulenceValue">0.5</span></label>
                            <input type="range" id="turbulence" min="0" max="2" value="0.5" step="0.1">
                        </div>

                        <div class="weather-effects">
                            <div class="button-container">
                                <!-- Storm -->
                                <button class="panel-button-tool" id="storm" title="Storm">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                        <!-- Swirling wind -->
                                        <path d="M6 12C8 10 10 10 12 12C14 14 16 14 18 12" fill="none" stroke="#ffffff" stroke-width="2"/>
                                        <!-- Lightning bolt -->
                                        <path d="M12 8L14 12L12 16L14 20" fill="none" stroke="#ffffff" stroke-width="2"/>
                                    </svg>
                                </button>
                            
                                <!-- Blizzard -->
                                <button class="panel-button-tool" id="blizzard" title="Blizzard">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                        <!-- Wind lines -->
                                        <path d="M6 12H10M14 12H18" fill="none" stroke="#ffffff" stroke-width="2"/>
                                        <!-- Snowflake -->
                                        <path d="M12 8V16M10 10L14 14M10 14L14 10" fill="none" stroke="#ffffff" stroke-width="2"/>
                                    </svg>
                                </button>
                            
                                <!-- Gentle -->
                                <button class="panel-button-tool" id="gentle" title="Gentle">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                        <!-- Soft flowing curves -->
                                        <path d="M6 14C8 12 10 12 12 14C14 16 16 16 18 14" fill="none" stroke="#ffffff" stroke-width="2"/>
                                        <path d="M6 16C8 14 10 14 12 16C14 18 16 18 18 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                                    </svg>
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Updated Explosion Controls with Consistent Styling -->
                    <div class="property-group">
                        <div class="panel-header">üí• Explosion Effects</div>
                        
                        <!-- Main Explosion Controls -->
                        <button class="panel-button" id="explosion-btn">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" style="margin-right: 8px;">
                                <!-- Explosion burst -->
                                <circle cx="12" cy="12" r="3" fill="#ff6b35"/>
                                <path d="M12 2L12 6M12 18L12 22M2 12L6 12M18 12L22 12M5.64 5.64L8.22 8.22M15.78 15.78L18.36 18.36M5.64 18.36L8.22 15.78M15.78 8.22L18.36 5.64" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                            DETONATE
                        </button>
                        <button class="panel-button" id="clear-explosion-btn">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" style="margin-right: 8px;">
                               <!-- Simple X icon -->
                               <path d="M6 6L18 18M6 18L18 6" 
                                    stroke="#ffffff" 
                                    stroke-width="2.5" 
                                    stroke-linecap="round"/>
                           </svg>
                            CLEAR
                        </button>

                        <!-- Explosion Presets -->
                        <div class="control-group">
                            <label>Explosion Presets:</label>
                            <div class="button-container">
                                <button class="panel-button-tool" id="preset-fireball" title="Classic Fireball">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                        <!-- Fireball -->
                                        <circle cx="12" cy="12" r="8" fill="none" stroke="#ff6b35" stroke-width="2"/>
                                        <path d="M12 4C16 6 20 8 20 12C20 16 16 18 12 20C8 18 4 16 4 12C4 8 8 6 12 4Z" fill="#ff6b35" opacity="0.3"/>
                                    </svg>
                                </button>
                                
                                <button class="panel-button-tool" id="preset-nuclear" title="Nuclear Blast">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                        <!-- Nuclear symbol -->
                                        <circle cx="12" cy="12" r="8" fill="none" stroke="#ffffff" stroke-width="2"/>
                                        <path d="M12 4L12 12L20 12M12 12L6 18M12 12L18 6" stroke="#ffffff" stroke-width="2"/>
                                        <circle cx="12" cy="12" r="2" fill="#ffffff"/>
                                    </svg>
                                </button>
                                
                                <button class="panel-button-tool" id="preset-dust" title="Dust Explosion">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                        <!-- Dust particles -->
                                        <circle cx="8" cy="8" r="1" fill="#ffffff"/>
                                        <circle cx="16" cy="8" r="1" fill="#ffffff"/>
                                        <circle cx="8" cy="16" r="1" fill="#ffffff"/>
                                        <circle cx="16" cy="16" r="1" fill="#ffffff"/>
                                        <circle cx="12" cy="12" r="2" fill="#ffffff"/>
                                        <circle cx="6" cy="12" r="0.5" fill="#ffffff"/>
                                        <circle cx="18" cy="12" r="0.5" fill="#ffffff"/>
                                    </svg>
                                </button>
                                
                                <button class="panel-button-tool" id="preset-default" title="Reset Defaults">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                        <!-- Reset arrow -->
                                        <path d="M3 12C3 7.03 7.03 3 12 3C16.97 3 21 7.03 21 12C21 16.97 16.97 21 12 21C9.5 21 7.26 19.94 5.77 18.18" fill="none" stroke="#ffffff" stroke-width="2"/>
                                        <path d="M5 14L5.77 18.18L9 17" fill="none" stroke="#ffffff" stroke-width="2"/>
                                    </svg>
                                </button>
                            </div>
                        </div>

                        <!-- Core Parameters -->
                        <div class="control-group">
                            <label>Max Particles: <span id="particle-count-value">5000</span></label>
                            <input type="range" id="particle-count" min="1000" max="30000" value="5000" step="500">
                        </div>

                        <div class="control-group">
                            <label>Explosion Force: <span id="explosion-force-value">10</span></label>
                            <input type="range" id="explosion-force" min="1" max="50" value="10" step="1">
                        </div>

                        <div class="control-group">
                            <label>Duration: <span id="explosion-duration-value">3</span>s</label>
                            <input type="range" id="explosion-duration" min="0.5" max="10" value="3" step="0.5">
                        </div>

                        <!-- Fire Effects -->
                        <div class="control-group">
                            <label>Fire Intensity: <span id="fire-intensity-value">0.8</span></label>
                            <input type="range" id="fire-intensity" min="0" max="2" value="0.8" step="0.1">
                        </div>

                        <div class="control-group">
                            <label>Fire Size: <span id="fire-size-value">5</span></label>
                            <input type="range" id="fire-size" min="1" max="20" value="5" step="1">
                        </div>

                        <!-- Smoke Effects -->
                        <div class="control-group">
                            <label>Smoke Density: <span id="smoke-density-value">0.6</span></label>
                            <input type="range" id="smoke-density" min="0" max="2" value="0.6" step="0.1">
                        </div>

                        <div class="control-group">
                            <label>Smoke Rise Speed: <span id="smoke-speed-value">2</span></label>
                            <input type="range" id="smoke-speed" min="0.1" max="10" value="2" step="0.1">
                        </div>

                        <!-- Advanced Controls -->
                        <div class="button-container">
                            <button class="panel-button-tool" id="toggle-shockwave" title="Toggle Shockwave">
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                    <!-- Shockwave rings -->
                                    <circle cx="12" cy="12" r="4" fill="none" stroke="#ffffff" stroke-width="2"/>
                                    <circle cx="12" cy="12" r="7" fill="none" stroke="#ffffff" stroke-width="1" opacity="0.7"/>
                                    <circle cx="12" cy="12" r="10" fill="none" stroke="#ffffff" stroke-width="1" opacity="0.4"/>
                                </svg>
                            </button>
                            
                            <button class="panel-button-tool" id="toggle-debris" title="Toggle Debris">
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                    <!-- Debris pieces -->
                                    <path d="M4 4L6 6L4 8L2 6Z" fill="#ffffff"/>
                                    <path d="M18 4L20 6L18 8L16 6Z" fill="#ffffff"/>
                                    <path d="M4 16L6 18L4 20L2 18Z" fill="#ffffff"/>
                                    <path d="M18 16L20 18L18 20L16 18Z" fill="#ffffff"/>
                                    <rect x="10" y="10" width="4" height="4" fill="#ffffff"/>
                                </svg>
                            </button>
                            
                            <button class="panel-button-tool" id="toggle-sparks" title="Toggle Sparks">
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                    <!-- Sparks -->
                                    <path d="M12 2L13 11L22 12L13 13L12 22L11 13L2 12L11 11Z" fill="#ffffff"/>
                                    <path d="M6 6L7 8L9 7L8 9L6 10L5 8L3 9L4 7Z" fill="#ffffff" opacity="0.7"/>
                                    <path d="M18 6L19 8L21 7L20 9L18 10L17 8L15 9L16 7Z" fill="#ffffff" opacity="0.7"/>
                                </svg>
                            </button>
                        </div>

                        <!-- Stats Display -->
                        <div class="control-group">
                            <label style="color: #888;">Active Particles: <span id="particle-count-display" style="color: #fff;">0</span></label>
                        </div>
                    </div>

                    <div class="property-group">
                        <div id="controls">
                             <!-- Toggle Particles -->
                             <button class="panel-button" id="toggleParticles" title="Toggle Particles">
                                Toggle Particles
                             </button>
                            <div class="button-container">
                                <!-- Increase Particles -->
                                <button class="panel-button-tool" id="increaseParticles" title="Increase Particles">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                        <!-- Particle dots -->
                                        <circle cx="8" cy="14" r="1" fill="#ffffff" stroke="#ffffff" stroke-width="2"/>
                                        <circle cx="12" cy="16" r="1" fill="#ffffff" stroke="#ffffff" stroke-width="2"/>
                                        <circle cx="16" cy="14" r="1" fill="#ffffff" stroke="#ffffff" stroke-width="2"/>
                                        <!-- Up arrow -->
                                        <path d="M12 12L12 6M10 8L12 6L14 8" fill="none" stroke="#ffffff" stroke-width="2"/>
                                    </svg>
                                </button>
                            
                                <!-- Decrease Particles -->
                                <button class="panel-button-tool" id="decreaseParticles" title="Decrease Particles">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                        <!-- Particle dots -->
                                        <circle cx="8" cy="10" r="1" fill="#ffffff" stroke="#ffffff" stroke-width="2"/>
                                        <circle cx="12" cy="8" r="1" fill="#ffffff" stroke="#ffffff" stroke-width="2"/>
                                        <circle cx="16" cy="10" r="1" fill="#ffffff" stroke="#ffffff" stroke-width="2"/>
                                        <!-- Down arrow -->
                                        <path d="M12 12L12 18M10 16L12 18L14 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                                    </svg>
                                </button>
                            
                                <!-- Particle Color (Color Picker) -->
                                <button class="panel-button-tool" title="Particle Color">
                                    <input type="color" id="particleColor" value="#ffcc88" />
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
           
            <div class="sculpting-tools" id="sculpting-tools"  style="display: none;">
                <div class="panel-header">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" d="m15.47 13.79l-2.58-1.03L6 15.05l-4-1.54v2.1l4 1.34zm-4.9-2.37L8 8H2v3.61l4 1.34zM6 19.05l-4-1.33V22h20l-4.97-6.62zM17 6V1l-5-1l-3 2v4l3 2zm1.5 1L16 9v3l2.5 2l4.5-2V8z"/></svg>
                    Sculpting Tools
                </div>
         
                <div class="property-group">
                    <div class="input-row">
                        <label for="terrainWidth">Width (X)</label>
                        <input type="number" id="terrainWidth" class="inspector-input" value="50" min="1">
                    </div>
                    <div class="input-row">
                        <label for="terrainLength">Length (Z)</label>
                        <input type="number" id="terrainLength" class="inspector-input" value="50" min="1">
                    </div>
                    <div class="input-row">
                        <label for="terrainResolution">Resolution</label>
                        <input type="number" id="terrainResolution" class="inspector-input" value="100" min="1" max="500">
                    </div>
                    <div class="input-row">
                        <label for="terrainTextureResolution">Texture Res</label>
                        <select id="terrainTextureResolution" class="inspector-select">
                            <option value="512">512x512</option>
                            <option value="1024" selected>1024x1024</option>
                            <option value="2048">2048x2048</option>
                            <option value="4096">4096x4096</option>
                        </select>
                    </div>
                    <button id="applyTerrainChanges" class="panel-button">Apply Changes</button>
                </div>

                <script>
              

                </script>

                <div class="property-group">
                    <!-- Basic Tools -->

                    <div class="button-container">
                        <!-- Raise/Lower -->
                        <button class="panel-button-tool" id="raiseLower" title="Raise/Lower">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Up arrow -->
                                <path d="M12 6L12 18" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <path d="M8 10L12 6L16 10" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Down arrow -->
                                <path d="M8 14L12 18L16 14" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>

                        <!-- Smooth (Reused) -->
                        <button class="panel-button-tool" id="smooth" title="Smooth">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Smooth flowing curve -->
                                <path d="M6 16C8 12 10 10 12 12C14 14 16 12 18 8" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Subtle wave -->
                                <path d="M6 14C8 13 10 13 12 14C14 15 16 15 18 14" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Flatten -->
                        <button class="panel-button-tool" id="flatten" title="Flatten">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Flat surface -->
                                <line x1="6" y1="12" x2="18" y2="12" stroke="#ffffff" stroke-width="2"/>
                                <!-- Downward pressure arrows -->
                                <path d="M8 8L8 12L10 10" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <path d="M16 8L16 12L14 10" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Noise -->
                        <button class="panel-button-tool" id="noise" title="Noise">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Jagged noise line -->
                                <path d="M6 12L8 14L10 10L12 14L14 10L16 14L18 12" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Subtle secondary noise -->
                                <path d="M6 14L8 12L10 16L12 12L14 16L16 12L18 14" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>

                        <button class="panel-button-tool"  id="perlinToolButton">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M2 17s3-5 6-5 4 3 6 3 3-4 5-4 3 5 3 5v4H2z"/>
                            </svg>
                        </button>
                    </div>

                    <!-- Advanced Tools -->
                    <div class="button-container">
                        <!-- Pinch (Reused) -->
                        <button class="panel-button-tool" id="pinch" title="Pinch">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Converging arrows -->
                                <path d="M6 8L12 12L6 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <path d="M18 8L12 12L18 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Center pinch point -->
                                <circle cx="12" cy="12" r="1" fill="#ffffff" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Clay -->
                        <button class="panel-button-tool" id="clay" title="Clay">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Clay lump -->
                                <path d="M8 10C6 12 6 16 8 18C10 20 14 20 16 18C18 16 18 12 16 10C14 8 10 8 8 10Z" 
                                      fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Shaping hint -->
                                <path d="M10 12C11 11 13 11 14 12" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Scrape -->
                        <button class="panel-button-tool" id="scrape" title="Scrape">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Scraping edge -->
                                <path d="M6 16L18 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Tool angle -->
                                <path d="M18 16L14 12L10 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Scraped material -->
                                <path d="M8 18L10 18M14 18L16 18" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Fill -->
                        <button class="panel-button-tool" id="fill" title="Fill">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Fill shape -->
                                <rect x="8" y="8" width="8" height="8" rx="2" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Inward flow arrows -->
                                <path d="M12 6V8M12 18V16M6 12H8M18 12H16" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Texture Paint -->
                        <button class="panel-button-tool" id="texturePaint" title="Texture Paint">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Paintbrush handle -->
                                <path d="M6 18L12 6" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Brush tip -->
                                <path d="M10 10C11 9 13 9 14 10" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Texture dots -->
                                <circle cx="12" cy="12" r="1" fill="#ffffff" stroke="#ffffff" stroke-width="2"/>
                                <circle cx="14" cy="14" r="1" fill="#ffffff" stroke="#ffffff" stroke-width="2"/>
                                <circle cx="10" cy="14" r="1" fill="#ffffff" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    </div>
            
                    <!-- Brush Controls -->
                    <div class="brush-controls">
                        <label>Brush Size:
                            <input type="range" id="brushSize" min="0.5" max="5" step="0.1" value="1.5">
                        </label>
                        <label>Brush Strength:
                            <input type="range" id="brushStrength" min="0.01" max="0.5" step="0.01" value="0.1">
                        </label>
                    </div>
            
                    <!-- Symmetry Controls -->
                    <div class="tool-options">
                        <label>
                            <input type="checkbox" id="symmetryToggle"> Enable Symmetry
                        </label>
                        <select id="symmetryAxis">
                            <option value="x">X Axis</option>
                            <option value="z">Z Axis</option>
                        </select>
                    </div>
            
                    <!-- History Controls -->
                    <div class="history-controls">
                        <button class="panel-button" id="undo"><i class="fas fa-undo"></i></button>
                        <button class="panel-button" id="redo"><i class="fas fa-redo"></i></button>
                    </div>
            
                    <!-- Texture Upload -->
                    <input type="file" id="uploadTexture" accept="image/*" style="display: none;">
                    <button class="panel-button" id="selectTexture">Upload Texture</button>

                    <canvas id="texturePreview" width="64" height="64" style="display: block;"></canvas>
                </div>

                <div class="advanced-tools">
                    <div class="button-container">
                        <!-- Terrace -->
                        <button class="panel-button-tool" id="terrace" title="Terrace">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Stepped levels -->
                                <path d="M6 18H18M6 14H18M6 10H18" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Connecting lines -->
                                <path d="M6 18V10M18 18V10" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Erosion -->
                        <button class="panel-button-tool" id="erosion" title="Erosion">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Wavy, worn lines -->
                                <path d="M6 16C8 14 10 14 12 16C14 18 16 18 18 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <path d="M6 14C8 12 10 12 12 14C14 16 16 16 18 14" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Ridge -->
                        <button class="panel-button-tool" id="ridge" title="Ridge">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Sharp peak -->
                                <path d="M6 18L12 6L18 18" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Base line -->
                                <path d="M6 18H18" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Canyon -->
                        <button class="panel-button-tool" id="canyon" title="Canyon">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Deep valley -->
                                <path d="M6 6L8 18L16 18L18 6" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Center dip -->
                                <path d="M8 18L12 14L16 18" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Plateau -->
                        <button class="panel-button-tool" id="plateau" title="Plateau">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Flat elevated surface -->
                                <path d="M6 14H18" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Slopes to base -->
                                <path d="M6 14L4 18H20L18 14" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Slope -->
                        <button class="panel-button-tool" id="slope" title="Slope">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Angled incline -->
                                <path d="M6 18L18 6" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Base and top lines -->
                                <path d="M6 18H4M18 6H20" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Blur Heights -->
                        <button class="panel-button-tool" id="blur" title="Blur Heights">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Soft wavy lines -->
                                <path d="M6 12C8 10 10 10 12 12C14 14 16 14 18 12" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <path d="M6 14C8 12 10 12 12 14C14 16 16 16 18 14" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Sharpen -->
                        <button class="panel-button-tool" id="sharpen" title="Sharpen">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Crisp peak -->
                                <path d="M6 16L12 8L18 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Base line -->
                                <path d="M6 16H18" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    </div>
                    
                    <div class="tool-settings">
                        <!--<label>Steps:
                            <input type="range" id="terraceSteps" min="2" max="10" value="4">
                        </label>
                        <label>Erosion Strength:
                            <input type="range" id="erosionStrength" min="0.1" max="1.0" value="0.5">
                        </label>
                        <label>Ridge Height:
                            <input type="range" id="ridgeHeight" min="0.1" max="2.0" value="1.0">
                        </label>-->

                        <label for="erosionStrength">Erosion Strength:</label>
                        <input type="range" id="erosionStrength" min="0" max="1" step="0.01" value="0.3">

                    </div>
                </div>

                <div class="material-tools" style="padding: 5px;">
                   <button class="panel-button-tool" id="materialPaint" title="Material Paint">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                            <path d="M6 18L12 6" fill="none" stroke="#ffffff" stroke-width="2"/>
                            <rect x="10" y="10" width="4" height="4" fill="none" stroke="#ffffff" stroke-width="2"/>
                            <circle cx="12" cy="12" r="2" fill="#ffffff"/>
                        </svg>
                    </button>



                    <div class="property-group" >
                        <input type="file" id="uploadMaterial" accept="image/*" style="display: none;">
                        <button class="panel-button" id="selectMaterial">Upload Material</button>
                        <canvas id="materialPreview" width="64" height="64" style="display: block;"></canvas>
                        
                        <label>Brush Size:
                            <input type="range" id="materialBrushSize" min="0.5" max="5" step="0.1" value="1.5">
                        </label>
                        <label>Strength:
                            <input type="range" id="materialStrength" min="0.1" max="1" step="0.01" value="0.5">
                        </label>
                        <label>Falloff:
                            <input type="range" id="materialFalloff" min="0.1" max="1" step="0.01" value="0.7">
                        </label>
                        <label>Rotation:
                            <input type="range" id="materialRotation" min="0" max="360" step="1" value="0">
                        </label>
                        <label>Scale:
                            <input type="range" id="materialScale" min="0.1" max="2" step="0.01" value="1">
                        </label>
                        <label>Opacity:
                            <input type="range" id="materialOpacity" min="0.1" max="1" step="0.01" value="1">
                        </label>
                        <label>Pattern:
                            <select id="materialPattern">
                                <option value="uniform">Uniform</option>
                                <option value="noise">Noise</option>
                                <option value="radial">Radial</option>
                                <option value="custom">Custom</option>
                            </select>
                        </label>
                        <label>Blend Mode:
                            <select id="materialBlendMode">
                                <option value="normal">Normal</option>
                                <option value="multiply">Multiply</option>
                                <option value="overlay">Overlay</option>
                                <option value="add">Add</option>
                            </select>
                        </label>
                    </div>
                </div>
            </div>

            <div id="sculpting-character-tools" class="character-sclupting" style="display: none;">
                <div class="panel-header">Character Sculpting</div>
                <div class="property-group">
                    <div class="group-header">Brush Settings</div>
                    <div class="brush-controls">
                        <label>Sculpting: <input type="checkbox" id="sculptingToggle" checked></label>
                        <label>Brush Size: <input type="range" id="brushSizeSc" min="0.05" max="1.0" step="0.05" value="0.2"></label>
                        <span id="brushSizeValue">0.2</span>
                        <label>Brush Strength: <input type="range" id="brushStrength" min="0.01" max="0.5" step="0.01" value="0.1"></label>
                        <span id="brushStrengthValue">0.1</span>
                        <label>Brush Falloff: <input type="range" id="brushFalloff" min="0.1" max="2.0" step="0.1" value="0.5"></label>
                        <span id="brushFalloffValue">0.5</span>
                    </div>
                </div>
                <div class="property-group">
                    <div class="group-header">Basic Shape Tools</div>
                    <div class="button-container">
                        <!-- Face Shape -->
                        <button class="panel-button-tool" id="faceShape" title="Face Shape">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Full face outline -->
                                <path d="M12 4C8 4 6 8 6 12C6 16 8 20 12 20C16 20 18 16 18 12C18 8 16 4 12 4Z" 
                                      fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Jawline curve -->
                                <path d="M8 16C9 18 11 19 12 19C13 19 15 18 16 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Nose Sculpt -->
                        <button class="panel-button-tool" id="noseSculpt" title="Nose Sculpt">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Nose profile -->
                                <path d="M12 6V10C12 12 13 14 14 15C13 16 12 17 12 18" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Nostril hint -->
                                <path d="M12 18C11.5 17.5 11 17 11 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Cheek Definition -->
                        <button class="panel-button-tool" id="cheekDefinition" title="Cheek Definition">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Face outline (simplified) -->
                                <path d="M8 6C6 8 6 16 8 18C10 20 14 20 16 18C18 16 18 8 16 6" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Cheekbone highlight -->
                                <path d="M9 12C10 13 11 13 12 12" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <path d="M12 12C13 13 14 13 15 12" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Jaw Sculpt -->
                        <button class="panel-button-tool" id="jawSculpt" title="Jaw Sculpt">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Jawline -->
                                <path d="M8 12C8 16 9 18 12 20C15 18 16 16 16 12" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Chin point -->
                                <path d="M12 20V22" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Forehead Shape -->
                        <button class="panel-button-tool" id="foreheadShape" title="Forehead Shape">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Forehead contour -->
                                <path d="M8 6C8 4 10 4 12 4C14 4 16 4 16 6C16 8 14 10 12 10C10 10 8 8 8 6Z" 
                                      fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Hairline hint -->
                                <path d="M8 6H16" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    </div>
                </div>
        
                <div class="property-group">
                    <div class="group-header">Advanced Shape Tools</div>
                    <div class="button-container">
                        <!-- Chin Sculpt -->
                        <button class="panel-button-tool" id="chinSculpt" title="Chin Sculpt">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Chin outline -->
                                <path d="M10 12C9 14 9 16 12 18C15 16 15 14 14 12" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Chin point -->
                                <path d="M12 18V20" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Temple Sculpt -->
                        <button class="panel-button-tool" id="templeSculpt" title="Temple Sculpt">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Temple area (side of forehead) -->
                                <path d="M8 6C8 4 10 4 12 6C14 4 16 4 16 6" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Side curve -->
                                <path d="M8 6C6 8 6 12 8 14" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <path d="M16 6C18 8 18 12 16 14" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Brow Ridge -->
                        <button class="panel-button-tool" id="browRidge" title="Brow Ridge">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Brow ridge arc -->
                                <path d="M8 8C9 6 11 6 12 8C13 6 15 6 16 8" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Eyebrow hint -->
                                <path d="M8 8C9 9 11 10 12 10C13 10 15 9 16 8" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Eye Socket -->
                        <button class="panel-button-tool" id="eyeSocket" title="Eye Socket">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Eye socket shape -->
                                <path d="M8 10C9 8 11 8 12 10C13 8 15 8 16 10C16 12 14 14 12 14C10 14 8 12 8 10Z" 
                                      fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Pupil hint -->
                                <circle cx="12" cy="12" r="1" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Lip Shape -->
                        <button class="panel-button-tool" id="lipShape" title="Lip Shape">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Upper lip -->
                                <path d="M8 12C9 11 11 10 12 11C13 10 15 11 16 12" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Lower lip -->
                                <path d="M8 12C9 13 11 14 12 14C13 14 15 13 16 12" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    </div>
                </div>
        
                <div class="property-group">
                    <div class="group-header">Advanced Tools</div>
                    <button class="panel-button-tool" id="snakeHook" title="Snake Hook">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                            <!-- Hook with snake-like curve -->
                            <path d="M6 18C8 14 10 12 12 14C14 16 16 14 18 10" fill="none" stroke="#ffffff" stroke-width="2"/>
                            <!-- Hook tip -->
                            <path d="M18 10L20 12L22 10" fill="none" stroke="#ffffff" stroke-width="2"/>
                        </svg>
                    </button>
                    <div class="group-header">Hair Brush Settings</div>
                    <button class="panel-button-tool" id="hairBrush" title="Hair Brush">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                            <!-- Brush handle -->
                            <rect x="10" y="4" width="4" height="8" fill="none" stroke="#ffffff" stroke-width="2"/>
                            <!-- Brush bristles (hair strands) -->
                            <path d="M8 12C8 14 10 16 12 16C14 16 16 14 16 12" fill="none" stroke="#ffffff" stroke-width="2"/>
                            <line x1="10" y1="12" x2="10" y2="18" stroke="#ffffff" stroke-width="2"/>
                            <line x1="12" y1="12" x2="12" y2="18" stroke="#ffffff" stroke-width="2"/>
                            <line x1="14" y1="12" x2="14" y2="18" stroke="#ffffff" stroke-width="2"/>
                        </svg>
                    </button>
                    <div class="hair-controls">
                        <h3>Hair Physics Settings</h3>
                        
                        <div class="control-group">
                          <label for="guideHairDensity">Guide Hair Density</label>
                          <input type="range" id="guideHairDensity" min="0.05" max="0.5" step="0.05" value="0.1">
                          <span class="value-display">0.1</span>
                        </div>
                        
                        <div class="control-group">
                          <label for="simulationQuality">Simulation Quality</label>
                          <select id="simulationQuality">
                            <option value="low">Low (Fast)</option>
                            <option value="medium" selected>Medium</option>
                            <option value="high">High (Slower)</option>
                          </select>
                        </div>
                        
                        <div class="control-group">
                          <button id="optimizePerformance">Optimize Hair</button>
                          <button id="togglePhysics">Toggle Physics</button>
                        </div>
                        
                        <div class="stats">
                          <div>Hair Strands: <span id="strandCount">0</span></div>
                          <div>Guide Hairs: <span id="guideCount">0</span></div>
                          <div>Performance: <span id="physicsTime">0</span> ms</div>
                        </div>
                      </div>
                    <div class="brush-controls">
                        <label title="Adjust the number of hair segments.">Segments: <input type="range" id="hairSegments" min="4" max="16" value="8" step="1"></label>
                        <label>Length: <input type="range" id="hairLength" min="0.02" max="0.2" value="0.05" step="0.01"></label>
                        <label>Density: <input type="range" id="hairDensity" min="3" max="12" value="5" step="1"></label>
                        <label>Curl: <input type="range" id="hairCurl" min="0" max="1" value="0.2" step="0.1"></label>
                        <label>Stiffness: <input type="range" id="hairStiffness" min="0.1" max="1" value="0.8" step="0.1"></label>
                    </div>

                    <div class="property-group">
                        <div class="group-header">Advanced Hair Settings</div>
                        <div class="brush-controls">
                            <label>Wave: <input type="range" id="hairWave" min="0" max="1" value="0.2" step="0.05"></label>
                            <label>Frizz: <input type="range" id="hairFrizz" min="0" max="0.5" value="0.1" step="0.05"></label>
                            <label>Clump Size: <input type="range" id="hairClumpSize" min="1" max="10" value="3" step="1"></label>
                            <label>Noise: <input type="range" id="hairNoise" min="0" max="0.2" value="0.05" step="0.01"></label>
                            <label>Color: <input type="color" id="hairColor" value="#3a1a00"></label>
                            <label>Highlight Color: <input type="color" id="hairSpecular" value="#8B4513"></label>
                            <!-- Rename the second togglePhysics to avoid conflict -->
                            <button class="panel-button" id="enablePhysics">Enable Physics</button>
                        </div>
                    </div>
                </div>

                <div class="property-group">
                    <div class="group-header">Detail Tools</div>
                    <div class="button-container">
                        <!-- Smooth -->
                        <button class="panel-button-tool" id="smooth" title="Smooth">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Smooth flowing curve -->
                                <path d="M6 16C8 12 10 10 12 12C14 14 16 12 18 8" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Subtle wave -->
                                <path d="M6 14C8 13 10 13 12 14C14 15 16 15 18 14" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Pinch -->
                        <button class="panel-button-tool" id="pinch" title="Pinch">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Converging arrows -->
                                <path d="M6 8L12 12L6 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <path d="M18 8L12 12L18 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Center pinch point -->
                                <circle cx="12" cy="12" r="1" fill="#ffffff" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Inflate -->
                        <button class="panel-button-tool" id="inflate" title="Inflate">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Expanding circle -->
                                <circle cx="12" cy="12" r="6" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Arrows outward -->
                                <path d="M12 6V4M12 20V18M6 12H4M20 12H18" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Crease -->
                        <button class="panel-button-tool" id="crease" title="Crease">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Sharp crease line -->
                                <path d="M6 18L12 12L18 18" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Fold hint -->
                                <path d="M6 16L12 10L18 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    </div>
                </div>
                
                <div class="property-group">
                    <div class="group-header">Symmetry</div>
                    <div class="symmetry-controls">
                        <label>
                            <input type="checkbox" id="symmetryToggle" checked>
                            Enable Symmetry
                        </label>
                        <select id="symmetryAxis">
                            <option value="x">X Axis</option>
                            <option value="y">Y Axis</option>
                            <option value="z">Z Axis</option>
                        </select>
                    </div>
                </div>
            </div>
          
            <div class="historySysteme">
                <div class="panel-header">
                    <i class="fas fa-history"></i>
                     History & Controls

                    <span class="expand-button">‚ñº</span>
                </div>
                <div class="history-panel" id="history-panel">
                    <div class="panel-header">
                        <i class="fas fa-history"></i>
                        History 
                        <span class="expand-button">‚ñº</span>
                    </div>
                    <div class="property-row">
                        <div id="history-items"></div>
                    </div>
                </div>
                <!-- Advanced Tools Panel -->
                <div class="advanced-tools" id="advanced-tools">
                    <div class="button-container">
                        <!-- Mirror -->
                        <button class="panel-button-tool" id="mirror" title="Mirror">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Shape (left half) -->
                                <path d="M6 8C8 6 10 8 10 12C10 16 8 18 6 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Symmetry line -->
                                <line x1="12" y1="6" x2="12" y2="18" stroke="#ffffff" stroke-width="2" stroke-dasharray="2"/>
                                <!-- Shape (right half, mirrored) -->
                                <path d="M18 8C16 6 14 8 14 12C14 16 16 18 18 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Array -->
                        <button class="panel-button-tool" id="array" title="Array">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Repeated rectangles -->
                                <rect x="6" y="8" width="4" height="4" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <rect x="12" y="8" width="4" height="4" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <rect x="6" y="14" width="4" height="4" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <rect x="12" y="14" width="4" height="4" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Plus hint -->
                                <path d="M18 12H20M19 11V13" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Boolean -->
                        <button class="panel-button-tool" id="boolean" title="Boolean">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Overlapping shapes -->
                                <circle cx="10" cy="12" r="4" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <rect x="10" y="8" width="8" height="8" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Cutout hint -->
                                <path d="M14 12H16" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    </div>
                </div>
            
            </div>
            <!-- Export Options -->
            <div class="export-panel" id="export-panel">
                <div class="panel-header">
                    Export Options
                </div>
                <div class="export-meth">
                    <select class="property-input" id="exportFormat">
                        <option value="gltf">GLTF/GLB</option>
                        <option value="obj">OBJ</option>
                        <option value="fbx">FBX</option>
                    </select>
                    <button class="tool-button" id="exportButton">Export</button>
                    <button class="tool-button" id="importScene">Export</button>
                </div>
            </div>
        </div>

        <style>
            /* Main Animator Panel */
.animator-panel {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    width: 80%;
    height: 400px;
    background-color: #2a2a2e;
    border: 1px solid #444;
    border-radius: 8px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    z-index: 1000;
    display: none; /* Initially hidden */
    flex-direction: column;
    color: #eee;
    font-family: sans-serif;
}

.animator-header {
    background-color: #3c3c42;
    padding: 10px;
    border-bottom: 1px solid #444;
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.animator-header h3 { margin: 0; }
.animator-controls select, .animator-controls button {
    margin-left: 10px;
    padding: 5px 10px;
    background-color: #555;
    border: 1px solid #777;
    color: white;
    border-radius: 4px;
}

.animator-graph-container {
    position: relative;
    flex-grow: 1;
    overflow: auto; /* Allows panning/zooming in a future update */
    background-color: #1e1e22;
    background-image:
        linear-gradient(rgba(255,255,255,0.07) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255,255,255,0.07) 1px, transparent 1px);
    background-size: 20px 20px;
}

.animator-svg-layer {
    position: absolute;
    top: 0; left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none; /* Allows clicking through to nodes */
}

/* State Nodes */
.animator-node {
    position: absolute;
    background-color: #4a5d7e;
    border: 1px solid #8aa3cf;
    border-radius: 5px;
    padding: 8px 12px;
    cursor: grab;
    user-select: none;
    min-width: 120px;
    text-align: center;
}
.animator-node.active-state {
    border-color: #ffb86c;
    box-shadow: 0 0 15px rgba(255, 184, 108, 0.5);
}

.animator-node-header {
    font-weight: bold;
    margin-bottom: 5px;
    padding-bottom: 5px;
    border-bottom: 1px solid rgba(255,255,255,0.2);
}

.animator-node-clip {
    font-style: italic;
    color: #ccc;
    font-size: 0.9em;
}

/* Properties Panel */
.animator-properties-panel {
    width: 250px;
    background-color: #333338;
    padding: 10px;
    border-left: 1px solid #444;
    overflow-y: auto;
}
.prop-group { margin-bottom: 15px; }
.prop-group label { display: block; margin-bottom: 5px; font-weight: bold; }
.prop-group input, .prop-group select {
    width: 100%;
    box-sizing: border-box;
    padding: 5px;
    background-color: #222;
    border: 1px solid #555;
    color: white;
    border-radius: 3px;
}

/* Add these new styles to your existing CSS file */

/* For the transition lines */
.animator-svg-layer path {
    stroke-width: 2px;
    fill: none;
    cursor: pointer;
    transition: stroke 0.2s;
}

.transition-path {
    stroke: #888;
    marker-end: url(#arrow-marker);
}

.transition-path:hover, .transition-path.selected {
    stroke: #ffb86c; /* Highlight color */
    stroke-width: 3px;
}

.temp-link-path {
    stroke: #5a99d4;
    stroke-dasharray: 5, 5;
    pointer-events: none;
}

/* For the properties panel for transitions */
.condition-row {
    display: flex;
    align-items: center;
    gap: 5px;
    margin-bottom: 5px;
    background-color: #444;
    padding: 5px;
    border-radius: 3px;
}
.condition-row select, .condition-row input {
    flex-grow: 1;
    width: auto;
}
.condition-row .delete-btn {
    background-color: #c14444;
    color: white;
    border: none;
    cursor: pointer;
    padding: 4px 8px;
    border-radius: 50%;
    font-weight: bold;
}
        </style>

        <div id="animator-panel" class="animator-panel">
    <div class="animator-header">
        <h3>Animator</h3>
        <div class="animator-controls">
            <span>Target:</span>
            <select id="animator-target-select">
                <option value="">- Select an Object -</option>
            </select>
            <button id="add-state-btn">+ Add State</button>
        </div>
    </div>
    <div id="animator-graph-container" class="animator-graph-container">
        <!-- Nodes will be dynamically added here -->
        <svg id="animator-svg-layer" class="animator-svg-layer"></svg>
    </div>
    <div id="animator-properties-panel" class="animator-properties-panel">
        <!-- Properties of the selected node/transition will appear here -->
        <h4>Properties</h4>
        <div id="properties-content">Select a node to see its properties.</div>
    </div>
</div>
        
        <div class="animator-container">
            <div class="layers-panel">
                <div class="panel-header">Layers</div>
                <div class="layer-item selected">
                    <span class="layer-icon">‚ñ∂</span>
                    Base Layer
                </div>
                <div class="layer-item">
                    <span class="layer-icon">‚ñ∂</span>
                    Left Hand Layer
                </div>
                <div class="layer-item">
                    <span class="layer-icon">‚ñ∂</span>
                    Right Hand Layer
                </div>
            </div>
    
            <div class="graph-panel">
                <div class="grid"></div>
                <div class="controls1">
                    <button class="control-btn1" id="addState">Add State</button>
                    <button class="control-btn1" id="addTransition">Add Transition</button>
                </div>
            </div>
    
            <div class="parameters-panel">
                <div class="parameter-group">
                    <label class="parameter-label">State Name</label>
                    <input type="text" class="parameter-input" id="stateName">
                </div>
                <div class="parameter-group">
                    <label class="parameter-label">Speed</label>
                    <input type="range" class="parameter-input" min="0" max="2" step="0.1" value="1">
                </div>
                <div class="parameter-group">
                    <label class="parameter-label">Transition Duration</label>
                    <input type="number" class="parameter-input" value="0.25" step="0.05">
                </div>
            </div>
        </div>

         <!-- Add this new modal container right before the existing model-viewer-container -->
         <div class="site-modal-container" id="siteModal">
            <button class="close-site-modal" id="closeSiteModal"><i class="fas fa-times"></i></button>
            <div class="site-modal-content" id="siteModalContent">
                <iframe id="siteIframe" frameborder="0"></iframe>
            </div>
        </div>

        <div class="sound-controls-header" id="sound-controls-header" style="display: none;">
    <header class="header-bar">
        <div class="transport-controls">
            <button class="btn" id="playBtn" title="Play">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polygon points="5 3 19 12 5 21 5 3"></polygon>
                </svg>
            </button>
            <button class="btn" id="stopBtn" title="Stop">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="3" y="3" width="18" height="18"></rect>
                </svg>
            </button>
            <button class="btn" id="loopBtn" title="Loop">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M17 1l4 4-4 4"></path>
                    <path d="M3 11V9a4 4 0 0 1 4-4h14"></path>
                    <path d="M7 23l-4-4 4-4"></path>
                    <path d="M21 13v2a4 4 0 0 1-4 4H3"></path>
                </svg>
            </button>
            <div class="time-display">
                <span id="currentTime">00:00</span>
            </div>
        </div>
        <div class="master-controls">
            <input type="file" id="fileInput" accept="audio/*" style="display: none">
            <label for="fileInput" class="btn" title="Upload Audio File">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                    <polyline points="17 8 12 3 7 8"></polyline>
                    <line x1="12" y1="3" x2="12" y2="15"></line>
                </svg>
            </label>
        </div>
    </header>
</div>

<style>
    .btn {
        background: rgba(0, 0, 0, 0.6);
        border: 0.6px solid #ccc;
        padding: 8px;
        border-radius: 4px;
        cursor: pointer;
        display: flex;
        justify-content: center;
        align-items: center;
        color: #fff; /* Default icon color */
    }
    .btn:hover {
        background-color: #f0f0f0;
        color: #007bff; /* Icon color on hover */
    }
    .btn svg {
        width: 20px; /* Adjust icon size as needed */
        height: 20px; /* Adjust icon size as needed */
    }
    .time-display {
        font-family: monospace;
        font-size: 1.1em;
        padding: 0 10px;
    }
</style>

        <!--<div class="sound-controls-header"  id="sound-controls-header" style="display: none;">
            <header class="header-bar">
                <div class="transport-controls">
                    <button class="btn" id="playBtn"><i class="fas fa-play"></i></button>
                    <button class="btn" id="stopBtn"><i class="fa-solid fa-stop"></i></button>
                    <button class="btn" id="loopBtn"><i class="fa-solid fa-repeat"></i></button>
                    <div class="time-display">
                        <span id="currentTime">00:00</span>
                    </div>
                </div>
                <div class="master-controls">
                    <input type="file" id="fileInput" accept="audio/*" style="display: none">
                    <label for="fileInput" class="btn"><i class="fa-solid fa-spinner"></i></label>
                </div>
            </header>
        </div>-->

    <style>
   .animator-container {
        display: none;
       position: absolute;
       top: 41%;
       left: 40%;
       bottom: 31vh;
       transform: translate(-50%, -48.5%);
       width: 57%;
       height: 70vh; /* Adjust height dynamically */
       max-height: 70vh; 
       background: #2a2a2a;
       border: 1px solid #444;
       z-index: 1000;
       overflow: auto;
       transition: width 0.3s ease, left 0.3s ease, transform 0.3s ease;
    }

    .animator-container.visible {
        display: flex;
        width: 80%; 
        left: 20%; 
        transform: translate(0, -50%);
    }

    /* Layers Panel */
    .layers-panel {
        width: 180px;
        background-color: #383838;
        border-right: 1px solid #222;
        overflow-y: auto;
    }

    .layer-icon {
        width: 16px;
        height: 16px;
        margin-right: 8px;
    }

    /* Graph Panel */
    .graph-panel {
        flex: 1;
        background-color: #2D2D2D;
        position: relative;
        overflow-x: auto;
        overflow-y: auto;
    }

    .grid {
        position: absolute;
        width: 100%;
        height: 100%;
        background-size: 20px 20px;
        background-image: 
        linear-gradient(to right, #333 1px, transparent 1px),
        linear-gradient(to bottom, #333 1px, transparent 1px);
    }

    

    .node.entry {
        background-color: #2C632C;
    }

    .node.exit {
        background-color: #633434;
    }

    .node-header {
    background-color: #4a4a4a;
    color: #eee;
    padding: 8px 12px;
    border-top-left-radius: 7px;
    border-top-right-radius: 7px;
    cursor: move; /* For dragging the node */
    border-bottom: 1px solid #555;
    }

    .connection {
        position: absolute;
        pointer-events: none;
        z-index: 1;
    }

    .controls1 {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            gap: 5px;
}

        .control-btn1 {
            background-color: #4A4A4A;
            border: none;
            color: white;
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 3px;
        }

        .control-btn1:hover {
            background-color: #555;
        }


        /* Parameters Panel */
        .parameters-panel {
            width: 200px;
            background-color: #383838;
            border-left: 1px solid #222;
            padding: 10px;
        }

        .parameter-group {
            margin-bottom: 15px;
        }

        .parameter-label {
            display: block;
            margin-bottom: 5px;
            color: #ccc;
        }

        .parameter-input {
            width: 100%;
            padding: 5px;
            background-color: #2D2D2D;
            border: 1px solid #444;
            color: white;
            border-radius: 3px;
        }
        </style>
        <script>
           document.getElementById("toggleAnimator").addEventListener("click", function() {
                document.querySelector(".animator-container").classList.toggle("visible");
             });
             class AnimationState {
    constructor(name, animation, transitions = []) {
        this.name = name;
        this.animation = animation;
        this.transitions = transitions;
        this.blendTime = 0.2; // Default blend duration
    }
}

class AnimationController {
    constructor(model) {
        this.model = model;
        this.mixer = new THREE.AnimationMixer(model);
        this.states = new Map();
        this.currentState = null;
    }

    addState(name, animation) {
        const state = new AnimationState(name, animation);
        this.states.set(name, state);
        return state;
    }

    transition(fromState, toState, duration) {
        const currentAction = this.mixer.clipAction(fromState.animation);
        const nextAction = this.mixer.clipAction(toState.animation);
        
        // Crossfade between animations
        currentAction.fadeOut(duration);
        nextAction.reset().fadeIn(duration).play();
        
        this.currentState = toState;
    }
}

class AnimatorInterface {
    constructor() {
        this.controllers = new Map();
        this.connections = new Map();
        this.parameters = new Map();
    }

    createController(model) {
        const controller = new AnimationController(model);
        this.controllers.set(model.uuid, controller);
        return controller;
    }

    addTransition(fromState, toState, conditions) {
        fromState.transitions.push({
            targetState: toState,
            conditions: conditions
        });
    }
}
              class AnimatorGraph {
            constructor() {
                this.nodes = new Map();
                this.connections = new Map();
                this.graphPanel = document.querySelector('.graph-panel');
                this.isDragging = false;
                this.selectedNode = null;
                this.offset = { x: 0, y: 0 };

                this.initializeEventListeners();
                this.createDefaultStates();
            }

            createDefaultStates() {
                // Create Entry state
                this.createNode('Entry', 100, 100, true);
                
                // Create default states
                this.createNode('Idle', 300, 100);
                this.createNode('Walking', 500, 100);
                this.createNode('Running', 700, 100);
                
                // Create connections
                this.createConnection('Entry', 'Idle');
                this.createConnection('Idle', 'Walking');
                this.createConnection('Walking', 'Running');
            }

            createNode(name, x, y, isEntry = false) {
                const node = document.createElement('div');
                node.className = `node ${isEntry ? 'entry' : ''}`;
                node.innerHTML = `
                    <div class="node-header">${name}</div>
                    <div class="node-content">
                        Speed: 1.0
                    </div>
                `;
                node.style.left = `${x}px`;
                node.style.top = `${y}px`;
                
                this.nodes.set(name, node);
                this.graphPanel.appendChild(node);
                
                return node;
            }

            createConnection(fromName, toName) {
                const connection = document.createElement('svg');
                connection.classList.add('connection');
                connection.setAttribute('width', '100%');
                connection.setAttribute('height', '100%');
                
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                line.setAttribute('stroke', '#666');
                line.setAttribute('stroke-width', '2');
                line.setAttribute('fill', 'none');
                
                connection.appendChild(line);
                this.graphPanel.appendChild(connection);
                
                this.connections.set(`${fromName}-${toName}`, {
                    element: connection,
                    line: line,
                    from: fromName,
                    to: toName
                });
                
                this.updateConnection(fromName, toName);
            }

            updateConnection(fromName, toName) {
                const connection = this.connections.get(`${fromName}-${toName}`);
                if (!connection) return;

                const fromNode = this.nodes.get(fromName);
                const toNode = this.nodes.get(toName);
                
                const fromRect = fromNode.getBoundingClientRect();
                const toRect = toNode.getBoundingClientRect();
                
                const x1 = fromRect.left + fromRect.width;
                const y1 = fromRect.top + fromRect.height / 2;
                const x2 = toRect.left;
                const y2 = toRect.top + toRect.height / 2;
                
                const path = `M ${x1} ${y1} C ${x1 + 50} ${y1}, ${x2 - 50} ${y2}, ${x2} ${y2}`;
                connection.line.setAttribute('d', path);
            }

            initializeEventListeners() {
                this.graphPanel.addEventListener('mousedown', (e) => {
                    if (e.target.classList.contains('node')) {
                        this.isDragging = true;
                        this.selectedNode = e.target;
                        const rect = this.selectedNode.getBoundingClientRect();
                        this.offset = {
                            x: e.clientX - rect.left,
                            y: e.clientY - rect.top
                        };
                    }
                });

                document.addEventListener('mousemove', (e) => {
                    if (this.isDragging && this.selectedNode) {
                        const x = e.clientX - this.offset.x;
                        const y = e.clientY - this.offset.y;
                        
                        this.selectedNode.style.left = `${x}px`;
                        this.selectedNode.style.top = `${y}px`;
                        
                        // Update connections
                        this.connections.forEach((connection, key) => {
                            if (key.includes(this.selectedNode.querySelector('.node-header').textContent)) {
                                this.updateConnection(connection.from, connection.to);
                            }
                        });
                    }
                });

                document.addEventListener('mouseup', () => {
                    this.isDragging = false;
                    this.selectedNode = null;
                });

                // Add State button
                document.getElementById('addState').addEventListener('click', () => {
                    const stateName = prompt('Enter state name:');
                    if (stateName) {
                        const x = Math.random() * 500 + 200;
                        const y = Math.random() * 300 + 100;
                        this.createNode(stateName, x, y);
                    }
                });
            }
        }

        // Initialize the animator
        const animator = new AnimatorGraph();
        </script>
         <!-- Timeline -->
         <div class="timeline">
            <div class="resize-handle-timeline"></div>
            <div class="status-bar" id="stats-panel"> 
                <div id="fps">FPS: 0</div>
                <div id="objects">Objects: 0</div>
                <div id="triangles">Triangles: 0</div>
                <div id="nanite-stats"></div>
                <!--
                <span id="fps">FPS: 60</span>                 
                <span id="objects">Objects: 0</span>                 
                <span id="triangles">Triangles: 0</span>   
                -->           
            </div>             
            <div class="timeline-controls">
                <button class="tool-button" id="play">                     
                    <i class="fas fa-play"></i>                 
                </button>                 
                <button class="tool-button" id="pause">                     
                    <i class="fas fa-pause"></i>                 
                </button>                 
                <button class="tool-button" id="stop">                     
                    <i class="fas fa-stop"></i>                 
                </button>
                <button class="tool-button" id="add-keyframe" title="Add Keyframe">
                    <i class="fas fa-diamond"></i>
                </button>
                <button class="tool-button" id="delete-keyframe" title="Delete Keyframe">
                    <i class="fas fa-trash"></i>
                </button>
                <span id="time-display">00:00:00</span>                 
                <div class="zoom-controls">                     
                    <button class="tool-button" id="zoom-out">-</button>                     
                    <button class="tool-button" id="zoom-in">+</button>                 
                </div>    
            
            </div>

            <div class="timeline-body">
                <div class="timeline-layers">
                    <div class="layers-list" id="layers-list"></div>
                </div>
                <div class="timeline-track">
                    <div class="timeline-scale"></div>
                    <div class="timeline-content" id="timeline-content">
                        <div class="playhead" id="playhead"></div>
                        <div class="keyframes-container" id="keyframes-container"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- COMPLETE SCRIPT FOR TIMELINE RESIZING & MODAL RESPONSIVENESS ---
        
        const resizeHandle = document.querySelector('.resize-handle-timeline');
        const timelineRes = document.querySelector('.timeline');
        const rendererContainer = document.getElementById('renderer-container');
        const viewport = document.querySelector('.viewport');
        // Variables to track the resizing
        let isResizing = false;
        let initialHeight = 0;
        let initialMouseY = 0;

        // Define min and max heights for timeline (in pixels)
        const MIN_HEIGHT = window.innerHeight * 0.06; // 29% of viewport height
        const MAX_HEIGHT = 400; // Maximum height in pixels

        resizeHandle.addEventListener('mousedown', (event) => {
            isResizing = true;
            initialHeight = timelineRes.offsetHeight;
            initialMouseY = event.clientY;
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
        });

        function handleMouseMove(event) {
            if (isResizing) {
                // Calculate the height change (inverted since we're resizing from top)
                const deltaY = initialMouseY - event.clientY;
                let newTimelineHeight = initialHeight + deltaY;

                // Apply height constraints to timeline
                newTimelineHeight = Math.max(MIN_HEIGHT, Math.min(MAX_HEIGHT, newTimelineHeight));

               // Update the timeline height
               timelineRes.style.height = `${newTimelineHeight}px`;

                // Calculate and update renderer container height
                const viewportHeight = viewport.offsetHeight;
                const newRendererHeight = viewportHeight - newTimelineHeight;
                rendererContainer.style.height = `${newRendererHeight}px`;
            }
        }

        function handleMouseUp() {
            isResizing = false;
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
        }
    </script>

    <div class="node-editor" id="main-node-editor">
        <div class="node-editor-header">
            <span>Node Editor</span>
            <button id="node-editor-close">√ó</button>
        </div>
        <div class="node-toolbar">
            <button class="toolbar-button" title="Add Object" data-type="object">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                    <!-- Cube -->
                    <path d="M6 6L12 4L18 6L18 14L12 16L6 14L6 6Z" fill="none" stroke="#ffffff" stroke-width="2"/>
                    <path d="M6 6L12 8L18 6" fill="none" stroke="#ffffff" stroke-width="2"/>
                    <!-- Plus sign -->
                    <path d="M20 12H22M21 11V13" fill="none" stroke="#ffffff" stroke-width="2"/>
                </svg>
            </button>
            <button class="toolbar-button" title="Add Physics" data-type="physics">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                    <!-- Falling ball -->
                    <circle cx="12" cy="12" r="2" fill="none" stroke="#ffffff" stroke-width="2"/>
                    <!-- Motion lines -->
                    <path d="M12 8V10M10 6L11 9M14 6L13 9" fill="none" stroke="#ffffff" stroke-width="2"/>
                    <!-- Plus sign -->
                    <path d="M20 12H22M21 11V13" fill="none" stroke="#ffffff" stroke-width="2"/>
                </svg>
            </button>
            <button class="toolbar-button" title="Add Effect" data-type="effect">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                    <!-- Sparkle/wave -->
                    <path d="M12 8C14 10 16 10 18 12C16 14 14 14 12 16C10 14 8 14 6 12C8 10 10 10 12 8Z" 
                          fill="none" stroke="#ffffff" stroke-width="2"/>
                    <!-- Plus sign -->
                    <path d="M20 12H22M21 11V13" fill="none" stroke="#ffffff" stroke-width="2"/>
                </svg>
            </button>
            <button class="toolbar-button" title="Add Material" data-type="material">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                    <!-- Textured square -->
                    <rect x="6" y="6" width="12" height="12" fill="none" stroke="#ffffff" stroke-width="2"/>
                    <path d="M8 8L10 10M14 14L16 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                    <!-- Plus sign -->
                    <path d="M20 12H22M21 11V13" fill="none" stroke="#ffffff" stroke-width="2"/>
                </svg>
            </button>
            <button class="toolbar-button" title="Add Transform" data-type="transform">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                    <!-- Transform arrows -->
                    <path d="M12 6V8M12 16V18M6 12H8M16 12H18" fill="none" stroke="#ffffff" stroke-width="2"/>
                    <path d="M10 8L12 6L14 8M10 16L12 18L14 16M8 10L6 12L8 14M16 10L18 12L16 14" 
                          fill="none" stroke="#ffffff" stroke-width="2"/>
                    <!-- Plus sign -->
                    <path d="M20 12H22M21 11V13" fill="none" stroke="#ffffff" stroke-width="2"/>
                </svg>
            </button>
            <button class="toolbar-button" title="Add Animation" data-type="animation">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                    <!-- Play button -->
                    <path d="M8 6L16 12L8 18Z" fill="none" stroke="#ffffff" stroke-width="2"/>
                    <!-- Plus sign -->
                    <path d="M20 12H22M21 11V13" fill="none" stroke="#ffffff" stroke-width="2"/>
                </svg>
            </button>
            <button class="toolbar-button" title="Add light" data-type="light">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                    <!-- Light bulb -->
                    <path d="M12 6C10 6 8 8 8 10C8 12 10 14 12 14C14 14 16 12 16 10C16 8 14 6 12 6Z" 
                          fill="none" stroke="#ffffff" stroke-width="2"/>
                    <path d="M10 14H14V16H10V14Z" fill="none" stroke="#ffffff" stroke-width="2"/>
                    <!-- Plus sign -->
                    <path d="M20 12H22M21 11V13" fill="none" stroke="#ffffff" stroke-width="2"/>
                </svg>
            </button>
        </div>
        <div class="node-canvas" id="node-canvas"></div>
    </div>

    <div class="camera-preview hidden" id="cameraPreview">
        <div class="preview-controls">
           <button class="minimizePreview" id="minimizePreview"><i class="fas fa-window-minimize"></i></button>
           <button class="expandPreview" id="expandPreview"><i class="fas fa-expand-arrows-alt"></i></button>
        </div>
    </div>

    <!-- Context Menu -->
    <div class="context-menu" id="context-menu"> 
        <div class="context-menu-item" >Copy (Ctrl+C)</div>
        <div class="context-menu-item" >Paste (Ctrl+V)</div>
        <div class="context-menu-item">Delete (Del)</div>
        <div class="context-menu-item" >Duplicate (Ctrl+D)</div>
    </div>
   
    <div id="code-editor-panel">
    <div class="resize-handle-Editor"></div>
    <div class="editor-header">
        <h3>Code Editor</h3>
        <!-- NEW: Status display for create/edit mode -->
        <span id="editing-status" class="editing-status-display">Mode: Create New</span>
        <button class="editor-btn" id="close-editor">√ó</button>
    </div>
    <div class="editor-tabs">
        <button class="editor-tab active" data-tab="js">JavaScript</button>
        <button class="editor-tab" data-tab="html">HTML</button>
        <button class="editor-tab" data-tab="css">CSS</button>
    </div>
    <div class="split-container">
        <div class="main-editor">
            <textarea id="js-editor"></textarea>
            <textarea id="html-editor" style="display: none;"></textarea>
            <textarea id="css-editor" style="display: none;"></textarea>
        </div>
        <div class="console-container" id="console-container">
            <!-- ... your console ... -->
        </div>
    </div>
    <div class="editor-footer">
        <input type="text" id="filename-input" placeholder="Enter object name">
        <!-- NEW: Dynamic Buttons. Note the new IDs. -->
        <button class="editor-btn" id="run-code-btn">Create Object</button>
        <button class="editor-btn" id="run-test-cube">Test_Object</button>
        <button class="editor-btn" id="apply-changes-btn">Apply Changes</button>
        <button class="editor-btn" id="detach-script-btn">Detach Script</button>
        <button class="editor-btn" id="clear-console">Clear Console</button>
    </div>
    <div class="status-bar-code">Ready</div>
</div>
   

    <div id="preview-container">
        <button id="close-preview">‚úñ</button>
    </div>

    <div class="context-menu1" id="context-menu1">
        <div class="context-menu-item1" data-action="delete">Delete Node</div>
        <div class="context-menu-item1" data-action="duplicate">Duplicate Node</div>
    </div>
  
    <script>
        const toggleButton = document.getElementById('toggle-inspector');
        const inspectorPanel = document.getElementById('inspector-panel');
        const timeline1 = document.querySelector('.timeline');
        const nodeEditorExpend = document.querySelector('.node-editor');
        const animatorEditor = document.querySelector('.animator-container');
        //const axisControls = document.querySelector('.axis-controls');
        const axisControlsContainer = document.querySelector('.axis-controls-container');
        const soundHeader = document.querySelector('.sound-controls-header');
        const storModal = document.querySelector('.site-modal-container');
        toggleButton.addEventListener('click', () => {
            const isInspectorOpen = !inspectorPanel.classList.contains('closed');
            
            inspectorPanel.classList.toggle('closed');
            
            if (isInspectorOpen) {
                // Expand timeline when inspector is closed
                timeline1.classList.add('expanded');
                nodeEditorExpend.classList.add('expanded');
                //axisControls.classList.add('expanded');
                axisControlsContainer.classList.add('expanded');
                animatorEditor.classList.add('expanded');
                storModal.classList.add('expanded');
                soundHeader.classList.add('expanded');
            } else {
                // Restore timeline size when inspector is open
                timeline1.classList.remove('expanded');
                nodeEditorExpend.classList.remove('expanded');
                //axisControls.classList.remove('expanded');
                axisControlsContainer.classList.remove('expanded');
                animatorEditor.classList.remove('expanded');
                storModal.classList.remove('expanded');
                soundHeader.classList.remove('expanded');
            }
        });
        
    </script>

    <script>
    class PhysicsManager {
    constructor(scene, world) {
        this.scene = scene;
        this.world = world;
        this.physicsBodies = new Map();
        this.forces = new Set();
        this.collisionGroups = {
            DEFAULT: 1,
            TERRAIN: 2,
            DYNAMIC_OBJECTS: 4,
            KINEMATIC: 8,
            WIND_AFFECTED: 16
        };
        
        this.materials = {
            default: new CANNON.Material({
                friction: 0.5,
                restitution: 0.3
            }),
            bouncy: new CANNON.Material({
                friction: 0.3,
                restitution: 0.8
            }),
            rough: new CANNON.Material({
                friction: 0.8,
                restitution: 0.1
            })
        };

        // Debug visualization settings
        this.debugMode = false;
        this.debugBodies = new Map();
    }

    initPhysicsWorld() {
        this.world.gravity.set(0, -9.81, 0);
        this.world.broadphase = new CANNON.SAPBroadphase(this.world);
        this.world.solver.iterations = 20;
        this.world.allowSleep = true;

        // Contact material behaviors
        Object.values(this.materials).forEach((mat1) => {
            Object.values(this.materials).forEach((mat2) => {
                const contact = new CANNON.ContactMaterial(mat1, mat2, {
                    friction: Math.min(mat1.friction, mat2.friction),
                    restitution: Math.max(mat1.restitution, mat2.restitution),
                    contactEquationStiffness: 1e7,
                    contactEquationRelaxation: 3
                });
                this.world.addContactMaterial(contact);
            });
        });

        // Ground plane setup
        const groundShape = new CANNON.Plane();
        const groundBody = new CANNON.Body({
            mass: 0,
            material: this.materials.default,
            shape: groundShape,
            collisionFilterGroup: this.collisionGroups.TERRAIN,
            collisionFilterMask: this.collisionGroups.DEFAULT | this.collisionGroups.DYNAMIC_OBJECTS
        });
        groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI/2);
        this.world.addBody(groundBody);

        return this;
    }

    addPhysicsToObject(object, options = {}) {
    const box = new THREE.Box3().setFromObject(object);
    const size = new THREE.Vector3();
    box.getSize(size);

    let shape;
    if (object.geometry instanceof THREE.BoxGeometry) {
        shape = new CANNON.Box(new CANNON.Vec3(size.x/2, size.y/2, size.z/2));
    } else if (object.geometry instanceof THREE.SphereGeometry) {
        shape = new CANNON.Sphere(object.geometry.parameters.radius);
    } else if (object.geometry instanceof THREE.CylinderGeometry) {
        shape = new CANNON.Cylinder(
            object.geometry.parameters.radiusTop,
            object.geometry.parameters.radiusBottom,
            object.geometry.parameters.height,
            object.geometry.parameters.radialSegments
        );
    } else {
        shape = new CANNON.Box(new CANNON.Vec3(size.x/2, size.y/2, size.z/2));
    }

    // ÿ•ŸÜÿ¥ÿßÿ° ŸÖÿßÿØÿ© ŸÖÿÆÿµÿµÿ© ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ friction Ÿà restitution ŸÖŸÜ ÿßŸÑÿÆŸäÿßÿ±ÿßÿ™
    const customMaterial = new CANNON.Material({
        friction: options.friction !== undefined ? options.friction : 0.5,
        restitution: options.restitution !== undefined ? options.restitution : 0.3
    });

    const bodyOptions = {
        mass: options.mass || 1,
        position: new CANNON.Vec3(object.position.x, object.position.y, object.position.z),
        shape: shape,
        material: customMaterial, // ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑŸÖÿßÿØÿ© ÿßŸÑŸÖÿÆÿµÿµÿ©
        linearDamping: options.linearDamping || 0.1,
        angularDamping: options.angularDamping || 0.1,
        collisionFilterGroup: options.group || this.collisionGroups.DYNAMIC_OBJECTS,
        collisionFilterMask: options.mask || 
            (this.collisionGroups.DEFAULT | this.collisionGroups.TERRAIN | this.collisionGroups.DYNAMIC_OBJECTS)
    };

    const body = new CANNON.Body(bodyOptions);

    if (options.velocity) {
        body.velocity.copy(options.velocity);
    }

    if (options.angularVelocity) {
        body.angularVelocity.copy(options.angularVelocity);
    }

    this.world.addBody(body);
    this.physicsBodies.set(object, body);

    body.addEventListener("collide", (event) => {
        if (options.onCollide) {
            options.onCollide(event);
        }
        this.handleCollision(event, object);
    });

    object.userData.physics = {
        enabled: true,
        body: body
    };

    return body;
}

    handleCollision(event, object) {
        const impact = event.contact.getImpactVelocityAlongNormal();
        
        // Visual feedback for collision
        if (Math.abs(impact) > 5) {
            this.createCollisionEffect(event.contact.bi.position);
        }

        // Sound feedback could be added here
        if (Math.abs(impact) > 3) {
            // Play collision sound based on impact force
        }
    }

    createCollisionEffect(position) {
        const particles = new THREE.Points(
            new THREE.BufferGeometry(),
            new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.1,
                transparent: true,
                opacity: 0.8
            })
        );

        const particleCount = 20;
        const positions = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount * 3; i += 3) {
            const offset = new THREE.Vector3(
                (Math.random() - 0.5) * 0.5,
                (Math.random() - 0.5) * 0.5,
                (Math.random() - 0.5) * 0.5
            );
            positions[i] = position.x + offset.x;
            positions[i + 1] = position.y + offset.y;
            positions[i + 2] = position.z + offset.z;
        }

        particles.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        this.scene.add(particles);

        // Animate and remove particles
        const startTime = Date.now();
        const animate = () => {
            const elapsed = Date.now() - startTime;
            if (elapsed > 1000) {
                this.scene.remove(particles);
                return;
            }

            const positions = particles.geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                positions[i + 1] += 0.01; // Move particles upward
            }
            particles.geometry.attributes.position.needsUpdate = true;
            particles.material.opacity = 1 - (elapsed / 1000);

            requestAnimationFrame(animate);
        };
        animate();
    }

    createWindZone(position, direction, strength, radius) {
        const windForce = {
            type: 'wind',
            position: position.clone(),
            direction: direction.normalize(),
            strength: strength,
            radius: radius,
            apply: (body) => {
                // Calculate distance to body
                const distance = position.distanceTo(body.position);
                
                if (distance <= radius) {
                    // Scale force based on distance from center
                    const forceMagnitude = strength * (1 - distance / radius);
                    const force = direction.clone().multiplyScalar(forceMagnitude);
                    
                    // Apply force to physics body
                    body.applyForce(
                        new CANNON.Vec3(force.x, force.y, force.z),
                        body.position
                    );
                }
            }
        };
        this.forces.push(windForce);
        return windForce;
    }

    createVortexZone(position, axis, strength, radius) {
        const vortexForce = {
            type: 'vortex',
            position: position.clone(),
            axis: axis.normalize(),
            strength: strength,
            radius: radius,
            apply: (body) => {
                const bodyPos = new THREE.Vector3(
                    body.position.x,
                    body.position.y,
                    body.position.z
                );
                
                const distance = position.distanceTo(bodyPos);
                
                if (distance <= radius) {
                    // Calculate tangential direction for vortex
                    const toCenter = bodyPos.clone().sub(position);
                    const tangent = toCenter.cross(axis).normalize();
                    
                    // Scale force based on distance
                    const forceMagnitude = strength * (distance / radius);
                    const force = tangent.multiplyScalar(forceMagnitude);
                    
                    body.applyForce(
                        new CANNON.Vec3(force.x, force.y, force.z),
                        body.position
                    );
                }
            }
        };
        this.forces.push(vortexForce);
        return vortexForce;
    }

    applyForces(bodies) {
        this.forces.forEach(force => {
            bodies.forEach(body => force.apply(body));
        });
    }

  
    updatePhysics() {
        // Apply forces before stepping the world
        for (const force of this.forces) {
            for (const body of this.world.bodies) {
                if (body.mass > 0) { // Only apply to non-static bodies
                    force.apply(body);
                }
            }
        }
        this.physicsBodies.forEach((body) => {
            this.forces.forEach(force => {
                if (force.active && body.mass > 0) {
                    force.apply(body);
                }
            });
        });

        this.world.step(1/60);

        // Update object positions
        this.physicsBodies.forEach((body, object) => {
            object.position.copy(body.position);
            object.quaternion.copy(body.quaternion);
        });
    }
  
}




function createWindZoneVisual(position, radius, strength) {
    const group = new THREE.Group();
    
    // Main cylinder with improved visibility
    const cylinderGeometry = new THREE.CylinderGeometry(radius, radius, radius * 2, 32, 1, true);
    const cylinderMaterial = new THREE.MeshBasicMaterial({
        color: 0x00ff88,
        transparent: true,
        opacity: 0.2,
        wireframe: true,
        side: THREE.DoubleSide
    });
    const cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
    
    // Direction arrows
    const arrowCount = 8;
    const arrowGroup = new THREE.Group();
    for (let i = 0; i < arrowCount; i++) {
        const arrowHelper = new THREE.ArrowHelper(
            new THREE.Vector3(1, 0, 0),
            new THREE.Vector3(0, 0, 0),
            radius * 0.8,
            0x00ff88,
            radius * 0.2,
            radius * 0.1
        );
        arrowHelper.position.y = (Math.random() - 0.5) * radius;
        arrowHelper.position.z = (Math.random() - 0.5) * radius;
        arrowGroup.add(arrowHelper);
    }

    // Particle system for wind visualization
    const particleCount = 100;
    const particleGeometry = new THREE.BufferGeometry();
    const particlePositions = new Float32Array(particleCount * 3);
    const particleSizes = new Float32Array(particleCount);
    
    for (let i = 0; i < particleCount; i++) {
        const x = (Math.random() - 0.5) * radius * 2;
        const y = (Math.random() - 0.5) * radius * 2;
        const z = (Math.random() - 0.5) * radius * 2;
        
        particlePositions[i * 3] = x;
        particlePositions[i * 3 + 1] = y;
        particlePositions[i * 3 + 2] = z;
        particleSizes[i] = Math.random() * 0.2 + 0.1;
    }
    
    particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
    particleGeometry.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));
    
    const particleMaterial = new THREE.PointsMaterial({
        color: 0x00ff88,
        size: 0.1,
        transparent: true,
        opacity: 0.6,
        sizeAttenuation: true
    });
    
    const particles = new THREE.Points(particleGeometry, particleMaterial);
    
    group.add(cylinder);
    group.add(arrowGroup);
    group.add(particles);
    group.position.copy(position);
    addObjectToScene(group, 'Wind Zone');
    // Animation
    let time = 0;
    group.animate = () => {
        time += 0.016 * strength;
        
        // Animate particles
        const positions = particles.geometry.attributes.position.array;
        for (let i = 0; i < particleCount; i++) {
            positions[i * 3] += 0.1 * strength;
            if (positions[i * 3] > radius) {
                positions[i * 3] = -radius;
            }
        }
        particles.geometry.attributes.position.needsUpdate = true;
        
        // Rotate arrows
        arrowGroup.children.forEach((arrow, i) => {
            arrow.position.x = Math.sin(time + i) * radius * 0.2;
        });
        
        // Pulse cylinder
        cylinder.scale.x = 1 + Math.sin(time) * 0.1;
        cylinder.scale.z = 1 + Math.sin(time) * 0.1;
    };

    return group;
}

function createVortexVisual(position, radius, strength) {
    const group = new THREE.Group();

    // Main torus
    const torusGeometry = new THREE.TorusGeometry(radius * 0.7, radius * 0.05, 16, 100);
    const torusMaterial = new THREE.MeshBasicMaterial({
        color: 0x3F51B5,
        transparent: true,
        opacity: 0.5,
        wireframe: true
    });
    const torus = new THREE.Mesh(torusGeometry, torusMaterial);

    // Spiral lines
    const spiralCount = 3;
    const pointsPerSpiral = 100;
    const spiralGroup = new THREE.Group();
    
    for (let s = 0; s < spiralCount; s++) {
        const spiralPoints = [];
        const angleOffset = (s * Math.PI * 2) / spiralCount;
        
        for (let i = 0; i < pointsPerSpiral; i++) {
            const t = i / (pointsPerSpiral - 1);
            const angle = t * Math.PI * 4 + angleOffset;
            const radiusAt = radius * (0.2 + t * 0.8);
            
            spiralPoints.push(new THREE.Vector3(
                radiusAt * Math.cos(angle),
                t * radius * 2 - radius,
                radiusAt * Math.sin(angle)
            ));
        }
        
        const spiralGeometry = new THREE.BufferGeometry().setFromPoints(spiralPoints);
        const spiralMaterial = new THREE.LineBasicMaterial({
            color: 0x5C6BC0,
            transparent: true,
            opacity: 0.7
        });
        const spiralLine = new THREE.Line(spiralGeometry, spiralMaterial);
        spiralGroup.add(spiralLine);
    }

    // Particle system
    const particleCount = 300;
    const particleGeometry = new THREE.BufferGeometry();
    const particlePositions = new Float32Array(particleCount * 3);
    const particleData = [];
    
    for (let i = 0; i < particleCount; i++) {
        const angle = Math.random() * Math.PI * 2;
        const radiusAt = radius * (0.2 + Math.random() * 0.8);
        const height = (Math.random() - 0.5) * radius * 2;
        
        particlePositions[i * 3] = Math.cos(angle) * radiusAt;
        particlePositions[i * 3 + 1] = height;
        particlePositions[i * 3 + 2] = Math.sin(angle) * radiusAt;
        
        particleData.push({
            angle,
            radius: radiusAt,
            height,
            speed: (0.5 + Math.random() * 0.5) * strength
        });
    }
    
    particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
    
    const particleMaterial = new THREE.PointsMaterial({
        color: 0x5C6BC0,
        size: 0.1,
        transparent: true,
        opacity: 0.8
    });
    
    const particles = new THREE.Points(particleGeometry, particleMaterial);

    group.add(torus);
    group.add(spiralGroup);
    group.add(particles);
    group.position.copy(position);
    addObjectToScene(group, 'Vortex Wind');
    // Animation
    let time = 0;
    group.animate = () => {
        time += 0.016 * strength;
        
        // Rotate torus
        torus.rotation.y += 0.02 * strength;
        
        // Rotate spiral lines
        spiralGroup.rotation.y += 0.01 * strength;
        
        // Animate particles
        const positions = particles.geometry.attributes.position.array;
        for (let i = 0; i < particleCount; i++) {
            const data = particleData[i];
            data.angle += data.speed * 0.02;
            
            positions[i * 3] = Math.cos(data.angle) * data.radius;
            positions[i * 3 + 1] = data.height + Math.sin(time + i) * 0.1;
            positions[i * 3 + 2] = Math.sin(data.angle) * data.radius;
        }
        particles.geometry.attributes.position.needsUpdate = true;
    };

    return group;
}
        
        function addDemonstrationObjects() {
            // Add some boxes and spheres with different materials
            for (let i = 0; i < 5; i++) {
                const size = 1 + Math.random() * 0.5;
                const geometry = Math.random() > 0.5 ? 
                    new THREE.BoxGeometry(size, size, size) :
                    new THREE.SphereGeometry(size/2, 16, 16);
                
                const material = new THREE.MeshStandardMaterial({
                    color: new THREE.Color().setHSL(Math.random(), 0.7, 0.5),
                    roughness: 0.7,
                    metalness: 0.3
                });

                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(
                    (Math.random() - 0.5) * 10,
                    5 + i * 2,
                    (Math.random() - 0.5) * 10
                );
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                addObjectToScene(mesh, 'Physic demostration shapes')

                scene.add(mesh);
                physicsManager.addPhysicsToObject(mesh, {
                    mass: 1,
                    friction: 0.9,
                    restitution: 0.7
                });
            }
        }

      
        function initPhysics() {
           world = new CANNON.World();
           world.gravity.set(0, -9.81, 0); // Apply gravity

           physicsManager = new PhysicsManager(scene, world).initPhysicsWorld();
          
            // Create a static floor for physics
            const floorShape = new CANNON.Plane();
            const floorBody = new CANNON.Body({
               mass: 0, // Static object (does not move)
               shape: floorShape,
               position: new CANNON.Vec3(0, 0, 0),
               quaternion: new CANNON.Quaternion().setFromEuler(-Math.PI / 2, 0, 0),
            });

            world.addBody(floorBody);

            // visual plane for the floor
            const floorGeometry = new THREE.PlaneGeometry(1000, 1000);
            const floorMaterial = new THREE.MeshStandardMaterial({
               color: 0xffffff,
               transparent: true,
               opacity: 0,
               side: THREE.DoubleSide,
            });
            const floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
            floorMesh.rotation.x = -Math.PI / 2;
            floorMesh.receiveShadow = true;

            scene.add(floorMesh);

// Add to PhysicsManager class
PhysicsManager.prototype.initClothSystem = function() {
    this.clothSystem = new ClothSystem(this);
    return this.clothSystem;
};



// Update physics loop
const originalUpdatePhysics = PhysicsManager.prototype.updatePhysics;
PhysicsManager.prototype.updatePhysics = function() {
    originalUpdatePhysics.call(this);
    if (this.clothSystem) {
        this.clothSystem.updateCloth();
    }
};

            //Listeners
            document.getElementById('gravity-strength').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                world.gravity.set(0, value, 0); // ‚úÖ Update gravity dynamically
                document.getElementById('gravity-value').textContent = value.toFixed(2);
            });

             // Apply Wind
             document.getElementById('add-wind').addEventListener('click', () => {
               const strength = parseFloat(document.getElementById('wind-strength').value);
               const radius = parseFloat(document.getElementById('wind-radius').value);
               const position = controls.target.clone();
               const direction = new THREE.Vector3(1, 0, 0);
    
               const windVisual = createWindZoneVisual(position, radius, strength);
               scene.add(windVisual);
    
               const windForce = physicsManager.createWindZone(position, direction, strength, radius);
               windForce.visual = windVisual;
            });

            // Apply Vortex
            document.getElementById('add-vortex').addEventListener('click', () => {
                const strength = parseFloat(document.getElementById('wind-strength').value);
                const radius = parseFloat(document.getElementById('wind-radius').value);
                const position = controls.target.clone();
                const axis = new THREE.Vector3(0, 1, 0);
    
                const vortexVisual = createVortexVisual(position, radius, strength);
                scene.add(vortexVisual);
    
                const vortexForce = physicsManager.createVortexZone(position, axis, strength, radius);
                vortexForce.visual = vortexVisual;
            });



    }

    </script>

   
    <script>
        class TerrainBrushSystem {
            constructor(scene, camera, renderer, terrain) {
                this.scene = scene;
                this.camera = camera;
                this.renderer = renderer;
                this.terrain = terrain;
                
                // Brush states
                this.isActive = false;
                this.isPainting = false;
                this.lastPaintPosition = new THREE.Vector3();
                
                // Brush settings
                this.settings = {
                    radius: 2,
                    density: 5,
                    spacing: 0.5,
                    scaleMin: 0.8,
                    scaleMax: 1.2,
                    rotationMin: 0,
                    rotationMax: 360,
                    heightOffset: 0,
                    paintDelay: 50, // ms between paint operations
                };
        
                // Storage for models
                this.models = new Map();
                this.activeModel = null;
                
                // Initialize systems
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.brushPreview = this.createBrushPreview2();
                this.scene.add(this.brushPreview);
                
                // Initialize event listeners
                this.initializeEventListeners();
                this.lastPaintTime = 0;
                
                // Undo/Redo system
                this.undoStack = [];
                this.redoStack = [];
                this.currentPaintOperation = [];
            }
        
            createBrushPreview2() {
                const group = new THREE.Group();
        
                // Main circle
                const circleGeometry = new THREE.CircleGeometry(1, 32);
                const circleMaterial = new THREE.MeshBasicMaterial({
                    color: 0xFF7F7F,
                    transparent: true,
                    opacity: 0.6,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });
                const circle = new THREE.Mesh(circleGeometry, circleMaterial);
                circle.rotation.x = -Math.PI / 2;
                circle.renderOrder = 1;
        
                // Outer ring
                const ringGeometry = new THREE.RingGeometry(0.95, 1, 32);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: 0xFFFFFF,
                    transparent: true,
                    opacity: 0.7,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = -Math.PI / 2;
                ring.renderOrder = 2;
        
                // Center dot
                const dotGeometry = new THREE.CircleGeometry(0.05, 16);
                const dotMaterial = new THREE.MeshBasicMaterial({
                    color: 0xFFFFFF,
                    transparent: true,
                    opacity: 0.9,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });
                const dot = new THREE.Mesh(dotGeometry, dotMaterial);
                dot.rotation.x = -Math.PI / 2;
                dot.position.y = 0.01;
                dot.renderOrder = 3;
        
                group.add(circle);
                group.add(ring);
                group.add(dot);
                group.visible = false;
        
                return group;
            }
        
            initializeEventListeners() {
                // Mouse events
                this.renderer.domElement.addEventListener('mousemove', this.onMouseMove.bind(this));
                this.renderer.domElement.addEventListener('mousedown', this.onMouseDown.bind(this));
                this.renderer.domElement.addEventListener('mouseup', this.onMouseUp.bind(this));
                
                // Keyboard shortcuts
                window.addEventListener('keydown', (e) => {
                    if (e.key === 'm' || e.key === 'M') {
                        this.toggleBrush();
                    }
                    if (e.key === 'z' && e.ctrlKey) {
                        this.undo();
                    }
                    if (e.key === 'y' && e.ctrlKey) {
                        this.redo();
                    }
                });
        
                // UI Controls
                this.setupUIControls();
            }
        
            setupUIControls() {
                // Brush size control
                const sizeSlider = document.getElementById('brush-size');
                if (sizeSlider) {
                    sizeSlider.addEventListener('input', (e) => {
                        this.settings.radius = parseFloat(e.target.value);
                        this.updateBrushPreview();
                    });
                }
        
                // Density control
                const densitySlider = document.getElementById('brush-density');
                if (densitySlider) {
                    densitySlider.addEventListener('input', (e) => {
                        this.settings.density = parseInt(e.target.value);
                    });
                }
        
                // Model upload
                const modelUpload = document.getElementById('model-upload');
                if (modelUpload) {
                    modelUpload.addEventListener('change', this.handleModelUpload.bind(this));
                }
            }
        
            handleModelUpload(event) {
                const file = event.target.files[0];
                if (!file) return;
        
                const loader = new THREE.GLTFLoader();
                const reader = new FileReader();
        
                reader.onload = (e) => {
                    loader.load(e.target.result, (gltf) => {
                        const model = gltf.scene;
                        const modelName = file.name.split('.')[0];
                        
                        // Center and normalize model
                        const box = new THREE.Box3().setFromObject(model);
                        const center = box.getCenter(new THREE.Vector3());
                        const size = box.getSize(new THREE.Vector3());
                        const maxDim = Math.max(size.x, size.y, size.z);
                        
                        model.position.sub(center);
                        model.scale.multiplyScalar(1 / maxDim);
                        
                        this.models.set(modelName, model);
                        this.activeModel = model;
                        
                        console.log(`Model ${modelName} loaded successfully`);
                    });
                };
        
                reader.readAsDataURL(file);
            }
        
            onMouseMove(event) {
                if (!this.isActive) return;
        
                this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        
                this.updateBrushPosition();
                
                if (this.isPainting) {
                    this.paint();
                }
            }
        
            onMouseDown(event) {
                if (event.button !== 0 || !this.isActive || !this.activeModel) return;
                this.isPainting = true;
                this.currentPaintOperation = [];
                this.paint();
            }
        
            onMouseUp() {
                if (this.isPainting && this.currentPaintOperation.length > 0) {
                    this.undoStack.push(this.currentPaintOperation);
                    this.redoStack = [];
                }
                this.isPainting = false;
            }
        
            updateBrushPosition() {
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObject(this.terrain);
        
                if (intersects.length > 0) {
                    const point = intersects[0].point;
                    this.brushPreview.position.copy(point);
                    this.brushPreview.scale.setScalar(this.settings.radius);
                    this.brushPreview.visible = true;
                } else {
                    this.brushPreview.visible = false;
                }
            }
        
            paint() {
                if (!this.activeModel || !this.isPainting) return;
        
                const now = Date.now();
                if (now - this.lastPaintTime < this.settings.paintDelay) return;
                this.lastPaintTime = now;
        
                const intersects = this.raycaster.intersectObject(this.terrain);
                if (intersects.length === 0) return;
        
                const center = intersects[0].point;
                const instanceCount = Math.floor(this.settings.density * (this.settings.radius * this.settings.radius));
        
                for (let i = 0; i < instanceCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * this.settings.radius;
                    
                    const position = new THREE.Vector3(
                        center.x + Math.cos(angle) * radius,
                        center.y + this.settings.heightOffset,
                        center.z + Math.sin(angle) * radius
                    );
        
                    // Check minimum distance from last placement
                    if (position.distanceTo(this.lastPaintPosition) < this.settings.spacing) {
                        continue;
                    }
        
                    const instance = this.activeModel.clone();
                    instance.position.copy(position);
        
                    // Random rotation
                    const rotation = THREE.MathUtils.degToRad(
                        this.settings.rotationMin + 
                        Math.random() * (this.settings.rotationMax - this.settings.rotationMin)
                    );
                    instance.rotation.y = rotation;
        
                    // Random scale
                    const scale = this.settings.scaleMin + 
                        Math.random() * (this.settings.scaleMax - this.settings.scaleMin);
                    instance.scale.setScalar(scale);
        
                    this.scene.add(instance);
                    this.currentPaintOperation.push(instance);
                    this.lastPaintPosition.copy(position);
                }
            }
        
            undo() {
                if (this.undoStack.length === 0) return;
                
                const objects = this.undoStack.pop();
                this.redoStack.push(objects);
                
                objects.forEach(obj => {
                    this.scene.remove(obj);
                });
            }
        
            redo() {
                if (this.redoStack.length === 0) return;
                
                const objects = this.redoStack.pop();
                this.undoStack.push(objects);
                
                objects.forEach(obj => {
                    this.scene.add(obj);
                });
            }
        
            toggleBrush() {
                this.isActive = !this.isActive;
                this.brushPreview.visible = this.isActive;
            }
        
            updateBrushPreview() {
                this.brushPreview.scale.setScalar(this.settings.radius);
            }
        }
    </script>
   
    <script src="index.js"></script>
    <script src="cloth.js"></script>
    <script src="nodes/node-editor.js"></script>
    <script src="physics/lighting-stystem.js"></script>
    <script src="processing/transform-controls.js"></script>
    <script src="js/code.js"></script>
    <script src="js/export.js"></script>
    <script src="sculpting/character-tools.js"></script>
    <script src="hilpers/canvas-selection.js"></script>
    <script src="animations/animation-path.js"></script>
    <script src="js/timeline.js"></script>
    <script type="module">
    // Path is relative to your HTML file, or needs to be an absolute path
    // that your development server can resolve and serve from node_modules.
    // This direct relative path to node_modules might not work with all simple dev servers.
    // A common pattern is to copy needed files from node_modules to a served 'libs' folder during a build step.
    // OR use a CDN that resolves npm modules to ESM URLs like Skypack (see previous answer)

    // Assuming your server *can* serve from node_modules or you copied it:
    // Adjust this path based on where 'index.js' (the ES module entry) for three-csg-ts is.
    // It's usually in node_modules/three-csg-ts/dist/index.js or similar
    import { CSG as CSGModule } from 'node_modules/three-csg-ts/dist/index.js'; // Adjust path as needed!

    window.CSG = CSGModule; // Make CSG global

    // Now dynamically load nanite-ex.js AFTER CSG is global
    const naniteScript = document.createElement('script');
    naniteScript.src = 'js/nanite-ex.js'; // Your existing script
    naniteScript.onload = () => {
        console.log("nanite-ex.js loaded after CSG.");
        // Call your main initialization function from nanite-ex.js if it has one
        if (typeof init === 'function') {
            init();
        }
    };
    naniteScript.onerror = () => {
        console.error("Failed to load nanite-ex.js");
    };
    document.body.appendChild(naniteScript);
</script>

    <script src="processing/nanite-ex.js"></script>
    <script src="processing/tool.js"></script>
    <script src="processing/nanite.js"></script>
    <script src="soundes/sond.js"></script>
    <script src="physics/material-brush-system.js"></script>
    <script src="nodes/vfx.js"></script>
    <script src="hilpers/grid-hilpers.js"></script>
    <script src="hilpers/Keyboard-Shortcuts.js"></script>
    <script src="nodes/explosion.js"></script>
    <script src="animations/animator.js"></script>
    <script src="animations/charater-animation.js"></script>
    <script src="physics/clothing.js"></script>
    <script src="rendering/render.js"></script>
    <script src="processing/spin-tool.js"></script>
    <script src="2D-editor/main.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/loaders/FBXLoader.js"></script>

    <script src="https://threejs.org/examples/jsm/controls/OrbitControls.js"></script>
    <script src="https://threejs.org/examples/jsm/controls/TransformControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/TransformControls.js"></script>

    
    <script src="js/libs/three-csg-bundle.js"></script> 

    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/DRACOLoader.js"></script>
    <!-- DragControls included as requested -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/DragControls.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/geometries/TextGeometry.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@latest/build/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/RGBELoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.17"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.139.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.139.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.139.0/examples/js/controls/TransformControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.139.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.139.0/examples/js/loaders/RGBELoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.139.0/examples/js/pmrem/PMREMGenerator.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.139.0/examples/js/pmrem/PMREMCubeUVPacker.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FBXLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/examples/js/controls/TransformControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r146/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.149.0/examples/js/controls/TransformControls.js"></script>
    <!-- Physics -->
    <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.7/build/dat.gui.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"></script>
    <script async src="https://cdn.jsdelivr.net/npm/ammo.js@0.0.10/ammo.wasm.js"></script>
    <!--Gui-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.139.0/examples/js/objects/Sky.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.17.0/dist/lil-gui.min.js"></script>
    <!-- Particle effects -->
    <script src="https://cdn.jsdelivr.net/npm/three-spritetext@1.6.5/dist/three-spritetext.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script  src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon-es/0.17.0/cannon-es.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/postprocessing/OutlinePass.js"></script>
   <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/loaders/FBXLoader.js"></script>
   <script src="https://cdn.jsdelivr.net/npm/three@0.166.1/build/three.min.js"></script>

   <script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/GLTFLoader.js"></script>
   <script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/OBJLoader.js"></script>
   <script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/FBXLoader.js"></script>

   <!-- Required for FBX -->
   <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/helpers/SkeletonHelper.js"></script>
   <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/loaders/FBXLoader.min.js"></script>
   <script src="https://cdn.jsdelivr.net/npm/fflate@0.7.4/umd/index.min.js"></script>
   <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/inflate.min.js"></script>


  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/postprocessing/UnrealBloomPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/postprocessing/SSAOPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/shaders/CopyShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/postprocessing/ShaderPass.js"></script>
    
  <!--Exporters-->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
  
  <!-- Exporters & Loaders -->
  <script src="https://cdn.jsdelivr.net/npm/three/examples/js/exporters/GLTFExporter.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three/examples/js/exporters/OBJExporter.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three/examples/js/exporters/FBXExporter.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/GLTFLoader.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/OBJLoader.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/FBXLoader.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.161.0/examples/js/loaders/RGBELoader.js"></script>

  <!--Brusch-->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/noisejs/2.0.0/perlin.min.js"></script>

  <!--Proccesing-->
  <script src="https://cdn.jsdelivr.net/npm/three-subdivide"></script>

<script>




// First, add these global variables at the top of your 

const vertexShader = `
    uniform float size;
    attribute float lifetime;
    varying float vLifetime;
    void main() {
        vLifetime = lifetime;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        gl_PointSize = size;
    }
`;

const fragmentShader = `
    uniform sampler2D map;
    varying float vLifetime;
    void main() {
        vec4 texColor = texture2D(map, gl_PointCoord);
        gl_FragColor = texColor * vec4(1.0, 1.0, 1.0, vLifetime * 0.8);
    }
`;

let objects = [];
let snowParticles = [];
let groundLevel = 0;
let snowDensity = 1500;
let snowSize = 0.2;
let snowSpeed = 0.5;
let windForce = 0.5;
let turbulence = 0.5;
let stormMode = false;
let isSnowing = true;
let snowMaterial;

let params = {
    density: 1000,
    size: 0.1,
    speed: 1,
    wind: 0,
    turbulence: 0.5,
    groundLevel: -10,
    mode: 'normal',  // Default mode
    vortexStrength: 1.0,  // For vortex mode
    vortexRadius: 5.0    // For vortex mode
};

const textureLoader = new THREE.TextureLoader();
const snowflakeTexture = textureLoader.load('https://threejs.org/examples/textures/sprites/snowflake2.png');

let snowAccumulation = new Map(); // Store accumulated snow particles
const maxAccumulatedParticles = 1000; // Maximum particles that can accumulate at one spot
const meltingRate = 0.01; // Rate at which snow melts
const gridY = params.groundLevel; // Y position of the grid

function setupSnowControls() {
    // Toggle snow
    document.getElementById('toggleSnow').addEventListener('click', () => {
        isSnowing = !isSnowing;
        if (isSnowing) {
            createSnow();
        } else {
            snowParticles.forEach(particle => scene.remove(particle));
            snowParticles = [];
        }
    });

    // Mode selection
    document.getElementById('snowMode').addEventListener('change', (e) => {
        params.mode = e.target.value;
        recreateSnow();
    });

    // Parameter controls
    ['density', 'size', 'speed', 'wind', 'turbulence'].forEach(param => {
        const slider = document.getElementById(param);
        const valueDisplay = document.getElementById(`${param}Value`);
        
        slider.addEventListener('input', (e) => {
            params[param] = parseFloat(e.target.value);
            valueDisplay.textContent = e.target.value;
            if (param === 'density') recreateSnow();
            if (param === 'size') updateSnowSize();
        });
    });

    // Weather presets
    setupWeatherEffects();
}

function createSnow() {
    const snowGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(params.density * 3);
    const velocities = new Float32Array(params.density * 3);
    const randomFactors = new Float32Array(params.density);

    for (let i = 0; i < params.density; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 50;
        positions[i * 3 + 1] = Math.random() * 50;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 50;

        velocities[i * 3] = (Math.random() - 0.5) * 0.05;
        velocities[i * 3 + 1] = -Math.random() * params.speed;
        velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.05;

        randomFactors[i] = Math.random();
    }

    snowGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    snowGeometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
    snowGeometry.setAttribute('random', new THREE.BufferAttribute(randomFactors, 1));

    const snowMaterial = new THREE.PointsMaterial({
        size: params.size,
        color: 0xffffff,
        transparent: true,
        opacity: 0.8,
        depthWrite: false,
        alphaTest: 0.1,
        map: snowflakeTexture,
        blending: THREE.AdditiveBlending
    });

    const snow = new THREE.Points(snowGeometry, snowMaterial);
    snowParticles.push(snow);
    scene.add(snow);
}

function createSnowflakeTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 32;
    canvas.height = 32;
    const ctx = canvas.getContext('2d');

    ctx.beginPath();
    ctx.arc(16, 16, 14, 0, Math.PI * 2);
    ctx.fillStyle = 'white';
    ctx.fill();

    return new THREE.CanvasTexture(canvas);
}

function updateSnow() {
    const time = Date.now() * 0.001;
    
    snowParticles.forEach(particle => {
        const positions = particle.geometry.attributes.position.array;
        const velocities = particle.geometry.attributes.velocity.array;
        const randomFactors = particle.geometry.attributes.random.array;

        for (let i = 0; i < positions.length; i += 3) {
            if (params.mode === 'normal') {
                // Normal falling snow
                positions[i] += velocities[i] + params.wind * 0.1;
                positions[i + 1] += velocities[i + 1];
                positions[i + 2] += velocities[i + 2];

                // Add some gentle turbulence
                positions[i] += Math.sin(time + randomFactors[i / 3]) * params.turbulence * 0.1;
                positions[i + 2] += Math.cos(time + randomFactors[i / 3]) * params.turbulence * 0.1;
            } else if (params.mode === 'vortex') {
                // Vortex snow
                const x = positions[i];
                const z = positions[i + 2];
                const distance = Math.sqrt(x * x + z * z);
                
                // Calculate vortex motion
                const angle = Math.atan2(z, x) + time * params.vortexStrength;
                const radius = Math.min(distance, params.vortexRadius);
                
                positions[i] = Math.cos(angle) * radius;
                positions[i + 2] = Math.sin(angle) * radius;
                positions[i + 1] += velocities[i + 1] - params.speed * 0.5;

                // Add turbulence to vortex
                positions[i] += Math.sin(time + randomFactors[i / 3]) * params.turbulence * 0.2;
                positions[i + 2] += Math.cos(time + randomFactors[i / 3]) * params.turbulence * 0.2;
            }

            // Ground collision and reset
            if (positions[i + 1] < params.groundLevel) {
                positions[i + 1] = 50 + Math.random() * 10;
                positions[i] = (Math.random() - 0.5) * 50;
                positions[i + 2] = (Math.random() - 0.5) * 50;
                
                velocities[i] = (Math.random() - 0.5) * 0.05;
                velocities[i + 1] = -Math.random() * params.speed;
                velocities[i + 2] = (Math.random() - 0.5) * 0.05;
            }
        }

        particle.geometry.attributes.position.needsUpdate = true;
    });
}

function updateSnowSize() {
    snowParticles.forEach(particle => {
        particle.material.size = params.size;
    });
}

function recreateSnow() {
    snowParticles.forEach(particle => scene.remove(particle));
    snowParticles = [];
    if (isSnowing) createSnow();
}

function setupWeatherEffects() {
    const effects = {
        storm: { speed: 3, wind: 3, turbulence: 2, mode: 'vortex', vortexStrength: 2.0 },
        blizzard: { speed: 4, wind: 4, turbulence: 2.5, mode: 'normal' },
        gentle: { speed: 0.5, wind: 0.2, turbulence: 0.3, mode: 'normal' }
    };

    Object.keys(effects).forEach(effect => {
        document.getElementById(effect).addEventListener('click', () => {
            const settings = effects[effect];
            Object.keys(settings).forEach(param => {
                params[param] = settings[param];
                const slider = document.getElementById(param);
                const valueDisplay = document.getElementById(`${param}Value`);
                if (slider && valueDisplay) {
                    slider.value = settings[param];
                    valueDisplay.textContent = settings[param];
                }
            });
            document.getElementById('snowMode').value = settings.mode;
            recreateSnow();
        });
    });
}

</script>



<script>
// Global variables
let scene, camera, renderer, controls, transformControls, raycaster, mouse;
let selectedObject = null;
let clock = new THREE.Clock();
let isPlaying = false;
let isDragging = false;
let timelineDuration = 300; // 5 minutes in seconds
let currentTime = 0;
const keyframes = new Map();


let  particles;
let particlesGeometry,  particlesMaterial;
const particlesCount = 10000;
let particleColor = 0xffcc88; 
let isParticlesVisible = true;
let isLocked = false;

let textureLoaded = null; 

function toggleParticles() {
    if (!particles) {
        // Create particles for the first time
        createParticles();
        console.log("Particles initialized and enabled");
    } else {
        // Toggle visibility if already created
        isParticlesVisible = !isParticlesVisible;
        particles.visible = isParticlesVisible;
        console.log(`Particles ${isParticlesVisible ? "enabled" : "disabled"}`);
    }
}


function createParticles() {
    if (!textureLoaded) {
        textureLoaded = new THREE.TextureLoader().load(
            'https://threejs.org/examples/textures/sprites/spark1.png'
        );
    }

    particlesGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particlesCount * 3);
    const sizes = new Float32Array(particlesCount);

    for (let i = 0; i < particlesCount; i++) {
        // Gaussian distribution for natural spread
        positions[i * 3] = (Math.random() - 0.5) * 100 + gaussianRandom() * 20;
        positions[i * 3 + 1] = (Math.random() - 0.5) * 100 + gaussianRandom() * 20;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 100 + gaussianRandom() * 20;

        // Randomized size variation
        sizes[i] = Math.random() * 0.5 + 0.1;
    }

    particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    particlesGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

    if (!particlesMaterial) {
        particlesMaterial = new THREE.PointsMaterial({
            color: particleColor,
            size: 0.3,
            sizeAttenuation: true,
            transparent: true,
            opacity: 0.8, // Slight fade-in effect
            map: textureLoaded,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
        });
    }

    particles = new THREE.Points(particlesGeometry, particlesMaterial);
    scene.add(particles);
    isParticlesVisible = true;
}

/**
 * Generates a Gaussian (normal) distribution random number.
 * Creates more naturally clustered particles.
 */
function gaussianRandom(mean = 0, stdev = 1) {
    let u = 1 - Math.random(); // Uniform(0,1] random number
    let v = 1 - Math.random();
    let z = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    return mean + z * stdev;
}


function changeParticlesCount(amount) {
    particlesCount = Math.max(1000, particlesCount + amount);  // Minimum particlesCount is 1000
    updateParticles();
}

function changeParticleColor(color) {
    particleColor = new THREE.Color(color);
    particles.material.color.set(particleColor);  // Update particle color
}





let isDrawing = false;
let drawMode = false;
let extrudeMode = false;
let points = [];
let previewMesh = null;
let previewLine = null;
let quadMeshes = [];
let snapThreshold = 0.3;
let extrudeHeight = 1.0;
cameraOrbitSpeed = 0.005;
let currentCameraPosition = new THREE.Vector3();
let targetCameraPosition = new THREE.Vector3();
let cameraVelocity = new THREE.Vector3();

let mouseDown = false;
let selectedFace = null;
let orbitControls = true;
let transformControlsActive = false;


let isModelingMode = false;
let selectionMode = 'vertex';
let activeObject = null;
let selectedElements = [];
let isOrthographicViewActive = false;

let vertexHelpers = new THREE.Group(); vertexHelpers.name = "VertexHelpers_Global";
let edgeHelpers = new THREE.Group(); edgeHelpers.name = "EdgeHelpers_Global";
let faceHelpers = new THREE.Group(); faceHelpers.name = "FaceHelpers_Global";

let naniteSystem; // Our Nanite system instance
const projScreenMatrix = new THREE.Matrix4();
let explosionManager;
let animatorSystem;
let isPlayerControlActive = false;
let player;


let hairGuides = [];
let selectedGuide = null;
let isEditHairMode = false; // The state for our new mode

function init() {
    
    //scene.background = new THREE.Color(0x333333); // Default to a neutral gray color
    scene = new THREE.Scene();

    if (scene.background && scene.background.dispose) {
        scene.background.dispose();
    }
    if (scene.environment && scene.environment.dispose) {
        scene.environment.dispose();
    }
    //updateRenderOrder();
    // Camera setup
    camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(3, 1.8, 3);
    camera.lookAt(0, 1, 0);
    // window.camera = camera;
    //updateCameraPosition();
  
    // Renderer setup
    renderer = new THREE.WebGLRenderer({
        antialias: true,
        toneMapping: THREE.ACESFilmicToneMapping,
        toneMappingExposure: 1.0,
        powerPreference: "high-performance",
        stencil: true,
        depth: true,
        logarithmicDepthBuffer: true,
        alpha: true
    });

    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('renderer-container').appendChild(renderer.domElement);
    renderer.setPixelRatio(window.devicePixelRatio); // ÿØŸÇÿ© ÿ£ŸÅÿ∂ŸÑ
    renderer.sortObjects = true; 
    renderer.setClearColor(0x000000, 0);
    renderer.autoClear = true;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.antialias = true; // ÿ™ŸÜÿπŸäŸÖ ÿßŸÑÿ≠ŸàÿßŸÅ
    renderer.physicallyCorrectLights = true;


    clock = new THREE.Clock();
    naniteSystem = new NaniteSystem(scene, camera);

    animatorSystem = new AnimatorSystem(scene);
    animatorSystem.init();

    // --- Asset Panel Integration ---
    

    // This event listener now cleanly handles both normal objects and our new LOD objects.
    document.addEventListener('add-to-scene', (event) => {
        const { object, name } = event.detail;
        
        // Add the object (Mesh, Group, or LOD) to the scene
        scene.add(object);
        
        // --- NEW LOGIC: Check if the object needs per-frame updates ---
        if (object.isLOD) {
            // If it's an LOD object, add it to our update list
            updatableObjects.push(object);
            console.log(`Added LOD object '${name}' to the scene and update loop.`);
        } else {
            console.log(`Added standard object '${name}' to the scene.`);
        }
        
        // Your existing logic to add to hierarchy, select it, etc. can go here
        // E.g., updateHierarchy();
        // E.g., selectObject(object);
    });

    //player = new AdvancedPlayerController(scene, camera);
    player = new AdvancedPlayerController(scene, camera, animatorSystem);
    setupPlayerLighting(camera, scene);
    // 2. Add a Ground Plane
    const groundGeometry = new THREE.PlaneGeometry(100, 100);
    const groundMaterial = new THREE.MeshStandardMaterial({
        color: 0x000000,
        opacity: 0.05,
        transparent: true
    });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    ground.name = "GroundPlane";
    scene.add(ground);

    // 3. Load the Character Model
    const loader = new THREE.GLTFLoader();
    loader.load('https://threejs.org/examples/models/gltf/Soldier.glb', (gltf) => {
        // Pass the loaded model AND a list of objects to collide with (just the ground for now)
        const mainCharacterModel = gltf.scene; 
        player.init(gltf, [ground]); 
        const checkPhysicsReady = setInterval(() => {
            if (physicsSimulator && physicsSimulator.isReady) {
                clearInterval(checkPhysicsReady);
                
                // Traverse the loaded model to find all meshes
                mainCharacterModel.traverse(child => {
                    if (child.isMesh) {
                        // Use the correct global variable: physicsSimulator
                        physicsSimulator.addCollider(child);
                        console.log(`Made '${child.name}' a cloth collider.`);
                    }
                });
            }
        }, 200); 
    }, undefined, (error) => {
        console.error('An error happened while loading the character model:', error);
    });

    // 4. Setup the toggle key listener (this code can remain the same)
    window.addEventListener('keydown', (event) => {
        if (event.key.toLowerCase() === 'p') {
            toggleControlMode();
        }
    });

    // 5. ADD A UI HINT to show the current mode
    const controlHint = document.createElement('div');
    controlHint.id = 'control-hint';

    // New styling to fit inside the container
    controlHint.style.color = 'white';
    controlHint.style.backgroundColor = 'rgba(0, 50, 100, 0.7)'; // A slightly different color to stand out
    controlHint.style.padding = '8px';
    controlHint.style.margin = '5px'; // Add some space around it
    controlHint.style.textAlign = 'center';
    controlHint.style.fontFamily = 'monospace';
    controlHint.style.borderRadius = '4px';
    controlHint.style.border = '1px solid #555';
    controlHint.textContent = "Press 'P' to enter Player Mode";

    // Find the container and add the hint to it
    const guiContainer = document.getElementById('gui-container');
    if (guiContainer) {
        // We use prepend to add it at the TOP of the GUI container
        guiContainer.prepend(controlHint);
    } else {
        console.error("Could not find 'gui-container' to add the control hint.");
        // Fallback to adding it to the body if the container isn't found
        document.body.appendChild(controlHint);
    }


    /*
      transformControls.enable = false;

    const loader = new THREE.GLTFLoader();
    // Using a free animated character model for demonstration.
    // Make sure your model has 'idle', 'walk', and 'run' animations.
    loader.load('https://threejs.org/examples/models/gltf/Soldier.glb', (gltf) => {
        
        // The animations are often named like "Walk", "Run", "Idle".
        // Our Player class converts them to lowercase.
        console.log("Available animations:", gltf.animations.map(a => a.name));
        
        // This is the crucial step: initialize the player with the loaded model and animations
        player.init(gltf);

    }, undefined, (error) => {
        console.error('An error happened while loading the character model:', error);
    });*/
    if (controls) {
        controls.dispose();
        controls = null;
    }

    // Axes helper
    const axesHelper = new THREE.AxesHelper(5);
    scene.add(axesHelper);

    // Raycaster and mouse setup
    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();

  
    // Controls
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    transformControls = new THREE.TransformControls(camera, renderer.domElement);
    scene.add(transformControls);
    controls.enableDamping = true;
    controls.dampingFactor = 0.25;
    controls.screenSpacePanning = false;
    controls.enabled = true;

    // 3. Set up the interaction between the two
    transformControls.addEventListener('mouseDown', function() {
        transformControlsActive = true;
        if (controls && !isLocked) {
            controls.enabled = false;
        }

        selectedObject = transformControls.object;
        updateLayersUI();

        console.log("Transform started, orbit controls disabled");
    });

    transformControls.addEventListener('mouseUp', function() {
        transformControlsActive = false;
        if (controls && !isLocked) {
            controls.enabled = true;
        }
        console.log("Transform ended, orbit controls restored");
    });

    transformControls.addEventListener('objectChange', () => {
        // When the user drags a handle, update the guide's data
        const handle = transformControls.object;
        if (handle && handle.userData.isGuideHandle) {
            const guide = handle.userData.guide;
            const pointIndex = handle.userData.pointIndex;
            
            // Update the data in the guide object
            guide.controlPoints[pointIndex].copy(handle.position);
            
            // Tell the guide to update its own visuals and flag for a rebuild
            guide.update();
        }
    });

    // This is still helpful as a backup
    /*transformControls.addEventListener('dragging-changed', function(event) {
        if (controls && !isLocked) {
            controls.enabled = !event.value;
        }
    }),*/

        transformControls.addEventListener('dragging-changed', function (event) {
        // Assuming your orbit controls are stored in a 'controls' variable
        if (controls) controls.enabled = !event.value;
    });
  


    /*const nodeEditor = new NodeEditor(scene, camera, raycaster);
    // Pass nodeEditor to global scope if needed
    window.nodeEditor = nodeEditor;*/

    const nodeEditorInstance = new NodeEditor(scene, camera);
    //window.nodeEditor = nodeEditorInstance;

    document.addEventListener('keydown', (e) => {
        if (e.ctrlKey && e.key === 'z') nodeEditor.undo();
        if (e.ctrlKey && e.key === 'y') nodeEditor.redo();
    });
    //modeling helpers
    scene.add(vertexHelpers);
    scene.add(edgeHelpers);
    scene.add(faceHelpers);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); // soft white light
    scene.add(ambientLight);

    // 2. Directional light - creates basic shadows and highlights
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(1, 1, 1).normalize();
    scene.add(directionalLight);

    // 3. Helper light from opposite side to reduce harsh shadows
    const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
    backLight.position.set(-1, 0.5, -1).normalize();
    scene.add(backLight);

    const light = new THREE.DirectionalLight(0xffffff, 1.0);
    light.position.set(1, 1, 1).normalize();
    scene.add(light);
    
    // Small amount of ambient so shadows aren't pure black
    scene.add(new THREE.AmbientLight(0xffffff, 0.2));

    const lighting = {
        ambientLight: null,
        hemiLight: null,
        sunLight: null,
        rectLight1: null,
        rectLight2: null,
        spotLight: null,
        directionalLight: null,
        fillLight: null,
        advancedEnabled: false
    };

    // Create basic lighting (always present)
    function setupBasicLighting() {
        lighting.ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(lighting.ambientLight);
        
        const basicDirectional = new THREE.DirectionalLight(0xffffff, 0.5);
        basicDirectional.position.set(1, 1, 1);
        scene.add(basicDirectional);
    }

    // Create advanced lighting
    function setupAdvancedLighting() {
        // Remove basic lights if they exist
        if (lighting.ambientLight) scene.remove(lighting.ambientLight);
        
        // 1. Ambient Light
        lighting.ambientLight = new THREE.AmbientLight(0xffffff, 0.1);
        scene.add(lighting.ambientLight);

        // 2. Hemisphere Light
        lighting.hemiLight = new THREE.HemisphereLight(0xb1e1ff, 0x444444, 0.5);
        lighting.hemiLight.position.set(0, 50, 0);
        scene.add(lighting.hemiLight);

        // 3. Sun Light
        lighting.sunLight = new THREE.DirectionalLight(0xfff2cc, 3.5);
        lighting.sunLight.position.set(40, 60, 20);
        lighting.sunLight.castShadow = true;
        lighting.sunLight.shadow.mapSize.width = 4096;
        lighting.sunLight.shadow.mapSize.height = 4096;
        lighting.sunLight.shadow.camera.left = -100;
        lighting.sunLight.shadow.camera.right = 100;
        lighting.sunLight.shadow.camera.top = 100;
        lighting.sunLight.shadow.camera.bottom = -100;
        lighting.sunLight.shadow.camera.far = 350;
        lighting.sunLight.shadow.camera.near = 0.5;
        lighting.sunLight.shadow.bias = -0.0001;
        lighting.sunLight.shadow.normalBias = 0.05;
        scene.add(lighting.sunLight);

        // 4. RectArea Lights
        lighting.rectLight1 = new THREE.RectAreaLight(0xffddbb, 2.5, 20, 20);
        lighting.rectLight1.position.set(-15, 20, 15);
        lighting.rectLight1.lookAt(0, 0, 0);
        scene.add(lighting.rectLight1);

        lighting.rectLight2 = new THREE.RectAreaLight(0x99ccff, 2.0, 30, 15);
        lighting.rectLight2.position.set(15, 10, -15);
        lighting.rectLight2.lookAt(0, 0, 0);
        scene.add(lighting.rectLight2);

        // 5. Spot Light
        lighting.spotLight = new THREE.SpotLight(0xffffff, 1.5, 100, Math.PI/5, 0.3, 2);
        lighting.spotLight.position.set(25, 40, 10);
        lighting.spotLight.target.position.set(0, 0, 0);
        lighting.spotLight.castShadow = true;
        lighting.spotLight.shadow.mapSize.width = 2048;
        lighting.spotLight.shadow.mapSize.height = 2048;
        lighting.spotLight.shadow.bias = -0.0001;
        lighting.spotLight.shadow.normalBias = 0.02;
        scene.add(lighting.spotLight);
        scene.add(lighting.spotLight.target);

        // 6. Directional Light
        lighting.directionalLight = new THREE.DirectionalLight(0xfff8e1, 1.0);
        lighting.directionalLight.position.set(5, 10, 7.5);
        lighting.directionalLight.castShadow = true;
        lighting.directionalLight.shadow.mapSize.width = 2048;
        lighting.directionalLight.shadow.mapSize.height = 2048;
        lighting.directionalLight.shadow.camera.near = 0.5;
        lighting.directionalLight.shadow.camera.far = 50;
        lighting.directionalLight.shadow.camera.left = -15;
        lighting.directionalLight.shadow.camera.right = 15;
        lighting.directionalLight.shadow.camera.top = 15;
        lighting.directionalLight.shadow.camera.bottom = -15;
        lighting.directionalLight.shadow.bias = -0.0005;
        scene.add(lighting.directionalLight);

        // 7. Fill Light
        lighting.fillLight = new THREE.SpotLight(0xe6e6fa, 1.5, 50, Math.PI/4, 0.5);
        lighting.fillLight.position.set(-10, 15, 20);
        lighting.fillLight.castShadow = true;
        lighting.fillLight.shadow.mapSize.width = 2048;
        lighting.fillLight.shadow.mapSize.height = 2048;
        scene.add(lighting.fillLight);

        lighting.advancedEnabled = true;
    }

    // Toggle between basic and advanced lighting
    function toggleAdvancedLighting() {
        const button = document.getElementById('toggle-lighting');
        
        if (lighting.advancedEnabled) {
            // Remove advanced lights
            scene.remove(
                lighting.hemiLight,
                lighting.sunLight,
                lighting.rectLight1,
                lighting.rectLight2,
                lighting.spotLight,
                lighting.spotLight.target,
                lighting.directionalLight,
                lighting.fillLight
            );
            
            // Setup basic lighting
            setupBasicLighting();
            button.textContent = 'Enable Advanced Lighting';
            lighting.advancedEnabled = false;
        } else {
            // Setup advanced lighting
            setupAdvancedLighting();
            button.textContent = 'Disable Advanced Lighting';
            lighting.advancedEnabled = true;
        }
    }

    // Initialize with basic lighting
    setupBasicLighting();

    // Add event listener for the toggle button
    document.getElementById('toggle-lighting').addEventListener('click', toggleAdvancedLighting);
  

   
    // Grid helper
    const advancedGrid = createAdvancedGridHelper(1000, 1000);
    advancedGrid.name = 'advancedGrid';
    advancedGrid.renderOrder = -2; 
    scene.add(advancedGrid);

    if (axesHelper) {
        axesHelper.renderOrder = -1;
    }
    const lineMaterial = new THREE.LineBasicMaterial({
        color: 0xffff00,
        linewidth: 2
    });

    previewLine = new THREE.Line(
        new THREE.BufferGeometry(),
        lineMaterial
    );
    scene.add(previewLine);

    const meshesToProcessForNanite = [];
    scene.traverse(obj => {
        if (obj.isMesh && obj.geometry && obj.geometry.attributes.position) {
            // Add filters: e.g., not part of axisHelper, not debug meshes, not ground, etc.
            // A common way is to check obj.name or specific userData flags.
            if (obj !== axesHelper && !obj.userData.isNaniteOriginal && !obj.userData.isNaniteLOD && obj.name !== "NaniteDebugGroup" && obj.name !== "advancedGrid") {
                if (obj.geometry.attributes.position.count > 100) { // Heuristic: only process reasonably complex meshes
                    meshesToProcessForNanite.push(obj);
                }
            }
        }
    });
    meshesToProcessForNanite.forEach(mesh => {
        console.log("Attempting to add to Nanite:", mesh.name || mesh.uuid);
        naniteSystem.addMesh(mesh, {
            autoGenerateLODs: true,
            isStatic: mesh.userData.static || false, // You can set userData.static = true on meshes
            preserveMaterials: true,
        });
    });

    // Enhanced fog
    scene.fog = new THREE.FogExp2(0x2a2a2a, 0.01);
    // GUI setup
    const settings = addGUI(scene, renderer, camera);
    if (settings.useHDR) {
        scene.background = new THREE.Color(settings.background);
        scene.environment = null;
        scene.fog = new THREE.FogExp2(settings.background, settings.density);
    } else {
        // Start with color background if HDRI is disabled
        const hdriPath = `https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/${hdriFiles[settings.selectedHDRI]}`;
        updateEnvironmentAndBackground(hdriPath);
    }

    // Event listeners and initialization
    window.addEventListener('DOMContentLoaded', () => {
        const lockButton = document.getElementById('toggle-lock');
        if (lockButton) {
            lockButton.addEventListener('click', toggleLock);
            console.log("Lock button listener attached");
        } else {
            console.error("Lock button not found!");
        }
    });
    
    /*document.addEventListener('DOMContentLoaded', () => {
        // Wait a short time to ensure THREE.js is initialized
        setTimeout(() => {
            initPathAnimationSystem();
            addPathAnimationStyles();
        }, 1000);
    });*/


    
    // Create spawn menu (OPTIONAL)
    //createSpawnMenu();
    
    // Add character controls to GUI (OPTIONAL)
    if (settings && settings.gui) {
        addCharacterToGUI(settings.gui);
    }


    // Override scene.add to auto-add objects to timeline
    const originalSceneAdd = scene.add;
    scene.add = function(object) {
        originalSceneAdd.apply(scene, arguments);
        // ADD THIS CHECK: If the object has the ignore flag, don't add it to the timeline.
        if (object.isObject3D && !object.userData.ignoreInTimeline) {
           addObjectToTimeline(object); // <--- THIS IS THE CRUCIAL CALL
        }
    return object;
    };
    /*scene.add = function(object) {
        originalSceneAdd.apply(scene, arguments);
        // ADD THIS CHECK: If the object has the ignore flag, don't add it to the timeline.
        if (object.isObject3D && !object.userData.ignoreInTimeline) {
            addObjectToTimeline(object);
        }
        return object;
    };*/
    /*scene.add = function(object) {
        originalSceneAdd.apply(scene, arguments); // Call original add
            if (object.isObject3D) { // Ensure it‚Äôs a 3D object
                addObjectToTimeline(object);
        }
        return object;
    };*/

    try {
        explosionManager = new ExplosionManager(scene, camera, clock);
        explosionManager.init();
        
        // Expose a global function for easy debugging from the console
        window.createExplosion = (x, y, z) => {
            if (explosionManager) {
                explosionManager.triggerExplosion(x, y, z);
            }
        };
        console.log("‚úÖ Explosion System Initialized Successfully.");
    } catch (e) {
        console.error("‚ùå Failed to initialize Explosion System:", e);
    }


 
    initializeTimeline();
    setupTimelineEventListeners();
    initCanvasSelection();
    setupMultiSelectionHandling();
    //initializeShortcutsSystem();
   
    //initializePathAnimationSystem(scene, camera, renderer);
    const pathAnimator = initPathAnimationSystem(scene, camera, renderer);
    //hookAnimate(pathAnimator);
    initShortcutsPanel();
    setupSceneElements();
    initModeling();
    setupSnowControls();
    createSnow();
    bindInspectorInputs(); 
    EditorAccess.init(scene, camera, transformControls);

   // setupViewportDragAndDrop();
    initializeEditors();
    initializePhysicsSystem();
    //addTestObjectsForClothSimBL();
    setupTerrainControls();
    setupEventListeners();
    activatePanelButtonTool();
    initPhysics();
    addDemonstrationObjects();
    //createParticles();
    toggleParticles();
    animate();
    optimizeScene();
    initBrush();
    initCharacterSculpting();
}


function updateEnvironmentAndBackground(hdriUrl) {
    const loader = new THREE.RGBELoader();
    const pmremGenerator = new THREE.PMREMGenerator(renderer);
    pmremGenerator.compileEquirectangularShader();

    loader.load(hdriUrl, function (texture) {
        const envMap = pmremGenerator.fromEquirectangular(texture).texture;

        // Dispose previous environment/background if needed
        if (scene.environment && scene.environment.dispose) {
            scene.environment.dispose();
        }
        if (scene.background && scene.background.dispose) {
            scene.background.dispose();
        }

        scene.environment = envMap;
        scene.background = envMap; // Set this if you want the HDR to be visible as the background

        texture.dispose();
        pmremGenerator.dispose();

        console.log("HDR environment and background applied.");
    }, undefined, function (err) {
        console.error("Failed to load HDRI:", err);
    });
}



function createAdvancedGridHelper(size = 100, divisions = 100) { // Adjusted default size for typical scenes
    const gridGroup = new THREE.Group();
    gridGroup.name = 'advancedGrid'; // Set name here for consistency

    gridGroup.renderOrder = -1;
    // Horizontal XZ grid
    const horizontalGrid = new THREE.GridHelper(size, divisions);
    horizontalGrid.material = new THREE.LineBasicMaterial({
        color: 0x666666,
        opacity: 0.5,
        transparent: true,
        depthWrite: false 
    });
    horizontalGrid.renderOrder = -1; 
    horizontalGrid.name = 'horizontalGrid';
    gridGroup.add(horizontalGrid);

    // Vertical grid (XY or YZ)
    const verticalGrid = new THREE.GridHelper(size, divisions * 2); // Can have more divisions if needed
    verticalGrid.material = new THREE.LineBasicMaterial({
        color: 0x888888, // Slightly lighter
        opacity: 0.7,
        transparent: true,
        depthWrite: false
    });
    verticalGrid.renderOrder = -1; 
    verticalGrid.name = 'verticalGrid';
    verticalGrid.visible = false; // Hidden by default
    gridGroup.add(verticalGrid);

    // Major axes (Placeholder, implement if needed)
    const axesGroup = createMajorAxes(size); // Assuming this returns a Group
    gridGroup.add(axesGroup);

    // Measurement labels (Placeholder, implement if needed)
    const labelsGroup = createMeasurementLabels(size); // Assuming this returns a Group
    gridGroup.add(labelsGroup);

    // Current active plane tracker
    gridGroup.currentPlane = 'xz'; // Default to horizontal XZ plane

    // Method to update grid visibility and orientation
    gridGroup.updateGrid = function(plane) {
        console.log(`[updateGrid] Called with plane: ${plane}`);
        
        // Set current plane
        this.currentPlane = plane || 'xz';
        
        // Update grid visibility based on plane
        horizontalGrid.visible = (plane === 'xz' || plane === null);
        verticalGrid.visible = (plane === 'xy' || plane === 'yz');
        
        console.log(`  [updateGrid] horizontalGrid.visible: ${horizontalGrid.visible}, verticalGrid.visible: ${verticalGrid.visible}`);

        // Always reset rotation before applying a new one to avoid cumulative rotations
        verticalGrid.rotation.set(0, 0, 0);

        if (plane === 'xy') {
            // For XY plane (looking along Z axis), rotate 90 degrees around X
            verticalGrid.rotation.x = Math.PI / 2;
        } else if (plane === 'yz') {
            // For YZ plane (looking along X axis)
            // For proper orientation facing the camera, we need specific rotations
            verticalGrid.rotation.x = Math.PI / 2;
            verticalGrid.rotation.z = Math.PI / 2;
        }
    };

    // Store original camera position and orientation for detecting view changes
    let lastCameraPosition = new THREE.Vector3();
    let lastCameraDirection = new THREE.Vector3();
    
    // Dynamic visibility based on camera distance and view change
    gridGroup.onBeforeRender = function(renderer, scene, camera) {
        if (!camera || typeof camera.position.length !== 'function') return;

        const distance = camera.position.length();
        const maxVisibleDistance = size * 1.5;

        // Fade out based on distance
        const fade = THREE.MathUtils.smoothstep(distance, maxVisibleDistance * 0.5, maxVisibleDistance);

        const baseHorizontalOpacity = 0.5;
        const baseVerticalOpacity = 0.7;

        if (horizontalGrid.material && typeof horizontalGrid.material.opacity !== 'undefined') {
            horizontalGrid.material.opacity = baseHorizontalOpacity * (1 - fade);
        }
        if (verticalGrid.material && typeof verticalGrid.material.opacity !== 'undefined') {
            verticalGrid.material.opacity = baseVerticalOpacity * (1 - fade);
        }

        // Visibility of labels based on distance
        if (labelsGroup) {
            labelsGroup.visible = (distance < size * 0.75);
        }
        
        // Get current camera position and direction
        const currentCameraPosition = new THREE.Vector3().copy(camera.position);
        // Get the direction the camera is pointing (normalized)
        const currentCameraDirection = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion).normalize();
        
        // Check if the camera has moved significantly
        const positionChanged = !lastCameraPosition.equals(currentCameraPosition);
        const directionChanged = lastCameraDirection.dot(currentCameraDirection) < 0.999; // Slight change in direction
        
        // If we moved or rotated and vertical grid is visible, check if we need to revert to horizontal
        if ((positionChanged || directionChanged) && verticalGrid.visible) {
            // Calculate normalized direction vector from origin to camera
            const cameraDir = new THREE.Vector3().copy(camera.position).normalize();
            
            // Define axis direction vectors for the three standard views
            const xAxisDir = new THREE.Vector3(1, 0, 0);   // X axis (YZ plane)
            const yAxisDir = new THREE.Vector3(0, 1, 0);   // Y axis (XZ plane)
            const zAxisDir = new THREE.Vector3(0, 0, 1);   // Z axis (XY plane)
            
            // Calculate dot products to see alignment with axes
            const xDot = Math.abs(cameraDir.dot(xAxisDir));
            const yDot = Math.abs(cameraDir.dot(yAxisDir));
            const zDot = Math.abs(cameraDir.dot(zAxisDir));
            
            // Threshold for deciding when view is "aligned" with an axis
            const alignmentThreshold = 0.97; // Higher value = stricter alignment required
            
            // Check if we're aligned with the current plane's axis
            let isAligned = false;
            if (this.currentPlane === 'xy' && zDot > alignmentThreshold) {
                isAligned = true;
            } else if (this.currentPlane === 'yz' && xDot > alignmentThreshold) {
                isAligned = true;
            } else if (this.currentPlane === 'xz' && yDot > alignmentThreshold) {
                isAligned = true;
            }
            
            // If we're not aligned with the current plane's axis, revert to horizontal grid
            if (!isAligned) {
                horizontalGrid.visible = true;
                verticalGrid.visible = false;
                this.currentPlane = 'xz'; // Reset to horizontal XZ plane
                console.log("[Grid] View changed, reverting to horizontal grid only");
            }
            
            // Update last position and direction for next frame
            lastCameraPosition.copy(currentCameraPosition);
            lastCameraDirection.copy(currentCameraDirection);
        }
    };

    return gridGroup;
}


let axisToggleState = {
    x: true,
    y: true,
    z: true
};

function setCameraView(direction) {
    console.log(`--- setCameraView CALLED with direction: ${direction} ---`);

    let targetPosition = new THREE.Vector3();
    let lookAtPosition = new THREE.Vector3(0, 0, 0); // Always look at origin
    let gridPlane = null;
    let initialIsOrthographicActive = isOrthographicViewActive;

    switch (direction) {
        case 'x':
            if (axisToggleState.x) {
                targetPosition.set(4, 0, 0); // +X
                document.getElementById("axis-x").innerText = "X";
            } else {
                targetPosition.set(-4, 0, 0); // -X
                document.getElementById("axis-x").innerText = "-X";
            }
            axisToggleState.x = !axisToggleState.x;
            gridPlane = 'yz';
            isOrthographicViewActive = true;
            break;
        case 'y':
        case 'top':
            if (axisToggleState.y) {
                targetPosition.set(0, 4, 0); // +Y
                document.getElementById("axis-y").innerText = "Y";
            } else {
                targetPosition.set(0, -4, 0); // -Y
                document.getElementById("axis-y").innerText = "-Y";
            }
            axisToggleState.y = !axisToggleState.y;
            gridPlane = 'xz';
            isOrthographicViewActive = true;
            break;
        case 'z':
            if (axisToggleState.z) {
                targetPosition.set(0, 0, 4); // +Z
                document.getElementById("axis-z").innerText = "Z";
            } else {
                targetPosition.set(0, 0, -4); // -Z
                document.getElementById("axis-z").innerText = "-Z";
            }
            axisToggleState.z = !axisToggleState.z;
            gridPlane = 'xy';
            isOrthographicViewActive = true;
            break;
        case 'bottom':
            targetPosition.set(0, -4, 0);
            gridPlane = 'xz';
            isOrthographicViewActive = true;
            break;
        case 'diagonal':
            targetPosition.set(4, 4, 4);
            gridPlane = 'xz';
            isOrthographicViewActive = false;
            break;
        default:
            console.warn('[setCameraView] Unknown camera view:', direction);
            return;
    }
    
    console.log(`[setCameraView] Direction: ${direction}, Initial isOrthographicViewActive: ${initialIsOrthographicActive}, New isOrthographicViewActive: ${isOrthographicViewActive}, Target GridPlane: ${gridPlane}`);

    const advancedGrid = scene.getObjectByName('advancedGrid');
    if (advancedGrid && advancedGrid.updateGrid) {
        advancedGrid.updateGrid(gridPlane);
        
        // Reset the camera tracking variables to prevent immediate reversion of grid
        if (advancedGrid.onBeforeRender && advancedGrid.onBeforeRender.lastCameraPosition) {
            advancedGrid.onBeforeRender.lastCameraPosition = targetPosition.clone();
            const lookDir = new THREE.Vector3().subVectors(lookAtPosition, targetPosition).normalize();
            advancedGrid.onBeforeRender.lastCameraDirection = lookDir;
        }
    } else {
        console.error("[setCameraView] Could not find advancedGrid or its updateGrid method!");
    }

    if (controls) controls.enabled = false; // Disable controls during animation

    gsap.to(camera.position, {
        duration: 0.5,
        x: targetPosition.x,
        y: targetPosition.y,
        z: targetPosition.z,
        ease: "power2.inOut",
        onUpdate: () => {
            camera.lookAt(lookAtPosition);
        },
        onComplete: () => {
            console.log(`[setCameraView GSAP Complete] Final isOrthographicViewActive after animation for '${direction}' view: ${isOrthographicViewActive}`);
            if (controls) {
                controls.target.copy(lookAtPosition);
                controls.update();
                controls.enabled = true;
                
                // After animation completes, store the final camera position and direction
                // to establish a new baseline for grid visibility checks
                if (advancedGrid && advancedGrid.onBeforeRender) {
                    const currentCameraPosition = new THREE.Vector3().copy(camera.position);
                    const currentCameraDirection = new THREE.Vector3(0, 0, -1)
                        .applyQuaternion(camera.quaternion).normalize();
                        
                    // Store these as the new baseline
                    if (!advancedGrid.onBeforeRender.lastCameraPosition) {
                        advancedGrid.onBeforeRender.lastCameraPosition = new THREE.Vector3();
                    }
                    if (!advancedGrid.onBeforeRender.lastCameraDirection) {
                        advancedGrid.onBeforeRender.lastCameraDirection = new THREE.Vector3();
                    }
                    
                    advancedGrid.onBeforeRender.lastCameraPosition.copy(currentCameraPosition);
                    advancedGrid.onBeforeRender.lastCameraDirection.copy(currentCameraDirection);
                }
            }
        }
    });
} 



function initModeling() {
     console.log("Initializing Modeling System...");
     // Ensure transformControls exists
     if (!transformControls) {
         console.error("TransformControls not initialized before initModeling!");
         return;
     }
    // This function now mainly sets up listeners, called from init
    initTransformControls(); // Setup TransformControls listeners specific to modeling
    setupTransformControls(); // Setup general interaction with OrbitControls
    setupModelingEventListeners(); // Setup buttons, mouse interactions for modeling panel/canvas
    console.log("Modeling System Initialized.");
    // Optionally toggle modeling mode ON by default for testing:
    // setTimeout(toggleModelingMode, 500); // Delay slightly to ensure UI is ready
}

// Camera controls
const zoomSpeed = 0.05; // Finer control over zoom sensitivity
const rotationSpeed = 0.005; // Smoother rotation
const moveSpeed = 0.1; // Consistent movement speed
let cameraDistance = 10;
let cameraTheta = Math.PI / 4;
let cameraPhi = Math.PI / 3;
const cameraTarget = new THREE.Vector3(0, 0, 0);
let isDraggingCam = false;
let lastMouseX, lastMouseY;
let velocity = new THREE.Vector3(); // For smooth movement
let targetTheta = cameraTheta;
let targetPhi = cameraPhi;
let targetDistance = cameraDistance;

const dampingFactor = 0.05; // Instead of 0.1 for more easing
/*
function updateCameraPosition() {
   const x = cameraDistance * Math.sin(cameraPhi) * Math.sin(cameraTheta);
   const y = cameraDistance * Math.cos(cameraPhi);
   const z = cameraDistance * Math.sin(cameraPhi) * Math.cos(cameraTheta);
   camera.position.set(x, y, z);
   camera.lookAt(cameraTarget);
}*/

// Enhanced smooth zoom with better focus
function smoothZoomToTarget(newTargetDistance, newTargetPoint) {
   const steps = 20;
   let stepCount = 0;

   const initialDistance = cameraDistance;
   const initialTarget = cameraTarget.clone();

   const deltaDistance = newTargetDistance - initialDistance;
   const deltaTarget = newTargetPoint.clone().sub(initialTarget);

    function step() {
       stepCount++;
       const t = stepCount / steps;

       cameraDistance = initialDistance + deltaDistance * t;
       cameraTarget.copy(initialTarget.clone().add(deltaTarget.clone().multiplyScalar(t)));

       updateCameraPosition();

        if (stepCount < steps) {
           requestAnimationFrame(step);
        }
    }

    requestAnimationFrame(step);
}

// Improved zoom camera with better intersection detection
function zoomCamera(delta, mouseX, mouseY) {
    const zoomFactor = 1 - delta * zoomSpeed;
    const newDistance = THREE.MathUtils.clamp(targetDistance * zoomFactor, 1, 100);
  

    raycaster.setFromCamera(new THREE.Vector2(mouseX, mouseY), camera);
    const intersects = raycaster.intersectObjects(scene.children, true);

    if (intersects.length > 0) {
       const point = intersects[0].point;
       smoothZoomToTarget(newDistance, point); // Use smooth zoom
    } else {
       smoothZoomToTarget(newDistance, cameraTarget); // Zoom to center if no object
    }

    // Update internal targets
    targetDistance = newDistance;


}

function focusOnObject(object) {
    const box = new THREE.Box3().setFromObject(object);
    const center = box.getCenter(new THREE.Vector3());

    cameraTarget.copy(center);

    const size = box.getSize(new THREE.Vector3()).length();
    targetDistance = size * 1.5;

    updateCameraPosition();

}

// Keyboard Movement Controls

function moveCamera(direction) {
    const forward = new THREE.Vector3();
    camera.getWorldDirection(forward);
    
    // ÿßÿ™ÿ¨ÿßŸá ÿßŸÑŸäŸÖŸäŸÜ ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ cross ŸÖÿπ ÿßŸÑŸÖÿ≠Ÿàÿ± Y
    const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();

    switch (direction) {
        case "forward": // Up Arrow / W
            camera.position.add(forward.multiplyScalar(moveSpeed));
            break;
        case "backward": // Down Arrow / S
            camera.position.add(forward.multiplyScalar(-moveSpeed));
            break;
        case "left": // Left Arrow / A
            camera.position.add(right.multiplyScalar(-moveSpeed));
            break;
        case "right": // Right Arrow / D
            camera.position.add(right.multiplyScalar(moveSpeed));
            break;
    }
}

document.addEventListener("keydown", (event) => {
    switch (event.code) {
        case "ArrowUp":
        case "KeyW":
            moveCamera("forward");
            break;
        case "ArrowDown":
        case "KeyS":
            moveCamera("backward");
            break;
        case "ArrowLeft":
        case "KeyA":
            moveCamera("left");
            break;
        case "ArrowRight":
        case "KeyD":
            moveCamera("right");
            break;
    }
});


// Add model to scene
function addModelToScene(model) {
    // Process model materials and enable shadows
    model.traverse((node) => {
        if (node.isMesh) {
            node.castShadow = true;
            node.receiveShadow = true;
            
            // Ensure materials update correctly
            if (node.material) {
                node.material.needsUpdate = true;
                if (Array.isArray(node.material)) {
                    node.material.forEach(mat => mat.needsUpdate = true);
                }
            }
        }
    });

    // Add model to the scene
    scene.add(model);
    objects.push(model);

    // Setup animations if present
    if (model.animations && model.animations.length > 0) {
        const mixer = new THREE.AnimationMixer(model);
        model.userData.mixer = mixer;
        model.animations.forEach(clip => {
            const action = mixer.clipAction(clip);
            action.play();
        });
    }

    // Update hierarchy (if needed)
    updateHierarchy();
}

function setupSceneElements() {
    scene.fog = new THREE.FogExp2(0x1c1c1c, 0.02);
    
    const axesHelper = new THREE.AxesHelper(5);
    scene.add(axesHelper);

    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();
}

function animateParticles() {
    const positions = particles.geometry.attributes.position.array;
    const time = Date.now() * 0.001;

    for (let i = 0; i < particlesCount * 3; i += 3) {
        positions[i] += Math.sin(time + positions[i + 2] * 0.1) * 0.01;
        positions[i + 1] += Math.cos(time + positions[i] * 0.1) * 0.01;
        positions[i + 2] += Math.sin(time * 0.5 + positions[i] * 0.1) * 0.01;
    }

    particles.geometry.attributes.position.needsUpdate = true;
}

function addGUI(scene, renderer, camera, naniteSystemInstance) {
    const gui = new dat.GUI({ autoPlace: false });

    const settings = {
        background: 0x2a2a2a, 
        density: 0.02,
        useHDR: true, 
        selectedHDRI: 'sunset', 
        hdriIntensity: 1.0, 
        hdriRotation: 0,
        fov: camera.fov, nearPlane: camera.near, farPlane: camera.far,
        enableShadows: true, shadowMapSize: 2048, shadowBias: -0.0001,
        lightIntensity: 1,
        ambientLightColor: 0xffffff, ambientLightIntensity: 0.5,
        pointLightColor: 0xffffff, pointLightIntensity: 1, pointLightDistance: 100, pointLightDecay: 2,
        directionalLightColor: 0xffffff, directionalLightIntensity: 1,
        directionalLightPosition: { x: 5, y: 5, z: 5 },
        materialReflectivity: 0.5, roughness: 0.5, metalness: 0.5, envMapIntensity: 1.0,
        enablePostProcessing: true, bloomEnabled: true, bloomIntensity: 1.0,
        bloomThreshold: 0.9, bloomRadius: 0.8,
        dofEnabled: false, focusDistance: 10, focalLength: 24, bokehScale: 2.0,
        enableStats: false, pixelRatio: 1.0
    };

    const hdriFiles = {
        sunset: 'venice_sunset_1k.hdr',
        forest: 'mossy_forest_1k.hdr',
        studio: 'studio_small_07_1k.hdr',
        night: 'dikhololo_night_1k.hdr',
        indoor: 'IndoorEnvironmentHDRI003_1K.hdr',
        Kloppenheim06: 'kloppenheim_06_1k.hdr',
        Syferfontein_1d_Clear : 'syferfontein_1d_clear_1k.hdr',
        Syferfontein_6d_Clear: 'syferfontein_6d_clear_1k.hdr',
        Syferfontein_18d_Clear : 'syferfontein_18d_clear_1k.hdr',
    };

    // Utility: Update material properties
    const updateMaterials = () => {
        scene.traverse(obj => {
            const mat = obj.material;
            if (mat) {
                ['reflectivity', 'roughness', 'metalness', 'envMapIntensity'].forEach(prop => {
                    if (mat[prop] !== undefined) mat[prop] = settings[prop];
                });
                mat.needsUpdate = true;
            }
        });
    };

    // === Scene Folder ===
    const sceneFolder = gui.addFolder('Scene Settings');
    sceneFolder.addColor(settings, 'background').onChange(() => {
        if (!settings.useHDR) {
            scene.background = new THREE.Color(settings.background);
            updateFog();
        }
    });
    sceneFolder.add(settings, 'density', 0.001, 0.1).step(0.001).onChange(updateFog);
    sceneFolder.open();

    // === HDRI Folder ===
    const hdriFolder = gui.addFolder('HDRI Settings');
    hdriFolder.add(settings, 'useHDR').name('Enable HDRI').onChange(updateHDRI);
    hdriFolder.add(settings, 'selectedHDRI', Object.keys(hdriFiles)).name('HDRI Type').onChange(updateHDRI);
    hdriFolder.add(settings, 'hdriIntensity', 0, 5).step(0.1).name('Intensity').onChange(updateHDRISettings);
    hdriFolder.add(settings, 'hdriRotation', 0, Math.PI * 2).step(0.1).name('Rotation').onChange(updateHDRISettings);
    hdriFolder.open();


    function updateFog() {
        scene.fog = new THREE.FogExp2(settings.background, settings.density);
    }

     function updateHDRI() {
        if (!settings.useHDR) {
            // When HDRI is disabled, set background to color and remove environment
            scene.background = new THREE.Color(settings.background);
            scene.environment = null;
            updateFog();
            console.log("HDRI disabled");
            return;
        }

        // When HDRI is enabled, load the selected HDRI
        const hdriPath = `https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/${hdriFiles[settings.selectedHDRI]}`;
        
        const loader = new THREE.RGBELoader();
        loader.setDataType(THREE.FloatType)
              .load(hdriPath, texture => {
            const pmremGen = new THREE.PMREMGenerator(renderer);
            pmremGen.compileEquirectangularShader();
            
            const envMap = pmremGen.fromEquirectangular(texture).texture;
            
            // Apply the HDRI to both background and environment
            scene.background = envMap;
            scene.environment = envMap;
            
            // Apply intensity and rotation
            scene.backgroundIntensity = settings.hdriIntensity;
            // Apply rotation if needed (requires a more complex setup with background material)
            
            texture.dispose();
            pmremGen.dispose();
            
            console.log("HDRI enabled and updated:", settings.selectedHDRI);
        });
    }

    // Function to update HDRI settings without reloading
    function updateHDRISettings() {
        if (settings.useHDR && scene.background) {
            scene.backgroundIntensity = settings.hdriIntensity;
            // For rotation, you might need a more sophisticated approach
            // involving a background mesh or transforming the environment map
            console.log("HDRI settings updated");
        }
    }
    // === Camera Folder ===
    const cameraFolder = gui.addFolder('Camera Settings');
    cameraFolder.add(settings, 'fov', 20, 120).onChange(updateCamera);
    cameraFolder.add(settings, 'nearPlane', 0.1, 10).onChange(updateCamera);
    cameraFolder.add(settings, 'farPlane', 100, 5000).onChange(updateCamera);
    cameraFolder.open();

    function updateCamera() {
        camera.fov = settings.fov;
        camera.near = settings.nearPlane;
        camera.far = settings.farPlane;
        camera.updateProjectionMatrix();
    }

    // === Shadow Folder ===
    const shadowFolder = gui.addFolder('Shadow Settings');
    shadowFolder.add(settings, 'enableShadows').onChange(enable => {
        renderer.shadowMap.enabled = enable;
        scene.traverse(obj => {
            if (obj.castShadow !== undefined) {
                obj.castShadow = enable;
                obj.receiveShadow = enable;
            }
        });
    });
    shadowFolder.add(settings, 'shadowMapSize', [512, 1024, 2048, 4096]).onChange(updateShadowMapSize);
    shadowFolder.add(settings, 'shadowBias', -0.01, 0.01).step(0.0001).onChange(updateShadowBias);
    shadowFolder.open();

    function updateShadowMapSize(val) {
        scene.traverse(obj => {
            if (obj.isLight && obj.shadow) {
                obj.shadow.mapSize.set(val, val);
                obj.shadow.map?.dispose();
            }
        });
    }

    function updateShadowBias(val) {
        scene.traverse(obj => {
            if (obj.isLight && obj.shadow) obj.shadow.bias = val;
        });
    }

    // === Lighting Folder ===
    const lightFolder = gui.addFolder('Lighting Settings');

    const ambient = lightFolder.addFolder('Ambient Light');
    ambient.addColor(settings, 'ambientLightColor').onChange(updateAmbientLight);
    ambient.add(settings, 'ambientLightIntensity', 0, 2).onChange(updateAmbientLight);

    const point = lightFolder.addFolder('Point Light');
    point.addColor(settings, 'pointLightColor').onChange(updatePointLight);
    point.add(settings, 'pointLightIntensity', 0, 5).onChange(updatePointLight);
    point.add(settings, 'pointLightDistance', 0, 1000).onChange(updatePointLight);
    point.add(settings, 'pointLightDecay', 0, 5).onChange(updatePointLight);

    const directional = lightFolder.addFolder('Directional Light');
    directional.addColor(settings, 'directionalLightColor').onChange(updateDirectionalLight);
    directional.add(settings, 'directionalLightIntensity', 0, 5).onChange(updateDirectionalLight);
    ['x', 'y', 'z'].forEach(axis => {
        directional.add(settings.directionalLightPosition, axis, -20, 20).onChange(updateDirectionalLight);
    });

    lightFolder.open();

    function updateAmbientLight() {
        scene.traverse(obj => {
            if (obj instanceof THREE.AmbientLight) {
                obj.color.set(settings.ambientLightColor);
                obj.intensity = settings.ambientLightIntensity;
            }
        });
    }

    function updatePointLight() {
        scene.traverse(obj => {
            if (obj instanceof THREE.PointLight) {
                obj.color.set(settings.pointLightColor);
                obj.intensity = settings.pointLightIntensity;
                obj.distance = settings.pointLightDistance;
                obj.decay = settings.pointLightDecay;
            }
        });
    }

    function updateDirectionalLight() {
        scene.traverse(obj => {
            if (obj instanceof THREE.DirectionalLight) {
                obj.color.set(settings.directionalLightColor);
                obj.intensity = settings.directionalLightIntensity;
                obj.position.set(
                    settings.directionalLightPosition.x,
                    settings.directionalLightPosition.y,
                    settings.directionalLightPosition.z
                );
            }
        });
    }


    // === Material Folder ===
    const matFolder = gui.addFolder('Material Settings');
    matFolder.add(settings, 'materialReflectivity', 0, 1).onChange(updateMaterials);
    matFolder.add(settings, 'roughness', 0, 1).onChange(updateMaterials);
    matFolder.add(settings, 'metalness', 0, 1).onChange(updateMaterials);
    matFolder.add(settings, 'envMapIntensity', 0, 5).onChange(updateMaterials);
    matFolder.open();

    // === Post-Processing ===
    const postFolder = gui.addFolder('Post-Processing');
    postFolder.add(settings, 'enablePostProcessing').onChange(() => {});

    const bloom = postFolder.addFolder('Bloom');
    bloom.add(settings, 'bloomEnabled').onChange(() => {});
    bloom.add(settings, 'bloomIntensity', 0, 5).onChange(() => {});
    bloom.add(settings, 'bloomThreshold', 0, 1).onChange(() => {});
    bloom.add(settings, 'bloomRadius', 0, 1).onChange(() => {});

    const dof = postFolder.addFolder('Depth of Field');
    dof.add(settings, 'dofEnabled').onChange(() => {});
    dof.add(settings, 'focusDistance', 0.1, 50).onChange(() => {});
    dof.add(settings, 'focalLength', 12, 100).onChange(() => {});
    dof.add(settings, 'bokehScale', 0, 10).onChange(() => {});

    postFolder.open();

    // Nanite System GUI Controls (Add this section)
    if (naniteSystemInstance) { // Check if naniteSystem was passed
        const naniteFolder = gui.addFolder('Nanite LOD System');
        naniteFolder.add(naniteSystemInstance, 'enabled').name('Enabled');
        naniteFolder.add(naniteSystemInstance, 'debugMode').name('Debug View').onChange(v => naniteSystemInstance.toggleDebug(v));
        naniteFolder.add(naniteSystemInstance, 'baseLODDistance', 5, 200, 1).name('Base LOD Dist');
        naniteFolder.add(naniteSystemInstance, 'lodDistanceMultiplier', 1.1, 5.0, 0.1).name('LOD Dist Mult');
        naniteFolder.add(naniteSystemInstance, 'lodLevels', 1, 8, 1).name('LOD Levels');
        naniteFolder.add(naniteSystemInstance, 'frustumCullLODs').name('Frustum Cull LODs');
        // naniteFolder.add(naniteSystemInstance, 'useClustering').name('Clustering (Debug)'); // If you implement it
        naniteFolder.add({
            addTestSphere: () => {
                const geometry = new THREE.SphereGeometry(2, 128, 128); // High poly sphere
                const material = new THREE.MeshStandardMaterial({ color: 0x00aaff, metalness: 0.5, roughness: 0.5 });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.name = "NaniteTestSphere";
                mesh.position.set(Math.random() * 20 - 10, 2, Math.random() * 20 - 10);
                scene.add(mesh); // Add to scene first
                naniteSystemInstance.addMesh(mesh); // Then to Nanite
            }
        }, 'addTestSphere').name('Add Test Sphere');
        naniteFolder.open();
    }



    // === Performance ===
    const perfFolder = gui.addFolder('Performance');
    perfFolder.add(settings, 'enableStats').onChange(() => {});
    perfFolder.add(settings, 'pixelRatio', 0.5, 2).step(0.25).onChange(() => {
        renderer.setPixelRatio(settings.pixelRatio);
    });
    perfFolder.open();

    // Append GUI to container
    const guiContainer = document.getElementById('gui-container');
    guiContainer.appendChild(gui.domElement);

    // Return settings object for external access
    return settings;

    return gui; // in case user wants to append GUI manually or reuse
}





//Modelign Shapes

let subdivisionLevel = 0;

function createMajorAxes(size = 10) {
    const axesGroup = new THREE.Group();
    const fontSize = size * 0.1;
    const arrowLength = size / 2;
    const arrowHeadLength = size * 0.05;
    const arrowHeadWidth = size * 0.03;

    // Create axis lines
    const xAxis = createAxisLine(size, 0xff0000, new THREE.Vector3(1, 0, 0));
    const yAxis = createAxisLine(size, 0x00ff00, new THREE.Vector3(0, 1, 0));
    const zAxis = createAxisLine(size, 0x0000ff, new THREE.Vector3(0, 0, 1));
    axesGroup.add(xAxis, yAxis, zAxis);

    // Create arrowheads
    const xArrow = new THREE.ArrowHelper(
        new THREE.Vector3(1, 0, 0),
        new THREE.Vector3(arrowLength, 0, 0),
        arrowHeadLength,
        0xff0000,
        arrowHeadLength,
        arrowHeadWidth
    );

    const yArrow = new THREE.ArrowHelper(
        new THREE.Vector3(0, 1, 0),
        new THREE.Vector3(0, arrowLength, 0),
        arrowHeadLength,
        0x00ff00,
        arrowHeadLength,
        arrowHeadWidth
    );

    const zArrow = new THREE.ArrowHelper(
        new THREE.Vector3(0, 0, 1),
        new THREE.Vector3(0, 0, arrowLength),
        arrowHeadLength,
        0x0000ff,
        arrowHeadLength,
        arrowHeadWidth
    );

    axesGroup.add(xArrow, yArrow, zArrow);

    // Create labels using your text sprite method
    const xLabel = createTextSprite('X');
    xLabel.position.set(arrowLength + arrowHeadLength * 1.5, 0, 0);
    axesGroup.add(xLabel);

    const yLabel = createTextSprite('Y');
    yLabel.position.set(0, arrowLength + arrowHeadLength * 1.5, 0);
    axesGroup.add(yLabel);

    const zLabel = createTextSprite('Z');
    zLabel.position.set(0, 0, arrowLength + arrowHeadLength * 1.5);
    axesGroup.add(zLabel);

    return axesGroup;
}


// Create arrow at the positive end
function createAxisLine(size, color, direction) { 
    const geometry = new THREE.BufferGeometry();
    const vertices = new Float32Array([
        -size/2 * direction.x, -size/2 * direction.y, -size/2 * direction.z,
        size/2 * direction.x, size/2 * direction.y, size/2 * direction.z
    ]);
    geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
    
    const material = new THREE.LineBasicMaterial({
        color: color,
        linewidth: 2,
        opacity: 0.8,
        transparent: true
    });

    return new THREE.Line(geometry, material);
}



function createMeasurementLabels(size) {
    const labelsGroup = new THREE.Group();
    const interval = size / 10;
    
    // Create text sprites for measurement labels
    for (let i = -size/2; i <= size/2; i += interval) {
        if (i === 0) continue; // Skip 0
        
        // X-axis labels
        const xLabel = createTextSprite(i.toString());
        xLabel.position.set(i, 0, -20);
        labelsGroup.add(xLabel);
        
        // Z-axis labels
        const zLabel = createTextSprite(i.toString());
        zLabel.position.set(-20, 0, i);
        labelsGroup.add(zLabel);
    }

    return labelsGroup;
}


function createTextSprite(message) {
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.width = 256;
    canvas.height = 256;
    
    context.font = "Bold 36px Arial";
    context.fillStyle = "rgba(255,255,255,0.95)";
    context.fillText(message, 128, 128);
    
    const texture = new THREE.CanvasTexture(canvas);
    const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
    const sprite = new THREE.Sprite(spriteMaterial);
    sprite.scale.set(50, 50, 1);
    
    return sprite;
}


function toggleLock() {
    isLocked = !isLocked;
    
    if (controls) {
        // If locked, disable controls regardless of transform state
        if (isLocked) {
            controls.enabled = false;
        } 
        // If unlocked, enable controls only if not currently transforming
        else if (!transformControlsActive) {
            controls.enabled = true;
        }
    }
    
    // Update UI
    const lockButton = document.getElementById('toggle-lock');
    if (lockButton) {
        lockButton.innerHTML = isLocked 
            ? '<i class="fas fa-lock"></i>' 
            : '<i class="fas fa-unlock"></i>';
        lockButton.style.backgroundColor = isLocked ? '#e74c3c' : '#2ecc71';
    }
    
    console.log("Camera lock toggled:", isLocked, "Controls enabled:", controls.enabled);
}





function toggleExtrudeMode() {
    if (drawMode) toggleDrawMode();
    extrudeMode = !extrudeMode;
    
    if (extrudeMode) {
        controls.enabled = false;
        transformControls.enabled = false;
        transformControls.detach();
        selectedObject = null;
    } else {
        controls.enabled = true;
        transformControls.enabled = true;
        selectedFace = null;
    }
    
    document.getElementById('toggle-extrude').classList.toggle('active', extrudeMode);
    updateStatus();
}


function exitCurrentMode() {
    if (drawMode) toggleDrawMode();
    if (extrudeMode) toggleExtrudeMode();
    
    // Restore normal controls
    controls.enabled = true;
    transformControls.enabled = true;
    
    points = [];
    updatePreviewLine();
    selectedFace = null;
    brushCursor.visible = false;
    updateStatus();
}

function toggleDrawMode() {
    if (extrudeMode) toggleExtrudeMode();
    drawMode = !drawMode;
    
    if (drawMode) {
        controls.enabled = false;
        transformControls.enabled = false;
        transformControls.detach();
        selectedObject = null;
        brushCursor.visible = true;
    } else {
        controls.enabled = true;
        transformControls.enabled = true;
        points = [];
        updatePreviewLine();
        brushCursor.visible = false;
    }
   
    document.getElementById('toggle-draw').classList.toggle('active', drawMode);
    updateStatus();
}

function updatePreviewLine() {
    if (points.length > 0) {
        const positions = [];
        points.forEach(point => {
            positions.push(point.x, point.y, point.z);
        });
        
        // Close the shape if we have enough points
        if (points.length >= 3) {
            positions.push(points[0].x, points[0].y, points[0].z);
        }

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        previewLine.geometry.dispose();
        previewLine.geometry = geometry;
    } else {
        previewLine.geometry.dispose();
        previewLine.geometry = new THREE.BufferGeometry();
    }
}

function clearGeometry() {
    quadMeshes.forEach(mesh => {
        mesh.geometry.dispose();
        mesh.material.dispose();
        scene.remove(mesh);
    });
    quadMeshes = [];
    points = [];
    updatePreviewLine();
    selectedFace = null;
    updateStatus();
}


function onMouseDown(event) {
    if (isLocked) return;
    event.preventDefault();
    mouseDown = true;
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    if (drawMode) {
        isDrawing = true;
        addPoint(event);
    } else if (extrudeMode) {
        selectFaceToExtrude();
    } else if (!drawMode && !extrudeMode) {
        orbitControls.enabled = true;
    }

    zoomCamera(e.deltaY > 0 ? 1 : -1);
}

function onMouseMove(event) {
    if (isLocked) return;
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    // Update brush cursor position
    updateBrushPosition(event);

    if (drawMode && isDrawing) {
        addPoint(event);
    }

    // Highlight face when in extrude mode
    if (extrudeMode && !mouseDown) {
        highlightFace();
    }

}

function onMouseUp(event) {
    if (isLocked) return;
    mouseDown = false;
    
    if (drawMode && isDrawing) {
        isDrawing = false;
        if (points.length >= 4) {
            createQuad();
            points = [];
            updatePreviewLine();
            updateStatus();
        }
    } else if (extrudeMode && selectedFace) {
        extrudeFace();
    }
}

function onMouseWheel(event) {
   event.preventDefault();
            
    // Adjust camera zoom
    cameraDistance = THREE.MathUtils.clamp(
        cameraDistance + event.deltaY * 0.01,
        5, 30
    );
    updateCameraPosition();
}


function initQuadBrush() {
    // Preview line for drawing
    const lineMaterial = new THREE.LineBasicMaterial({
        color: 0xffff00,
        linewidth: 2
    });
    
    previewLine = new THREE.Line(
        new THREE.BufferGeometry(),
        lineMaterial
    );
    scene.add(previewLine);
    
    // Reset quad-related variables
    points = [];
    quadMeshes = [];
    drawMode = false;
    extrudeMode = false;
}

    
function addPoint(event) {
    raycaster.setFromCamera(mouse, camera);
    
    // Try to snap to existing points or grid
    let snappedPoint = null;
    
    // First try to snap to existing points
    if (points.length > 0 && snapThreshold > 0) {
        for (const point of points) {
            const screenPoint = point.clone().project(camera);
            const distance = Math.sqrt(
                Math.pow(screenPoint.x - mouse.x, 2) + 
                Math.pow(screenPoint.y - mouse.y, 2)
            );
            
            if (distance < snapThreshold * 0.1) {
                snappedPoint = point.clone();
                break;
            }
        }
    }
    
    // If no point snap, check for mesh or grid intersections
    if (!snappedPoint) {
        // Include all scene objects that should be considered for drawing
        const intersectObjects = [...quadMeshes, ...objects];
        const intersects = raycaster.intersectObjects(intersectObjects, true);
        
        if (intersects.length > 0) {
            snappedPoint = intersects[0].point.clone();
            
            // Add some height offset to avoid z-fighting
            snappedPoint.y += 0.01;
            
            // Grid snapping
            if (snapThreshold > 0) {
                snappedPoint.x = Math.round(snappedPoint.x / snapThreshold) * snapThreshold;
                snappedPoint.z = Math.round(snappedPoint.z / snapThreshold) * snapThreshold;
            }
        }
    }
    
    if (snappedPoint) {
        // Check if this is close to first point (to close the loop)
        if (points.length >= 3) {
            const firstPoint = points[0];
            if (snappedPoint.distanceTo(firstPoint) < 0.5) {
                createQuad();
                points = [];
                updatePreviewLine();
                isDrawing = false;
                updateStatus();
                return;
            }
        }
        
        // Only add point if it's far enough from the last point
        if (points.length === 0 || 
            snappedPoint.distanceTo(points[points.length - 1]) > 0.1) {
            points.push(snappedPoint);
            updatePreviewLine();
            updateStatus();
        }
    }
}



function selectFaceToExtrude() {
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(quadMeshes);
    
    if (intersects.length > 0) {
        const face = intersects[0].face;
        const mesh = intersects[0].object;
        
        selectedFace = {
            mesh: mesh,
            faceIndex: face.a, // Store the first vertex index of the face
            normal: face.normal.clone()
        };
        
        updateStatus();
    }
}


function highlightFace() {
    // Reset any previously selected face
    quadMeshes.forEach(mesh => {
        if (mesh.material.emissive) {
            mesh.material.emissive.setRGB(0, 0, 0);
        }
    });
    
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(quadMeshes);
    
    if (intersects.length > 0) {
        const mesh = intersects[0].object;
        
        // Highlight by setting emissive color
        if (mesh.material.emissive) {
            mesh.material.emissive.setRGB(0.2, 0.2, 0);
        }
    }
}

function extrudeFace() {
    if (!selectedFace) return;
    
    const mesh = selectedFace.mesh;
    const geometry = mesh.geometry;
    const normal = selectedFace.normal;
    
    // Get the indices of the face to extrude (assuming quads)
    const faceIndex = selectedFace.faceIndex;
    const indices = [];
    
    // For a quad, find the indices that make up the face
    if (geometry.index) {
        for (let i = 0; i < geometry.index.count; i += 3) {
            if (geometry.index.array[i] === faceIndex ||
                geometry.index.array[i+1] === faceIndex ||
                geometry.index.array[i+2] === faceIndex) {
                indices.push(
                    geometry.index.array[i],
                    geometry.index.array[i+1],
                    geometry.index.array[i+2]
                );
                // Get next triangle if it's part of the same quad
                if (i+3 < geometry.index.count && 
                    (geometry.index.array[i+3] === geometry.index.array[i] ||
                     geometry.index.array[i+3] === geometry.index.array[i+1] ||
                     geometry.index.array[i+3] === geometry.index.array[i+2])) {
                    indices.push(
                        geometry.index.array[i+3],
                        geometry.index.array[i+4],
                        geometry.index.array[i+5]
                    );
                }
                break;
            }
        }
    }
    
    if (indices.length === 0) return;
    
    // Get unique vertex indices
    const uniqueIndices = [...new Set(indices)];
    
    // Create new geometry
    const newGeometry = new THREE.BufferGeometry();
    
    // Get position attribute
    const positions = geometry.getAttribute('position');
    const newPositions = [];
    
    // Original vertices
    uniqueIndices.forEach(index => {
        newPositions.push(
            positions.getX(index),
            positions.getY(index),
            positions.getZ(index)
        );
    });
    
    // Extruded vertices
    uniqueIndices.forEach(index => {
        newPositions.push(
            positions.getX(index) + normal.x * extrudeHeight,
            positions.getY(index) + normal.y * extrudeHeight,
            positions.getZ(index) + normal.z * extrudeHeight
        );
    });
    
    // Create new index buffer for the sides
    const newIndices = [];
    
    // The front face (original quad)
    newIndices.push(0, 1, 2, 0, 2, 3);
    
    // The back face (extruded quad)
    newIndices.push(4, 6, 5, 4, 7, 6);
    
    // The four side faces
    newIndices.push(0, 4, 1, 1, 4, 5);
    newIndices.push(1, 5, 2, 2, 5, 6);
    newIndices.push(2, 6, 3, 3, 6, 7);
    newIndices.push(3, 7, 0, 0, 7, 4);
    
    newGeometry.setAttribute('position', new THREE.Float32BufferAttribute(newPositions, 3));
    newGeometry.setIndex(newIndices);
    newGeometry.computeVertexNormals();
    
    const material = new THREE.MeshPhongMaterial({
        color: 0x808080,
        side: THREE.DoubleSide,
        flatShading: true
    });
    
    const newMesh = new THREE.Mesh(newGeometry, material);
    scene.add(newMesh);
    quadMeshes.push(newMesh);
    
    // Remove the original face/mesh
    scene.remove(mesh);
    quadMeshes = quadMeshes.filter(m => m !== mesh);
    mesh.geometry.dispose();
    mesh.material.dispose();
    
    selectedFace = null;
    updateStatus();
}

function createQuad() {
    if (points.length < 4) return;

    // Use the first 4 points or simplify if more
    const validPoints = points.length > 4 ? simplifyPoints(points) : points.slice(0, 4);
    
    const geometry = new THREE.BufferGeometry();
    const vertices = [];
    const indices = [];

    // Create vertices
    for (let i = 0; i < validPoints.length; i++) {
        vertices.push(validPoints[i].x, validPoints[i].y, validPoints[i].z);
    }

    // Create faces - first triangle
    indices.push(0, 1, 2);
    
    // If we have 4 points, add second triangle
    if (validPoints.length >= 4) {
        indices.push(0, 2, 3);
    }

    geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
    geometry.setIndex(indices);
    geometry.computeVertexNormals();

    const material = new THREE.MeshPhongMaterial({
        color: 0x808080,
        side: THREE.DoubleSide,
        flatShading: true
    });

    const quad = new THREE.Mesh(geometry, material);
    scene.add(quad);
    addObjectToScene(quad, "Quad geomitry")
    quadMeshes.push(quad);
    
    // Make it selectable in your existing system
    objects.push(quad);
}

function simplifyPoints(inputPoints) {
    if (inputPoints.length <= 4) return inputPoints;
    
    // Simple algorithm to find corners
    const result = [inputPoints[0]];
    
    // Find point furthest from first point
    let maxDist = 0;
    let furthestIdx = 0;
    for (let i = 1; i < inputPoints.length; i++) {
        const dist = inputPoints[0].distanceTo(inputPoints[i]);
        if (dist > maxDist) {
            maxDist = dist;
            furthestIdx = i;
        }
    }
    result.push(inputPoints[furthestIdx]);
    
    // Find point furthest from line between first and second point
    maxDist = 0;
    furthestIdx = 0;
    const line = new THREE.Line3(result[0], result[1]);
    for (let i = 1; i < inputPoints.length; i++) {
        if (i === result[1]) continue;
        const closest = new THREE.Vector3();
        line.closestPointToPoint(inputPoints[i], true, closest);
        const dist = closest.distanceTo(inputPoints[i]);
        if (dist > maxDist) {
            maxDist = dist;
            furthestIdx = i;
        }
    }
    result.push(inputPoints[furthestIdx]);
    
    // Find the fourth point
    maxDist = 0;
    furthestIdx = 0;
    for (let i = 1; i < inputPoints.length; i++) {
        if (result.includes(inputPoints[i])) continue;
        
        // Calculate area of quad with this point
        const area = calculateQuadArea([
            result[0], result[1], result[2], inputPoints[i]
        ]);
        
        if (area > maxDist) {
            maxDist = area;
            furthestIdx = i;
        }
    }
    result.push(inputPoints[furthestIdx]);
    
    return result;
}

function calculateQuadArea(points) {
    if (points.length !== 4) return 0;
    
    // Calculate area using cross product
    const v1 = points[2].clone().sub(points[0]);
    const v2 = points[3].clone().sub(points[1]);
    return v1.cross(v2).length() / 2;
}


// Event listeners setup
function setupEventListeners() {
    // Tool buttons
    document.getElementById('translate').addEventListener('click', () => setTransformMode('translate'));
    document.getElementById('rotate').addEventListener('click', () => setTransformMode('rotate'));
    document.getElementById('scale').addEventListener('click', () => setTransformMode('scale'));
   
    document.addEventListener('keydown', (e) => {
        if (e.key.toLowerCase() === 'g') {
            document.getElementById('translate').click();
        } else if (e.key.toLowerCase() === 'r') {
            document.getElementById('rotate').click();
        } else if (e.key.toLowerCase() === 's') {
            document.getElementById('scale').click();
        }
    });
    // Event delegation for cleaner code
    document.querySelector('.toolbar-group').addEventListener('click', (event) => {
    const mode = event.target.id;
    if (TRANSFORM_MODES.includes(mode)) {
        setTransformMode(mode);
    }
    });  
    
    // Add objects buttons
    document.getElementById('addCube').addEventListener('click', addCube);
    document.getElementById('addSphere').addEventListener('click', addSphere);
    document.getElementById('addSculptingSphere').addEventListener('click', addSculptingSphere);

    document.getElementById("addSculptingSphere").addEventListener("click", function() {
       const sculptingTools = document.getElementById("sculpting-character-tools");
      // Toggle visibility
      if (sculptingTools.style.display === "none" || sculptingTools.style.display === "") {
        sculptingTools.style.display = "block";
      } else {
        sculptingTools.style.display = "none";
    }
    });

    document.getElementById("addTerrain").addEventListener("click", function() {
       const sculptingTools = document.getElementById("sculpting-tools");
      // Toggle visibility
      if (sculptingTools.style.display === "none" || sculptingTools.style.display === "") {
        sculptingTools.style.display = "block";
      } else {
        sculptingTools.style.display = "none";
    }
    });

    document.getElementById("materialsEditor").addEventListener("click", function() {
       const materialsEditor = document.getElementById("material-editor");
      // Toggle visibility
      if (materialsEditor.style.display === "none" || materialsEditor.style.display === "") {
        materialsEditor.style.display = "block";
      } else {
        materialsEditor.style.display = "none";
    }
    });

    document.getElementById("guiControls").addEventListener("click", function() {
       const guiControlsEditor = document.getElementById("GuiContainer");
      // Toggle visibility
      if (guiControlsEditor.style.display === "none" || guiControlsEditor.style.display === "") {
        guiControlsEditor.style.display = "block";
      } else {
        guiControlsEditor.style.display = "none";
    }
    });

    document.getElementById("cameraControls").addEventListener("click", function() {
       const cameraControls = document.getElementById("Cameras");
      // Toggle visibility
      if (cameraControls.style.display === "none" || cameraControls.style.display === "") {
        cameraControls.style.display = "block";
      } else {
        cameraControls.style.display = "none";
    }
    });

    document.getElementById("lightControls").addEventListener("click", function() {
       const lightControls = document.getElementById("lights");
      // Toggle visibility
      if (lightControls.style.display === "none" || lightControls.style.display === "") {
        lightControls.style.display = "block";
      } else {
        lightControls.style.display = "none";
    }
    });

    document.getElementById("modelingControls").addEventListener("click", function() {
       const modelingTools = document.getElementById("modelingTools");
      // Toggle visibility
      if (modelingTools.style.display === "none" || modelingTools.style.display === "") {
        modelingTools.style.display = "block";
      } else {
        modelingTools.style.display = "none";
    }
    });

    document.getElementById("soundControls").addEventListener("click", function() {
        const meterSection = document.getElementById("sound-controls-meter");
        const visSection = document.getElementById("sound-controls-vis");
        const headerSection = document.getElementById("sound-controls-header");

        // Toggle all sections
        const isHidden = meterSection.style.display === "none" || meterSection.style.display === "";
    
        meterSection.style.display = isHidden ? "block" : "none";
        visSection.style.display = isHidden ? "block" : "none";
        headerSection.style.display = isHidden ? "block" : "none";
    });

    document.getElementById("drawingControls").addEventListener("click", function() {
       const drawingTools = document.getElementById("drawingMode");
      // Toggle visibility
      if (drawingTools.style.display === "none" || drawingTools.style.display === "") {
         drawingTools.style.display = "block";
      } else {
        drawingTools.style.display = "none";
    }
    });

    document.getElementById("physicsControls").addEventListener("click", function() {
       const physicsControls = document.getElementById("physics-controls");
      // Toggle visibility
      if (physicsControls.style.display === "none" || physicsControls.style.display === "") {
        physicsControls.style.display = "block";
      } else {
        physicsControls.style.display = "none";
    }
    });

    document.getElementById("coloring2D").addEventListener("click", function() {
       const inspector2D = document.getElementById("inspector2D");
      // Toggle visibility
      if (inspector2D.style.display === "none" || inspector2D.style.display === "") {
        inspector2D.style.display = "block";
      } else {
        inspector2D.style.display = "none";
    }
    });

    document.getElementById("snow-controls").addEventListener("click", function() {
       const snowTools = document.getElementById("snow-sittings");
      // Toggle visibility
      if (snowTools.style.display === "none" || snowTools.style.display === "") {
        snowTools.style.display = "block";
      } else {
        snowTools.style.display = "none";
    }
    });

    document.getElementById('addPlane').addEventListener('click', addPlane);
    document.getElementById('addCylinder').addEventListener('click', addCylinder);
    document.getElementById('addPyramid').addEventListener('click', addPyramid);
    document.getElementById('addRectangularPrism').addEventListener('click', addRectangularPrism);
    document.getElementById('addTorus').addEventListener('click', addTorus)
    document.getElementById('addCone').addEventListener('click', addCone);
    document.getElementById('addRoundedBox').addEventListener('click', addRoundedBox);
    document.getElementById('addIcosahedron').addEventListener('click', addIcosahedron);
    document.getElementById('addTorusKnot').addEventListener('click', addTorusKnot);

    document.getElementById('addLight').addEventListener('click', addLight);
    document.getElementById('addCameraInit').addEventListener('click', addCameraInit);
  
    renderer.domElement.addEventListener('mousemove', onModelingMouseMove);
    renderer.domElement.addEventListener('click', onModelingClick);

    window.addEventListener('resize', onWindowResize, false);
        window.addEventListener('keydown', (e) => {
            if (e.key === 'f' || e.key === 'F') {
                toggleDrawMode();
            }
            if (e.key === 'e' || e.key === 'E') {
                toggleExtrudeMode();
            }
            if (e.key === 'l' || e.key === 'L') {
                clearGeometry();
            }
            if (e.key === 'Escape') {
                exitCurrentMode();
            }
    });
            
    document.getElementById('toggle-draw').addEventListener('click', toggleDrawMode);
    document.getElementById('toggle-extrude').addEventListener('click', toggleExtrudeMode);
    document.getElementById('clear').addEventListener('click', clearGeometry);
            
    document.getElementById('brush-size').addEventListener('input', (e) => {
        brushSize = parseFloat(e.target.value);
        e.target.nextElementSibling.textContent = `Brush Size: ${brushSize.toFixed(1)}`;
    });
            
    document.getElementById('snapping').addEventListener('input', (e) => {
        snapThreshold = parseFloat(e.target.value);
        e.target.nextElementSibling.textContent = `Snapping: ${snapThreshold.toFixed(1)}`;
    });
            
    document.getElementById('extrude-height').addEventListener('input', (e) => {
         extrudeHeight = parseFloat(e.target.value);
        e.target.nextElementSibling.textContent = `Extrude: ${extrudeHeight.toFixed(1)}`;
    });

    const canvas = renderer.domElement;
    canvas.addEventListener('mousedown', onMouseDown);
    canvas.addEventListener('mousemove', onMouseMove);
    canvas.addEventListener('mouseup', onMouseUp);
    canvas.addEventListener('wheel', onMouseWheel);
    //canvas.addEventListener('pointerleave', onPointerUp);
    canvas.addEventListener('pointerdown', (event) => {
        if (isModelingMode) return;  // Skip selection in modeling mode

        const rect = canvas.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(scene.children, true);

        if (intersects.length > 0) {
            const firstSelectable = intersects.find(i => i.object.userData.selectable);
            if (firstSelectable) {
                const clickedObject = firstSelectable.object;
                setHoverObject(clickedObject);     // visually hover on click
                selectObject(clickedObject);       // also select
            }
        }
    });

    
    //Particls
    document.addEventListener("DOMContentLoaded", () => {
        document.getElementById("toggleParticles").addEventListener("click", toggleParticles);
    });

    document.getElementById('increaseParticles').addEventListener('click', () => changeParticlesCount(1000));  // Increase by 1000
    document.getElementById('decreaseParticles').addEventListener('click', () => changeParticlesCount(-1000));  // Decrease by 1000
    document.getElementById('particleColor').addEventListener('input', (e) => changeParticleColor(e.target.value));  // Color picker

    //Snow 
    document.getElementById('density').addEventListener('input', (e) => {
    params.density = parseInt(e.target.value);
    document.getElementById('densityValue').textContent = params.density;
    recreateSnow();
    });
    

    document.addEventListener('keydown', (event) => {
    if (event.key === 's') {
        stormMode = !stormMode;
    }
    });

    
    document.getElementById('size').addEventListener('input', (e) => {
        params.size = parseFloat(e.target.value);
        document.getElementById('sizeValue').textContent = params.size;
         updateSnowSize();
    });

    document.getElementById('speed').addEventListener('input', (e) => {
        params.speed = parseFloat(e.target.value);
         document.getElementById('speedValue').textContent = params.speed;
    });

    document.getElementById('wind').addEventListener('input', (e) => {
        params.wind = parseFloat(e.target.value);
        document.getElementById('windValue').textContent = params.wind;
    });

    document.getElementById('turbulence').addEventListener('input', (e) => {
        params.turbulence = parseFloat(e.target.value);
        document.getElementById('turbulenceValue').textContent = params.turbulence;
    });



    setupWeatherEffects();

    //hierarchy resizing
    document.addEventListener('DOMContentLoaded', () => {
        setupHierarchyResize();
    });
    
    // add Physics listeners here
    document.querySelectorAll('.preview-item').forEach(item => {
        item.addEventListener('click', (e) => {
            document.querySelectorAll('.preview-item').forEach(i => i.classList.remove('active'));
            e.target.closest('.preview-item').classList.add('active');
            
            const type = e.target.closest('.preview-item').dataset.type;
            if (window.brushSystem) {
                window.brushSystem.setModelType(type);
            }
        });
    });

    // Add model upload handler
    document.getElementById('model-upload').addEventListener('change', (e) => {
        const file = e.target.files[0];
        const loader = new THREE.GLTFLoader();
        
        loader.load(URL.createObjectURL(file), (gltf) => {
            if (window.brushSystem) {
                window.brushSystem.loadedModels.set('current', gltf.scene);
                window.brushSystem.loadedModels.set('custom', gltf.scene);
            }
        });
    });

    //material brush system listeners
    document.getElementById('materialPaint').addEventListener('click', () => {
        selectedTool = TOOLS.MATERIAL_PAINT;
        updateToolUI('materialPaint');
        console.log("Material Paint tool selected");
        // Ensure brush preview is updated if it was hidden
        if(brushPreviewMesh) brushPreviewMesh.visible = !!uploadedMaterial;
         // Save initial texture state if it's the first time painting
        if (textureUndoStack.length === 0 && terrain && terrain.userData.textureCanvas) {
            saveTextureStateForUndo();
        }
    });

    // Material Upload
    document.getElementById('selectMaterial').addEventListener('click', () => {
        document.getElementById('uploadMaterial').click();
    });

    /*document.getElementById('uploadMaterial').addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            const image = new Image();
            image.onload = () => {
                uploadedMaterial = image;
                console.log('Material uploaded for painting. Dimensions:', image.width, 'x', image.height, 'Src:', image.src.substring(0, 100) + '...');
                updateHTMLMaterialPreview();
            };
            // ADD THIS:
            image.onerror = () => {
                console.error("Error loading the uploaded material image.");
                uploadedMaterial = null; // Ensure it's null if loading failed
                updateHTMLMaterialPreview(); // Update preview to show no material
            };
            image.src = e.target.result;
        };
        // AND THIS:
        reader.onerror = () => {
            console.error("Error reading the material file with FileReader.");
            uploadedMaterial = null;
             updateHTMLMaterialPreview();
        };
        reader.readAsDataURL(file);
    }
});*/

document.getElementById('uploadMaterial').addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();

    reader.onload = (e) => {
        const image = new Image();

        // THIS IS THE CRITICAL PART
        image.onload = () => {
            // Success! The image is fully loaded and decoded.
            uploadedMaterial = image;
            console.log('‚úÖ Material loaded successfully. Dimensions:', image.width, 'x', image.height);
            updateHTMLMaterialPreview(); // Update the UI preview
            
            // Now that we have a material, make the 3D brush visible if the tool is active
            if (selectedTool === TOOLS.MATERIAL_PAINT && brushPreviewMesh) {
                brushPreviewMesh.visible = true;
            }
        };

        // Don't forget to handle errors!
        image.onerror = () => {
            console.error("Error: The uploaded file could not be loaded as an image.");
            uploadedMaterial = null;
            updateHTMLMaterialPreview(); // Clear the preview
            if (brushPreviewMesh) brushPreviewMesh.visible = false;
        };

        image.src = e.target.result; // Start loading the image
    };

    reader.onerror = () => {
        console.error("Error: Could not read the selected file.");
        uploadedMaterial = null;
        updateHTMLMaterialPreview();
    };

    reader.readAsDataURL(file);
});


    document.getElementById('materialBrushSize').addEventListener('input', (e) => {
        materialBrushSettings.size = parseFloat(e.target.value);
       // Optionally, call update3DBrushPreviewOnMouseMove if you want live preview update without mouse move
    });
    document.getElementById('materialStrength').addEventListener('input', (e) => {
        materialBrushSettings.strength = parseFloat(e.target.value);
    });
    document.getElementById('materialFalloff').addEventListener('input', (e) => {
        materialBrushSettings.falloff = parseFloat(e.target.value);
    });
    document.getElementById('materialRotation').addEventListener('input', (e) => {
        materialBrushSettings.rotation = parseFloat(e.target.value);
        // Optionally, call update3DBrushPreviewOnMouseMove
    });
    document.getElementById('materialScale').addEventListener('input', (e) => {
        materialBrushSettings.scale = parseFloat(e.target.value);
    });
    document.getElementById('materialOpacity').addEventListener('input', (e) => {
        materialBrushSettings.opacity = parseFloat(e.target.value);
        // Optionally, call update3DBrushPreviewOnMouseMove
    });
    document.getElementById('materialPattern').addEventListener('change', (e) => {
       materialBrushSettings.pattern = e.target.value;
    });
    document.getElementById('materialBlendMode').addEventListener('change', (e) => {
       materialBrushSettings.blendMode = e.target.value;
    });

 
   
    window.addEventListener('resize', onWindowResize);
    // In setupEventListeners()
    document.getElementById('raiseLower').addEventListener('click', () => {
        selectedTool = TOOLS.RAISE_LOWER;
        updateToolUI('raiseLower');
    });
    document.getElementById('smooth').addEventListener('click', () => {
        selectedTool = TOOLS.SMOOTH;
        updateToolUI('smooth');
    });
    document.getElementById('flatten').addEventListener('click', () => {
        selectedTool = TOOLS.FLATTEN;
        updateToolUI('flatten');
    });
    document.getElementById('noise').addEventListener('click', () => {
        selectedTool = TOOLS.NOISE;
        updateToolUI('noise');
    });
    document.getElementById('perlinToolButton').addEventListener('click', () => {
       selectedTool = TOOLS.PERLIN;
       console.log("üåÄ Perlin Sculpting Tool selected");
    });

    document.getElementById('pinch').addEventListener('click', () => {
        selectedTool = TOOLS.PINCH;
        updateToolUI('pinch');
    });
    document.getElementById('clay').addEventListener('click', () => {
        selectedTool = TOOLS.CLAY;
        updateToolUI('clay');
    });
    document.getElementById('scrape').addEventListener('click', () => {
        selectedTool = TOOLS.SCRAPE;
        updateToolUI('scrape');
    });
    document.getElementById('fill').addEventListener('click', () => {
        selectedTool = TOOLS.FILL;
        updateToolUI('fill');
    });

    //NWE ADVANCED TOOLS
    document.getElementById('terrace').addEventListener('click', () => {
        selectedTool = TOOLS.TERRACE;
        updateToolUI('terrace');
    });
    
    document.getElementById('erosion').addEventListener('click', () => {
        selectedTool = TOOLS.EROSION;
    });

    /*document.getElementById('erosion').addEventListener('click', () => {
        selectedTool = TOOLS.EROSION;
        updateToolUI('erosion');
    });*/
    document.getElementById('ridge').addEventListener('click', () => {
        selectedTool = TOOLS.RIDGE;
        updateToolUI('ridge');
    });
    document.getElementById('canyon').addEventListener('click', () => {
        selectedTool = TOOLS.CANYON;
        updateToolUI('canyon');
    });
    document.getElementById('plateau').addEventListener('click', () => {
        selectedTool = TOOLS.PLATEAU;
        updateToolUI('plateau');
    });
    document.getElementById('slope').addEventListener('click', () => {
        selectedTool = TOOLS.SLOPE;
        updateToolUI('slope');
    });
    document.getElementById('blur').addEventListener('click', () => {
        selectedTool = TOOLS.BLUR;
        updateToolUI('blur');
    });
    document.getElementById('sharpen').addEventListener('click', () => {
        selectedTool = TOOLS.SHARPEN;
        updateToolUI('sharpen');
    });

    
   
    // Settings of textures
    document.getElementById('selectTexture').addEventListener('click', () => {
        document.getElementById('uploadTexture').click();
    });
    document.getElementById('uploadTexture').addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const image = new Image();
                image.onload = () => {
                    uploadedTextureImage = image; // Store raw image for painting
                    console.log('Texture uploaded for painting');

                    // Optional preview
                    const previewCanvas = document.getElementById('texturePreview');
                    if (previewCanvas) {
                        const ctx = previewCanvas.getContext('2d');
                        ctx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
                        ctx.drawImage(image, 0, 0, previewCanvas.width, previewCanvas.height);
                    }
                };
                image.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
    });

    document.getElementById('texturePaint').addEventListener('click', () => {
        selectedTool = TOOLS.TEXTURE_PAINT;
        updateToolUI('texturePaint');
    });

    // Terrain creation button
    document.getElementById('addTerrain').addEventListener('click', createTerrain);

    // Brush size controls
    document.getElementById('brushSize').addEventListener('input', (e) => {
        brushSize = parseFloat(e.target.value);
    });

    document.getElementById('brushStrength').addEventListener('input', (e) => {
        brushStrength = parseFloat(e.target.value);
    });


    // Mouse move for brush preview
    renderer.domElement.addEventListener('mousemove', updateBrushPreview);

    // Add pointer events for sculpting and painting
    /*renderer.domElement.addEventListener('pointerdown', (event) => {
        isSculpting = true;
        if (selectedTool === TOOLS.TEXTURE_PAINT) {
            applyTexturePaint(event);
        } else if (selectedTool) {
            applySculpting(event);
        }

        if (event.button !== 0) return; // Only left click
        
        if (selectedTool === TOOLS.MATERIAL_PAINT && uploadedMaterial) {
            isPaintingOrSculpting = true;
            saveTextureStateForUndo(); // Save state BEFORE painting stroke begins
            applyAdvancedMaterialPaint(event);
        } else if (selectedTool && selectedTool !== TOOLS.MATERIAL_PAINT && selectedTool !== TOOLS.TEXTURE_PAINT ) {
            isPaintingOrSculpting = true;
            saveSculptStateForUndo(); // If you have separate undo for sculpt
            applySculpting(event);
        }
    });*/

     renderer.domElement.addEventListener('pointerdown', (event) => {
        if (event.button !== 0 || !selectedTool || !terrain) return; // Only sculpt with left click
        isSculpting = true;
        
        // Save state ONCE at the beginning of the stroke for undo
        saveTerrainState(); 

        applySculpting(event); // Apply first dab
    });

    /*renderer.domElement.addEventListener('pointermove', onPointerMoveCH);

    renderer.domElement.addEventListener('pointermove', (event) => {
        updateBrushPreview(event); // Blue brush for feedback
        if (isSculpting) {
            if (selectedTool === TOOLS.TEXTURE_PAINT) {
                applyTexturePaint(event);
            } else if (selectedTool) {
                applySculpting(event);
            }
        }

        // Call your existing updateBrushPreview OR the new update3DBrushPreviewOnMouseMove
        update3DBrushPreviewOnMouseMove(event, isPaintingOrSculpting);

        if (isPaintingOrSculpting) {
            if (selectedTool === TOOLS.MATERIAL_PAINT && uploadedMaterial) {
                applyAdvancedMaterialPaint(event);
            } else if (selectedTool && selectedTool !== TOOLS.MATERIAL_PAINT && selectedTool !== TOOLS.TEXTURE_PAINT) {
                // applySculpting(event);
            }
        }
    });*/

    renderer.domElement.addEventListener('pointermove', (event) => {
        updateBrushPreview(event);
        if (isSculpting) {
            applySculpting(event);
        }
    });

     renderer.domElement.addEventListener('pointerup', () => {
        isSculpting = false;
    });
    renderer.domElement.addEventListener('pointerleave', () => {
        isSculpting = false; // Stop sculpting if the mouse leaves the canvas
    });

    /*renderer.domElement.addEventListener('pointerup', () => {
        isSculpting = false;
        if (isPaintingOrSculpting) {
            isPaintingOrSculpting = false;
             // update3DBrushPreviewOnMouseMove(event, false); // event might not be available here
            if (brushPreviewMesh) brushPreviewMesh.visible = (selectedTool === TOOLS.MATERIAL_PAINT && !!uploadedMaterial); // Keep visible if tool active
        }
    });*/

    
    // Symmetry controls
    document.getElementById('symmetryToggle').addEventListener('change', (e) => {
        symmetryEnabled = e.target.checked;
    });
    
    document.getElementById('symmetryAxis').addEventListener('change', (e) => {
        symmetryAxis = e.target.value;
    });



    // History controls
    /*document.getElementById('undo').addEventListener('click', () => {
        if (undoStack.length > 0) {
            const currentState = terrain.geometry.attributes.position.array.slice();
            redoStack.push(currentState);
            
            const previousState = undoStack.pop();
            terrain.geometry.attributes.position.array.set(previousState);
            terrain.geometry.attributes.position.needsUpdate = true;
            terrain.geometry.computeVertexNormals();
        }
    });
    
    document.getElementById('redo').addEventListener('click', () => {
        if (redoStack.length > 0) {
            const currentState = terrain.geometry.attributes.position.array.slice();
            undoStack.push(currentState);
            
            const nextState = redoStack.pop();
            terrain.geometry.attributes.position.array.set(nextState);
            terrain.geometry.attributes.position.needsUpdate = true;
            terrain.geometry.computeVertexNormals();
        }
    });*/

    document.getElementById('undo').addEventListener('click', undo);
    document.getElementById('redo').addEventListener('click', redo);



    // Add helper function to find symmetry vertex index
    function findSymmetryVertexIndex(originalIndex, vertices) {
        const original = new THREE.Vector3(
            vertices.getX(originalIndex),
            vertices.getY(originalIndex),
            vertices.getZ(originalIndex)
        );
        
        // Create world position for more accurate symmetry
        const worldPosition = original.clone();
        terrain.localToWorld(worldPosition);
        
        // Create symmetry point
        const symmetryPoint = worldPosition.clone();
        symmetryPoint[symmetryAxis] *= -1;
        
        // Transform back to local space
        terrain.worldToLocal(symmetryPoint);
        
        let closestIndex = -1;
        let minDistance = Infinity;
        
        for (let i = 0; i < vertices.count; i++) {
            if (i === originalIndex) continue;
    
            const vertex = new THREE.Vector3(
                vertices.getX(i),
                vertices.getY(i),
                vertices.getZ(i)
            );
            
            // More precise symmetry detection
            const tolerance = 0.001;
            const isSymmetric = Math.abs(vertex[symmetryAxis] + original[symmetryAxis]) < tolerance;
            
            if (isSymmetric) {
                const otherAxes = ['x', 'y', 'z'].filter(axis => axis !== symmetryAxis);
                const matchesOtherAxes = otherAxes.every(axis => 
                    Math.abs(vertex[axis] - original[axis]) < tolerance
                );
                
                if (matchesOtherAxes) {
                    return i;
                }
                
                const distance = vertex.distanceTo(symmetryPoint);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestIndex = i;
                }
            }
        }
        
        return closestIndex;
    }

    erosionStrength = parseFloat(document.getElementById('erosionStrength').value);

    
   
    
    // File operations
    document.getElementById('newScene').addEventListener('click', newScene);
    document.getElementById('saveScene').addEventListener('click', saveScene);
    document.getElementById('loadScene').addEventListener('click', loadScene);
    document.getElementById('exportButton').addEventListener('click', exportScene);
    document.getElementById('importScene').addEventListener('click', importScene);

    
    // Timeline controls
    /*document.getElementById('play').addEventListener('click', playAnimation);
    document.getElementById('pause').addEventListener('click', pauseAnimation);
    document.getElementById('stop').addEventListener('click', stopAnimation); */
 
    // Transform controls events
    /*transformControls.addEventListener('dragging-changed', function(event) {
        controls.enabled = !event.value;
    });*/
 
     transformControls.addEventListener('change', updateInspector);


    /*renderer.domElement.addEventListener('pointerleave', () => {
        if (brushPreviewMesh && !isPaintingOrSculpting) {
             brushPreviewMesh.visible = false;
        }
    });*/

}


function updateToolUI(toolId) {
    document.querySelectorAll('.panel-button').forEach(button => {
        button.classList.remove('active');
    });
    document.getElementById(toolId).classList.add('active');
}

document.querySelectorAll('.panel-button').forEach(button => {
    button.addEventListener('click', () => {
        updateToolUI(button.id);
    });
});

// Object creation functions
function addCube() {
    const geometry = new THREE.BoxGeometry();
    const material = new THREE.MeshStandardMaterial({ color: 0xC8C8C8, side: THREE.DoubleSide }); // Light gray
    const cube = new THREE.Mesh(geometry, material);
    cube.castShadow = true;
    cube.receiveShadow = true;
    cube.position.set(0, 0.5, 0);
    cube.renderOrder = 0;
    addObjectToScene(cube, 'Cube');
}

function addPlane() {
    const geometry = new THREE.PlaneGeometry(10, 10);
    const material = new THREE.MeshStandardMaterial({ color: 0xBFD4D9, side: THREE.DoubleSide }); // Light blue-green
    const plane = new THREE.Mesh(geometry, material);
    plane.rotation.x = -Math.PI / 2;
    addObjectToScene(plane, 'Plane');
}



let symmetryEnabled = false;
let symmetryAxis = 'x';
let undoStack = [];
let redoStack = [];
let lastSavedState = null;
let autoSaveInterval = 5000; 


let brushSize = 1.5; // Default brush size
let brushStrength = 0.1; // Default brush strength
let brushPreview; // Brush preview mesh


let terrain; // Reference to the terrain
let selectedTool = null; // Current active tool
let isSculpting = false; // Flag for sculpting state
let uploadedTexture = null; // Stores the uploaded texture for painting
let isPaintingOrSculpting = false;




const TOOLS = {
    RAISE_LOWER: 'raiseLower',
    SMOOTH: 'smooth',
    FLATTEN: 'flatten',
    NOISE: 'noise',
    PERLIN: 'PERLIN',
    PINCH: 'pinch',
    CLAY: 'clay',
    SCRAPE: 'scrape',
    FILL: 'fill',
    TEXTURE_PAINT: 'texturePaint',
    TERRACE: 'terrace',
    EROSION: 'erosion',
    RIDGE: 'ridge',
    CANYON: 'canyon',
    PLATEAU: 'plateau',
    SLOPE: 'slope',
    BLUR: 'blur',
    SHARPEN: 'sharpen',
    MATERIAL_PAINT: 'materialPaint'
};


function applySymmetry(originalVertex, index, vertices) {
    if (!symmetryEnabled) return;

    const symmetryVertex = originalVertex.clone();
    symmetryVertex[symmetryAxis] *= -1;

    // search symitry point
    const tolerance = 0.0001;
    for (let i = 0; i < vertices.count; i++) {
        if (i === index) continue;
        
        const vertex = new THREE.Vector3(
            vertices.getX(i),
            vertices.getY(i),
            vertices.getZ(i)
        );

        if (Math.abs(vertex[symmetryAxis] + originalVertex[symmetryAxis]) < tolerance &&
            Math.abs(vertex[(symmetryAxis === 'x' ? 'z' : 'x')] - originalVertex[(symmetryAxis === 'x' ? 'z' : 'x')]) < tolerance) {
            vertices.setXYZ(i, symmetryVertex.x, symmetryVertex.y, symmetryVertex.z);
            break;
        }
    }
}


/**
 * Creates a new terrain or updates the existing one.
 * This function is backward-compatible. If called with no arguments,
 * it will use the default hard-coded values as before.
 *
 * @param {object} [settings] - Optional. An object with terrain settings.
 * @param {number} [settings.width=50] - The width of the terrain on the X-axis.
 * @param {number} [settings.length=50] - The length of the terrain on the Z-axis (previously 'height').
 * @param {number} [settings.resolution=100] - The number of segments on each axis.
 * @param {number} [settings.textureResolution=1024] - The pixel resolution of the paintable texture.
 */

 /*
 function createTerrain(settings) {
    console.log("createTerrain function called.");

    // --- 1. Define Default and Final Settings ---
    const defaults = {
        width: 50,
        length: 50, // Using 'length' for Z-axis to be clearer than 'height'
        resolution: 100,
        textureResolution: 1024
    };

   

    // Merge user settings with defaults
    const finalSettings = Object.assign({}, defaults, settings);

    // --- 2. Preserve Old Data if Updating ---
    let oldCanvasData = null;
    if (terrain) {
        console.log("An existing terrain was found. Updating it.");

        // Preserve existing texture canvas
        if (terrain.userData.textureCanvas) {
            oldCanvasData = terrain.userData.textureCanvas;
        }

        // Clean up old terrain
        scene.remove(terrain);
        terrain.geometry.dispose();
        if (terrain.material.map) terrain.material.map.dispose();
        terrain.material.dispose();
    } else {
        console.log("No existing terrain found. Creating new.");
    }

    // --- 3. Create New Geometry ---
    const geometry = new THREE.PlaneGeometry(
        finalSettings.width,
        finalSettings.length,
        finalSettings.resolution,
        finalSettings.resolution
    );
    geometry.rotateX(-Math.PI / 2); // Orient horizontally

    // --- 4. Create New Material and Texture ---
    const canvas = document.createElement('canvas');
    canvas.width = finalSettings.textureResolution;
    canvas.height = finalSettings.textureResolution;
    const ctx = canvas.getContext('2d');

    if (oldCanvasData) {
        console.log("Restoring and resizing previous texture data.");
        ctx.drawImage(oldCanvasData, 0, 0, canvas.width, canvas.height);
    } else {
        ctx.fillStyle = '#87CEEB';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    const texture = new THREE.CanvasTexture(canvas);
    texture.needsUpdate = true;

    const material = new THREE.MeshStandardMaterial({
        map: texture,
        side: THREE.DoubleSide
    });

    // --- 5. Create the New Mesh and Add to Scene ---
    terrain = new THREE.Mesh(geometry, material);
    terrain.name = "Terrain";
    terrain.receiveShadow = true;
    terrain.castShadow = true;

    terrain.userData.textureCanvas = canvas;
    terrain.userData.textureContext = ctx;
    terrain.userData.settings = { ...finalSettings };

    scene.add(terrain);

    if (typeof addObjectToScene === 'function') {
        addObjectToScene(terrain, 'Terrain');
    }

    // --- 6. Update Dependencies ---
    // Update brush preview
    if (typeof createBrushPreview === 'function') {
        createBrushPreview();
    }

    // Update 3D brush preview
    if (typeof createOrUpdate3DBrushPreview === 'function') {
        createOrUpdate3DBrushPreview();
    }

    // Initialize or update the brush system
    if (!window.brushSystem && typeof TerrainBrushSystem === 'function') {
        window.brushSystem = new TerrainBrushSystem(scene, camera, renderer, terrain);
    } else if (window.brushSystem && typeof window.brushSystem.setTerrain === 'function') {
        window.brushSystem.setTerrain(terrain);
    }

    // Reset texture history and save initial state
    if (terrain && terrain.userData.textureCanvas && typeof saveTextureStateForUndo === 'function') {
        textureUndoStack = [];
        textureRedoStack = [];
        setTimeout(() => saveTextureStateForUndo(), 100);
    }

    // Update any UI panel if needed
    if (typeof updateTerrainInspectorUI === 'function') {
        updateTerrainInspectorUI();
    }

    console.log("‚úÖ Terrain successfully created/updated with settings:", finalSettings);
}*/

function createTerrain(settings) {
    console.log("createTerrain function called.");

    // --- 1. Define Default and Final Settings ---
    const defaults = {
        width: 50,
        length: 50,
        resolution: 128, // Using a slightly higher default for better detail
        textureResolution: 1024
    };

    const finalSettings = Object.assign({}, defaults, settings);

    // --- 2. Preserve Old Data if Updating ---
    let oldCanvasData = null;
    if (terrain) {
        console.log("An existing terrain was found. Updating it.");
        if (terrain.userData.textureCanvas) {
            oldCanvasData = terrain.userData.textureCanvas;
        }
        scene.remove(terrain);
        terrain.geometry.dispose();
        if (terrain.material.map) terrain.material.map.dispose();
        terrain.material.dispose();
    } else {
        console.log("No existing terrain found. Creating new.");
    }

    // --- 3. Create New Geometry ---
    const geometry = new THREE.PlaneGeometry(
        finalSettings.width,
        finalSettings.length,
        finalSettings.resolution,
        finalSettings.resolution
    );
    geometry.rotateX(-Math.PI / 2);

    // --- 4. Create New Material and Texture ---
    const canvas = document.createElement('canvas');
    canvas.width = finalSettings.textureResolution;
    canvas.height = finalSettings.textureResolution;
    const ctx = canvas.getContext('2d');

    if (oldCanvasData) {
        console.log("Restoring and resizing previous texture data.");
        ctx.drawImage(oldCanvasData, 0, 0, canvas.width, canvas.height);
    } else {
        // Using a more neutral, earthy base color
        ctx.fillStyle = '#7a6b5a'; 
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    const texture = new THREE.CanvasTexture(canvas);
    // --- FIX FOR PAINTING: Ensure correct color space ---
    texture.colorSpace = THREE.SRGBColorSpace;
    texture.needsUpdate = true;

    const material = new THREE.MeshStandardMaterial({
        map: texture,
        side: THREE.DoubleSide,
        flatShading: false // Use smooth shading for better sculpting results
    });

    // --- 5. Create the New Mesh and Add to Scene ---
    terrain = new THREE.Mesh(geometry, material);
    terrain.name = "Terrain";
    terrain.receiveShadow = true;
    terrain.castShadow = true;

    // Store your user data
    terrain.userData.textureCanvas = canvas;
    terrain.userData.textureContext = ctx;
    terrain.userData.settings = { ...finalSettings };

    // =================================================================
    // --- NEW CODE: ADDING THE PERFORMANCE GRID ---
    // This grid is essential for high-performance sculpting. It maps vertex
    // indices to a 2D grid for incredibly fast lookups.
    console.log("Building performance grid for sculpting...");
    const segmentsX = finalSettings.resolution;
    const segmentsZ = finalSettings.resolution;
    const vertexGrid = Array(segmentsZ + 1).fill(null).map(() => Array(segmentsX + 1).fill(0));
    
    for (let i = 0; i < geometry.attributes.position.count; i++) {
        const z = Math.floor(i / (segmentsX + 1));
        const x = i % (segmentsX + 1);
        vertexGrid[z][x] = i;
    }
    // Store the grid and a simplified config directly on the terrain for easy access
    terrain.userData.vertexGrid = vertexGrid;
    terrain.userData.config = {
        width: finalSettings.width,
        length: finalSettings.length,
        resolution: finalSettings.resolution
    };
    console.log("...Performance grid built.");
    // =================================================================
    
    scene.add(terrain);

    // Your existing logic for adding to the scene hierarchy
    if (typeof addObjectToScene === 'function') {
        addObjectToScene(terrain, 'Terrain');
    }

    // --- 6. Update Dependencies (Your existing code) ---
    if (typeof createBrushPreview === 'function') {
        createBrushPreview();
    }

    if (typeof createOrUpdate3DBrushPreview === 'function') {
        createOrUpdate3DBrushPreview();
    }
    
    // (The rest of your dependency updates remain unchanged)
    if (!window.brushSystem && typeof TerrainBrushSystem === 'function') {
        window.brushSystem = new TerrainBrushSystem(scene, camera, renderer, terrain);
    } else if (window.brushSystem && typeof window.brushSystem.setTerrain === 'function') {
        window.brushSystem.setTerrain(terrain);
    }

    // --- FIX FOR HISTORY: Ensure the correct undo stacks are reset ---
    // It's better to use the main `undoStack` and `redoStack` you defined globally.
    // If `textureUndoStack` is separate, that's fine, but geometry changes should
    // use the main one. We will handle this in the `pointerdown` event.
    undoStack = [];
    redoStack = [];
    
    // Your existing logic for updating UI
    if (typeof updateTerrainInspectorUI === 'function') {
        updateTerrainInspectorUI();
    }

    console.log("‚úÖ Terrain successfully created/updated with settings:", finalSettings);
}



function setupTerrainControls() {
    const applyBtn = document.getElementById('applyTerrainChanges');
    
    // Call this once to populate the UI with the initial default values
    updateTerrainInspectorUI(); 

    applyBtn.addEventListener('click', () => {
        // Gather the new settings from the UI inputs
        const newSettings = {
            width: parseFloat(document.getElementById('terrainWidth').value),
            length: parseFloat(document.getElementById('terrainLength').value),
            resolution: parseInt(document.getElementById('terrainResolution').value, 10),
            textureResolution: parseInt(document.getElementById('terrainTextureResolution').value, 10)
        };

        // Call your single, powerful createTerrain function with the new settings
        createTerrain(newSettings);
    });
}

// This function keeps the UI in sync with the actual terrain.
function updateTerrainInspectorUI() {
    // If a terrain exists, use its settings. Otherwise, use the defaults.
    const currentSettings = (terrain && terrain.userData.settings) ? terrain.userData.settings : {
        width: 50,
        length: 50,
        resolution: 100,
        textureResolution: 1024
    };

    document.getElementById('terrainWidth').value = currentSettings.width;
    document.getElementById('terrainLength').value = currentSettings.length;
    document.getElementById('terrainResolution').value = currentSettings.resolution;
    document.getElementById('terrainTextureResolution').value = currentSettings.textureResolution;
}


// Create advanced brush preview
/*function createBrushPreview() {
    if (brushPreview) {
        scene.remove(brushPreview);
    }

    // Create inner circle
    const innerGeometry = new THREE.CircleGeometry(1, 32);
    const innerMaterial = new THREE.MeshBasicMaterial({
        color: 0x4A90E2,
        transparent: true,
        opacity: 0.3,
        side: THREE.DoubleSide
    });
    
    // Create outer circle (falloff indicator)
    const outerGeometry = new THREE.RingGeometry(0.8, 1, 32);
    const outerMaterial = new THREE.MeshBasicMaterial({
        color: 0x4A90E2,
        transparent: true,
        opacity: 0.15,
        side: THREE.DoubleSide
    });

    // Create direction indicator for certain tools
    const directionGeometry = new THREE.ConeGeometry(0.2, 0.5, 32);
    const directionMaterial = new THREE.MeshBasicMaterial({
        color: 0xEE82EE,
        transparent: true,
        opacity: 0.5
    });

    const innerCircle = new THREE.Mesh(innerGeometry, innerMaterial);
    const outerCircle = new THREE.Mesh(outerGeometry, outerMaterial);
    const directionIndicator = new THREE.Mesh(directionGeometry, directionMaterial);

    brushPreview = new THREE.Group();
    brushPreview.add(innerCircle);
    brushPreview.add(outerCircle);
    brushPreview.add(directionIndicator);
    
    brushPreview.rotation.x = -Math.PI / 2;
    brushPreview.visible = false;
    scene.add(brushPreview);
}*/

function createBrushPreview() {
    // If a brush preview already exists in the scene, remove it first.
    if (brushPreview) {
        scene.remove(brushPreview);
        brushPreview.geometry.dispose();
        brushPreview.material.dispose();
    }

    // Create a new ring geometry for the brush outline.
    const brushGeometry = new THREE.RingGeometry(0.95, 1, 32); 
    const brushMaterial = new THREE.MeshBasicMaterial({
        color: 0x00ffff, // A bright cyan color
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.75,
        depthTest: false // Render on top of everything
    });

    brushPreview = new THREE.Mesh(brushGeometry, brushMaterial);
    brushPreview.rotation.x = -Math.PI / 2; // Lay it flat
    brushPreview.visible = false; // Start hidden
    scene.add(brushPreview);
}

/**
 * Updates the position and size of the brush preview on mouse move.
 * This should be called by your 'mousemove' event listener.
 */
function updateBrushPreview(event) {
    // Exit if the necessary objects don't exist yet
    if (!terrain || !brushPreview) return;

    // Use your existing helper to get correct mouse coordinates
    const mouse = getMouseNormalized(event, renderer.domElement);

    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(terrain);

    if (intersects.length > 0) {
        // If the mouse is over the terrain, show and position the brush
        const intersect = intersects[0];
        brushPreview.visible = true;
        brushPreview.position.copy(intersect.point).add(intersect.face.normal.multiplyScalar(0.01)); // Lift slightly to avoid z-fighting
        brushPreview.scale.set(brushSize, brushSize, brushSize); // Match the current brush size
    } else {
        // If the mouse is not over the terrain, hide the brush
        brushPreview.visible = false;
    }
}

/**
 * Calculates the normalized mouse coordinates (-1 to +1) relative to the renderer's canvas.
 * This correctly handles canvas position, size, and offsets on the page.
 * @param {MouseEvent} event - The mouse event (e.g., from a 'pointermove' listener).
 * @param {HTMLCanvasElement} canvas - The renderer's DOM element.
 * @returns {THREE.Vector2} A Vector2 with the corrected x and y coordinates.
 */
/*function getMouseNormalized(event, canvas) {
    const rect = canvas.getBoundingClientRect();
    const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    return new THREE.Vector2(x, y);
}*/

function getMouseNormalized(event, canvas) {
    const rect = canvas.getBoundingClientRect();
    const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    return new THREE.Vector2(x, y);
}


// Update brush preview with advanced features
/*function updateBrushPreview(event) {
    if (!terrain || !brushPreview) return;
    if (selectedTool === TOOLS.MATERIAL_PAINT || selectedTool === TOOLS.TEXTURE_PAINT) { // Or any tool that should NOT use this sculpt preview
        brushPreview.visible = false;
        return; // Don't do anything else for this brush if material/texture paint is active
    }
   

       // --- NEW, CORRECT WAY ---
    const mouse = getMouseNormalized(event, renderer.domElement);

    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(terrain);
  

    if (intersects.length > 0) {
        const intersect = intersects[0];
        brushPreview.position.copy(intersect.point);
        
        if (selectedTool === TOOLS.MATERIAL_PAINT) {
            brushPreview.scale.set(materialBrushSettings.size, materialBrushSettings.size, 1);
            if (materialPreviewTexture) {
                brushPreview.children[0].material.map = materialPreviewTexture;
                brushPreview.children[0].material.opacity = materialBrushSettings.opacity;
                brushPreview.children[0].material.needsUpdate = true;
            }
        } else {
            brushPreview.scale.set(brushSize, brushSize, 1);
            brushPreview.children[0].material.map = null;
            brushPreview.children[0].material.needsUpdate = true;
        }
        brushPreview.visible = Object.values(TOOLS).includes(selectedTool);
    } else {
        brushPreview.visible = false;
    }
}*/


// Save terrain state for undo/redo
/*function saveTerrainState() {
    const positions = terrain.geometry.attributes.position.array.slice();
    undoStack.push(positions);
    redoStack.length = 0; // Clear redo stack when new action is performed
    
    // Limit undo stack size
    if (undoStack.length > 20) {
        undoStack.shift();
    }
}*/

function saveTerrainState() {
    if (!terrain) return;
    const positions = terrain.geometry.attributes.position.array.slice();
    undoStack.push(positions);
    
    // A new action always clears the redo stack
    redoStack.length = 0; 
    
    // Optional: Limit undo stack size to prevent memory issues
    if (undoStack.length > 50) {
        undoStack.shift();
    }
}

// Advanced sculpting functions
function pinchTerrain(vertex, position, influence) {
    const direction = new THREE.Vector3().subVectors(position, vertex);
    vertex.add(direction.multiplyScalar(influence * brushStrength));
}

function clayTerrain(vertex, position, influence, normal) {
    const offset = normal.multiplyScalar(brushStrength * influence);
    if (vertex.y < position.y) {
        vertex.add(offset);
    }
}

function scrapeTerrain(vertex, position, influence, normal) {
    const offset = normal.multiplyScalar(-brushStrength * influence);
    if (vertex.y > position.y) {
        vertex.add(offset);
    }
}

function fillTerrain(vertex, position, influence) {
    if (vertex.y < position.y) {
        vertex.y += brushStrength * influence;
    }
}

function startSculpting(event) {
    isSculpting = true;
    applySculpting(event);
    applySculpting1(event);
}

function stopSculpting() {
    isSculpting = false;
}


// ÿ™ÿ≠ÿ≥ŸäŸÜ ÿØÿßŸÑÿ© ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑŸÜÿ≠ÿ™
/*function applySculpting(event) {
    if (!isSculpting || !selectedTool || !terrain) return;



    const mouse = getMouseNormalized(event, renderer.domElement);
    
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(terrain);
    
    if (intersects.length > 0) {
        // Save state for undo/redo
        if (!lastSavedState || Date.now() - lastSavedState > autoSaveInterval) {
            saveTerrainState();
            lastSavedState = Date.now();
        }
        
        const intersect = intersects[0];
        const vertices = terrain.geometry.attributes.position;
        const position = intersect.point.clone();
        const normal = intersect.face.normal.clone().transformDirection(terrain.matrixWorld);
        
        // Transform position to local space
        terrain.worldToLocal(position);
        
        // Handle material painting separately
        if (selectedTool === TOOLS.MATERIAL_PAINT) {
            applyAdvancedMaterialPaint(event);
            return; // Exit early since material painting doesn't modify vertices
        }

        for (let i = 0; i < vertices.count; i++) {
            const vertex = new THREE.Vector3(
                vertices.getX(i),
                vertices.getY(i),
                vertices.getZ(i)
            );
            
            const distance = vertex.distanceTo(position);
            if (distance < brushSize) {
                const influence = Math.pow(1 - (distance / brushSize), 2); // Smoother falloff
                const originalVertex = vertex.clone();
                
                // Apply tool effect
                switch (selectedTool) {
                    case TOOLS.RAISE_LOWER:
                        vertex.y += brushStrength * influence;
                        break;
                    case TOOLS.SMOOTH:
                        vertex.y += (position.y - vertex.y) * influence * brushStrength;
                        break;
                    case TOOLS.FLATTEN:
                        vertex.y += (position.y - vertex.y) * influence;
                        break;
                    case TOOLS.NOISE:
                        vertex.y += (Math.random() - 0.5) * brushStrength * influence * 2;
                        break;
                    case TOOLS.PERLIN:
                        const freq = 0.1;
                        const amp = 3;
                        const noiseValue = noise.perlin2(vertex.x * freq, vertex.z * freq);
                        vertex.y += noiseValue * amp * influence;
                        break;
                    case TOOLS.PINCH:
                        const toCenter = new THREE.Vector3().subVectors(position, vertex);
                        vertex.add(toCenter.multiplyScalar(influence * brushStrength));
                        break;
                    case TOOLS.CLAY:
                        if (vertex.y < position.y) {
                            vertex.add(normal.clone().multiplyScalar(brushStrength * influence));
                        }
                        break;
                    case TOOLS.SCRAPE:
                        if (vertex.y > position.y) {
                            vertex.add(normal.clone().multiplyScalar(-brushStrength * influence));
                        }
                        break;
                    case TOOLS.FILL:
                        if (vertex.y < position.y) {
                            vertex.y += brushStrength * influence;
                        }
                        break;
                    case TOOLS.TERRACE:
                        applyTerrace(vertex, position, influence);
                        break;
                    //case TOOLS.EROSION:
                        //applyErosion(vertex, position, influence, vertices, i);
                        //break;
                    case TOOLS.EROSION:
                        applyHydraulicErosion(vertex, i, vertices, brushSize);
                        break;
                    case TOOLS.RIDGE:
                        applyRidge(vertex, position, influence);
                        break;
                    case TOOLS.CANYON:
                        applyCanyon(vertex, position, influence);
                        break;
                    case TOOLS.PLATEAU:
                        applyPlateau(vertex, position, influence);
                        break;
                    case TOOLS.SLOPE:
                        applySlope(vertex, position, influence, normal);
                        break;
                    case TOOLS.BLUR:
                        applyBlur(vertex, position, influence, vertices, i);
                        break;
                    case TOOLS.SHARPEN:
                        applySharpen(vertex, position, influence, vertices, i);
                        break;
                }
                
                vertices.setXYZ(i, vertex.x, vertex.y, vertex.z);
                applySymmetry(originalVertex, i, vertices);
               
            }
        }
        
        vertices.needsUpdate = true;
        terrain.geometry.computeVertexNormals();
    }
}*/

function applySculpting(event) {
    if (!isSculpting || !selectedTool || !terrain) return;

    if (selectedTool === TOOLS.TEXTURE_PAINT || selectedTool === TOOLS.MATERIAL_PAINT) {
        applyTexturePaint(event); // We'll use one function for both for simplicity
        return; 
    }
    const mouse = getMouseNormalized(event, renderer.domElement);
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(terrain);

    if (intersects.length > 0) {
        const intersect = intersects[0];
        const vertices = terrain.geometry.attributes.position;
        const localPoint = terrain.worldToLocal(intersect.point.clone()); // Work in local space

        // Get pre-calculated grid and config from terrain object
        const { vertexGrid, config } = terrain.userData;
        
        // --- PERFORMANCE OPTIMIZATION ---
        // Instead of looping all vertices, we find which vertices are in the brush's "bounding box" on the grid.
        const gridSpacingX = config.width / config.resolution;
        const gridSpacingZ = config.length / config.resolution;
        const brushRadiusInGridX = Math.ceil(brushSize / gridSpacingX);
        const brushRadiusInGridZ = Math.ceil(brushSize / gridSpacingZ);

        const centerGridX = Math.round((localPoint.x + config.width / 2) / gridSpacingX);
        const centerGridZ = Math.round((localPoint.z + config.length / 2) / gridSpacingZ);

        // Iterate ONLY over the vertices within the brush's area.
        for (let z = Math.max(0, centerGridZ - brushRadiusInGridZ); z <= Math.min(config.resolution, centerGridZ + brushRadiusInGridZ); z++) {
            for (let x = Math.max(0, centerGridX - brushRadiusInGridX); x <= Math.min(config.resolution, centerGridX + brushRadiusInGridX); x++) {
                
                const i = vertexGrid[z][x]; // Get vertex index directly from grid
                const vertex = new THREE.Vector3().fromBufferAttribute(vertices, i);
                const distance = vertex.distanceTo(localPoint);

                if (distance < brushSize) {
                    const influence = Math.pow(1 - (distance / brushSize), 2); // Smoother falloff
                    
                    // --- APPLY SCULPTING EFFECT ---
                    let targetHeight = localPoint.y; // The height at the center of the brush
                    
                    switch (selectedTool) {
                        case TOOLS.RAISE_LOWER:
                            vertex.y += brushStrength * influence * (event.ctrlKey ? -1 : 1);
                            break;
                        case TOOLS.SMOOTH:
                        case TOOLS.BLUR: // Blur is just a weaker smooth
                            const avgHeight = getNeighborAverageHeight(i);
                            vertex.y += (avgHeight - vertex.y) * influence * brushStrength;
                            break;
                        case TOOLS.FLATTEN:
                        case TOOLS.PLATEAU:
                            vertex.y += (targetHeight - vertex.y) * influence * brushStrength;
                            break;
                        case TOOLS.NOISE:
                            vertex.y += (Math.random() - 0.5) * brushStrength * influence;
                            break;
                        case TOOLS.PINCH:
                        case TOOLS.RIDGE: // Ridge is a directional pinch
                            vertex.addScaledVector(new THREE.Vector3(localPoint.x - vertex.x, 0, localPoint.z - vertex.z), influence * brushStrength * 0.1);
                            break;
                        case TOOLS.CLAY:
                             if(vertex.y < targetHeight) vertex.y += brushStrength * influence;
                             break;
                        case TOOLS.SCRAPE:
                             if(vertex.y > targetHeight) vertex.y -= brushStrength * influence;
                             break;
                        case TOOLS.FILL:
                             if(vertex.y < targetHeight) vertex.y = Math.min(targetHeight, vertex.y + brushStrength * influence);
                             break;
                        case TOOLS.CANYON:
                             vertex.y -= brushStrength * influence;
                             break;
                        case TOOLS.TERRACE:
                            const terraceStep = 1.0; // Define step height for terraces
                            const terracedY = Math.round(vertex.y / terraceStep) * terraceStep;
                            vertex.y += (terracedY - vertex.y) * influence * brushStrength;
                            break;
                        case TOOLS.EROSION:
                            const lowestNeighbor = getLowestNeighbor(i);
                            if(lowestNeighbor && lowestNeighbor.y < vertex.y){
                                const drop = (vertex.y - lowestNeighbor.y) * influence * brushStrength * 0.5;
                                vertex.y -= drop; // Move material down
                            }
                            break;
                        case TOOLS.SHARPEN:
                            const neighborAvg = getNeighborAverageHeight(i);
                            vertex.y += (vertex.y - neighborAvg) * influence * brushStrength;
                            break;
                    }
                    
                    vertices.setXYZ(i, vertex.x, vertex.y, vertex.z);

                    // --- SYMMETRY APPLICATION (FAST) ---
                    if (symmetryEnabled) {
                        const symmIndex = getSymmetricIndex(i);
                        if (symmIndex !== -1 && symmIndex !== i) {
                            // We apply the same modification to the symmetric vertex
                            // Note: This simple duplication works for most brushes.
                            const symmVertex = new THREE.Vector3().fromBufferAttribute(vertices, symmIndex);
                            symmVertex.y = vertex.y; // Mirror the height change
                            vertices.setXYZ(symmIndex, symmVertex.x, symmVertex.y, symmVertex.z);
                        }
                    }
                }
            }
        }
        
        vertices.needsUpdate = true;
        terrain.geometry.computeVertexNormals();
    }
}

// Advanced Texture Painting Function
let uploadedTextureImage = null; 
function applyTexturePaint(event) {
    if (!terrain || !terrain.userData.textureCanvas || !uploadedTextureImage) {
        console.error('Terrain, texture canvas, or uploaded texture not ready');
        return;
    }

    const mouse = getMouseNormalized(event, renderer.domElement);
    
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(terrain);

    if (intersects.length > 0) {
        const intersect = intersects[0];
        const uv = intersect.uv;
        const ctx = terrain.userData.textureContext;
        const canvas = terrain.userData.textureCanvas;

        // Calculate brush position on canvas
        const x = uv.x * canvas.width;
        const y = (1 - uv.y) * canvas.height;
        const brushRadius = brushSize * 50; // Scale to canvas size

        // Save current state for undo
        if (!lastSavedState || Date.now() - lastSavedState > autoSaveInterval) {
            saveTerrainState();
            lastSavedState = Date.now();
        }

        // Create a temporary canvas for the brush
        const brushCanvas = document.createElement('canvas');
        brushCanvas.width = brushRadius * 2;
        brushCanvas.height = brushRadius * 2;
        const brushCtx = brushCanvas.getContext('2d');

        // Draw the uploaded texture portion
        const sx = uv.x * uploadedTextureImage.width - brushRadius;
        const sy = (1 - uv.y) * uploadedTextureImage.height - brushRadius;
        brushCtx.drawImage(
            uploadedTextureImage,
            sx, sy, brushRadius * 2, brushRadius * 2,
            0, 0, brushCanvas.width, brushCanvas.height
        );

        // Apply brush mask with gradient
        const gradient = brushCtx.createRadialGradient(
            brushRadius, brushRadius, 0,
            brushRadius, brushRadius, brushRadius
        );
        gradient.addColorStop(0, `rgba(255, 255, 255, ${brushStrength})`);
        gradient.addColorStop(0.7, `rgba(255, 255, 255, ${brushStrength * 0.3})`);
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        
        brushCtx.globalCompositeOperation = 'destination-in';
        brushCtx.fillStyle = gradient;
        brushCtx.beginPath();
        brushCtx.arc(brushRadius, brushRadius, brushRadius, 0, Math.PI * 2);
        brushCtx.fill();

        // Draw the brush result onto the terrain texture
        ctx.drawImage(
            brushCanvas,
            x - brushRadius,
            y - brushRadius
        );

        // Update the texture
        terrain.material.map.needsUpdate = true;
    }
}

/**
 * --- NEW & FAST ---
 * Gets the symmetric vertex index instantly using the spatial grid.
 * Replaces your slow findSymmetryVertexIndex function.
 */
function getSymmetricIndex(index) {
    if (!terrain) return -1;
    const { vertexGrid, config } = terrain.userData;
    const segmentsX = config.resolution;
    const segmentsZ = config.resolution;
    
    const z = Math.floor(index / (segmentsX + 1));
    const x = index % (segmentsX + 1);

    if (symmetryAxis === 'x') {
        return vertexGrid[z][segmentsX - x];
    } else { // 'z' axis
        return vertexGrid[segmentsZ - z][x];
    }
}

/**
 * --- NEW ---
 * Gets all neighbors of a vertex using the spatial grid. Essential for smooth, erosion, etc.
 */
function getNeighbors(index) {
    if (!terrain) return [];
    const { vertexGrid, config } = terrain.userData;
    const segmentsX = config.resolution;
    const z = Math.floor(index / (segmentsX + 1));
    const x = index % (segmentsX + 1);
    const neighbors = [];

    for (let dz = -1; dz <= 1; dz++) {
        for (let dx = -1; dx <= 1; dx++) {
            if (dx === 0 && dz === 0) continue;
            const nz = z + dz;
            const nx = x + dx;
            if (nz >= 0 && nz <= config.resolution && nx >= 0 && nx <= config.resolution) {
                neighbors.push(vertexGrid[nz][nx]);
            }
        }
    }
    return neighbors;
}

function getNeighborAverageHeight(index) {
    const vertices = terrain.geometry.attributes.position;
    const neighbors = getNeighbors(index);
    if (neighbors.length === 0) return vertices.getY(index);
    const sum = neighbors.reduce((acc, i) => acc + vertices.getY(i), 0);
    return sum / neighbors.length;
}

function getLowestNeighbor(index) {
    const vertices = terrain.geometry.attributes.position;
    const neighbors = getNeighbors(index);
    if (neighbors.length === 0) return null;
    let lowest = { index: -1, y: Infinity };
    neighbors.forEach(i => {
        const y = vertices.getY(i);
        if (y < lowest.y) {
            lowest.y = y;
            lowest.index = i;
        }
    });
    return lowest;
}

function addSphere() {
    const geometry = new THREE.SphereGeometry(0.5, 32, 32);
    const material = new THREE.MeshStandardMaterial({ color: 0xE67E22, side: THREE.DoubleSide }); // Reddish orange
    const sphere = new THREE.Mesh(geometry, material);
    sphere.castShadow = true;
    sphere.receiveShadow = true;
    sphere.position.set(0, 0.5, 0);
    addObjectToScene(sphere, 'Sphere');
    meshes.push(sphere);
}

 
function addCylinder() {
    const geometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 32);
    const material = new THREE.MeshStandardMaterial({ color: 0x3498DB, side: THREE.DoubleSide }); // Sky blue
    const cylinder = new THREE.Mesh(geometry, material);
    cylinder.castShadow = true;
    cylinder.receiveShadow = true;
    cylinder.position.set(0, 0.5, 0);
    addObjectToScene(cylinder, 'Cylinder');
    meshes.push(cylinder);
}
 
// Function to add a Pyramid
function addPyramid() {
    // Pyramid parameters
    const radius = 1;
    const height = 2;
    const segments = 4;  // 4 sides makes it a perfect pyramid
    const color = 0xE67E22; // Warm orange color
    
    // Create geometry
    const geometry = new THREE.ConeGeometry(radius, height, segments);
    
    // Blender-like material (flat, non-metallic)
    const material = new THREE.MeshStandardMaterial({
        color: color,
        flatShading: true,       // Gives sharp edges like Blender
        metalness: 0,            // Completely non-metallic
        roughness: 1,            // Fully rough (matte appearance)
        side: THREE.DoubleSide,  // Render both sides
        name: 'blenderMaterial'
    });
    
    // Create the pyramid mesh
    const pyramid = new THREE.Mesh(geometry, material);
    pyramid.name = 'Pyramid';
    pyramid.position.set(0, 1, 0);
    
    // Blender-style properties
    pyramid.castShadow = true;
    pyramid.receiveShadow = true;
    
    // Calculate smooth normals (for better lighting)
    geometry.computeVertexNormals();
    
    // Add to scene
    addObjectToScene(pyramid, 'Pyramid')
    
    return pyramid;
}


// Function to add a Rectangular Prism
function addRectangularPrism() {
    const geometry = new THREE.BoxGeometry(1, 2, 3);
    const material = new THREE.MeshStandardMaterial({ color: 0x9B59B6, side: THREE.DoubleSide }); // Purple
    const rectangularPrism = new THREE.Mesh(geometry, material);
    rectangularPrism.castShadow = true;
    rectangularPrism.receiveShadow = true;
    rectangularPrism.position.set(0, 1, 0);
    addObjectToScene(rectangularPrism, 'Rectangular Prism');
    meshes.push(rectangularPrism);
}
// Function to add a Torus (Donut Shape)
function addTorus() {
    const geometry = new THREE.TorusGeometry(1, 0.4, 16, 100);
    const material = new THREE.MeshStandardMaterial({ color: 0xE74C3C, side: THREE.DoubleSide }); // Coral / Red-orange
    const torus = new THREE.Mesh(geometry, material);
    torus.castShadow = true;
    torus.receiveShadow = true;
    torus.position.set(0, 1, 0);
    addObjectToScene(torus, 'Torus');
    meshes.push(torus);
}

function addCone() {
    const geometry = new THREE.ConeGeometry(0.5, 1.5, 32); // radius, height, radial segments
    const material = new THREE.MeshStandardMaterial({ color: 0xE67E22, side: THREE.DoubleSide });
    const cone = new THREE.Mesh(geometry, material);
    cone.castShadow = true;
    cone.receiveShadow = true;
    cone.position.set(0, 0.75, 0);
    addObjectToScene(cone, 'Cone');
    meshes.push(cone);
}

function addRoundedBox() {
    const geometry = new THREE.BoxGeometry(1, 1, 1); // fallback if RoundedBoxGeometry is unavailable
    const material = new THREE.MeshStandardMaterial({ color: 0x3498DB, side: THREE.DoubleSide });
    const box = new THREE.Mesh(geometry, material);
    box.castShadow = true;
    box.receiveShadow = true;
    box.position.set(0, 0.5, 0);
    addObjectToScene(box, 'Rounded Box');
    meshes.push(box);
}

function addIcosahedron() {
    const geometry = new THREE.IcosahedronGeometry(0.75, 0); // radius, detail
    const material = new THREE.MeshStandardMaterial({ color: 0x1ABC9C, side: THREE.DoubleSide });
    const ico = new THREE.Mesh(geometry, material);
    ico.castShadow = true;
    ico.receiveShadow = true;
    ico.position.set(0, 0.75, 0);
    addObjectToScene(ico, 'Icosahedron');
    meshes.push(ico);
}

function addTorusKnot() {
    const geometry = new THREE.TorusKnotGeometry(0.5, 0.2, 100, 16);
    const material = new THREE.MeshStandardMaterial({ color: 0x9B59B6, side: THREE.DoubleSide });
    const knot = new THREE.Mesh(geometry, material);
    knot.castShadow = true;
    knot.receiveShadow = true;
    knot.position.set(0, 0.5, 0);
    addObjectToScene(knot, 'Torus Knot');
    meshes.push(knot);
}


 function addLight() {
    const light = new THREE.PointLight(0xffffff, 1);
    light.position.set(0, 2, 0);
    addObjectToScene(light, 'Light');
 }
 
function addCameraInit() {
    const newCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    newCamera.position.set(0, 0, 5);
    addObjectToScene(newCamera, 'Camera');
}




// Advanced tool implementations
function applyTerrace(vertex, position, influence) {
    const steps = parseInt(document.getElementById('terraceSteps').value);
    const heightDiff = position.y - vertex.y;
    const stepHeight = heightDiff / steps;
    
    // Calculate closest step
    const currentStep = Math.round(vertex.y / stepHeight);
    const targetHeight = currentStep * stepHeight;
    
    // Smooth transition between steps
    vertex.y += (targetHeight - vertex.y) * influence * brushStrength;
}

function applyHydraulicErosion(vertex, index, vertices, brushRadius) {
    const erosionStrength = 0.3;

    // ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ÿßŸÑÿ¨Ÿäÿ±ÿßŸÜ
    const neighbors = [];
    const resolution = terrain.geometry.parameters.widthSegments + 1;
    const row = Math.floor(index / resolution);
    const col = index % resolution;

    for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
            if (dx === 0 && dy === 0) continue;
            const ni = (row + dy) * resolution + (col + dx);
            if (ni >= 0 && ni < vertices.count) {
                neighbors.push(ni);
            }
        }
    }

    let totalDelta = 0;
    neighbors.forEach((ni) => {
        const neighborY = vertices.getY(ni);
        const delta = vertex.y - neighborY;
        if (delta > 0) {
            const erosionAmount = delta * erosionStrength * brushStrength;
            vertex.y -= erosionAmount;
            const newY = vertices.getY(ni) + erosionAmount;
            vertices.setY(ni, newY);
            totalDelta += erosionAmount;
        }
    });
}

/*
function applyErosion(vertex, position, influence, vertices, index) {
    const erosionStrength = parseFloat(document.getElementById('erosionStrength').value);
    const radius = brushSize * 2;
    let avgHeight = 0;
    let count = 0;
    
    // Sample neighboring vertices
    for (let i = 0; i < vertices.count; i++) {
        const neighborVertex = new THREE.Vector3(
            vertices.getX(i),
            vertices.getY(i),
            vertices.getZ(i)
        );
        
        const distance = vertex.distanceTo(neighborVertex);
        if (distance < radius && distance > 0) {
            avgHeight += neighborVertex.y;
            count++;
        }
    }
    
    if (count > 0) {
        avgHeight /= count;
        const heightDiff = vertex.y - avgHeight;
        vertex.y -= heightDiff * erosionStrength * influence;
    }
}*/

function applyRidge(vertex, position, influence) {
    const ridgeHeight = parseFloat(document.getElementById('ridgeHeight').value);
    const distance = Math.abs(vertex.x - position.x);
    const falloff = 1 - Math.min(distance / brushSize, 1);
    
    if (falloff > 0) {
        // Create ridge shape using sine function
        const ridge = Math.sin(falloff * Math.PI) * ridgeHeight;
        vertex.y += ridge * influence * brushStrength;
    }
}

function applyCanyon(vertex, position, influence) {
    const depth = brushStrength * 2;
    const distance = Math.abs(vertex.x - position.x);
    const falloff = 1 - Math.min(distance / brushSize, 1);
    
    if (falloff > 0) {
        // Create canyon shape using exponential function
        const canyon = Math.exp(-falloff * 2) * depth;
        vertex.y -= canyon * influence;
    }
}

function applyPlateau(vertex, position, influence) {
    const targetHeight = position.y;
    const threshold = brushSize * 0.3;
    const distance = vertex.distanceTo(position);
    
    if (distance < threshold) {
        // Flat plateau area
        vertex.y += (targetHeight - vertex.y) * influence;
    } else if (distance < brushSize) {
        // Smooth transition to plateau
        const falloff = 1 - ((distance - threshold) / (brushSize - threshold));
        vertex.y += (targetHeight - vertex.y) * falloff * influence;
    }
}

function applySlope(vertex, position, influence, normal) {
    const angle = Math.PI / 4; // 45-degree slope
    const direction = new THREE.Vector3().subVectors(position, vertex);
    const distance = direction.length();
    
    if (distance < brushSize) {
        const targetHeight = position.y - Math.tan(angle) * distance;
        vertex.y += (targetHeight - vertex.y) * influence;
    }
}

function applyBlur(vertex, position, influence, vertices, index) {
    const radius = brushSize * 1.5;
    let avgHeight = 0;
    let totalWeight = 0;
    
    // Gaussian blur
    for (let i = 0; i < vertices.count; i++) {
        const neighborVertex = new THREE.Vector3(
            vertices.getX(i),
            vertices.getY(i),
            vertices.getZ(i)
        );
        
        const distance = vertex.distanceTo(neighborVertex);
        if (distance < radius) {
            const weight = Math.exp(-(distance * distance) / (2 * radius * radius));
            avgHeight += neighborVertex.y * weight;
            totalWeight += weight;
        }
    }
    
    if (totalWeight > 0) {
        avgHeight /= totalWeight;
        vertex.y += (avgHeight - vertex.y) * influence * brushStrength;
    }
}

function applySharpen(vertex, position, influence, vertices, index) {
    const radius = brushSize;
    let avgHeight = 0;
    let count = 0;
    
    // Calculate local average height
    for (let i = 0; i < vertices.count; i++) {
        const neighborVertex = new THREE.Vector3(
            vertices.getX(i),
            vertices.getY(i),
            vertices.getZ(i)
        );
        
        const distance = vertex.distanceTo(neighborVertex);
        if (distance < radius && distance > 0) {
            avgHeight += neighborVertex.y;
            count++;
        }
    }
    
    if (count > 0) {
        avgHeight /= count;
        const heightDiff = vertex.y - avgHeight;
        vertex.y += heightDiff * influence * brushStrength;
    }
}





function addObjectToScene(object, name) { // This is YOUR function
    object.userData.selectable = true;
    object.name = name + '_' + objects.length;
    // Your logic for naming might be different, adapt if needed.
    // The NodeEditor will try to set an initial name on the THREE.Object3D.
    if (name && !object.name) object.name = name;
    else if (!object.name) object.name = `Object_${objects.length}`;

    objects.push(object);
    if (scene) { // Ensure scene is initialized
        scene.add(object);
    } else {
        console.error("addObjectToScene: Scene not yet initialized!");
    }
    updateHierarchy(); // Assuming you have this function
    selectObject(object); // Assuming you have this function

       if (!object) {
        console.error("addObjectToScene: Object is undefined for type:", type);
        return;
    }

    if (typeof updateHierarchy === 'function') { // If you have a UI tree
        updateHierarchy(object);
    }
    

    if (isModelingMode) { // Assuming these variables exist
        activeObject = object;
        showMeshStructure(activeObject);
    }
    console.log(`Main addObjectToScene called for: ${object.name}`);
}
window.addObjectToScene = addObjectToScene;

/*
function addObjectToScene(object, name) {
    object.userData.selectable = true; // Mark object as selectable
    object.name = name + '_' + objects.length;
    objects.push(object); 
    scene.add(object)
    updateHierarchy();
    selectObject(object);

    if (isModelingMode) {
        activeObject = object;
        showMeshStructure(activeObject);
    }
}*/

/*function addObjectToScene(object, name) {
    object.userData.selectable = true;
    object.name = name + '_' + objects.length;
    
    // Set render order for the object to be higher than grid
    object.renderOrder = 1;
    
    // If the object is a mesh, adjust its material
    if (object.isMesh) {
        if (Array.isArray(object.material)) {
            object.material.forEach(mat => {
                mat.depthWrite = true;
                mat.depthTest = true;
            });
        } else if (object.material) {
            object.material.depthWrite = true;
            object.material.depthTest = true;
        }
    }
    
    objects.push(object);
    scene.add(object);
    updateHierarchy();
    selectObject(object);

    if (isModelingMode) {
        activeObject = object;
        showMeshStructure(activeObject);
    }
}
*/
function updateRenderOrder() {
    scene.traverse((object) => {
        if (object.isGroup && object.name === 'advancedGrid') {
            object.renderOrder = -2;
            object.children.forEach(child => {
                child.renderOrder = -2;
                if (child.material) {
                    child.material.depthWrite = false;
                    child.material.transparent = true;
                }
            });
        } else if (object.isHelper) {
            object.renderOrder = -1;
        } else if (object.isMesh || object.isLine) {
            object.renderOrder = 1;
        }
    });
}


const COLORS = { 
    HIGHLIGHT: 0x00e5ff,           // Cyan hover
    SELECTED:  0xffa500,            // Orange select
    SECONDARY: 0x8888ff            // Blue for multi-select (new)
};

const originalEmissive = new WeakMap();

function applySelectionHighlight(object, colorHex, intensity = 0.4) {
    if (!object || !object.material) return;

    if (!originalEmissive.has(object)) {
        originalEmissive.set(object, {
            color: object.material.emissive.clone(),
            intensity: object.material.emissiveIntensity
        });
    }

    object.material.emissive.setHex(colorHex);
    object.material.emissiveIntensity = intensity;
}

function highlightSelectionBlenderStyle(object) {
    if (!object || !object.material || object.isLight) return;

    const mat = object.material;

    if (!originalMaterials.has(object)) {
        originalMaterials.set(object, mat.clone());
    }

    mat.transparent = false; // No transparency for selection (solid)
    mat.depthWrite = true;
    mat.emissive = new THREE.Color(COLORS.SELECTED); // Orange
    mat.emissiveIntensity = 0.3; // Stronger to match Blender's selected orange
    mat.needsUpdate = true;
}

function highlightHoverBlenderStyle(object) {
    if (!object || !object.material || object === selectedObject || object.isLight) return;

    const mat = object.material;

    if (!originalMaterials.has(object)) {
        originalMaterials.set(object, mat.clone());
    }

    mat.transparent = true;
    mat.opacity = 0.4; // Optional: affects surface visibility, not emissive
    mat.depthWrite = false;
    mat.emissive = new THREE.Color(COLORS.HIGHLIGHT); // Cyan
    mat.emissiveIntensity = 0.3; // Low glow to simulate soft hover like Blender
    mat.needsUpdate = true;
}


// State management
let hoveredObject = null;
const originalMaterials = new WeakMap();
const selectionHandlers = new Set();


// Selection management functions
function addSelectionHandler(handler) {
    selectionHandlers.add(handler);
}

function removeSelectionHandler(handler) {
    selectionHandlers.delete(handler);
}

function notifySelectionHandlers(object) {
    selectionHandlers.forEach(handler => handler(object));
}

let selectedObjects = [];


// Enhanced selectObject function to work with multiple selection
function selectObject(newObject) {
    activeObject = newObject;

    
    try {
        if (newObject) {
            ensureObjectUUID(newObject);
        }
        
        // If selecting the same object, do nothing
        if (selectedObject === newObject) return selectedObject;

        // Clear hover state if the hovered object is being selected
        if (hoveredObject === newObject) {
            hoveredObject = null;
        }

        // If we have box-selected objects, handle them differently
        if (selectedObjectsFromBox && selectedObjectsFromBox.length > 1) {
            // Only restore the previous active object if it's not in the box selection
            if (selectedObject && !selectedObjectsFromBox.includes(selectedObject)) {
                restoreOriginalMaterial(selectedObject);
                
                if (selectedObject.helper) {
                    selectedObject.helper.visible = false;
                }
            }
        } else {
            // Restore previous selection's material (normal case)
            if (selectedObject) {
                restoreOriginalMaterial(selectedObject);
                
                if (selectedObject.helper) {
                    selectedObject.helper.visible = false;
                }
            }
        }

        selectedObject = newObject;

        // Handle new selection
        if (selectedObject) {
            // Store and apply selection material if not already applied
            // (Don't apply again if it's part of a multiple selection)
            if (!selectedObjectsFromBox || selectedObjectsFromBox.length <= 1) {
                applySelectionHighlight(selectedObject, COLORS.SELECTED, 0.4);
            }

            if (selectedObject.helper) {
                selectedObject.helper.visible = true;
            }

            transformControls.attach(selectedObject);

            if (selectedObject.isLight) {
                updateLightUI(selectedObject);
            } else if (selectedObject.isCamera) {
                updateCameraUI(selectedObject);
            }
        } else {
            transformControls.detach();
            
            // Clear box selection if we're selecting nothing
            if (selectedObjectsFromBox && selectedObjectsFromBox.length > 0) {
                selectedObjectsFromBox.forEach(obj => {
                    restoreOriginalMaterial(obj);
                });
                selectedObjectsFromBox = [];
            }
        }

        // Notify handlers of selection change
        notifySelectionHandlers(selectedObject);
        
        // Update UI elements
        updateInspector();
        updateHierarchySelection();
    

        // If in modeling mode, show mesh structure
        if (isModelingMode && selectedObject) {
            showMeshStructure(selectedObject);
        }

        
        return selectedObject;

    } catch (error) {
        console.error('Error in selectObject:', error);
        throw error;
    }
}


// Utility function to restore original material
function restoreOriginalMaterial(object) {
    if (!object) return;
    
    if (object.userData.originalMaterial) {
        if (Array.isArray(object.material)) {
            // Clone the original materials back
            object.material = object.userData.originalMaterial.map(m => m.clone());
        } else {
            // Clone the original material back
            object.material = object.userData.originalMaterial.clone();
        }
        delete object.userData.originalMaterial;
    } else if (object.material) {
        // Reset emissive properties if no original material stored
        if (Array.isArray(object.material)) {
            object.material.forEach(mat => {
                if (mat.emissive) {
                    mat.emissive.set(0x000000);
                    mat.emissiveIntensity = 0;
                }
            });
        } else if (object.material.emissive) {
            object.material.emissive.set(0x000000);
            object.material.emissiveIntensity = 0;
        }
    }
}

function setHoverObject(object) {
    if (object === selectedObject || !object || !object.material || object.isLight) return;

    // Restore previous hovered object
    if (hoveredObject && originalEmissive.has(hoveredObject)) {
        const original = originalEmissive.get(hoveredObject);
        hoveredObject.material.emissive.copy(original.color);
        hoveredObject.material.emissiveIntensity = original.intensity;
    }

    hoveredObject = object;

    // Store original emissive values
    if (!originalEmissive.has(object)) {
        originalEmissive.set(object, {
            color: object.material.emissive.clone(),
            intensity: object.material.emissiveIntensity
        });
    }

    // Apply hover effect
    object.material.emissive.setHex(COLORS.HIGHLIGHT);
    object.material.emissiveIntensity = 0.3;
}

function clearHoverObject() {
    if (hoveredObject && originalEmissive.has(hoveredObject)) {
        const original = originalEmissive.get(hoveredObject);
        hoveredObject.material.emissive.copy(original.color);
        hoveredObject.material.emissiveIntensity = original.intensity;
        hoveredObject = null;
    }
}

// Hierarchy view functions
function getObjectIcon(obj) {
    if (obj.isLight) return 'üí°';
    if (obj.isCamera) return 'üé•';
    if (obj.isMesh) return 'üì¶';
    if (obj.isGroup) return 'üìÅ';
    if (obj.type === 'Scene') return 'üåê';
    if (obj.type === 'Bone') return 'ü¶¥';

    // Fallback based on object type string
    const type = obj.type?.toLowerCase() || '';

    if (type.includes('mesh')) return 'üì¶';
    if (type.includes('light')) return 'üí°';
    if (type.includes('camera')) return 'üé•';
    if (type.includes('group')) return 'üìÅ';
    if (type.includes('bone')) return 'ü¶¥';
    if (type.includes('object3d')) return 'üîπ';

    return '‚ö™'; // default unknown type
}

function createHierarchyItem(obj, level = 0, isLastChild = false, siblings = []) {
    const item = document.createElement('div');
    item.className = 'hierarchy-item';
    item.dataset.uuid = obj.uuid || generateUUID();
    item.dataset.level = level;

    // Add hierarchy line
    const line = document.createElement('div');
    line.className = 'hierarchy-line';
    line.style.left = `${level * 20 + 10}px`; // Position line based on level

    if (isLastChild) {
        line.style.height = '50%'; // Only show top half of the line for last child
        line.style.bottom = 'auto'; // Don't extend to bottom
    }
    item.appendChild(line);

    // Add horizontal connector line
    if (level > 0) {
        const connector = document.createElement('div');
        connector.className = 'hierarchy-connector';
        connector.style.left = `${level * 20 + 10}px`;
        connector.style.width = `10px`;
        item.appendChild(connector);
    }

    const content = document.createElement('div');
    content.className = 'hierarchy-item-content';
    content.style.paddingLeft = `${level * 20 + 25}px`;

    // Add expand/collapse toggle
    if (obj.children && obj.children.length > 0) {
        const toggle = document.createElement('span');
        toggle.className = 'hierarchy-toggle';
        toggle.innerHTML = obj.expanded ? '‚ñº' : '‚ñ∂';
        toggle.onclick = (e) => {
            e.stopPropagation();
            obj.expanded = !obj.expanded;
            updateHierarchy();
        };
        content.appendChild(toggle);
    }

    item.oncontextmenu = (e) => {
        e.preventDefault();
        e.stopPropagation();
        showContextMenu(e.clientX, e.clientY, obj);
        return false;
    };

    // Add icon and name with visual prefix
    const icon = document.createElement('span');
    icon.className = 'hierarchy-icon';
    icon.innerHTML = getObjectIcon(obj);
    content.appendChild(icon);

    const prefix = getTreePrefix(level, isLastChild);
    const name = document.createElement('span');
    name.className = 'hierarchy-name';
    name.style.cssText = 'max-width: 110px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;';
    name.textContent = `${prefix}${obj.name || `${obj.type || 'Object'}_${obj.id}`}`;
    content.appendChild(name);

    // Enable inline renaming on double-click
    name.ondblclick = () => {
  const input = document.createElement('input');
  input.type = 'text';
  input.value = obj.name;
  input.style.width = '100px';
  input.className = 'hierarchy-rename-input';

  input.onblur = () => {
    obj.name = input.value || obj.name;
    updateHierarchy();
  };

  input.onkeydown = (e) => {
    if (e.key === 'Enter' || e.key === 'Escape') {
      input.blur();
    }
  };

  name.replaceWith(input);
  input.focus();
};

    // Visibility toggle
    const visibilityToggle = document.createElement('button');
    visibilityToggle.className = 'hierarchy-visibility';
    visibilityToggle.innerHTML = obj.visible ? 'üëÅÔ∏è' : 'üëÅÔ∏è‚Äçüó®Ô∏è';
    visibilityToggle.onclick = (e) => {
        e.stopPropagation();
        obj.visible = !obj.visible;
        visibilityToggle.innerHTML = obj.visible ? 'üëÅÔ∏è' : 'üëÅÔ∏è‚Äçüó®Ô∏è';
    };
    content.appendChild(visibilityToggle);

    // Geometry/material info
    if (obj.geometry || obj.material) {
        const properties = document.createElement('div');
        properties.className = 'hierarchy-properties';

        if (obj.geometry) {
            const vertCount = document.createElement('span');
            vertCount.className = 'property';
            vertCount.textContent = `Verts: ${obj.geometry.attributes.position.count}`;
            properties.appendChild(vertCount);
        }

        if (obj.material) {
            const matType = document.createElement('span');
            matType.className = 'property';
            matType.textContent = `Mat: ${obj.material.type}`;
            properties.appendChild(matType);
        }

        content.appendChild(properties);
    }

    item.appendChild(content);

    if (selectedObject && selectedObject.uuid === obj.uuid) {
        item.classList.add('selected');
    }

    item.onclick = (e) => {
        e.stopPropagation();
        selectObject(obj);
    };

    item.onmouseenter = () => {
        if (obj !== selectedObject) {
            setHoverObject(obj);
        }
    };

    item.onmouseleave = () => {
        if (obj !== selectedObject) {
            setHoverObject(null);
        }
    };

    setupDragAndDrop(item, obj);

    if (selectedObject === obj) {
        item.classList.add('selected');
    }

    return item;
}

function getTreePrefix(level, isLastChild) {
    return '';
}



function showContextMenu(x, y, obj) {
    const menu = document.createElement('div');
    menu.className = 'hierarchy-context-menu';
    menu.style.left = `${x}px`;
    menu.style.top = `${y}px`;
    
    const options = [
        { label: 'Rename', action: () => renameObject(obj) },
        { label: 'Duplicate', action: () => duplicateObject(obj) },
        { label: 'Delete', action: () => deleteObject(obj) },
        { label: 'Create Child', action: () => createChildObject(obj) }
    ];
    
    options.forEach(option => {
        const item = document.createElement('div');
        item.className = 'context-menu-item';
        item.textContent = option.label;
        item.onclick = () => {
            option.action();
            document.body.removeChild(menu);
        };
        menu.appendChild(item);
    });
    
    document.body.appendChild(menu);
    
    // Close menu when clicking elsewhere
    setTimeout(() => {
        window.addEventListener('click', function closeMenu() {
            if (document.body.contains(menu)) {
                document.body.removeChild(menu);
            }
            window.removeEventListener('click', closeMenu);
        });
    }, 0);
}

function renameObject(obj) {
    const newName = prompt("Enter new name:", obj.name || obj.type || "Object");
    if (newName !== null && newName.trim() !== "") {
        obj.name = newName.trim();
        updateHierarchy();
    }
}


function createChildObject(parentObj) {
    const child = new THREE.Mesh( // or new THREE.Object3D() if you want a generic object
        new THREE.BoxGeometry(1, 1, 1),
        new THREE.MeshBasicMaterial({ color: 0x00ff00 })
    );
    child.name = "NewChild_" + Date.now();
    parentObj.add(child);
    parentObj.expanded = true; // Make sure the parent shows children
    updateHierarchy();
}


function showDropIndicator(targetItem, position) {
    // Remove any existing indicators
    document.querySelectorAll('.drop-indicator').forEach(el => el.remove());
    
    const indicator = document.createElement('div');
    indicator.className = 'drop-indicator';
    
    if (position === 'inside') {
        targetItem.classList.add('drop-target');
    } else {
        // Position indicator above or below target
        indicator.style.top = position === 'before' ? 
            `${targetItem.offsetTop - 2}px` : 
            `${targetItem.offsetTop + targetItem.offsetHeight - 2}px`;
        
        document.getElementById('hierarchy-content').appendChild(indicator);
    }
}

document.getElementById('hierarchy-search-input').addEventListener('input', function() {
    const searchTerm = this.value.toLowerCase();
    highlightMatchingItems(searchTerm);
});

document.getElementById('hierarchy-search-clear').addEventListener('click', function() {
    document.getElementById('hierarchy-search-input').value = '';
    highlightMatchingItems('');
});

function highlightMatchingItems(searchTerm) {
    const items = document.querySelectorAll('.hierarchy-item');
    
    if (!searchTerm) {
        items.forEach(item => {
            item.style.display = '';
            item.classList.remove('search-match');
        });
        return;
    }
    
    items.forEach(item => {
        const name = item.querySelector('.hierarchy-name').textContent.toLowerCase();
        if (name.includes(searchTerm)) {
            item.style.display = '';
            item.classList.add('search-match');
        } else {
            item.style.display = 'none';
        }
    });
}

function setupHierarchyResize() {
    const hierarchyPanel = document.getElementById('hierarchy-panel');
    const resizeHandle = hierarchyPanel.querySelector('.resize-handle-hierarchy');

    let isResizing = false;
    let startX = 0;
    let startWidth = 0;

    resizeHandle.addEventListener('mousedown', (e) => {
        isResizing = true;
        startX = e.clientX;
        startWidth = hierarchyPanel.offsetWidth;
        document.body.style.cursor = 'ew-resize';
    });

    document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;

        const newWidth = startWidth + (e.clientX - startX);
        const minWidth = window.innerWidth * 0.2; // 20% of viewport width
        const maxWidth = window.innerWidth * 0.5; // 50% of viewport width
        const hierarchyWidth = Math.min(Math.max(newWidth, minWidth), maxWidth);

        // Set hierarchy panel width
        hierarchyPanel.style.width = `${hierarchyWidth}px`;

        // Calculate remaining width
        const totalWidth = window.innerWidth;
        const sidebarWidth = totalWidth - hierarchyWidth - timeline.offsetWidth;
        const sidebarThreshold = totalWidth * 0.1; // Hide sidebar if less than 10% width

        // Adjust sidebar
        if (sidebarWidth > sidebarThreshold) {
            sidebar.style.width = `${sidebarWidth}px`;
            sidebar.style.left = `${hierarchyWidth}px`;
            sidebar.classList.remove('hidden');
        } else {
            sidebar.classList.add('hidden');
        }

        // Adjust timeline
        const timelineWidth = totalWidth - hierarchyWidth;
        timeline.style.width = `${timelineWidth}px`;
        timeline.style.left = `${hierarchyWidth}px`;
    });

    document.addEventListener('mouseup', () => {
        if (isResizing) {
            isResizing = false;
            document.body.style.cursor = 'default';
        }
    });
}

/*function ensureObjectUUID(obj) {
    if (!obj) return;

    // Ensure the object itself has a UUID
    if (!obj.uuid) {
        obj.uuid = THREE.MathUtils.generateUUID();
    }

    // Recursively ensure all children have UUIDs
    if (obj.children && obj.children.length > 0) {
        obj.children.forEach(child => ensureObjectUUID(child));
    }

    // Handle bones for SkinnedMesh
    if (obj.isSkinnedMesh && obj.skeleton) {
        obj.skeleton.bones.forEach(bone => {
            if (!bone.uuid) {
                bone.uuid = THREE.MathUtils.generateUUID();
            }
        });
    }

    return obj.uuid;
}*/


function ensureObjectUUID(obj) {
    if (!obj.uuid) {
        obj.uuid = THREE.MathUtils.generateUUID();
    }
    return obj.uuid;
}

// Drag and drop handling
let draggedItem = null;
let dropTarget = null;

function setupDragAndDrop(item, obj) {
    item.draggable = true;

    item.addEventListener('dragstart', (e) => {
        e.dataTransfer.setData('application/json', JSON.stringify({ uuid: obj.uuid }));
        e.stopPropagation();
    });

    item.addEventListener('dragover', (e) => {
        e.preventDefault(); // Allow drop
        item.classList.add('drag-over');
    });

    item.addEventListener('dragleave', () => {
        item.classList.remove('drag-over');
    });

    item.addEventListener('drop', (e) => {
        e.preventDefault();
        e.stopPropagation();
        item.classList.remove('drag-over');

        const data = JSON.parse(e.dataTransfer.getData('application/json'));
        const draggedObj = findObjectByUUID(scene, data.uuid); // Replace 'scene' with your actual root scene object

        if (draggedObj && draggedObj !== obj && !isDescendant(draggedObj, obj)) {
            obj.add(draggedObj); // Reparent the object
            updateHierarchy(); // Refresh the hierarchy
        }
    });
}

function findObjectByUUID(root, uuid) {
    if (root.uuid === uuid) return root;
    for (let child of root.children) {
        const found = findObjectByUUID(child, uuid);
        if (found) return found;
    }
    return null;
}

function isDescendant(parent, child) {
    while (child.parent) {
        if (child.parent === parent) return true;
        child = child.parent;
    }
    return false;
}


function canDrop(draggedObj, targetObj) {
    if (draggedObj === targetObj) return false;
    let parent = targetObj.parent;
    while (parent) {
        if (parent === draggedObj) return false;
        parent = parent.parent;
    }
    return true;
}



function handleDrop(draggedObj, targetObj) {
    const oldParent = draggedObj.parent;
    oldParent.remove(draggedObj);
    targetObj.add(draggedObj);
    updateHierarchy();
}

function clearDropTargets() {
    const dropTargets = document.querySelectorAll('.drop-target');
    dropTargets.forEach(el => el.classList.remove('drop-target'));
    dropTarget = null;
}

function updateHierarchy() {
    const container = document.getElementById('hierarchy-content');
    container.innerHTML = '';

    const viewMode = document.getElementById('hierarchyViewMode')?.value || 'tree';

    if (viewMode === 'flat') {
        renderFlatView(container);
    } else if (viewMode === 'type') {
        renderTypeView(container);
    } else {
        renderTreeView(container); // default
    }

    updateHierarchySelection();
}

function renderTreeView(container) {
    function addChildrenToHierarchy(parent, level, siblings = []) {
        const children = parent.children || [];
        children.forEach((child, index) => {
            const isLastChild = index === children.length - 1;
            const item = createHierarchyItem(child, level, isLastChild, siblings);
            container.appendChild(item);
            if (child.expanded && child.children && child.children.length > 0) {
                addChildrenToHierarchy(child, level + 1, children);
            }
        });
    }

    objects.forEach((obj, index) => {
        const isLastChild = index === objects.length - 1;
        container.appendChild(createHierarchyItem(obj, 0, isLastChild, objects));
        if (obj.expanded && obj.children && obj.children.length > 0) {
            addChildrenToHierarchy(obj, 1, objects);
        }
    });
}

function renderFlatView(container) {
    function addFlatItems(objList) {
        objList.forEach(obj => {
            container.appendChild(createHierarchyItem(obj, 0, false, []));
            if (obj.children) addFlatItems(obj.children);
        });
    }
    addFlatItems(objects);
}

function renderTypeView(container) {
    const typeGroups = {};

    function collectByType(objList) {
        objList.forEach(obj => {
            const type = obj.type || 'Unknown';
            if (!typeGroups[type]) typeGroups[type] = [];
            typeGroups[type].push(obj);
            if (obj.children) collectByType(obj.children);
        });
    }

    collectByType(objects);

    for (const [type, group] of Object.entries(typeGroups)) {
        const header = document.createElement('div');
        header.textContent = `üì¶ ${type}`;
        header.style.fontWeight = 'bold';
        header.style.marginTop = '10px';
        container.appendChild(header);

        group.forEach(obj => {
            container.appendChild(createHierarchyItem(obj, 1, false, group));
        });
    }
}
document.getElementById('hierarchyViewMode').addEventListener('change', updateHierarchy);

// Material cache for highlighting

function updateInspector() {
    if (!selectedObject) return;
 
    document.getElementById('posX').value = selectedObject.position.x;
    document.getElementById('posY').value = selectedObject.position.y;
    document.getElementById('posZ').value = selectedObject.position.z;
 
    document.getElementById('rotX').value = selectedObject.rotation.x;
    document.getElementById('rotY').value = selectedObject.rotation.y;
    document.getElementById('rotZ').value = selectedObject.rotation.z;
 
    document.getElementById('scaleX').value = selectedObject.scale.x;
    document.getElementById('scaleY').value = selectedObject.scale.y;
    document.getElementById('scaleZ').value = selectedObject.scale.z;
}
 
function bindInspectorInputs() {
    const positionInputs = ['posX', 'posY', 'posZ'];
    const rotationInputs = ['rotX', 'rotY', 'rotZ'];
    const scaleInputs = ['scaleX', 'scaleY', 'scaleZ'];

    positionInputs.forEach(axis => {
        document.getElementById(axis).addEventListener('input', () => {
            if (!selectedObject) return;
            selectedObject.position.x = parseFloat(document.getElementById('posX').value);
            selectedObject.position.y = parseFloat(document.getElementById('posY').value);
            selectedObject.position.z = parseFloat(document.getElementById('posZ').value);
        });
    });

    rotationInputs.forEach(axis => {
        document.getElementById(axis).addEventListener('input', () => {
            if (!selectedObject) return;
            selectedObject.rotation.x = parseFloat(document.getElementById('rotX').value);
            selectedObject.rotation.y = parseFloat(document.getElementById('rotY').value);
            selectedObject.rotation.z = parseFloat(document.getElementById('rotZ').value);
        });
    });

    scaleInputs.forEach(axis => {
        document.getElementById(axis).addEventListener('input', () => {
            if (!selectedObject) return;
            selectedObject.scale.x = parseFloat(document.getElementById('scaleX').value);
            selectedObject.scale.y = parseFloat(document.getElementById('scaleY').value);
            selectedObject.scale.z = parseFloat(document.getElementById('scaleZ').value);
        });
    });
}


 function updateHierarchySelection() {
    const items = document.querySelectorAll('.hierarchy-item');

    items.forEach(item => {
        item.classList.remove('selected');
    });

    if (selectedObject) {
        const selectedItem = document.querySelector(`.hierarchy-item[data-uuid="${selectedObject.uuid}"]`);
        if (selectedItem) {
            selectedItem.classList.add('selected');

            let parent = selectedItem.parentElement;
            while (parent) {
                const parentItem = parent.closest('.hierarchy-item');
                if (parentItem) {
                    const toggle = parentItem.querySelector('.hierarchy-toggle');
                    if (toggle && toggle.innerHTML === '‚ñ∂') {
                        const parentObj = objects.find(obj => obj.uuid === parentItem.dataset.uuid);
                        if (parentObj) {
                            parentObj.expanded = true;
                            updateHierarchy();
                            return;
                        }
                    }
                }
                parent = parent.parentElement;
            }
        }
    }
}

 
// Available Transform Modes
const TRANSFORM_MODES = ['translate', 'rotate', 'scale', 'mirror', 'snap', 'shear', 'reset','transform-all', ];

// Function to Set Transform Mode
function setTransformMode(mode) {
    if (!TRANSFORM_MODES.includes(mode)) return;

    transformControls.setMode(mode);
    
    document.querySelectorAll('.toolbar-group button').forEach(btn => {
        btn.classList.remove('active');
        gsap.to(btn, { scale: 1, duration: 0.2 });  // Reset size
    });

    const activeBtn = document.getElementById(mode);
    activeBtn.classList.add('active');

    // Smooth animation for button feedback
    gsap.to(activeBtn, { scale: 1.2, duration: 0.3, yoyo: true, repeat: 1 });

    // Apply Special Modes
    applySpecialTransform(mode);
}

// Function to Apply Special Transformations
function applySpecialTransform(mode) {
    const object = transformControls.object;
    if (!object) return;

    switch (mode) {
        case 'mirror': 
            object.scale.x *= -1; // Flip along X-axis
            break;

        case 'snap':
            object.position.x = Math.round(object.position.x / 5) * 5; // Snap to 5 units
            object.position.y = Math.round(object.position.y / 5) * 5;
            object.position.z = Math.round(object.position.z / 5) * 5;
            break;

        case 'shear': 
            object.scale.x += 0.1;  // Skew effect
            object.scale.y -= 0.05;
            break;

        case 'reset': 
            object.position.set(0, 0, 0);
            object.rotation.set(0, 0, 0);
            object.scale.set(1, 1, 1);
            break;
    }
    object.matrixWorldNeedsUpdate = true;
}


/*
 // File operations
function newScene() {
    objects.forEach(obj => scene.remove(obj));
    objects = [];
    selectedObject = null;
    updateHierarchy();
    updateInspector();
    localStorage.removeItem("savedScene"); // Reset saved scene
}

// ‚úÖ **Auto-save Scene**
function autoSaveScene() {
    const sceneData = serializeScene();
    try {
        localStorage.setItem("savedScene", JSON.stringify(sceneData));
        console.log("‚úÖ Scene auto-saved!");
    } catch (error) {
        console.error("‚ùå Failed to auto-save scene:", error);
    }
}

// ‚úÖ **Load Scene from Local Storage**
function loadSavedScene() {
    try {
        const savedData = localStorage.getItem("savedScene");
        if (savedData) {
            restoreScene(JSON.parse(savedData));
            console.log("‚úÖ Scene loaded from localStorage!");
        }
    } catch (error) {
        console.error("‚ùå Failed to load saved scene:", error);
    }
}

// ‚úÖ **Save Scene Manually (Download as JSON)**
function saveScene() {
    const sceneData = serializeScene();
    const blob = new Blob([JSON.stringify(sceneData, null, 2)], { type: 'application/json' });
    saveAs(blob, "scene.json");
}

// ‚úÖ **Load Scene from File**
function loadScene() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    input.onchange = (e) => {
        const file = e.target.files[0];
        const reader = new FileReader();
        reader.onload = (event) => {
            restoreScene(JSON.parse(event.target.result));
            console.log("‚úÖ Scene loaded from JSON!");
        };
        reader.readAsText(file);
    };
    input.click();
}

// ‚úÖ **Serialize Scene**
function serializeScene() {
    return {
        objects: objects.map(obj => ({
            type: obj.type,
            geometry: obj.geometry ? obj.geometry.parameters : null,
            material: obj.material ? {
                color: obj.material.color.getHex(),
                wireframe: obj.material.wireframe
            } : null,
            position: obj.position.toArray(),
            rotation: obj.rotation.toArray(),
            scale: obj.scale.toArray(),
            name: obj.name
        })),
        timestamp: Date.now()
    };
}


// ‚úÖ **Restore Scene**
function restoreScene(sceneData) {
    newScene();
    sceneData.objects.forEach(objData => {
        let obj;
        switch (objData.type) {
            case 'Mesh':
                obj = new THREE.Mesh(
                    new THREE.BoxGeometry(
                        objData.geometry.width,
                        objData.geometry.height,
                        objData.geometry.depth
                    ),
                    new THREE.MeshStandardMaterial({ color: objData.material.color })
                );
                break;
        }
        if (obj) {
            obj.position.fromArray(objData.position);
            obj.rotation.fromArray(objData.rotation);
            obj.scale.fromArray(objData.scale);
            obj.name = objData.name;
            addObjectToScene(obj);
        }
    });

}

// ‚úÖ **Export Scene as GLTF, OBJ, FBX, and ZIP**
function exportScene() {
    const format = document.getElementById('exportFormat').value;
    switch (format) {
        case 'gltf':
            exportGLTF();
            break;
        case 'obj':
            exportOBJ();
            break;
        case 'fbx':
            exportFBX();
            break;
        case 'zip':
            exportAsZip();
            break;
    }
}

// ‚úÖ **Export as GLTF**
function exportGLTF() {
    const exporter = new THREE.GLTFExporter();
    exporter.parse(scene, (result) => {
        const blob = new Blob([JSON.stringify(result)], { type: 'application/json' });
        saveAs(blob, "scene.gltf");
    });
}

// ‚úÖ **Export as OBJ**
function exportOBJ() {
    const exporter = new THREE.OBJExporter();
    const result = exporter.parse(scene);
    const blob = new Blob([result], { type: 'text/plain' });
    saveAs(blob, "scene.obj");
}

// ‚úÖ **Export as FBX**
function exportFBX() {
    const exporter = new THREE.FBXExporter();
    const result = exporter.parse(scene);
    const blob = new Blob([result], { type: 'application/octet-stream' });
    saveAs(blob, "scene.fbx");
}

// ‚úÖ **Export Scene as Compressed ZIP**
function exportAsZip() {
    const zip = new JSZip();
    zip.file("scene.json", JSON.stringify(serializeScene(), null, 2));

    zip.generateAsync({ type: "blob" }).then((content) => {
        saveAs(content, "scene.zip");
    });
}

// ‚úÖ **Import Scene**
function importScene() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json,.gltf,.glb,.obj,.fbx,.zip';
    input.onchange = (e) => {
        const file = e.target.files[0];
        const reader = new FileReader();
        reader.onload = (event) => {
            if (file.name.endsWith('.json')) {
                restoreScene(JSON.parse(event.target.result));
            } else if (file.name.endsWith('.gltf') || file.name.endsWith('.glb')) {
                loadGLTF(event.target.result);
            } else if (file.name.endsWith('.obj')) {
                loadOBJ(event.target.result);
            } else if (file.name.endsWith('.fbx')) {
                loadFBX(event.target.result);
            } else if (file.name.endsWith('.zip')) {
                loadZIP(event.target.result);
            }
        };
        reader.readAsText(file);
    };
    input.click();
}

// ‚úÖ **Warn Before Leaving (If Unsaved Changes)**
window.addEventListener("beforeunload", (event) => {
    if (localStorage.getItem("savedScene")) {
        event.preventDefault();
        event.returnValue = "You have unsaved changes. Do you want to leave?";
    }
});


// Keep your existing auto-save setup
setInterval(autoSaveScene, 2 * 60 * 1000);
window.addEventListener("load", loadSavedScene);
*/


// File operations
 function newScene() {
    objects.forEach(obj => scene.remove(obj));
    objects = [];
    selectedObject = null;
    updateHierarchy();
    updateInspector();
    localStorage.removeItem("savedScene"); // Reset saved scene
}

// ‚úÖ **Auto-save Scene**
function autoSaveScene() {
    const sceneData = serializeScene();
    try {
        localStorage.setItem("savedScene", JSON.stringify(sceneData));
        console.log("‚úÖ Scene auto-saved!");
    } catch (error) {
        console.error("‚ùå Failed to auto-save scene:", error);
    }
}

// ‚úÖ **Load Scene from Local Storage**
function loadSavedScene() {
    try {
        const savedData = localStorage.getItem("savedScene");
        if (savedData) {
            restoreScene(JSON.parse(savedData));
            console.log("‚úÖ Scene loaded from localStorage!");
        }
    } catch (error) {
        console.error("‚ùå Failed to load saved scene:", error);
    }
}

// ‚úÖ **Save Scene Manually (Download as JSON)**
function saveScene() {
    const sceneData = serializeScene();
    const blob = new Blob([JSON.stringify(sceneData, null, 2)], { type: 'application/json' });
    saveAs(blob, "scene.json");
}

// ‚úÖ **Load Scene from File**
function loadScene() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    input.onchange = (e) => {
        const file = e.target.files[0];
        const reader = new FileReader();
        reader.onload = (event) => {
            restoreScene(JSON.parse(event.target.result));
            console.log("‚úÖ Scene loaded from JSON!");
        };
        reader.readAsText(file);
    };
    input.click();
}

// ‚úÖ **Serialize Scene**
function serializeScene() {
    return {
        objects: objects.map(obj => ({
            type: obj.type,
            geometry: obj.geometry ? obj.geometry.parameters : null,
            material: obj.material ? {
                color: obj.material.color.getHex(),
                wireframe: obj.material.wireframe
            } : null,
            position: obj.position.toArray(),
            rotation: obj.rotation.toArray(),
            scale: obj.scale.toArray(),
            name: obj.name
        })),
        timestamp: Date.now()
    };
}

// ‚úÖ **Restore Scene**
function restoreScene(sceneData) {
    newScene();
    sceneData.objects.forEach(objData => {
        let obj;
        switch (objData.type) {
            case 'Mesh':
                obj = new THREE.Mesh(
                    new THREE.BoxGeometry(
                        objData.geometry.width,
                        objData.geometry.height,
                        objData.geometry.depth
                    ),
                    new THREE.MeshStandardMaterial({ color: objData.material.color })
                );
                break;
        }
        if (obj) {
            obj.position.fromArray(objData.position);
            obj.rotation.fromArray(objData.rotation);
            obj.scale.fromArray(objData.scale);
            obj.name = objData.name;
            addObjectToScene(obj);
        }
    });
}

// ‚úÖ **Export Scene as GLTF, OBJ, FBX, and ZIP**
function exportScene() {
    const format = document.getElementById('exportFormat').value;
    switch (format) {
        case 'gltf':
            exportGLTF();
            break;
        case 'obj':
            exportOBJ();
            break;
        case 'fbx':
            exportFBX();
            break;
        case 'zip':
            exportAsZip();
            break;
    }
}

// ‚úÖ **Export as GLTF**
function exportGLTF() {
    const exporter = new THREE.GLTFExporter();
    exporter.parse(scene, (result) => {
        const blob = new Blob([JSON.stringify(result)], { type: 'application/json' });
        saveAs(blob, "scene.gltf");
    });
}

// ‚úÖ **Export as OBJ**
function exportOBJ() {
    const exporter = new THREE.OBJExporter();
    const result = exporter.parse(scene);
    const blob = new Blob([result], { type: 'text/plain' });
    saveAs(blob, "scene.obj");
}

// ‚úÖ **Export as FBX**
function exportFBX() {
    const exporter = new THREE.FBXExporter();
    const result = exporter.parse(scene);
    const blob = new Blob([result], { type: 'application/octet-stream' });
    saveAs(blob, "scene.fbx");
}

// ‚úÖ **Export Scene as Compressed ZIP**
function exportAsZip() {
    const zip = new JSZip();
    zip.file("scene.json", JSON.stringify(serializeScene(), null, 2));

    zip.generateAsync({ type: "blob" }).then((content) => {
        saveAs(content, "scene.zip");
    });
}

// ‚úÖ **Import Scene**
function importScene() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json,.gltf,.glb,.obj,.fbx,.zip';
    input.onchange = (e) => {
        const file = e.target.files[0];
        const reader = new FileReader();
        reader.onload = (event) => {
            if (file.name.endsWith('.json')) {
                restoreScene(JSON.parse(event.target.result));
            } else if (file.name.endsWith('.gltf') || file.name.endsWith('.glb')) {
                loadGLTF(event.target.result);
            } else if (file.name.endsWith('.obj')) {
                loadOBJ(event.target.result);
            } else if (file.name.endsWith('.fbx')) {
                loadFBX(event.target.result);
            } else if (file.name.endsWith('.zip')) {
                loadZIP(event.target.result);
            }
        };
        reader.readAsText(file);
    };
    input.click();
}

// ‚úÖ **Warn Before Leaving (If Unsaved Changes)**
window.addEventListener("beforeunload", (event) => {
    if (localStorage.getItem("savedScene")) {
        event.preventDefault();
        event.returnValue = "You have unsaved changes. Do you want to leave?";
    }
});

// ‚úÖ **Auto-save every 2 minutes**
setInterval(autoSaveScene, 2 * 60 * 1000);

// ‚úÖ **Load scene from local storage on startup**
window.addEventListener("load", loadSavedScene);



/*
// Utility functions
function onWindowResize() {
    const aspect = window.innerWidth / window.innerHeight;
    
    // Update perspective camera
    perspectiveCamera.aspect = aspect;
    perspectiveCamera.updateProjectionMatrix();
    
    // Update orthographic camera
    const frustumSize = 10;
    orthographicCamera.left = -frustumSize * aspect / 2;
    orthographicCamera.right = frustumSize * aspect / 2;
    orthographicCamera.top = frustumSize / 2;
    orthographicCamera.bottom = -frustumSize / -2;
    orthographicCamera.updateProjectionMatrix();
    
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
}
*/

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
    if (orientationWidget) {
        orientationWidget.position.set(-window.innerWidth/2 + 70, window.innerHeight/2 - 70, 0);
    }
}
// Store references to elements once
const objectsElem = document.getElementById('objects');
const fpsElem = document.getElementById('fps');
const trianglesElem = document.getElementById('triangles');
const naniteStatsElem = document.getElementById('nanite-stats');

let lastTime = performance.now();
let frameCount = 0;
let fps = 0;

function updateStats(naniteStatsData = null) { // Parameter for nanite stats
    // FPS Calculation
    const now = performance.now();
    frameCount++;
    if (now - lastTime >= 1000) {
        fps = frameCount;
        frameCount = 0;
        lastTime = now;
    }
    if (fpsElem) fpsElem.textContent = `FPS: ${fps}`;

    // Calculate total visible objects and triangles from active LODs
    let triangles = 0;
    let visibleObjectCount = 0;

    if (naniteSystem && naniteSystem.enabled) {
        naniteSystem.meshes.forEach(naniteData => {
            naniteData.lods.forEach(lod => {
                if (lod.mesh.visible && lod.mesh.parent === scene) { // Check if actually visible and in scene
                    visibleObjectCount++;
                    if (lod.mesh.geometry && lod.mesh.geometry.attributes.position) {
                        triangles += lod.mesh.geometry.index ? lod.mesh.geometry.index.count / 3 : lod.mesh.geometry.attributes.position.count / 3;
                    }
                }
            });
        });
         // Add non-nanite objects if any are still directly in scene and visible
        scene.traverse(object => {
            if (object.isMesh && object.visible && !object.userData.isNaniteOriginal && !object.userData.isNaniteLOD) {
                if (!naniteSystem.meshes.has(object.uuid)) { // Only count if not managed by nanite
                    visibleObjectCount++;
                     if (object.geometry && object.geometry.attributes.position) {
                        triangles += object.geometry.index ? object.geometry.index.count / 3 : object.geometry.attributes.position.count / 3;
                    }
                }
            }
        });


    } else { // If Nanite is disabled, count all visible meshes normally
        scene.traverse(object => {
            if (object.isMesh && object.visible) {
                visibleObjectCount++;
                if (object.geometry && object.geometry.attributes.position) {
                     triangles += object.geometry.index ? object.geometry.index.count / 3 : object.geometry.attributes.position.count / 3;
                }
            }
        });
    }


    if (objectsElem) objectsElem.textContent = `Visible Objects: ${visibleObjectCount}`;
    if (trianglesElem) trianglesElem.textContent = `Triangles: ${Math.round(triangles)}`;

    // Display Nanite-specific stats
    if (naniteStatsElem && naniteStatsData) {
        naniteStatsElem.innerHTML = `
            Nanite Active LODs: ${naniteStatsData.activeLODs}<br>
            Nanite Meshes: ${naniteStatsData.processedMeshes}
        `;
            // Nanite Visible Meshes: ${naniteStatsData.visibleMeshesThisFrame} // This can be same as activeLODs if frustum culling is on
    } else if (naniteStatsElem) {
        naniteStatsElem.innerHTML = "Nanite: Off";
    }
}


/*function updateStats() {
    // Update object count
    objectsElem.textContent = `Objects: ${objects.length}`;

    // FPS Calculation
    const now = performance.now();
    frameCount++;
    if (now - lastTime >= 1000) {
        fps = frameCount;
        frameCount = 0;
        lastTime = now;
    }
    fpsElem.textContent = `FPS: ${fps}`;

    // Calculate total triangles
    let triangles = 0;
    scene.traverse(object => {
        if (object.geometry?.attributes?.position) {
            triangles += object.geometry.attributes.position.count / 3;
        }
    });
    trianglesElem.textContent = `Triangles: ${triangles}`;
}*/
    
function updateStatus() {
    let statusText = "Ready";
    if (drawMode) {
        statusText = `Drawing: ${points.length} points`;
    } else if (extrudeMode) {
        statusText = "Select a face to extrude";
        if (selectedFace) {
            statusText = "Click to extrude selected face";
        }
    }
    document.getElementById('status').textContent = statusText;
}



let zoomLevel = 1;
let timelineOffset = 0;

let dragStart = 0;
let selectedSegment = null;

const timeline = document.querySelector('.timeline-track');
const playhead = document.querySelector('.playhead');
const timelineScale = document.querySelector('.timeline-scale');
const timelineContent = document.querySelector('.timeline-content');

/**
 * Starts or resumes the timeline animation.
 * It simply sets the isPlaying flag to true, letting the animate loop handle time progression.
 */
function playAnimation() {
    if (isPlaying) return; // Do nothing if already playing

    isPlaying = true;
    console.log("Animation playing. Resuming from:", currentTime.toFixed(2));

    // If you have a corresponding function in your pathAnimator, call it.
    // This assumes pathAnimator is globally available.
    if (window.pathAnimator) {
        pathAnimator.resumeAllAnimations();
    }
}

/**
 * Pauses the timeline animation.
 * It sets the isPlaying flag to false, which stops time from advancing in the animate loop.
 */
function pauseAnimation() {
    if (!isPlaying) return; // Do nothing if already paused

    isPlaying = false;
    console.log("Animation paused at:", currentTime.toFixed(2));

    // It's good practice to have a matching pause function for other systems.
    if (window.pathAnimator) {
        pathAnimator.pauseAllAnimations(); // You might need to create this function.
    }
}

function stopAnimation() {
    isPlaying = false;
    currentTime = 0; // Reset the master time to zero.

    console.log("Animation stopped and reset.");

    if (window.pathAnimator) {
        pathAnimator.stopAllAnimations();
    }

    // Update the UI and scene to reflect the reset state (frame 0).
    updatePlayhead();
    updateTimeDisplay();
    updateSceneFromTimeline();
}

function zoomIn() {
    zoomLevel = Math.min(zoomLevel * 1.2, 10); // Smoother zoom, max 10x
    updateTimelineZoom();
}

function zoomOut() {
    zoomLevel = Math.max(zoomLevel / 1.2, 0.1); // Min 0.1x
    updateTimelineZoom();
}


function updateTimeDisplay() {
    const totalSeconds = Math.floor(currentTime);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    const milliseconds = Math.round((currentTime - totalSeconds) * 1000);
    document.getElementById('time-display').textContent = 
        `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}:${milliseconds.toString().padStart(3, '0')}`;
}


/*function playAnimation() {
    if (!isPlaying) {
        isPlaying = true;
        clock.start(); // Reset clock to 0
        currentTime = 0; // Sync timeline
        requestAnimationFrame(updatePlayhead);
    }
}


function pauseAnimation() {
    isPlaying = false;
    clock.stop();
}

function stopAnimation() {
    isPlaying = false;
    clock.stop();
    currentTime = 0;
    updatePlayhead();
    updateTimeDisplay();
    updateSceneFromTimeline();
}*/

/* 2 function playAnimation() {
    if (!isPlaying) {
        isPlaying = true;
        clock.start();
        // ŸÑÿß ÿ™ÿπŸäÿØ ÿ∂ÿ®ÿ∑ currentTime ŸáŸÜÿß ÿ•ŸÜ ŸÉŸÜÿ™ ÿ™ÿ±ŸäÿØ resume
        requestAnimationFrame(animate);
        pathAnimator.resumeAllAnimations(); // üëà new function you‚Äôll define next

    }
}*/



/*function pauseAnimation() {
    isPlaying = false;
    clock.stop();
}*/




/*function stopAnimation() {
    isPlaying = false;
    clock.stop();
    currentTime = 0;
    pathAnimator.stopAllAnimations();

    updatePlayhead();
    updateTimeDisplay();
    updateSceneFromTimeline(); // Reset positions etc.
}*/  



/*
function updateTimelineZoom() {
    const timelineContent = document.getElementById('timeline-content');
    const timelineScale = document.querySelector('.timeline-scale');
    
    // Apply transform to timeline content (keyframes and playhead)
    timelineContent.style.transform = `translateX(${timelineOffset}px) scaleX(${zoomLevel})`;
    
    // Update timeline scale to match zoom
    timelineScale.style.transform = `scaleX(${zoomLevel})`;
    timelineScale.style.transformOrigin = 'left'; // Ensure scale starts from left
    
    // Adjust playhead width to prevent distortion
    const playhead = document.getElementById('playhead');
    playhead.style.transform = `scaleX(${1 / zoomLevel})`; // Counter-scale to maintain width
    playhead.style.transformOrigin = 'left';
    
    // Update keyframes UI if needed
    updateKeyframesUI();
}
    
//2
function updateTimelineZoom() {
    const timelineContent = document.getElementById('timeline-content');
    const timelineScale = document.querySelector('.timeline-scale');

    // Apply scale to the container but exclude keyframes
    timelineScale.style.transform = `scaleX(${zoomLevel})`;
    timelineScale.style.transformOrigin = 'left';

    timelineContent.style.transform = `translateX(${timelineOffset}px)`;

    // Adjust only the width of playhead to prevent stretch
    const playhead = document.getElementById('playhead');
    playhead.style.transform = `scaleX(${1 / zoomLevel})`;
    playhead.style.transformOrigin = 'left';

    updateKeyframesUI(); // Re-render if needed
}
*/

function updateTimelineZoom() {
    const timelineContent = document.getElementById('timeline-content');
    const timelineScale = document.querySelector('.timeline-scale');

    // Don't scale .timeline-content ‚Äî instead, zoom keyframes using a container
    timelineContent.style.transform = `translateX(${timelineOffset}px)`; // no scale
    timelineScale.style.transform = `scaleX(${zoomLevel})`;
    timelineScale.style.transformOrigin = 'left';

    // DO NOT scale playhead ‚Äî it already spans full height
    // playhead.style.transform = `scaleX(${1 / zoomLevel})`; // ‚ùå remove this
}

function initializeTimelineScale() {
    const timelineScale = document.querySelector('.timeline-scale');
    timelineScale.innerHTML = ''; // Clear existing markers
    const totalSeconds = timelineDuration; // Use global duration
    const majorMarkerInterval = 3; // Major tick every 30 seconds
    const minorMarkerInterval = 5; // Minor tick every 5 seconds

    for (let i = 0; i <= totalSeconds; i += minorMarkerInterval) {
        const marker = document.createElement('div');
        const isMajor = i % majorMarkerInterval === 0;
        marker.className = `timeline-scale-marker ${isMajor ? 'major' : ''}`;
        marker.style.left = `${(i / totalSeconds) * 100}%`;

        if (isMajor) {
            const label = document.createElement('div');
            label.className = 'timeline-scale-label';
            label.textContent = `${Math.floor(i / 60)}:${String(i % 60).padStart(2, '0')}`;
            marker.appendChild(label);
        }

        timelineScale.appendChild(marker);
    }
}

// this whenever timeline duration or zoom changes
function updateTimelineScale() {
    initializeTimelineScale(); // Rebuild scale
    updateTimelineZoom(); // Reapply zoom
}

/*function updatePlayhead() {
    const playhead = document.getElementById('playhead');
    if (isPlaying) {
        currentTime = clock.getElapsedTime();
        if (currentTime >= timelineDuration) {
            stopAnimation();
            return;
        }
        requestAnimationFrame(updatePlayhead);
    }
    const position = (currentTime / timelineDuration) * 100;
    playhead.style.left = `${position}%`;
    updateTimeDisplay();
    updateSceneFromTimeline();
}
    
//2
// function updatePlayhead() {
    const playhead = document.getElementById('playhead');
    const percent = (currentTime / timelineDuration) * 100;
    playhead.style.left = `${percent}%`;
    updateTimeDisplay();
}
   
*/
//3
function updatePlayhead() {
    const playhead = document.getElementById('playhead');
    const timelineContent = document.getElementById('timeline-content');

    // Width of timeline-content changes with zoom
    const baseWidth = timelineContent.offsetWidth;
    const scaledWidth = baseWidth * zoomLevel;

    // Compute playhead's position based on total timeline duration
    const timeRatio = currentTime / timelineDuration;
    const left = timeRatio * scaledWidth;

    playhead.style.left = `${left}px`;
    timelineContent.scrollLeft = left - timelineContent.clientWidth / 2;

    updateTimeDisplay();
}


const mixers = [];

function registerMixer(mixer) {
    mixers.push(mixer);
}




// Timeline dragging
timeline.addEventListener('mousedown', (e) => {
    if (e.target.closest('.keyframe') || e.target.closest('.playhead')) return; // Ignore clicks on keyframes/playhead
    isDragging = true;
    dragStart = e.clientX - timelineOffset;
    timeline.style.cursor = 'grabbing';
});

document.addEventListener('mousemove', (e) => {
    if (isDragging) {
        timelineOffset = e.clientX - dragStart;
        // Limit offset to prevent panning too far
        const maxOffset = 0; // Leftmost position
        const minOffset = -(timelineContent.offsetWidth * zoomLevel - timelineContent.offsetWidth); // Rightmost
        timelineOffset = Math.min(maxOffset, Math.max(minOffset, timelineOffset));
        updateTimelineZoom();
    }
});

document.addEventListener('mouseup', () => {
    isDragging = false;
    timeline.style.cursor = 'grab';
});

// Segment selection
timelineContent.addEventListener('click', (e) => {
    if (e.target.classList.contains('recording-segment')) {
        if (selectedSegment) {
            selectedSegment.classList.remove('selected');
        }
        selectedSegment = e.target;
        selectedSegment.classList.add('selected');
    }
});




function recordSceneData() {
    if (isPlaying && selectedSegment) {
        const time = clock.getElapsedTime();
        const position = (time / timelineDuration) * 100;
        selectedSegment.style.width = `${position}%`;
    }
}

//this animate function integrate the node editor
/*function animate () {
    requestAnimationFrame(animate);
    if (controls && controls.enabled) {
        controls.update();
    }
    transformControls.setTranslationSnap(null);
    animateParticles();
    recordSceneData();
    
    if (isSnowing) {
        updateSnow();
    }
    
    // Update animations
    if (world) world.step(1 / 60); // Physics simulation step
    const delta = clock.getDelta();
    
    scene.traverse((object) => {
        if (object.userData && object.userData.mixer) {
          object.userData.mixer.update(delta);
        }
    });
    
    if (physicsEnabled) updateHairPhysics();
    
    scene.traverse((obj) => {
        if (obj.userData.animate) {
            obj.rotation.y += 0.01;
            obj.position.y += Math.sin(Date.now() * 0.001) * 0.01;
        }
    });
    
    scene.traverse(object => {
        if (object.userData.physicsBody) {
            object.position.copy(object.userData.physicsBody.position);
            object.quaternion.copy(object.userData.physicsBody.quaternion);
        }
    });
    
    if (world && physicsManager) {
        world.step(1/60);
        physicsManager.updatePhysics();
    }
    
    // Update scene objects
    scene.traverse(obj => {
        if (obj.userData.needsUpdate) {
            if (obj.userData.mixer) obj.userData.mixer.update(delta);
            if (obj.userData.physicsBody) {
                obj.position.copy(obj.userData.physicsBody.position);
                obj.quaternion.copy(obj.userData.physicsBody.quaternion);
            }
        }
    });
    
    // Update node editor and apply VFX
    if (window.nodeEditor) {
        window.nodeEditor.update(delta);
        
        // Execute active VFX in the node graph
        if (window.nodeEditor.activeEffects) {
            window.nodeEditor.activeEffects.forEach(effect => {
                if (effect.enabled && effect.execute) {
                    effect.execute(scene, camera, renderer, delta);
                }
            });
        }
    }
    
    if (window.materialSettings && window.materialSettings.enableTextureAnimation) {
        window.materialSettings.updateMaterialAnimation();
    }
    
    scene.traverse((object) => {
        if (object.animate && typeof object.animate === 'function') {
            object.animate();
        }
    });
    
    scene.traverse((obj) => {
        if (obj.userData.mixer) obj.userData.mixer.update(delta);
    });
    
    if (isPlaying) {
        currentTime = clock.getElapsedTime();
        updatePlayhead();
    }

    scene.traverse(object => {
        if (object.userData.mixer) {
            object.userData.mixer.update(delta);
        }
    });
    
    updateStats();
    updateHelpers();
    // First render the scene normally
    renderer.clear();
    renderer.render(scene, camera);
    // Then apply post-processing if node editor has active post effects
    if (window.nodeEditor && window.nodeEditor.hasPostProcessing) {
        window.nodeEditor.renderPostEffects(renderer, scene, camera);
    }
    
    if (activeCamera && previewRenderer) {
        previewRenderer.render(scene, activeCamera);
    }
    updateRenderOrder();
    composer.render();
}*/




function animate () {
    requestAnimationFrame(animate);

    const delta = clock.getDelta();

    // === CONTROLS ===
    if (controls && controls.enabled) controls.update();
    transformControls.setTranslationSnap(null);


    // === PARTICLES & SNOW ===
    animateParticles();
    if (isSnowing) updateSnow();

    // === NANITE SYSTEM ===
    let currentNaniteStats = naniteSystem ? naniteSystem.update() : null;

    // === PHYSICS ===
    if (world) world.step(1 / 60);
    if (physicsEnabled) updateHairPhysics();
    if (physicsSimulator?.isReady) {
        physicsSimulator.update(Math.min(delta, 0.033));
    }

    if (world && physicsManager) {
        world.step(1 / 60);
        physicsManager.updatePhysics();
    }

    // === PATH ANIMATOR ===
    const deltaPath = pathAnimator.clock.getDelta();
    pathAnimator.update(deltaPath);

    // === PLAYER MOVEMENT ===
    if (isPlayerControlActive && player) {
        player.update(delta);
    } else if (controls?.enabled) {
        controls.update();
    }

    // === MIXERS + ANIMATION ===
    scene.traverse((object) => {
        const mixer = object.userData?.mixer;
        if (mixer && object !== player.model) {
            mixer.update(delta);
        }

        // For animated objects with custom functions
        if (object.animate && typeof object.animate === 'function') {
            object.animate();
        }

        // Physics sync
        if (object.userData?.physicsBody) {
            object.position.copy(object.userData.physicsBody.position);
            object.quaternion.copy(object.userData.physicsBody.quaternion);
        }

        // Needs update
        if (object.userData?.needsUpdate) {
            if (object.userData.mixer) object.userData.mixer.update(delta);
        }
    });

    if (animatorSystem) animatorSystem.update(delta);
    if (explosionManager) explosionManager.update(delta);
    mixers.forEach(mixer => mixer.update(delta));


    // === MATERIAL / TEXTURE ANIMATION ===
    if (window.materialSettings?.enableTextureAnimation) {
        window.materialSettings.updateMaterialAnimation();
    }

    // === NODE EDITOR ===
    if (window.nodeEditor) {
        window.nodeEditor.update(delta);
        // Apply post-processing effects
        if (window.nodeEditor.hasPostProcessing) {
            window.nodeEditor.renderPostEffects(renderer, scene, camera);
        }
    }

    /*if (isPlaying) {
        currentTime += delta; // Instead of clock.getElapsedTime(), this gives finer control
        if (currentTime >= timelineDuration) {
            stopAnimation();
        } else {
            updatePlayhead(); // This will move the playhead on the UI
            updateSceneFromTimeline(); // Optional: interpolates keyframes
        }
    }*/
    // === TIMELINE ===
      if (isPlaying) {
        // Advance our master time counter.
        currentTime += delta;

        // Check if the animation has finished.
        if (currentTime >= timelineDuration) {
            // Option 1: Stop the animation completely.
            stopAnimation();
            
            // Option 2 (Alternative): Just pause at the end.
            // currentTime = timelineDuration;
            isPlaying = false;
            updatePlayhead();
        } else {
            // While playing, update the UI and the 3D scene.
            updatePlayhead();          // Move the red bar on the timeline UI.
            updateSceneFromTimeline(); // Move the objects in the 3D view.
        }
    }
   

    recordSceneData(); // Optional: track recording during playback

    // === STATS & RENDER ===
    updateStats(currentNaniteStats);
    updateHelpers();
    updateHairMesh(); 

    renderer.clear();
    renderer.render(scene, camera);

    // === PREVIEW ===
    if (activeCamera && previewRenderer) {
        previewRenderer.render(scene, activeCamera);
    }
}

/*
function animate () {
    requestAnimationFrame(animate);
    if (controls && controls.enabled) {
        controls.update();
    }

    transformControls.setTranslationSnap(null);
    animateParticles();
    recordSceneData();
    
    let currentNaniteStats = null;
    if (naniteSystem) { // naniteSystem might not be initialized immediately if init is async
        currentNaniteStats = naniteSystem.update(); // Call update, it handles its 'enabled' state internally
    }

    if (isSnowing) {
        updateSnow();
    }
    
    // Update animations
    if (world) world.step(1 / 60); // Physics simulation step
    const delta = clock.getDelta();
    const deltaPath = pathAnimator.clock.getDelta();
    pathAnimator.update(deltaPath);
    
     const time = clock.getElapsedTime(); // Get total time

    // UPDATE ALL ACTIVE SCRIPTS!
    scriptManager.update(delta, time);
    scene.traverse((object) => {
        if (object.userData && object.userData.mixer) {
          object.userData.mixer.update(delta);
        }
    });
    
    if (physicsEnabled) updateHairPhysics();

    if (physicsSimulator && physicsSimulator.isReady) {
        // We cap the delta to prevent physics explosions on lag spikes
        const cappedDelta = Math.min(delta, 0.033); 
        physicsSimulator.update(cappedDelta);
    }

   
    if (animatorSystem) {
        animatorSystem.update(delta);
    }

    if (!player.isActive && controls && controls.enabled) {
        controls.update(); 
    }

    if (isPlayerControlActive && player) {
        player.update(delta); // This one function does it all: movement, physics, camera
    } else {
        if (controls && controls.enabled) {
            controls.update(); // Editor mode
        }
    }

  
    
    scene.traverse((obj) => {
        if (obj.userData.animate) {
            obj.rotation.y += 0.01;
            obj.position.y += Math.sin(Date.now() * 0.001) * 0.01;
        }
    });
    
    scene.traverse(object => {
        if (object.userData.physicsBody) {
            object.position.copy(object.userData.physicsBody.position);
            object.quaternion.copy(object.userData.physicsBody.quaternion);
        }
    });
    
    if (world && physicsManager) {
        world.step(1/60);
        physicsManager.updatePhysics();
    }

    if (world) world.step(1 / 60);

    // If you have other animated objects, their mixers still need to be updated
    scene.traverse((object) => {
        if (object.userData && object.userData.mixer && object !== player.model) {
          object.userData.mixer.update(delta);
        }
    });
   
   
    // Update scene objects
    scene.traverse(obj => {
        if (obj.userData.needsUpdate) {
            if (obj.userData.mixer) obj.userData.mixer.update(delta);
            if (obj.userData.physicsBody) {
                obj.position.copy(obj.userData.physicsBody.position);
                obj.quaternion.copy(obj.userData.physicsBody.quaternion);
            }
        }
    });
    
    if (explosionManager) {
        explosionManager.update(delta);
    }

    // Update node editor and apply VFX
    if (window.nodeEditor) {
        window.nodeEditor.update(delta);
        
        // Execute active VFX in the node graph
        if (window.nodeEditor.activeEffects) {
            window.nodeEditor.activeEffects.forEach(effect => {
                if (effect.enabled && effect.execute) {
                    effect.execute(scene, camera, renderer, delta);
                }
            });
        }
    }
    
    if (window.materialSettings && window.materialSettings.enableTextureAnimation) {
        window.materialSettings.updateMaterialAnimation();
    }
    
    scene.traverse((object) => {
        if (object.animate && typeof object.animate === 'function') {
            object.animate();
        }
    });
    
    scene.traverse((obj) => {
        if (obj.userData.mixer) obj.userData.mixer.update(delta);
    });
    
    if (isPlaying) {
        currentTime = clock.getElapsedTime();
        updatePlayhead();
    }

    scene.traverse(object => {
        if (object.userData.mixer) {
            object.userData.mixer.update(delta);
        }
    });
   

    updateStats(currentNaniteStats);
    updateHelpers();
    // First render the scene normally
    renderer.clear();
    renderer.render(scene, camera);
    // Then apply post-processing if node editor has active post effects
    if (window.nodeEditor && window.nodeEditor.hasPostProcessing) {
        window.nodeEditor.renderPostEffects(renderer, scene, camera);
    }
    
    if (activeCamera && previewRenderer) {
        previewRenderer.render(scene, activeCamera);
    }
}*/
 // Initialize the editor when the page loads
 init();
    </script>
    <script>
        function initializeUI() {
            // Ensure timeline and inspector are visible
            const timeline = document.querySelector('.timeline');
            const inspector = document.querySelector('.inspector-panel');
            if (timeline) timeline.style.display = 'flex';
            if (inspector) inspector.style.display = 'flex';
        }

        
       /*
        function setupMaterialEditor() {
            const materialColor = document.getElementById('materialColor');
            const materialMetalness = document.getElementById('materialMetalness');
            const materialRoughness = document.getElementById('materialRoughness');
            const materialOpacity = document.getElementById('materialOpacity');
            const materialTexture = document.getElementById('materialTexture');
            materialColor.addEventListener('input', updateMaterial);
            materialMetalness.addEventListener('input', updateMaterial);
            materialRoughness.addEventListener('input', updateMaterial);
            materialOpacity.addEventListener('input', updateMaterial);
            materialTexture.addEventListener('change', updateTexture);
        
            const gui = new dat.GUI({ autoPlace: false });
            const settings = {
                texture: 'glass'
            };
        
            gui.add(settings, 'texture', ['glass', 'metal', 'water', 'crystal', 'plastic', 'ceramic', 'wood', 'marble', 'gold', 'chrome', 'holographic', 'matte']).onChange((value) => {
                updateTextureMaterials(value);
            });
        
            // Style the GUI container
            gui.domElement.style.position = 'relative';
            gui.domElement.style.marginTop = '10px';
        
            // Get the materialTextures div and append the GUI
            const materialTextures = document.getElementById('materialTextures');
            materialTextures.appendChild(gui.domElement);
        }
        
       

        // Enhanced textures object with more materials
        const textures = {
            glass: new THREE.MeshPhysicalMaterial({
                color: 0xA0D8EF,
                roughness: 0.1,
                metalness: 0.1,
                clearcoat: 1.0,
                clearcoatRoughness: 0.1,
                transmission: 0.95,
                thickness: 0.5,
                reflectivity: 1.0,
                transparent: true,
                opacity: true,
                attenuationColor: 0xA0D8EF, 
                attenuationDistance: 0.75 ,
                envMap: loadEnvironmentMap(),
                refractionRatio: 1.5
            }),
        
            metal: new THREE.MeshPhysicalMaterial({
                color: 0xAAAAAA,
                roughness: 0.05,
                metalness: 1.0,
                clearcoat: 0.7,
                clearcoatRoughness: 0.02,
                anisotropy: 0.8,
                envMap: loadEnvironmentMap()
            }),
        
            water: new THREE.MeshPhysicalMaterial({
                color: 0x1e90ff,
                roughness: 0.01,
                metalness: 0.0,
                transmission: 1,
                thickness: 0.1,
                transparent: true,
                opacity: 0.9,
                envMap: loadEnvironmentMap(),
                reflectivity: 0.9,
                refractionRatio: 1.33,

            }),
        
           crystal: new THREE.MeshPhysicalMaterial({
                color: 0x7F7FFF,
                roughness: 0.01,
                metalness: 0.0,
                transmission: 1.0,
                thickness: 1.0,
                transparent: true,
                opacity: 0.95,
                envMap: loadEnvironmentMap(),
                clearcoat: 1.0,
                clearcoatRoughness: 0.01,
                attenuationColor: 0x7F7FFF,
                attenuationDistance: 1.0,
                iridescence: 0.8,
                iridescenceIOR: 2.0,
                iridescenceThicknessRange: [200, 500]
            }),
        
            
            plastic: new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                roughness: 0.3,
                metalness: 0.0,
                clearcoat: 0.8,
                clearcoatRoughness: 0.2
            }),
        
            ceramic: new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                roughness: 0.1,
                metalness: 0.0,
                clearcoat: 1.0,
                clearcoatRoughness: 0.1,
                sheen: 1.0,
                sheenRoughness: 0.3,
                sheenColor: 0xffffff
            }),
        
            wood: new THREE.MeshStandardMaterial({
                color: 0x885533,
                roughness: 0.8,
                metalness: 0.0,
                map: loadWoodTexture()
            }),
        
            marble: new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                roughness: 0.15,
                metalness: 0.0,
                transmission: 0.5,
                thickness: 0.5,
                clearcoat: 0.8,
                clearcoatRoughness: 0.2
            }),
        
            gold: new THREE.MeshPhysicalMaterial({
                color: 0xffd700,
                roughness: 0.1,
                metalness: 1.0,
                envMap: loadEnvironmentMap(),
                clearcoat: 0.5,
                clearcoatRoughness: 0.1
            }),
        
            chrome: new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                roughness: 0.0,
                metalness: 1.0,
                envMap: loadEnvironmentMap(),
                clearcoat: 1.0,
                clearcoatRoughness: 0.0
            }),
        
            holographic: new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                roughness: 0.2,
                metalness: 0.5,
                transmission: 0.5,
                thickness: 0.5,
                attenuationColor: 0xff00ff,
                attenuationDistance: 0.5,
                iridescence: 1.0,
                iridescenceIOR: 2.0,
                iridescenceThicknessRange: [100, 400]
            }),
        
            matte: new THREE.MeshStandardMaterial({
                color: 0x808080,
                roughness: 1.0,
                metalness: 0.0
            })
            
        };
    
        function loadEnvironmentMap() {
            return new THREE.CubeTextureLoader().load([
                'textures/skybox/px.jpg',
                'textures/skybox/nx.jpg',
                'textures/skybox/py.jpg',
                'textures/skybox/ny.jpg',
                'textures/skybox/pz.jpg',
                'textures/skybox/nz.jpg'
            ]);
        }
        
    
        function loadWoodTexture() {
            return new THREE.TextureLoader().load('textures/wood/woodgrain.jpg');
        }


        function updateMaterial() {
            if (!selectedObject || !selectedObject.material) return;
        
            selectedObject.material.color.setHex(parseInt(materialColor.value.substr(1), 16));
            selectedObject.material.metalness = parseFloat(materialMetalness.value);
            selectedObject.material.roughness = parseFloat(materialRoughness.value);
            selectedObject.material.opacity = parseFloat(materialOpacity.value);
            selectedObject.material.emissive.setHex(parseInt(materialEmissive.value.substr(1), 16));
            selectedObject.material.emissiveIntensity = parseFloat(materialEmissiveIntensity.value);
            selectedObject.material.clearcoat = parseFloat(materialClearcoat.value);
            selectedObject.material.iridescence = parseFloat(materialIridescence.value);
            selectedObject.material.transparent = selectedObject.material.opacity < 1;
            selectedObject.material.needsUpdate = true;
        }
    
     
        function updateTexture(event) {
            if (!selectedObject || !selectedObject.material) return;
        
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const texture = new THREE.TextureLoader().load(e.target.result);
                    texture.encoding = THREE.sRGBEncoding;
                    selectedObject.material.map = texture;
                    selectedObject.material.needsUpdate = true;
                };
                reader.readAsDataURL(file);
            }
        }
    
        function updateTextureMaterials(textureName) {
            if (!selectedObject || !selectedObject.material) return;
            
            const newMaterial = textures[textureName].clone();
            selectedObject.material = newMaterial;
            selectedObject.material.needsUpdate = true;
        }
        */

// This script assumes THREE.js and dat.GUI are already included in your HTML.
// It also assumes you have a `selectedObject` variable and a render loop.
// IMPORTANT: You must run this from a local web server (like VS Code's "Live Server") for textures to load.

// --- Global Loaders & Maps (Good practice to create these once and reuse them) ---
const textureLoaderEdit = new THREE.TextureLoader();
const cubeTextureLoader = new THREE.CubeTextureLoader();
const environmentMap = loadEnvironmentMap(); // Pre-load the environment map for all materials

// --- Helper Functions for Loading Textures ---

// Uses a reliable, high-quality EXR Cube Map for realistic lighting and reflections.
function loadEnvironmentMap() {
    // Using a more reliable URL from the official three.js examples.
    return cubeTextureLoader
        .setPath('https://threejs.org/examples/textures/cube/pisaEXR/')
        .load(['px.exr', 'nx.exr', 'py.exr', 'ny.exr', 'pz.exr', 'nz.exr']);
}

// *** FIXED *** Loads wood textures from a reliable CDN. This will now work.
function loadWoodTextures() {
    const woodColorMap = textureLoaderEdit.load('https://cdn.jsdelivr.net/gh/Sean-Bradley/Three.js-Furniture-Customization-App@main/assets/textures/wood/wood_floor_deck_diff_1k.jpg');
    const woodNormalMap = textureLoaderEdit.load('https://cdn.jsdelivr.net/gh/Sean-Bradley/Three.js-Furniture-Customization-App@main/assets/textures/wood/wood_floor_deck_nor_gl_1k.jpg');
    const woodRoughnessMap = textureLoaderEdit.load('https://cdn.jsdelivr.net/gh/Sean-Bradley/Three.js-Furniture-Customization-App@main/assets/textures/wood/wood_floor_deck_rough_1k.jpg');

    [woodColorMap, woodNormalMap, woodRoughnessMap].forEach(texture => {
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
    });

    return {
        map: woodColorMap,
        normalMap: woodNormalMap,
        roughnessMap: woodRoughnessMap,
    };
}

// *** FIXED *** Loads marble textures from a reliable CDN.
function loadMarbleTextures() {
    const marbleColorMap = textureLoaderEdit.load('https://cdn.jsdelivr.net/gh/Sean-Bradley/Three.js-Furniture-Customization-App@main/assets/textures/marble/marble_white_diff_1k.jpg');
    const marbleNormalMap = textureLoaderEdit.load('https://cdn.jsdelivr.net/gh/Sean-Bradley/Three.js-Furniture-Customization-App@main/assets/textures/marble/marble_white_nor_gl_1k.jpg');
    const marbleRoughnessMap = textureLoaderEdit.load('https://cdn.jsdelivr.net/gh/Sean-Bradley/Three.js-Furniture-Customization-App@main/assets/textures/marble/marble_white_rough_1k.jpg');

    return {
        map: marbleColorMap,
        normalMap: marbleNormalMap,
        roughnessMap: marbleRoughnessMap,
    };
}

// --- NEW --- Helper functions for new textures
function loadRustyMetalTextures() {
    const colorMap = textureLoaderEdit.load('https://cdn.jsdelivr.net/gh/Sean-Bradley/Three.js-Furniture-Customization-App@main/assets/textures/metal/metal_plate_diff_1k.jpg');
    const normalMap = textureLoaderEdit.load('https://cdn.jsdelivr.net/gh/Sean-Bradley/Three.js-Furniture-Customization-App@main/assets/textures/metal/metal_plate_nor_gl_1k.jpg');
    const roughnessMap = textureLoaderEdit.load('https://cdn.jsdelivr.net/gh/Sean-Bradley/Three.js-Furniture-Customization-App@main/assets/textures/metal/metal_plate_rough_1k.jpg');
    const metalnessMap = textureLoaderEdit.load('https://cdn.jsdelivr.net/gh/Sean-Bradley/Three.js-Furniture-Customization-App@main/assets/textures/metal/metal_plate_metal_1k.jpg');
    [colorMap, normalMap, roughnessMap, metalnessMap].forEach(t => { t.wrapS = t.wrapT = THREE.RepeatWrapping; });
    return { map: colorMap, normalMap: normalMap, roughnessMap: roughnessMap, metalnessMap: metalnessMap };
}

function loadCobblestoneTextures() {
    const colorMap = textureLoaderEdit.load('https://cdn.jsdelivr.net/gh/Sean-Bradley/Three.js-Furniture-Customization-App@main/assets/textures/cobblestone/cobblestone_large_01_diff_1k.jpg');
    const normalMap = textureLoaderEdit.load('https://cdn.jsdelivr.net/gh/Sean-Bradley/Three.js-Furniture-Customization-App@main/assets/textures/cobblestone/cobblestone_large_01_nor_gl_1k.jpg');
    const roughnessMap = textureLoaderEdit.load('https://cdn.jsdelivr.net/gh/Sean-Bradley/Three.js-Furniture-Customization-App@main/assets/textures/cobblestone/cobblestone_large_01_rough_1k.jpg');
    [colorMap, normalMap, roughnessMap].forEach(t => { t.wrapS = t.wrapT = THREE.RepeatWrapping; });
    return { map: colorMap, normalMap: normalMap, roughnessMap: roughnessMap };
}

function loadLavaTextures() {
    const colorMap = textureLoaderEdit.load('https://cdn.jsdelivr.net/gh/Sean-Bradley/Three.js-Furniture-Customization-App@main/assets/textures/lava/lava_diff_1k.jpg');
    const normalMap = textureLoaderEdit.load('https://cdn.jsdelivr.net/gh/Sean-Bradley/Three.js-Furniture-Customization-App@main/assets/textures/lava/lava_nor_gl_1k.jpg');
    const roughnessMap = textureLoaderEdit.load('https://cdn.jsdelivr.net/gh/Sean-Bradley/Three.js-Furniture-Customization-App@main/assets/textures/lava/lava_rough_1k.jpg');
    const emissiveMap = textureLoaderEdit.load('https://cdn.jsdelivr.net/gh/Sean-Bradley/Three.js-Furniture-Customization-App@main/assets/textures/lava/lava_emissive_1k.jpg');
    [colorMap, normalMap, roughnessMap, emissiveMap].forEach(t => { t.wrapS = t.wrapT = THREE.RepeatWrapping; });
    return { map: colorMap, normalMap: normalMap, roughnessMap: roughnessMap, emissiveMap: emissiveMap };
}

function loadBrickTextures() {
    const colorMap = textureLoaderEdit.load('https://cdn.jsdelivr.net/gh/Sean-Bradley/Three.js-Furniture-Customization-App@main/assets/textures/brick/brick_wall_diff_1k.jpg');
    const normalMap = textureLoaderEdit.load('https://cdn.jsdelivr.net/gh/Sean-Bradley/Three.js-Furniture-Customization-App@main/assets/textures/brick/brick_wall_nor_gl_1k.jpg');
    const roughnessMap = textureLoaderEdit.load('https://cdn.jsdelivr.net/gh/Sean-Bradley/Three.js-Furniture-Customization-App@main/assets/textures/brick/brick_wall_rough_1k.jpg');
    [colorMap, normalMap, roughnessMap].forEach(t => { t.wrapS = t.wrapT = THREE.RepeatWrapping; });
    return { map: colorMap, normalMap: normalMap, roughnessMap: roughnessMap };
}

function loadFabricTextures() {
    const colorMap = textureLoaderEdit.load('https://cdn.jsdelivr.net/gh/Sean-Bradley/Three.js-Furniture-Customization-App@main/assets/textures/fabric/fabric_pattern_07_col_1k.jpg');
    const normalMap = textureLoaderEdit.load('https://cdn.jsdelivr.net/gh/Sean-Bradley/Three.js-Furniture-Customization-App@main/assets/textures/fabric/fabric_pattern_07_nor_gl_1k.jpg');
    const roughnessMap = textureLoaderEdit.load('https://cdn.jsdelivr.net/gh/Sean-Bradley/Three.js-Furniture-Customization-App@main/assets/textures/fabric/fabric_pattern_07_rough_1k.jpg');
    [colorMap, normalMap, roughnessMap].forEach(t => { t.wrapS = t.wrapT = THREE.RepeatWrapping; });
    return { map: colorMap, normalMap: normalMap, roughnessMap: roughnessMap };
}


// --- Material Editor with GUI Display ---
function setupMaterialEditor() {
    const materialColor = document.getElementById('materialColor');
    const materialMetalness = document.getElementById('materialMetalness');
    const materialRoughness = document.getElementById('materialRoughness');
    const materialOpacity = document.getElementById('materialOpacity');
    const materialTexture = document.getElementById('materialTexture');

    if (materialColor) materialColor.addEventListener('input', updateMaterial);
    if (materialMetalness) materialMetalness.addEventListener('input', updateMaterial);
    if (materialRoughness) materialRoughness.addEventListener('input', updateMaterial);
    if (materialOpacity) materialOpacity.addEventListener('input', updateMaterial);
    if (materialTexture) materialTexture.addEventListener('change', updateTexture);

    const gui = new dat.GUI({ autoPlace: false });
    const settings = { texture: 'wood' }; // Default to wood to easily test the fix

    // --- NEW --- Added all new material names to the GUI dropdown list
    const materialList = [
        'glass', 'metal', 'water', 'crystal', 'plastic', 'ceramic', 'wood', 'marble', 'gold', 'chrome', 'holographic', 'matte', 
        'rustyMetal', 'cobblestone', 'lava', 'bricks', 'fabric'
    ];
    gui.add(settings, 'texture', materialList).onChange(updateTextureMaterials);

    gui.domElement.style.position = 'relative';
    gui.domElement.style.marginTop = '10px';
    const materialTextures = document.getElementById('materialTextures');
    if (materialTextures) {
        materialTextures.appendChild(gui.domElement);
    } else {
        console.error("Element with ID 'materialTextures' not found for GUI.");
    }
}

// --- Enhanced textures object with all materials ---
const textures = {
    // Original materials
    glass: new THREE.MeshPhysicalMaterial({ color: 0xA0D8EF, roughness: 0.1, metalness: 0.0, transmission: 1.0, thickness: 1.5, envMap: environmentMap, envMapIntensity: 1.5, transparent: true }),
    metal: new THREE.MeshPhysicalMaterial({ color: 0xAAAAAA, roughness: 0.1, metalness: 1.0, envMap: environmentMap }),
    water: new THREE.MeshPhysicalMaterial({ color: 0x1e90ff, roughness: 0.05, metalness: 0.0, transmission: 1, thickness: 0.5, transparent: true, opacity: 0.9, envMap: environmentMap }),
    crystal: new THREE.MeshPhysicalMaterial({ color: 0x7F7FFF, roughness: 0.01, metalness: 0.0, transmission: 1.0, thickness: 1.0, transparent: true, opacity: 0.95, envMap: environmentMap, iridescence: 0.8, iridescenceIOR: 2.0, iridescenceThicknessRange: [200, 500] }),
    plastic: new THREE.MeshPhysicalMaterial({ color: 0xffffff, roughness: 0.3, metalness: 0.0, clearcoat: 0.8, clearcoatRoughness: 0.2 }),
    ceramic: new THREE.MeshPhysicalMaterial({ color: 0xffffff, roughness: 0.1, metalness: 0.0, clearcoat: 1.0, clearcoatRoughness: 0.1, sheen: 1.0, sheenRoughness: 0.3, sheenColor: 0xffffff }),
    
    // Fixed materials with reliable textures
    wood: new THREE.MeshStandardMaterial({ ...loadWoodTextures(), metalness: 0.0, normalScale: new THREE.Vector2(0.5, 0.5), envMap: environmentMap }),
    marble: new THREE.MeshPhysicalMaterial({ ...loadMarbleTextures(), metalness: 0.0, clearcoat: 0.8, clearcoatRoughness: 0.1, envMap: environmentMap }),
    
    // Original materials continued
    gold: new THREE.MeshPhysicalMaterial({ color: 0xffd700, roughness: 0.1, metalness: 1.0, envMap: environmentMap, }),
    chrome: new THREE.MeshPhysicalMaterial({ color: 0xffffff, roughness: 0.01, metalness: 1.0, envMap: environmentMap, }),
    holographic: new THREE.MeshPhysicalMaterial({ roughness: 0.2, metalness: 0.5, transmission: 0.5, thickness: 0.5, iridescence: 1.0, iridescenceIOR: 2.0, iridescenceThicknessRange: [100, 400], envMap: environmentMap }),
    matte: new THREE.MeshStandardMaterial({ color: 0x404040, roughness: 1.0, metalness: 0.0 }),
    
    // --- NEW --- The new materials
    rustyMetal: new THREE.MeshStandardMaterial({ ...loadRustyMetalTextures(), envMap: environmentMap, normalScale: new THREE.Vector2(0.8, 0.8) }),
    cobblestone: new THREE.MeshStandardMaterial({ ...loadCobblestoneTextures(), normalScale: new THREE.Vector2(1.0, 1.0), envMap: environmentMap }),
    lava: new THREE.MeshStandardMaterial({ ...loadLavaTextures(), emissive: 0xffffff, emissiveIntensity: 3.0, metalness: 0.2, normalScale: new THREE.Vector2(1.5, 1.5) }),
    bricks: new THREE.MeshStandardMaterial({ ...loadBrickTextures(), envMap: environmentMap, normalScale: new THREE.Vector2(0.7, 0.7) }),
    fabric: new THREE.MeshPhysicalMaterial({ ...loadFabricTextures(), envMap: environmentMap, clearcoat: 0.1, clearcoatRoughness: 0.5, sheen: 0.5, sheenColor: 0xffffff, sheenRoughness: 0.5 })
};


// --- Material Update Functions --- (Unchanged, they are perfectly structured)
function updateMaterial() {
    if (!selectedObject || !selectedObject.material) return;
    // ... Your logic for manual sliders goes here ...
    selectedObject.material.needsUpdate = true;
}

function updateTexture(event) {
    if (!selectedObject || !selectedObject.material) return;
    const file = event.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = function(e) {
            const uploadedTexture = textureLoaderEdit.load(e.target.result);
            uploadedTexture.encoding = THREE.sRGBEncoding;
            selectedObject.material.map = uploadedTexture;
            selectedObject.material.needsUpdate = true;
        };
        reader.readAsDataURL(file);
    }
}

function updateTextureMaterials(textureName) {
    if (!selectedObject) return;
    // Good practice to dispose of the old material to free up GPU memory
    if (selectedObject.material && typeof selectedObject.material.dispose === 'function') {
        selectedObject.material.dispose();
    }
    // Clone the new material so each object gets its own unique instance
    selectedObject.material = textures[textureName].clone();
}



        // History System
const history = [];
let currentHistoryIndex = -1;

// Utility function to add an action to history and update UI
function recordHistoryAction(type, objectName, undoAction = null, redoAction = null) {
    const action = {
        type: type,
        object: objectName,
        undo: undoAction,
        redo: redoAction
    };
    history.push(action);
    currentHistoryIndex = history.length - 1;
    updateHistoryPanel();
}

/*function undo() {
    if (currentHistoryIndex >= 0) {
        const action = history[currentHistoryIndex];
        if (action.undo) action.undo();
        currentHistoryIndex--;
        updateHistoryPanel();
    }
}

function redo() {
    if (currentHistoryIndex < history.length - 1) {
        currentHistoryIndex++;
        const action = history[currentHistoryIndex];
        if (action.redo) action.redo();
        updateHistoryPanel();
    }
}*/


function undo() {
    if (undoStack.length === 0 || !terrain) return;
    
    const currentState = terrain.geometry.attributes.position.array.slice();
    redoStack.push(currentState);
    
    const previousState = undoStack.pop();
    terrain.geometry.attributes.position.array.set(previousState);
    terrain.geometry.attributes.position.needsUpdate = true;
    terrain.geometry.computeVertexNormals();
}

function redo() {
    if (redoStack.length === 0 || !terrain) return;

    const currentState = terrain.geometry.attributes.position.array.slice();
    undoStack.push(currentState);
    
    const nextState = redoStack.pop();
    terrain.geometry.attributes.position.array.set(nextState);
    terrain.geometry.attributes.position.needsUpdate = true;
    terrain.geometry.computeVertexNormals();
}

function clearHistory() {
    history.length = 0;
    currentHistoryIndex = -1;
    updateHistoryPanel();
}

function updateHistoryPanel() {
    const historyPanel = document.getElementById('history-items');
    if (!historyPanel) {
        console.error("History panel not found!");
        return;
    }

    historyPanel.innerHTML = ''; // Clear previous history items

    history.forEach((action, index) => {
        const historyItem = document.createElement('div');
        historyItem.classList.add('history-item'); // Uses the styled class
        historyItem.textContent = `${index + 1}. ${action.type || 'Action'}`;

        historyItem.addEventListener('click', () => {
            if (action.undo) action.undo();
            updateHistoryPanel();
        });

        historyPanel.appendChild(historyItem);
    });
}





        // Initialize everything
        function initializeAll() {
            initializeUI();
            setupClipboardOperations();
            const objectPool = optimizeScene();
    
            // Store objectPool for later use
            window.objectPool = objectPool;
        }

// Call initialization when the page loads
window.addEventListener('load', initializeAll);

// Context Menu
function setupContextMenu() {
    const rendererContainer = document.getElementById('renderer-container');

    // Add contextmenu listener only to renderer-container
    rendererContainer.addEventListener('contextmenu', (e) => {
        e.preventDefault(); // Prevent default browser context menu

        // Check if the click is within renderer-container (redundant here since the listener is on the element, but good practice)
        if (rendererContainer.contains(e.target)) {
            const contextMenu = document.getElementById('context-menu');
            contextMenu.style.display = 'block';
            contextMenu.style.left = e.pageX + 'px';
            contextMenu.style.top = e.pageY + 'px';
        }
    });

    // Hide context menu when clicking anywhere on the document
    document.addEventListener('click', () => {
        const contextMenu = document.getElementById('context-menu');
        contextMenu.style.display = 'none';
    });
}



// Initialize new features
function initializeAdvancedFeatures() {
    setupMaterialEditor();
    enableSnapping();
    setupContextMenu();
    initializeTextures();
}

// Call initialization
initializeAdvancedFeatures();
    </script>
    <script>

        // Camera Preview
        let activeCamera = null; 
        const expandButton = document.getElementById('expandPreview');
        const previewRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        const previewContainer = document.getElementById('cameraPreview');
        previewRenderer.setSize(previewContainer.clientWidth, previewContainer.clientHeight);
        previewRenderer.setPixelRatio(window.devicePixelRatio); // High DPI support
        previewContainer.appendChild(previewRenderer.domElement);
    

        function initializePanelControls() {
            const lightIntensityControl = document.getElementById('lightIntensity');
            const lightColorControl = document.getElementById('lightColor');

            // Update light properties when controls change
            function updateLightControls() {
                if (selectedObject && (selectedObject instanceof THREE.Light)) {
                    selectedObject.intensity = parseFloat(lightIntensityControl.value);
                    selectedObject.color.setStyle(lightColorControl.value);
                    if (selectedObject.helper) {
                        selectedObject.helper.update();
                    }
                }
            }

            lightIntensityControl.addEventListener('input', updateLightControls);
            lightColorControl.addEventListener('input', updateLightControls);

            function updatePreviewSize() {
              const rect = previewContainer.getBoundingClientRect();
               previewRenderer.setSize(rect.width, rect.height);
                if (activeCamera) {
                  activeCamera.aspect = rect.width / rect.height;
                  activeCamera.updateProjectionMatrix();
                }
            }

           // Toggle preview size
           document.getElementById('expandPreview').addEventListener('click', () => {
                previewContainer.classList.toggle('expanded');
                updatePreviewSize();
            });

           
            // Resize observer for dynamic adjustments
            new ResizeObserver(updatePreviewSize).observe(previewContainer);
            
       
           
            // Light controls initialization
            document.getElementById('addPointLight').addEventListener('click', () => {
                const light = new THREE.PointLight(0xffffff, 1);
                light.position.set(0, 5, 0);
                light.castShadow = true;
                
                // Create visual representation
                const sphereGeometry = new THREE.SphereGeometry(0.2);
                const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true });
                const visualMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
                light.add(visualMesh);
                
                // Add helper
                const helper = new THREE.PointLightHelper(light, 0.5);
                scene.add(helper);
                light.helper = helper;
                
                // Add to scene
                light.name = `PointLight_${objects.length}`;
                addObjectToScene(light, 'Point Light');
                document.querySelector('.controls-panel').appendChild(controls);
                light.controls = controls;
                updateHierarchy();
            });

            document.getElementById('addSpotLight').addEventListener('click', () => {
                const light = new THREE.SpotLight(0xffffff, 1);
                light.position.set(0, 5, 0);
                light.angle = Math.PI / 4;
                light.castShadow = true;
                
                // Create visual representation
                const coneGeometry = new THREE.ConeGeometry(0.2, 0.5);
                const coneMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true });
                const visualMesh = new THREE.Mesh(coneGeometry, coneMaterial);
                light.add(visualMesh);
                
                // Add helper
                const helper = new THREE.SpotLightHelper(light);
                scene.add(helper);
                light.helper = helper;
                
                // Add to scene
                light.name = `SpotLight_${objects.length}`;
                addObjectToScene(light, 'Spot Light');
                updateHierarchy();
            });

            document.getElementById('addAreaLight').addEventListener('click', () => {
                const light = new THREE.RectAreaLight(0xffffff, 1, 2, 2);
                light.position.set(0, 5, 0);
                
                // Create visual representation
                const planeGeometry = new THREE.PlaneGeometry(0.4, 0.4);
                const planeMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true });
                const visualMesh = new THREE.Mesh(planeGeometry, planeMaterial);
                light.add(visualMesh);
                
                // Add helper
                const helper = new THREE.RectAreaLightHelper(light);
                scene.add(helper);
                light.helper = helper;
                
                // Add to scene
                light.name = `AreaLight_${objects.length}`;
                addObjectToScene(light, 'Area Light');
                updateHierarchy();
            });

             document.getElementById('addSunLight').addEventListener('click', () => {
               const { sunSystem, updateDayNightCycle } = createSimpleSunLight();
               scene.add(sunSystem);

               // ÿ™ÿ≠ÿØŸäÿ´ ÿ≠ŸÑŸÇÿ© ÿßŸÑÿ£ŸÜŸäŸÖŸäÿ¥ŸÜ
                function animate() {
                   updateDayNightCycle();
                   requestAnimationFrame(animate);
                }
                requestAnimationFrame(animate);

                // Add to scene management
                sunSystem.name = `SunSystem_${objects.length}`;
                addObjectToScene(sunSystem, 'Sun System');
                updateHierarchy();
            });

            document.getElementById('addDirectionalLight').addEventListener('click', () => {
                const light = new THREE.DirectionalLight(0xffffff, 1);
                light.position.set(0, 5, 0);
                light.castShadow = true;
                
                // Create visual representation
                const boxGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
                const boxMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true });
                const visualMesh = new THREE.Mesh(boxGeometry, boxMaterial);
                light.add(visualMesh);
                
                // Add helper
                const helper = new THREE.DirectionalLightHelper(light, 1);
                scene.add(helper);
                light.helper = helper;
                
                // Add to scene
                light.name = `DirectionalLight_${objects.length}`;
                addObjectToScene(light, 'Directional Light');
                updateHierarchy();
            });

            // New Light Types
            document.getElementById('addHemisphereLight').addEventListener('click', () => {
                const light = new THREE.HemisphereLight(0xffffbb, 0x080820, 1);
                light.position.set(0, 5, 0);
                
                // Create visual representation
                const sphereGeometry = new THREE.SphereGeometry(0.3);
                const sphereMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffffbb,
                    wireframe: true,
                    vertexColors: true
                });
                const visualMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
                light.add(visualMesh);
                
                // Add helper
                const helper = new THREE.HemisphereLightHelper(light, 1);
                scene.add(helper);
                light.helper = helper;
                
                light.name = `HemisphereLight_${objects.length}`;
                addObjectToScene(light, 'Hemisphere Light');
                updateHierarchy();
            });
        
            document.getElementById('addLensflareLight').addEventListener('click', () => {
                const light = new THREE.PointLight(0xffffff, 1.5, 2000);
                light.position.set(0, 10, 0);
                
                // Create lensflare effect
                const textureLoader = new THREE.TextureLoader();
                const textureFlare = textureLoader.load('path_to_lensflare_texture.png');
                
                const lensflare = new THREE.Lensflare();
                lensflare.addElement(new THREE.LensflareElement(textureFlare, 512, 0));
                light.add(lensflare);
                
                // Visual representation
                const sphereGeometry = new THREE.SphereGeometry(0.2);
                const sphereMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00,
                    wireframe: true
                });
                const visualMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
                light.add(visualMesh);
                
                light.name = `LensflareLight_${objects.length}`;
                addObjectToScene(light, 'Lensflare Light');
                updateHierarchy();
            });
        
            document.getElementById('addVolumetricLight').addEventListener('click', () => {
                const light = new THREE.SpotLight(0xffffff, 1);
                light.position.set(0, 5, 0);
                light.angle = Math.PI / 6;
                light.penumbra = 0.3;
                light.decay = 2;
                light.distance = 50;
                
                // Create volumetric effect
                const geometry = new THREE.CylinderGeometry(0, 2, 10, 32);
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        lightColor: { value: new THREE.Color(0xffffff) },
                        intensity: { value: 1.0 }
                    },
                    vertexShader: `
                        varying vec3 vNormal;
                        void main() {
                            vNormal = normalize(normalMatrix * normal);
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform vec3 lightColor;
                        uniform float intensity;
                        varying vec3 vNormal;
                        void main() {
                            float opacity = pow(1.0 - abs(dot(vNormal, vec3(0.0, 1.0, 0.0))), 2.0);
                            gl_FragColor = vec4(lightColor, opacity * intensity * 0.2);
                        }
                    `,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    side: THREE.DoubleSide
                });
                
                const volumetricCone = new THREE.Mesh(geometry, material);
                light.add(volumetricCone);
                
                // Add helper
                const helper = new THREE.SpotLightHelper(light);
                scene.add(helper);
                light.helper = helper;
                
                light.name = `VolumetricLight_${objects.length}`;
                addObjectToScene(light, 'Volumetric Light');
                updateHierarchy();
            });

            
            // Camera Management System
            /*document.getElementById('addCameraOrto').addEventListener('click', () => {
                const aspectRatio = window.innerWidth / window.innerHeight;
                const orthoCamera = new THREE.OrthographicCamera(
                    -10 * aspectRatio, 10 * aspectRatio,
                    10, -10,
                    0.1, 100
                );

                orthoCamera.position.set(15, 10, 15);
                orthoCamera.lookAt(0, 0, 0);

                // Create main group that will contain both camera model and helper
                const mainGroup = new THREE.Group();

                // Camera model group
                const cameraGroup = new THREE.Group();

                const bodyGeometry = new THREE.BoxGeometry(1, 0.6, 0.8);
                const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xffbd54 });
                const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
                cameraGroup.add(bodyMesh);

                const lensGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.4, 16);
                const lensMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
                const lensMesh = new THREE.Mesh(lensGeometry, lensMaterial);
                lensMesh.rotation.z = Math.PI / 2;
                lensMesh.position.x = 0.7;
                cameraGroup.add(lensMesh);

                cameraGroup.scale.set(0.5, 0.5, 0.5);
                mainGroup.add(cameraGroup);

                // Improved pyramid helper
                const pyramidGeometry = new THREE.BufferGeometry();
    
                // Define pyramid dimensions
                const baseWidth = 8;    // Width of the base
                const baseHeight = 8;   // Height of the base
                const pyramidLength = 12; // Length of the pyramid

                const pyramidVertices = new Float32Array([
                    // Pyramid tip (at camera position)
                    0, 0, 0,

                    // Base vertices (forming a rectangle)
                    -baseWidth/2, -baseHeight/2, -pyramidLength,  // bottom left
                    baseWidth/2, -baseHeight/2, -pyramidLength,   // bottom right
                    baseWidth/2, baseHeight/2, -pyramidLength,    // top right
                    -baseWidth/2, baseHeight/2, -pyramidLength,   // top left
                ]);

                // Define the indices for drawing lines
                const pyramidIndices = [
                    // Lines from tip to base corners
                    0, 1,  // tip to bottom left
                    0, 2,  // tip to bottom right
                    0, 3,  // tip to top right
                    0, 4,  // tip to top left

                    // Base rectangle
                    1, 2,  // bottom edge
                    2, 3,  // right edge
                    3, 4,  // top edge
                    4, 1   // left edge
                ];

                pyramidGeometry.setAttribute('position', new THREE.BufferAttribute(pyramidVertices, 3));
                pyramidGeometry.setIndex(pyramidIndices);

                const pyramidMaterial = new THREE.LineBasicMaterial({ 
                    color: 0xffbd54,
                    linewidth: 1
                }); 
    
                const pyramidHelper = new THREE.LineSegments(pyramidGeometry, pyramidMaterial);
    
                // Add guide lines for better visualization
                const guideGeometry = new THREE.BufferGeometry();
                const numGuides = 4;
                const guideVertices = [];
                const guideIndices = [];
    
                // Create vertical guide lines
                for (let i = 1; i < numGuides; i++) {
                    const x = -baseWidth/2 + (baseWidth * i/numGuides);
                    guideVertices.push(
                        0, 0, 0,  // Start at tip
                        x, -baseHeight/2, -pyramidLength  // End at base
                    );
                    guideIndices.push(guideVertices.length/3 - 2, guideVertices.length/3 - 1);
        
                    guideVertices.push(
                        0, 0, 0,  // Start at tip
                        x, baseHeight/2, -pyramidLength  // End at base
                    );
                    guideIndices.push(guideVertices.length/3 - 2, guideVertices.length/3 - 1);
                }

                guideGeometry.setAttribute('position', new THREE.Float32BufferAttribute(guideVertices, 3));
                guideGeometry.setIndex(guideIndices);

                const guideMaterial = new THREE.LineBasicMaterial({ 
                    color: 0xffbd54,
                    opacity: 0.3,
                    transparent: true
                });
    
                const guideLines = new THREE.LineSegments(guideGeometry, guideMaterial);
                pyramidHelper.add(guideLines);

                mainGroup.add(pyramidHelper);

                // Position and orient main group
                mainGroup.position.copy(orthoCamera.position);
                scene.add(mainGroup);

                function syncWithCamera() {
                    mainGroup.position.copy(orthoCamera.position);
        
                    const target = new THREE.Vector3(0, 0, 0);
                    mainGroup.lookAt(target);
                    mainGroup.rotateOnAxis(new THREE.Vector3(0, 1, 0), Math.PI);
                }

                const handleResize = () => {
                    const newAspectRatio = window.innerWidth / window.innerHeight;
                    orthoCamera.left = -10 * newAspectRatio;
                    orthoCamera.right = 10 * newAspectRatio;
                    orthoCamera.updateProjectionMatrix();
                };

                window.addEventListener('resize', handleResize);

                const gridHelper = new THREE.GridHelper(20, 20);
                scene.add(gridHelper);
    
                const axesHelper = new THREE.AxesHelper(10);
                scene.add(axesHelper);

                addObjectToScene(orthoCamera, 'Ortho_camera');
                updateHierarchy();
                setupCameraControls(orthoCamera);

                if (activeCamera) {
                   transitionToCamera(orthoCamera);
                }

                activeCamera = orthoCamera;

                function animate() {
                    requestAnimationFrame(animate);
                    syncWithCamera();
                }
                animate();
            });*/

document.getElementById('addCameraOrto').addEventListener('click', () => {
    const aspectRatio = window.innerWidth / window.innerHeight;
    const viewSize = 5;
    const zoomFactor = 0.8;

    // Create orthographic camera
    const orthoCamera = new THREE.OrthographicCamera(
        -viewSize * aspectRatio * zoomFactor,
        viewSize * aspectRatio * zoomFactor,
        viewSize * zoomFactor,
        -viewSize * zoomFactor,
        0.1,
        50
    );

    orthoCamera.name = 'OrthoCamera';
    orthoCamera.position.set(8, 6, 8);
    orthoCamera.lookAt(0, 0, 0);
    orthoCamera.userData = {
        viewSize: viewSize,
        zoomFactor: zoomFactor,
        minZoom: 0.2,
        maxZoom: 2,
        isOrtho: true,
        showHelpers: false
    };

    // Main camera system group
    const cameraSystemGroup = new THREE.Group();
    cameraSystemGroup.name = "CameraSystem";
    cameraSystemGroup.visible = false; // Start with helpers hidden

    // --- Small White Pyramid (Camera Representation) ---
    const cameraModelGroup = new THREE.Group();
    cameraModelGroup.name = "CameraPyramid";

    const pyramidGeometry = new THREE.ConeGeometry(0.2, 0.4, 4);
    const edges = new THREE.EdgesGeometry(pyramidGeometry);
    const pyramidMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
    const pyramidMesh = new THREE.LineSegments(edges, pyramidMaterial);
    pyramidMesh.rotation.x = Math.PI / 2;
    pyramidMesh.rotation.y = Math.PI / 4;
    pyramidMesh.position.z = -0.2;
    cameraModelGroup.add(pyramidMesh);
    cameraModelGroup.scale.set(0.5, 0.5, 0.5);
    cameraSystemGroup.add(cameraModelGroup);

    // --- Big Aqua Pyramid (Frustum Visualization) ---
    const frustumHelperGroup = new THREE.Group();
    frustumHelperGroup.name = "FrustumHelper";

    // Create pyramid-shaped frustum helper
    const frustumSize = 1.5; // Scale factor for the frustum visualization
    const frustumMaterial = new THREE.LineBasicMaterial({ 
        color: 0x00ffff,
        linewidth: 2,
        transparent: true,
        opacity: 0.7
    });

    const frustumGeom = new THREE.BufferGeometry();
    const frustumLines = new THREE.LineSegments(frustumGeom, frustumMaterial);
    frustumHelperGroup.add(frustumLines);

    // Update function for frustum visualization
    function updateFrustumVisualization() {
        const visualLength = 10 * frustumSize; // Larger frustum visualization
        const near = orthoCamera.near;
        const far = Math.min(visualLength, orthoCamera.far - near);
        
        // Get current camera bounds (scaled up for better visibility)
        const width = (orthoCamera.right - orthoCamera.left) * frustumSize;
        const height = (orthoCamera.top - orthoCamera.bottom) * frustumSize;

        // Create pyramid shape (lines from tip to base corners)
        const vertices = new Float32Array([
            // Lines from tip to base corners
            0, 0, 0, -width/2, -height/2, -far,
            0, 0, 0, width/2, -height/2, -far,
            0, 0, 0, width/2, height/2, -far,
            0, 0, 0, -width/2, height/2, -far,
            
            // Base rectangle
            -width/2, -height/2, -far, width/2, -height/2, -far,
            width/2, -height/2, -far, width/2, height/2, -far,
            width/2, height/2, -far, -width/2, height/2, -far,
            -width/2, height/2, -far, -width/2, -height/2, -far
        ]);

        frustumGeom.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
        frustumGeom.computeBoundingSphere();
    }

    // Add central axis line
    const axisGeom = new THREE.BufferGeometry();
    const axisMaterial = new THREE.LineBasicMaterial({ color: 0xff5555 });
    const axisLine = new THREE.Line(axisGeom, axisMaterial);
    frustumHelperGroup.add(axisLine);

    cameraSystemGroup.add(frustumHelperGroup);

    // Toggle helpers visibility
    function toggleHelpers(show) {
        orthoCamera.userData.showHelpers = show;
        cameraSystemGroup.visible = show;
        if (show) {
            updateFrustumVisualization();
        }
    }

    // Zoom function
    function adjustZoom(delta) {
        orthoCamera.userData.zoomFactor = THREE.MathUtils.clamp(
            orthoCamera.userData.zoomFactor + delta,
            orthoCamera.userData.minZoom,
            orthoCamera.userData.maxZoom
        );
        
        const newAspectRatio = window.innerWidth / window.innerHeight;
        orthoCamera.left = -orthoCamera.userData.viewSize * newAspectRatio * orthoCamera.userData.zoomFactor;
        orthoCamera.right = orthoCamera.userData.viewSize * newAspectRatio * orthoCamera.userData.zoomFactor;
        orthoCamera.top = orthoCamera.userData.viewSize * orthoCamera.userData.zoomFactor;
        orthoCamera.bottom = -orthoCamera.userData.viewSize * orthoCamera.userData.zoomFactor;
        orthoCamera.updateProjectionMatrix();
        
        if (orthoCamera.userData.showHelpers) {
            updateFrustumVisualization();
        }
    }

    // Create UI controls
    /*function createZoomControls() {
    // Remove existing controls if any
    if (window.orthoCamera && orthoCamera.userData.zoomControls) { // Added window.orthoCamera for safety
        document.body.removeChild(orthoCamera.userData.zoomControls);
    }

    const container = document.createElement('div');
    container.style.position = 'fixed';
    container.style.bottom = '20px';
    container.style.right = '20px';
    container.style.zIndex = '100';
    container.style.display = 'flex';
    container.style.flexDirection = 'column'; // Stack them nicely
    container.style.gap = '5px';
    container.style.background = 'rgba(0,0,0,0.7)';
    container.style.padding = '10px';
    container.style.borderRadius = '5px';

    // Common button styles
    const btnStyle = (btn) => {
        btn.style.padding = '8px 12px'; // Adjusted padding slightly
        btn.style.fontSize = '16px';    // SVG height is 1em, so it will match this
        btn.style.cursor = 'pointer';
        btn.style.border = 'none';
        btn.style.background = '#555';
        btn.style.color = 'white';
        btn.style.borderRadius = '3px';
        // For buttons with icon + text
        btn.style.display = 'inline-flex';
        btn.style.alignItems = 'center';
        btn.style.gap = '8px'; // Space between icon and text
    };

    // Zoom buttons
    const zoomOutBtn = document.createElement('button');
    zoomOutBtn.innerHTML = svgMinus;
    zoomOutBtn.setAttribute('aria-label', 'Zoom Out'); // Accessibility
    btnStyle(zoomOutBtn);
    zoomOutBtn.onclick = () => adjustZoom(0.1);

    const zoomInBtn = document.createElement('button');
    zoomInBtn.innerHTML = svgPlus;
    zoomInBtn.setAttribute('aria-label', 'Zoom In'); // Accessibility
    btnStyle(zoomInBtn);
    zoomInBtn.onclick = () => adjustZoom(-0.1);

    // Helpers toggle button
    const helpersBtn = document.createElement('button');
    btnStyle(helpersBtn); // Apply common styles
    helpersBtn.style.marginTop = '10px'; // Add some space above this distinct button

    // Function to update helper button text and icon
    const updateHelpersButton = () => {
        if (orthoCamera.userData.showHelpers) {
            helpersBtn.innerHTML = `${svgArrowDown} Hide Volume`;
            helpersBtn.setAttribute('aria-label', 'Hide Volume Helpers');
        } else {
            helpersBtn.innerHTML = `${svgArrowUp} View Volume`;
            helpersBtn.setAttribute('aria-label', 'View Volume Helpers');
        }
    };
    
    // Initial setup for helpers button
    // Assume orthoCamera.userData.showHelpers is initialized (e.g., to false)
    if (typeof orthoCamera.userData.showHelpers === 'undefined') {
        orthoCamera.userData.showHelpers = false; // Sensible default
    }
    updateHelpersButton();


    helpersBtn.onclick = () => {
        toggleHelpers(!orthoCamera.userData.showHelpers); // toggleHelpers should update orthoCamera.userData.showHelpers
        updateHelpersButton();
    };

    container.appendChild(zoomOutBtn);
    container.appendChild(zoomInBtn);
    container.appendChild(helpersBtn);
    document.body.appendChild(container);

    if (window.orthoCamera) { // Ensure orthoCamera exists
       orthoCamera.userData.zoomControls = container;
    }
}*/

function createZoomControls() {
    // Remove existing controls if any
    /*if (orthoCamera.userData.zoomControls) {
        document.body.removeChild(orthoCamera.userData.zoomControls);
    }*/

    const container = document.createElement('div');
    container.style.position = 'fixed';
    container.style.bottom = '20px';
    container.style.right = '20px';
    container.style.zIndex = '100';
    container.style.display = 'flex';
    container.style.gap = '5px';
    container.style.background = 'rgba(0,0,0,0.7)';
    container.style.padding = '10px';
    container.style.borderRadius = '5px';

    const closeBtn = document.createElement('button');
    closeBtn.textContent = '√ó';
    closeBtn.title = 'Close panel';
    closeBtn.style.cssText = `
        font-weight:bold;font-size:18px;line-height:14px;
        padding:4px 10px;cursor:pointer;color:#fff;background:#d33;border:none;
    `;
    closeBtn.onclick = () => {
        if (container.parentNode)
           container.parentNode.removeChild(container);
        if (camera.userData && camera.userData.uiCleanup)
           camera.userData.uiCleanup();          // keep everything in sync
    };
    container.appendChild(closeBtn);
        
    // Zoom buttons
    const zoomOutBtn = document.createElement('button');
    zoomOutBtn.textContent = '‚àí';
    zoomOutBtn.style.padding = '8px 16px';
    zoomOutBtn.style.fontSize = '16px';
    zoomOutBtn.style.cursor = 'pointer';
    zoomOutBtn.onclick = () => adjustZoom(0.1);
        
    const zoomInBtn = document.createElement('button');
    zoomInBtn.textContent = '+';
    zoomInBtn.style.padding = '8px 16px';
    zoomInBtn.style.fontSize = '16px';
    zoomInBtn.style.cursor = 'pointer';
    zoomInBtn.onclick = () => adjustZoom(-0.1);
        
    // Helpers toggle button
    const helpersBtn = document.createElement('button');
    helpersBtn.textContent = '‚ñ≤ View Volume';
    helpersBtn.style.padding = '8px 16px';
    helpersBtn.style.fontSize = '14px';
    helpersBtn.style.cursor = 'pointer';
    helpersBtn.style.marginLeft = '10px';
    helpersBtn.onclick = () => {
       toggleHelpers(!orthoCamera.userData.showHelpers);
        helpersBtn.textContent = orthoCamera.userData.showHelpers ? 
        '‚ñº Hide Volume' : '‚ñ≤ View Volume';
    };
        
    container.appendChild(zoomOutBtn);
    container.appendChild(zoomInBtn);
    container.appendChild(helpersBtn);
    document.body.appendChild(container);
        
    orthoCamera.userData.zoomControls = container;
    }

    // Add to scene
    orthoCamera.add(cameraSystemGroup);
    scene.add(orthoCamera);

    // Scene helpers
    const gridHelper = new THREE.GridHelper(10, 10, 0x666666, 0x333333);
    scene.add(gridHelper);
    orthoCamera.userData.gridHelper = gridHelper;

    const axesHelper = new THREE.AxesHelper(3);
    scene.add(axesHelper);
    orthoCamera.userData.axesHelper = axesHelper;

    // Handle resize
    function handleResize() {
        const newAspectRatio = window.innerWidth / window.innerHeight;
        orthoCamera.left = -orthoCamera.userData.viewSize * newAspectRatio * orthoCamera.userData.zoomFactor;
        orthoCamera.right = orthoCamera.userData.viewSize * newAspectRatio * orthoCamera.userData.zoomFactor;
        orthoCamera.updateProjectionMatrix();
        if (orthoCamera.userData.showHelpers) {
            updateFrustumVisualization();
        }
    }
    window.addEventListener('resize', handleResize);
    orthoCamera.userData.resizeListener = handleResize;

    // Initialize
    createZoomControls();
    
    // Scene management
    addObjectToScene(orthoCamera, 'OrthoCamera');
    updateHierarchy();
    setupCameraControls(orthoCamera);

    if (activeCamera && activeCamera !== orthoCamera) {
        transitionToCamera(orthoCamera);
    }
    activeCamera = orthoCamera;

    // Cleanup function
    orthoCamera.userData.cleanup = function() {
        window.removeEventListener('resize', this.userData.resizeListener);
        if (this.userData.zoomControls && document.body.contains(this.userData.zoomControls)) {
            document.body.removeChild(this.userData.zoomControls);
        }
        if (this.userData.gridHelper) scene.remove(this.userData.gridHelper);
        if (this.userData.axesHelper) scene.remove(this.userData.axesHelper);
    };
});



document.getElementById('addCubeCamera').addEventListener('click', () => {
    // Create cube camera for environment capturing
    const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(256, {
        format: THREE.RGBFormat,
        generateMipmaps: true,
        minFilter: THREE.LinearMipmapLinearFilter
    });


    const cubeCamera = new THREE.CubeCamera(0.1, 1000, cubeRenderTarget);
    cubeCamera.name = 'CubeCamera';
    cubeCamera.position.set(0, 2, 0);
    scene.add(cubeCamera);

    // Main container for visual elements
    const cameraVisuals = new THREE.Group();
    cameraVisuals.name = 'CubeCameraVisuals';
    cubeCamera.add(cameraVisuals);

    // --- Visual Representation ---
    const cameraModel = new THREE.Group();
    cameraModel.name = 'CubeCameraModel';
    
    // Cube body (wireframe)
    const cubeGeom = new THREE.BoxGeometry(0.8, 0.8, 0.8);
    const cubeEdges = new THREE.EdgesGeometry(cubeGeom);
    const cubeMaterial = new THREE.LineBasicMaterial({ 
        color: 0x1db34d,
        linewidth: 2
    });
    const cubeMesh = new THREE.LineSegments(cubeEdges, cubeMaterial);
    cameraModel.add(cubeMesh);

    // Lens indicators on each face
    const lensMaterial = new THREE.MeshBasicMaterial({ 
        color: 0x1db34d,
        transparent: true,
        opacity: 0.7
    });
    
    // Front lens
    const frontLens = new THREE.Mesh(
        new THREE.CircleGeometry(0.15, 16),
        lensMaterial
    );
    frontLens.position.z = 0.41;
    frontLens.rotation.y = Math.PI;
    cameraModel.add(frontLens);

    // Back lens
    const backLens = frontLens.clone();
    backLens.position.z = -0.41;
    backLens.rotation.y = 0;
    cameraModel.add(backLens);

    // Left lens
    const leftLens = frontLens.clone();
    leftLens.position.set(-0.41, 0, 0);
    leftLens.rotation.y = Math.PI/2;
    cameraModel.add(leftLens);

    // Right lens
    const rightLens = frontLens.clone();
    rightLens.position.set(0.41, 0, 0);
    rightLens.rotation.y = -Math.PI/2;
    cameraModel.add(rightLens);

    // Top lens
    const topLens = frontLens.clone();
    topLens.position.set(0, 0.41, 0);
    topLens.rotation.x = -Math.PI/2;
    cameraModel.add(topLens);

    // Bottom lens
    const bottomLens = frontLens.clone();
    bottomLens.position.set(0, -0.41, 0);
    bottomLens.rotation.x = Math.PI/2;
    cameraModel.add(bottomLens);

    cameraVisuals.add(cameraModel);

    // --- Helpers ---
    const sphereRadius = 3;
    const sphereHelper = new THREE.Mesh(
        new THREE.SphereGeometry(sphereRadius, 16, 16),
        new THREE.MeshBasicMaterial({
            color: 0x1db34d,
            wireframe: true,
            transparent: true,
            opacity: 0.3
        })
    );
    sphereHelper.visible = false;
    cameraVisuals.add(sphereHelper);

    // Axis helper
    const axisHelper = new THREE.AxesHelper(2);
    axisHelper.visible = false;
    cameraVisuals.add(axisHelper);

    // --- Controls UI ---
    const controlsContainer = document.createElement('div');
    controlsContainer.className = 'camera-controls';
    Object.assign(controlsContainer.style, {
       position: 'fixed',
       bottom:   '20px',
       right:    '20px',
       zIndex:   '100',
       background:'rgba(0,0,0,0.75)',
       padding:  '10px',
       borderRadius:'6px',
       display:  'flex',
       gap:      '6px',
    });
    /* ‚¨á NEW close button */
    const closeBtn = document.createElement('button');
    closeBtn.textContent = '√ó';
    closeBtn.title = 'Close panel';
    closeBtn.style.cssText = `
        font-weight:bold;font-size:18px;line-height:14px;
        padding:4px 10px;cursor:pointer;color:#fff;background:#d33;border:none;
    `;
    closeBtn.onclick = () => {
        if (controlsContainer.parentNode)
           controlsContainer.parentNode.removeChild(controlsContainer);
        if (camera.userData && camera.userData.uiCleanup)
          camera.userData.uiCleanup();          // keep everything in sync
    };
    controlsContainer.appendChild(closeBtn);   // always first
    

   /* const controlsContainer = document.createElement('div');
    controlsContainer.style.position = 'fixed';
    controlsContainer.style.bottom = '60px';
    controlsContainer.style.right = '20px';
    controlsContainer.style.zIndex = '100';
    controlsContainer.style.background = 'rgba(0,0,0,0.7)';
    controlsContainer.style.padding = '10px';
    controlsContainer.style.borderRadius = '5px';
    controlsContainer.style.display = 'flex';
    controlsContainer.style.flexDirection = 'column';
    controlsContainer.style.gap = '8px';
    */

    // Toggle sphere helper
    const sphereToggle = document.createElement('button');
    sphereToggle.textContent = '‚ñ≤ Capture Range';
    sphereToggle.style.padding = '8px 12px';
    sphereToggle.onclick = () => {
        sphereHelper.visible = !sphereHelper.visible;
        sphereToggle.textContent = sphereHelper.visible ? 
            '‚ñº Hide Range' : '‚ñ≤ Capture Range';
    };

    // Toggle axes
    const axesToggle = document.createElement('button');
    axesToggle.textContent = '‚ñ≤ Show Axes';
    axesToggle.style.padding = '8px 12px';
    axesToggle.onclick = () => {
        axisHelper.visible = !axisHelper.visible;
        axesToggle.textContent = axisHelper.visible ? 
            '‚ñº Hide Axes' : '‚ñ≤ Show Axes';
    };

    // Update button
    /*const updateBtn = document.createElement('button');
    updateBtn.textContent = 'Update Capture';
    updateBtn.style.padding = '8px 12px';
    updateBtn.style.background = '#1db34d';
    updateBtn.onclick = () => {
        cubeCamera.update(renderer, scene);
    };*/

    // --- THIS IS THE CORRECTED CODE ---
    const updateBtn = document.createElement('button');
    updateBtn.textContent = 'Update Capture';
    updateBtn.style.padding = '8px 12px';
    updateBtn.style.background = '#1db34d';
    updateBtn.onclick = () => {
        // 1. Hide the camera's visual model so it doesn't see itself
        cameraVisuals.visible = false;
    
        // 2. Perform the capture
        cubeCamera.update(renderer, scene);
    
        // 3. Make the visual model visible again for the main scene view
        cameraVisuals.visible = true;

        // Optional: Give user feedback
        console.log("CubeCamera texture updated.");
    };

    controlsContainer.appendChild(sphereToggle);
    controlsContainer.appendChild(axesToggle);
    controlsContainer.appendChild(updateBtn);
    document.body.appendChild(controlsContainer);

    // Store references for cleanup
    cubeCamera.userData = {
        visuals: cameraVisuals,
        controls: controlsContainer,
        renderTarget: cubeRenderTarget,
        helpers: {
            sphere: sphereHelper,
            axes: axisHelper
        }
    };

    // Add to scene management
    addObjectToScene(cubeCamera, 'CubeCamera');
    updateHierarchy();

    // Setup controls
    setupCameraControls(cubeCamera);

    if (activeCamera && activeCamera !== cubeCamera) {
        transitionToCamera(cubeCamera);
    }
    activeCamera = cubeCamera;

    // Cleanup function
    cubeCamera.userData.cleanup = function() {
        if (this.userData.controls && document.body.contains(this.userData.controls)) {
            document.body.removeChild(this.userData.controls);
        }
        if (this.userData.renderTarget) {
            this.userData.renderTarget.dispose();
        }
        scene.remove(this);
    };

  

});



document.getElementById('addStereoCamera').addEventListener('click', () => {
    // Create base camera for stereo
    const perspectiveCamera = new THREE.PerspectiveCamera(
        75, 
        window.innerWidth / window.innerHeight, 
        0.1, 
        1000
    );
    perspectiveCamera.position.set(0, 1.6, 0);
    perspectiveCamera.lookAt(0, 1.6, -1);
    perspectiveCamera.name = 'StereoCamera';
    
    // Create stereo camera wrapper
    const stereoCamera = new THREE.StereoCamera();
    stereoCamera.aspect = 0.5;
    stereoCamera.eyeSep = 0.064;
    
    // Get preview container and special controls div
    const previewContainer = document.getElementById('cameraPreview');
    const specialControls = document.querySelector('.camera-special-controls');
    
    // Clear any existing special controls
    specialControls.innerHTML = '';
    
    // Create stereo renderer for preview
    const stereoPreviewRenderer = new THREE.WebGLRenderer({ 
        antialias: true, 
        alpha: true
    });
    stereoPreviewRenderer.setPixelRatio(window.devicePixelRatio);
    stereoPreviewRenderer.autoClear = false;
    
    // Set initial size and add to preview container
    updatePreviewSize();
    previewContainer.insertBefore(
        stereoPreviewRenderer.domElement, 
        previewContainer.querySelector('.preview-controls')
    );
    
    // Show the preview container if hidden
    previewContainer.classList.remove('hidden');
    
    // Create visual representation
    const cameraVisuals = createStereoCameraVisuals();
    perspectiveCamera.add(cameraVisuals);
    scene.add(perspectiveCamera);
    
    // Update stereo parameters
    function updateStereoCamera() {
        stereoCamera.focalLength = perspectiveCamera.getFocalLength();
        stereoCamera.fov = perspectiveCamera.fov;
        stereoCamera.near = perspectiveCamera.near;
        stereoCamera.far = perspectiveCamera.far;
        stereoCamera.update(perspectiveCamera);
    }
    
    // Animation loop for stereo preview
    function renderStereoPreview() {
        if (!perspectiveCamera.parent) return;
        
        updateStereoCamera();
        stereoPreviewRenderer.clear();
        
        const width = previewContainer.clientWidth;
        const height = previewContainer.clientHeight;
        const halfWidth = width / 2;
        
        // Left eye
        stereoPreviewRenderer.setViewport(0, 0, halfWidth, height);
        stereoPreviewRenderer.setScissor(0, 0, halfWidth, height);
        stereoPreviewRenderer.setScissorTest(true);
        stereoPreviewRenderer.render(scene, stereoCamera.cameraL);
        
        // Right eye
        stereoPreviewRenderer.setViewport(halfWidth, 0, halfWidth, height);
        stereoPreviewRenderer.setScissor(halfWidth, 0, halfWidth, height);
        stereoPreviewRenderer.render(scene, stereoCamera.cameraR);
        
        requestAnimationFrame(renderStereoPreview);
    }
    
    // Start rendering
    renderStereoPreview();
    
    // Handle preview resize
    function updatePreviewSize() {
        const width = previewContainer.clientWidth;
        const height = previewContainer.clientHeight;
        stereoPreviewRenderer.setSize(width, height);
        
        perspectiveCamera.aspect = (width/2) / height;
        perspectiveCamera.updateProjectionMatrix();
    }
    
    // Setup preview controls
    document.getElementById('minimizePreview').addEventListener('click', () => {
        previewContainer.classList.toggle('minimized');
        if (previewContainer.classList.contains('minimized')) {
            stereoPreviewRenderer.domElement.style.display = 'none';
        } else {
            stereoPreviewRenderer.domElement.style.display = 'block';
            updatePreviewSize();
        }
    });
    
    document.getElementById('expandPreview').addEventListener('click', () => {
        previewContainer.classList.toggle('expanded');
        updatePreviewSize();
    });
    
    // Handle container resize
    const resizeObserver = new ResizeObserver(() => {
        if (!previewContainer.classList.contains('minimized')) {
            updatePreviewSize();
        }
    });
    resizeObserver.observe(previewContainer);
    
    // Add stereo controls to special controls div
    const eyeSepControl = document.createElement('div');
    eyeSepControl.className = 'stereo-control';
    eyeSepControl.innerHTML = `
        <label>Eye Separation: <span>${stereoCamera.eyeSep.toFixed(3)}m</span></label>
        <input type="range" min="0.01" max="0.1" step="0.001" value="${stereoCamera.eyeSep}">
    `;
    
    const focalControl = document.createElement('div');
    focalControl.className = 'stereo-control';
    focalControl.innerHTML = `
        <label>Focal Length: <span>${perspectiveCamera.getFocalLength().toFixed(0)}mm</span></label>
        <input type="range" min="10" max="100" step="1" value="${perspectiveCamera.getFocalLength()}">
    `;
    
    // Add controls to special controls container
    specialControls.appendChild(eyeSepControl);
    specialControls.appendChild(focalControl);
    
    // Event listeners for controls
    eyeSepControl.querySelector('input').addEventListener('input', (e) => {
        stereoCamera.eyeSep = parseFloat(e.target.value);
        eyeSepControl.querySelector('span').textContent = `${stereoCamera.eyeSep.toFixed(3)}m`;
    });
    
    focalControl.querySelector('input').addEventListener('input', (e) => {
        perspectiveCamera.setFocalLength(parseFloat(e.target.value));
        focalControl.querySelector('span').textContent = `${perspectiveCamera.getFocalLength().toFixed(0)}mm`;
        updateStereoCamera();
    });
    
    // Scene integration
    addObjectToScene(perspectiveCamera, 'StereoCamera');
    updateHierarchy();
    setupCameraControls(perspectiveCamera);
    
    if (activeCamera && activeCamera !== perspectiveCamera) {
        transitionToCamera(perspectiveCamera);
    }
    activeCamera = perspectiveCamera;
    
    // Cleanup function
    perspectiveCamera.userData.cleanup = () => {
        cancelAnimationFrame(renderStereoPreview);
        
        if (stereoPreviewRenderer.domElement.parentNode === previewContainer) {
            previewContainer.removeChild(stereoPreviewRenderer.domElement);
        }
        
        // Clear special controls
        specialControls.innerHTML = '';
        
        stereoPreviewRenderer.dispose();
        scene.remove(perspectiveCamera);
        resizeObserver.disconnect();
        
        if (activeCamera === perspectiveCamera) {
            previewContainer.classList.add('hidden');
            activeCamera = null;
        }
    };
});

// Visual representation function (same as before)
function createStereoCameraVisuals() {
    const group = new THREE.Group();
    
    // Camera body (white wireframe box)
    const bodyGeom = new THREE.BoxGeometry(1.2, 0.8, 0.6);
    const edges = new THREE.EdgesGeometry(bodyGeom);
    const bodyMat = new THREE.LineBasicMaterial({ color: 0xffffff });
    const body = new THREE.LineSegments(edges, bodyMat);
    group.add(body);
    
    // Two lenses (white circles)
    const lensGeom = new THREE.CircleGeometry(0.15, 16);
    const lensMat = new THREE.MeshBasicMaterial({ 
        color: 0xffffff,
        transparent: true,
        opacity: 0.8,
        side: THREE.DoubleSide
    });
    
    // Left lens
    const leftLens = new THREE.Mesh(lensGeom, lensMat);
    leftLens.position.set(-0.3, 0, 0.31);
    leftLens.rotation.y = Math.PI;
    group.add(leftLens);
    
    // Right lens
    const rightLens = leftLens.clone();
    rightLens.position.set(0.3, 0, 0.31);
    group.add(rightLens);
    
    // Top trapezoid
    const topGeom = new THREE.BufferGeometry();
    const vertices = new Float32Array([
        -0.4, 0.4, 0.3,  0.4, 0.4, 0.3,
        0.4, 0.4, 0.3,  0.2, 0.6, 0.3,
        0.2, 0.6, 0.3, -0.2, 0.6, 0.3,
        -0.2, 0.6, 0.3, -0.4, 0.4, 0.3
    ]);
    topGeom.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
    const top = new THREE.LineSegments(topGeom, bodyMat);
    group.add(top);
    
    return group;
}




    document.getElementById('addCamera').addEventListener('click', () => {
            const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 5);
            camera.lookAt(0, 0, 0);
            
            const cameraGroup = new THREE.Group();
            
            // Main Camera Body
            const bodyGeometry = new THREE.BoxGeometry(0.6, 0.3, 0.5);
            const bodyMaterial = new THREE.MeshPhysicalMaterial({ 
                color: 0x2c3e50,
                metalness: 0.8,
                roughness: 0.2,
                clearcoat: 1,
                clearcoatRoughness: 0.1
            });
            const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
            cameraGroup.add(bodyMesh);
            
            // Camera Grip
            const gripGeometry = new THREE.CylinderGeometry(0.08, 0.06, 0.4, 8);
            const gripMaterial = new THREE.MeshPhysicalMaterial({ 
                color: 0x34495e,
                metalness: 0.6,
                roughness: 0.8,
                clearcoat: 0.5
            });
            const gripMesh = new THREE.Mesh(gripGeometry, gripMaterial);
            gripMesh.position.y = -0.2;
            cameraGroup.add(gripMesh);
            
            function animateLensFocus() {
            const maxExtension = 0.2;
            lensGroup.userData.focusing = true;
            
            const animate = () => {
                const time = performance.now() * 0.001;
                const extension = Math.sin(time) * maxExtension;
                
                lensElements.forEach((lens, index) => {
                    lens.position.z = lensPositions[index] + extension;
                });
                
                if (lensGroup.userData.focusing) {
                    requestAnimationFrame(animate);
                }
            };
            animate();
            }
            
            // Add focus trigger on right-click
            cameraGroup.userData.onRightClick = () => {
            if (!lensGroup.userData.focusing) {
            animateLensFocus();
            } else {
            lensGroup.userData.focusing = false;
            }
            };
            
            // Lens System
            const lensGroup = new THREE.Group();
            
            // Main Lens
            const lensElements = [];
            const lensPositions = [0.3, 0.4, 0.5];
            
            lensPositions.forEach((pos, index) => {
                const element = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.12 - (index * 0.01), 0.13 - (index * 0.01), 0.05, 32),
                    new THREE.MeshPhysicalMaterial({
                        color: 0x88ccff,
                        metalness: 0.1,
                        roughness: 0.1,
                        transmission: 0.9,
                        thickness: 0.02,
                        clearcoat: 1
                    })
                );
                element.rotation.x = Math.PI / 2;
                element.position.z = pos;
                lensElements.push(element);
                lensGroup.add(element);
            });
            
            // Lens Glass
            const lensGlassGeometry = new THREE.CircleGeometry(0.15, 32);
            const glassMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x88ccff,
                metalness: 0.9,
                roughness: 0.1,
                transmission: 0.9,
                thickness: 0.1,
                clearcoat: 1
            });
            
            
            
            // Lens Ring
            const ringGeometry = new THREE.TorusGeometry(0.15, 0.02, 16, 60);
            const ringMaterial = new THREE.MeshPhysicalMaterial({ 
                color: 0x444444,
                metalness: 0.8,
                roughness: 0.4,
                clearcoat: 1
            });
            const ringMesh = new THREE.Mesh(ringGeometry, ringMaterial);
            ringMesh.position.z = 0.45;
            lensGroup.add(ringMesh);
            
            cameraGroup.add(lensGroup);
            
            // Viewfinder
            const viewfinderGeometry = new THREE.BoxGeometry(0.3, 0.2, 0.2);
            const viewfinderMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x2c3e50,
                metalness: 0.8,
                roughness: 0.2,
                clearcoat: 1
            });
            const viewfinderMesh = new THREE.Mesh(viewfinderGeometry, viewfinderMaterial);
            viewfinderMesh.position.y = 0.25;
            cameraGroup.add(viewfinderMesh);
            
            // OLED Screen
            // Replace the existing screenMaterial definition with this
            const createLCDContent = () => {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 192;
            const ctx = canvas.getContext('2d');
            
            
            const updateLCD = () => {
                ctx.fillStyle = '#001122';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#00ff00';
                ctx.font = '24px monospace';
                ctx.fillText(`ISO: 100`, 10, 30);
                ctx.fillText(`f/2.8`, 10, 60);
                ctx.fillText(`1/125`, 10, 90);
                
                ctx.strokeStyle = '#00ff00';
                ctx.strokeRect(200, 10, 40, 20);
                ctx.fillRect(202, 12, 36 * 0.8, 16);
            };
            
            updateLCD();
            return new THREE.CanvasTexture(canvas);
            };
            
            const screenMaterial = new THREE.MeshBasicMaterial({
            map: createLCDContent(),
            emissive: 0x222222,
            emissiveIntensity: 0.5
            });
            
             // Control Dials
             const dialGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.02, 32, 1, false, 0, Math.PI * 2);
            const dialMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x95a5a6,
                metalness: 0.9,
                roughness: 0.3,
                clearcoat: 1
            });
            
            // Mode Dial
            const modeDial = new THREE.Mesh(dialGeometry, dialMaterial);
            modeDial.rotation.x = Math.PI / 2;
            modeDial.position.set(0.2, 0.15, 0);
            cameraGroup.add(modeDial);
            
            // Command Dial
            const commandDial = new THREE.Mesh(dialGeometry, dialMaterial);
            commandDial.rotation.x = Math.PI / 2;
            commandDial.position.set(-0.2, 0.15, 0);
            cameraGroup.add(commandDial);
            
            cameraGroup.scale.set(0.5, 0.5, 0.5);
            cameraGroup.position.set(0, 0, 0);
            camera.add(cameraGroup);
            
            
            // Hot Shoe
            const hotShoeGeometry = new THREE.BoxGeometry(0.2, 0.05, 0.2);
            const hotShoeMesh = new THREE.Mesh(hotShoeGeometry, gripMaterial);
            hotShoeMesh.position.y = 0.35;
            cameraGroup.add(hotShoeMesh);
            
            cameraGroup.scale.set(0.5, 0.5, 0.5);
            cameraGroup.position.set(0, 0, 0);
            camera.add(cameraGroup);
            
            // Enhanced Camera Helper with thicker lines
            const helper = new THREE.CameraHelper(camera);
            helper.material.linewidth = 3; // Increased line width
            helper.material.color.setHex(0xff6600); // Brighter orange color
            helper.visible = true;
            scene.add(helper);
            camera.helper = helper;
            
            
            // Add camera to the scene
            camera.name = `Camera_${objects.length}`;
            addObjectToScene(camera, 'camera');
            updateHierarchy();
            
            setupCameraControls(camera);
            
            if (activeCamera) {
                transitionToCamera(camera);
            }
            
            activeCamera = camera;
            
            
            // Add pop-up flash
            const flashGroup = new THREE.Group();
            const flashBase = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, 0.05, 0.1),
            new THREE.MeshPhysicalMaterial({ color: 0x2c3e50, metalness: 0.8 })
            );
            
            const flashHead = new THREE.Mesh(
            new THREE.BoxGeometry(0.2, 0.1, 0.05),
            new THREE.MeshPhysicalMaterial({ color: 0x2c3e50, metalness: 0.8 })
            );
            flashHead.position.y = 0.05;
            
            const flashBulb = new THREE.Mesh(
            new THREE.CylinderGeometry(0.03, 0.03, 0.02, 16),
            new THREE.MeshPhysicalMaterial({
            color: 0xffffff,
            emissive: 0xffffff,
            emissiveIntensity: 0
            })
            );
            flashBulb.rotation.x = Math.PI / 2;
            flashHead.add(flashBulb);
            
            flashGroup.add(flashBase, flashHead);
            flashGroup.position.set(0, 0.4, -0.1);
            cameraGroup.add(flashGroup);
            
            // Add strap lugs
            const strapLugGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.1, 8);
            const strapLugMaterial = new THREE.MeshPhysicalMaterial({
            color: 0x95a5a6,
            metalness: 0.9
            });
            
            [-0.3, 0.3].forEach(x => {
            const lug = new THREE.Mesh(strapLugGeometry, strapLugMaterial);
            lug.rotation.z = Math.PI / 2;
            lug.position.set(x, 0.1, 0);
            cameraGroup.add(lug);
            });
            
            // Add dial animations
            function animateDials() {
            modeDial.rotation.z += 0.02;
            commandDial.rotation.z -= 0.015;
            }
            
            cameraGroup.userData.controlsActive = false;
            cameraGroup.userData.onControlClick = () => {
            cameraGroup.userData.controlsActive = !cameraGroup.userData.controlsActive;
            };
            
            // Create DOF helper
            const createDOFVisualization = () => {
            const dofGroup = new THREE.Group();
            
            
            const focalPlane = new THREE.Mesh(
                new THREE.PlaneGeometry(2, 2),
                new THREE.MeshBasicMaterial({ 
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.2
                })
            );
            focalPlane.position.z = -5;
            
            dofGroup.add(focalPlane);
            scene.add(dofGroup);
            
            return dofGroup;
            };
            
            const dofHelper = createDOFVisualization();
            
            function animate() {
            requestAnimationFrame(animate);
            if (cameraGroup.userData.controlsActive) {
            animateDials();
            }
            }
            // Start animation
            animate();
            });
            
           
       
            function setupCameraControls(camera) {
                const fovInput = document.querySelector('#cameraFOV input');
                if (fovInput) {
                  fovInput.value = camera.fov;
                  fovInput.addEventListener('input', () => {
                  camera.fov = parseFloat(fovInput.value);
                  camera.updateProjectionMatrix();
                  if (camera.helper) camera.helper.update();
                });
            }
            
            
            const nearInput = document.querySelector('#cameraNear input');
            const farInput = document.querySelector('#cameraFar input');
            
            if (nearInput) {
                nearInput.value = camera.near;
                nearInput.addEventListener('input', () => {
                    camera.near = parseFloat(nearInput.value);
                    camera.updateProjectionMatrix();
                    if (camera.helper) camera.helper.update();
                });
            }
            
            if (farInput) {
                farInput.value = camera.far;
                farInput.addEventListener('input', () => {
                    camera.far = parseFloat(farInput.value);
                    camera.updateProjectionMatrix();
                    if (camera.helper) camera.helper.update();
                });
            }
            }

            function transitionToCamera(targetCamera) {
                const duration = 1.5;
                const startPosition = activeCamera.position.clone();
                const startRotation = activeCamera.rotation.clone();
                const startQuaternion = activeCamera.quaternion.clone();

                const endPosition = targetCamera.position.clone();
                const endRotation = targetCamera.rotation.clone();
                const endQuaternion = targetCamera.quaternion.clone();

                let time = 0;
                const easing = t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;

                function animateTransition() {
                    time += 0.016;
                    const alpha = easing(Math.min(time / duration, 1));

                    activeCamera.position.lerpVectors(startPosition, endPosition, alpha);
                    THREE.Quaternion.slerp(startQuaternion, endQuaternion, activeCamera.quaternion, alpha);

                    if (time < duration) {
                       requestAnimationFrame(animateTransition);
                    } else {
                    activeCamera.position.copy(endPosition);
                    activeCamera.rotation.copy(endRotation);
                    if (activeCamera.helper) activeCamera.helper.update();
                    if (activeCamera.projectionLine) {
                        const positions = new Float32Array([
                           activeCamera.position.x, activeCamera.position.y, activeCamera.position.z,
                           0, 0, 0
                        ]);
                        activeCamera.projectionLine.geometry.setAttribute('position', 
                        new THREE.BufferAttribute(positions, 3));
                        activeCamera.projectionLine.geometry.attributes.position.needsUpdate = true;
                    }
                }
            }

               animateTransition();
            }
        }


       
        // Add this to your init() function or call it when the page loads
        window.addEventListener('load', initializePanelControls);
        document.querySelectorAll('.panel-header').forEach(header => {
            header.addEventListener('click', () => {
                const content = header.nextElementSibling;
                const button = header.querySelector('.expand-button');
                if (content.style.display === 'none') {
                    content.style.display = 'block';
                    button.textContent = '‚ñº';
                } else {
                    content.style.display = 'none';
                    button.textContent = '‚ñ∂';
                }
            });
        });

        // Switch tabs
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
        });
    });



        // functions to update the UI
        function updateLightUI(light) {
            // Update light-specific controls in the UI
            const fovInput = document.querySelector('#cameraFOV input');
            if (fovInput) {
                fovInput.disabled = true;
            }

           
        }
        
        function updateCameraUI(camera) {
            // Update camera-specific controls in the UI
            const fovInput = document.querySelector('#cameraFOV input');
            if (fovInput) {
                fovInput.disabled = false;
                fovInput.value = camera.fov;
            }

           
        }
        
        // Call this in your init function
        function initializeLightAndCameraSystem() {
            setupLightControls();
    
            
            // Make renderer support shadows
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        }
        
        // Add this to your animation loop
        function updateHelpers() {
            objects.forEach(obj => {
                if (obj.helper) {
                    obj.helper.update();
                }
            });
        }

    </script>
<script src="processing/assets.js"></script>
<script src="animations/camera-path.js"></script>

</body>
</html>
