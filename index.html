<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Advanced 3D Editor</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/remixicon/fonts/remixicon.css">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Outlined" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <!--Mirror librarys-->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/theme/monokai.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/hint/show-hint.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/fold/foldgutter.min.css">

    
    <!--Coding librarys-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/javascript/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/xml/xml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/css/css.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/edit/closebrackets.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/edit/matchbrackets.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/hint/show-hint.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/hint/javascript-hint.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/fold/foldcode.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/fold/foldgutter.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/fold/brace-fold.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tern/0.24.3/tern.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/acorn/8.7.0/acorn.min.js"></script>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon-es/0.20.0/cannon-es.min.js"></script>
    <script src="https://unpkg.com/three@0.155.0/examples/js/renderers/WebGPURenderer.js"></script>

    <link href='https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css' rel='stylesheet'>
    <link rel="stylesheet" href="stzle.css">
    <link rel="stylesheet" href="preview.css">
    <link rel="stylesheet" href="tools.css">
    <link rel="stylesheet" href="search.css">
    <link rel="stylesheet" href="gui.css">
    <link rel="stylesheet" href="assets-panel.css">
    <link rel="stylesheet" href="code-editor.css">
    <link rel="stylesheet" href="meuni-bar.css">
</head>
<body>
    
    <div class="editor-container">
       
        <div id="toggle-status" class="toolbar-group">
               
        </div>
        <!-- Top Toolbar -->
        <div class="sidebar"> 
                <button class="tool-btn" id="toggle-lock">
                   <i class="fas fa-unlock"></i>
                </button>
                <button class="tool-btn" id="guiControls">
                    Gui
                </button>
                <button  class="tool-btn" id="toggle-editor">
                    <i class="fa-solid fa-code-merge"></i>
                </button>
                <button class="tool-btn" id="preview-button">
                    <i class="fa-solid fa-gamepad"></i>
                </button>
                <button class="tool-btn" id="translate">
                    <i class="fas fa-arrows-alt"></i>
                </button>
                <button class="tool-btn" id="rotate">
                    <i class="fas fa-sync"></i>
                </button>
                <button class="tool-btn" id="scale">
                    <i class="fas fa-expand-arrows-alt"></i>
                </button>
                <button class="tool-btn" id="materialsEditor">
                    <i class="fas fa-fill-drip"></i> 
                </button>
                <button class="tool-btn" id="addSculptingSphere">
                    <i class="fas fa-paint-brush icon"></i>
                </button>
                <button class="tool-btn" id="snow-controls">
                    <i class="fas fa-snowflake"></i>
                </button>
                <button class="tool-btn" id="lightControls">
                    <i class="fas fa-sun"></i> 
                </button>
                <button class="tool-btn" id="cameraControls">
                   <i class="fas fa-video"></i> 
                </button>
                <button class="tool-btn" id="physicsControls">
                    <i class="fas fa-atom"></i>
                </button>
                <button class="tool-btn" id="modelingControls">
                    <i class='bx bx-buildings'></i>
                </button>
                <button class="tool-btn" id="drawingControls">
                    <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24"><path fill="currentColor" d="M1.999 15V2h13v5h-2V4h-9v9h3v2zm6 5V8h12v5.5h-2V10h-8v8h3.5v2zm8.778 3.684L13.41 13.378l10.258 3.407l-4.656 2.227z"/></svg>
                </button>
        </div>
    
        
        <div class="toolbar">
            <div class="toolbar-group">
                <button class="tool-button" id="newScene">
                    <i class="fas fa-file"></i> New
                </button>
                <button class="tool-button" id="saveScene">
                    <i class="fas fa-save"></i> Save
                </button>
                <button class="tool-button" id="loadScene">
                    <i class="fas fa-folder-open"></i> Load
                </button>
                <button class="tool-button" onclick="toggleAssetsPanel()">
                    Assets
                </button>
                <button class="tool-button">Export</button>
                <button class="tool-button" id="toggle-inspector">Inspector</button>
            </div>
            <div class="toolbar-group">
                <button class="tool-button" id="menuButton" style="background-color: #555;">☰</button>
                <div id="submenuMainBar" class="submenu-main-bar">
                    <div class="menu-item-br" data-submenu="fileMenu">File</div>
                    <div class="menu-item-br" data-submenu="editMenu">Edit</div>
                    <div class="menu-item-br" data-submenu="helpMenu">Help</div>
                </div>
        
                <!-- Child Submenus -->
                <div id="fileMenu" class="child-submenu">
                    <div>New</div>
                    <div>Open</div>
                    <div>Save</div>
                    <div>Export</div>
                </div>
        
                <div id="editMenu" class="child-submenu">
                    <div>Undo</div>
                    <div>Redo</div>
                    <div>Copy</div>
                    <div>Paste</div>
                </div>
        
                <div id="helpMenu" class="child-submenu">
                    <div>Documentation</div>
                    <div>About</div>
                    <div>Support</div>
                </div>

                <button id="toggleContainerButton" class="tool-button" style="background-color: #555; border: none; cursor: pointer;">
                    <svg id="toggle-status" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24">
                        <path id="icon-path" d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1-13h2v6h-2z" fill="#00bcd4"/>
                    </svg>
                </button>
            </div>
            <div id="toolbar-group-shapes" class="toolbar-group">
                <button class="tool-button" id="shapeButton">Shape</button>
                <div id="shapeMenu" class="menu">
                    <button class="tool-button" id="addCube">
                        <i class='bx bx-cube-alt'></i> Cube
                    </button>
                    <button class="tool-button" id="addPlane">
                        <i class="fas fa-square"></i>  Plane<!-- Icon for Plane -->
                    </button>
                    <button class="tool-button" id="addTerrain">
                        <i class="fas fa-border-all"></i>  Terrain <!-- Icon for Plane -->
                    </button>
                    <button class="tool-button" id="addSphere">
                        <i class="fas fa-circle"></i>  Sphere
                    </button>
                    <button class="tool-button" id="addCylinder">
                        <i class='bx bx-cylinder' style='color:#ffffff'></i>  Cylinder
                    </button>
                    <button class="tool-button" id="addRectangularPrism">
                        <i class='bx bx-cuboid'></i> Prism
                    </button>
                    <button class="tool-button" id="addPyramid">
                        <i class='bx bxs-pyramid'></i> Pyramid
                    </button>
                    <button class="tool-button" id="addTorus">
                        <i class="fas fa-ring"></i>  Torus
                    </button>
                </div>
            </div>
        
            <script>

document.addEventListener("DOMContentLoaded", function() {
    const menuButton = document.getElementById("menuButton");
    const submenuMainBar = document.getElementById("submenuMainBar");
    const menuItems = document.querySelectorAll(".menu-item-br");
    const childSubmenus = document.querySelectorAll(".child-submenu");

    // Toggle main menu
    menuButton.addEventListener("click", function(e) {
        submenuMainBar.classList.toggle("active");
        e.stopPropagation();
    });

    // Handle menu item hover
    menuItems.forEach(item => {
        item.addEventListener("mouseenter", function() {
            closeChildMenus();
            const submenuId = this.getAttribute("data-submenu");
            const targetSubmenu = document.getElementById(submenuId);
            if (targetSubmenu) {
                targetSubmenu.classList.add("active");

                // Position submenu relative to the parent
                let rect = this.getBoundingClientRect();
                targetSubmenu.style.top = `${rect.top}px`;
                targetSubmenu.style.left = `${rect.right + 5}px`;
            }
        });
    });

    // Close menus when clicking outside
    document.addEventListener("click", function(e) {
        if (!e.target.closest('.toolbar-group')) {
            submenuMainBar.classList.remove("active");
            closeChildMenus();
        }
    });

    // Close all child submenus
    function closeChildMenus() {
        childSubmenus.forEach(submenu => {
            submenu.classList.remove("active");
        });
    }

    // Prevent submenu from closing when clicking inside
    submenuMainBar.addEventListener("click", function(e) {
        e.stopPropagation();
    });
});
             


            document.addEventListener("DOMContentLoaded", function () {
                document.getElementById('shapeButton').addEventListener('click', function(event) {
                    event.stopPropagation();
                    var menu = document.getElementById('shapeMenu');
                    menu.classList.toggle('show');
                });

                var cameraButton = document.getElementById('cameraTools');
                var cameraMenu = document.getElementById('cameraMenu');

                if (cameraButton && cameraMenu) {
                    cameraButton.addEventListener('click', function(event) {
                       event.stopPropagation();
                       cameraMenu.classList.toggle('show');
                    });
                }


                document.addEventListener('click', function() {
                    var shapeMenu = document.getElementById('shapeMenu');
                    var cameraMenu = document.getElementById('cameraMenu');
                    var listMenu = document.getElementById('submenuMainBar');

                    if (shapeMenu.classList.contains('show')) {
                       shapeMenu.classList.remove('show');
                    }
                    if (cameraMenu && cameraMenu.classList.contains('show')) {
                       cameraMenu.classList.remove('show');
                    }
                });
            });


      


            </script>
            <div class="toolbar-group">
                <button class="tool-button" id="addLight">
                    <i class="fas fa-lightbulb"></i> Light
                </button>
                <button class="tool-button" id="addCameraInit">
                    <i class="fas fa-video"></i> Camera
                </button>
            </div>
            <div id="toolbar-group-camera" class="toolbar-group">
                <button class="tool-button" id="cameraTools">
                    <i class="fas fa-info-circle"></i> Camera
                </button>
                <div id="cameraMenu" class="menu">
                    <button class="tool-button" id="addPointBtn">
                        <i class="fa-solid fa-bezier-curve"></i> Add Point
                    </button>
                    <button class="tool-button" id="startCameraBtn">
                        <i class="fa-solid fa-person-walking-arrow-loop-left"></i> Start Camera
                    </button>
                    <button class="tool-button" id="toggleLookAtBtn">
                        <i class="fas fa-eye"></i> Toggle Look At
                    </button>
                    <button class="tool-button" id="startRecordingBtn">
                        <i class='bx bxs-video-recording'></i> Start Recording
                    </button>
                    <button class="tool-button" id="stopRecordingBtn">
                        <i class='bx bx-stop-circle'></i> Stop Recording
                    </button>
                </div>
            </div>
            <div class="toolbar-group">
                <div  class="tool-button-status" id="statusBar">
                    <span id="recordingStatus">Recording: Stopped</span>
                    <span id="recordingTimer">00:00</span>
                </div>
            </div>
            <div class="toolbar-group">
                <button class="tool-button"  id="node-editor-toggle">Node</button>
            </div>

            <div class="toolbar-group">
                <button class="tool-button"  id="toggleAnimator">Animator</button>
            </div>
        </div>

        <!-- Left Panel - Hierarchy -->
        <div id="hierarchy-panel"  class="hierarchy-panel">
            <div class="panel-header" style="cursor: pointer;">
                <i class="fas fa-sitemap" ></i> Hierarchy 
                <span class="expand-button"  style="margin-left: 30px;">▼</span>
            </div>
            <div class="hierarchy-search">
                <input type="text" id="hierarchy-search-input" placeholder="Search objects...">
                <button id="hierarchy-search-clear">×</button>
            </div>
            <div class="hierarchy-content" id="hierarchy-content">
                <!-- Hierarchy items will be added here dynamically -->
            </div>
            <div class="panel-header">
                <i class="fa-solid fa-paint-brush"></i> Brush Model Settings
                <span class="expand-button"  style="margin-left: 30px;">▼</span>
            </div>
            <div id="brush-panel" >
                <div class="brush-controls" >
                    <label>Brush Size</label>
                    <input type="range" id="brush-size" min="0.5" max="10" step="0.1" value="2">
                        
                    <label>Density</label>
                    <input type="range" id="brush-density" min="1" max="20" value="5">
                        
                    <label>Upload Model</label>
                    <input type="file" id="model-upload" accept=".glb,.gltf">
                    
                    <div class="brush-actions" style="margin: 10px auto;  display: flex;">
                        <button class="brush-button" onclick="brushSystem.undo()">Undo</button>
                        <button class="brush-button" onclick="brushSystem.redo()">Redo</button>
                    </div>
                </div>
            </div>
            <div class="resize-handle-hierarchy"></div>
        </div>

        <!-- Main Viewport -->
        <div class="viewport" id="viewportRenderer">
            <div id="renderer-container">
                <div id="render-container">
                    <div id="axis-controls" class="axis-controls">
                        <div class="axis-button" id="axis-x" onclick="setCameraView('x')">X</div>
                        <div class="axis-button" id="axis-y" onclick="setCameraView('y')">Y</div>
                        <div class="axis-button" id="axis-z" onclick="setCameraView('z')">Z</div>
                        <div class="axis-button" id="top" onclick="setCameraView('top')"><i class="fa-solid fa-arrow-up-long"></i></div>
                        <div class="axis-button" id="bottom" onclick="setCameraView('bottom')"><i class="fa-solid fa-arrow-down"></i></div>
                        <div class="axis-button" id="diagonal" onclick="setCameraView('diagonal')"><i class="fa-solid fa-square-arrow-up-right"></i></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right Panel - Inspector -->
        <div id="inspector-panel" class="inspector-panel">
            
            <div class="panel-header">
                <i class="fas fa-info-circle"></i> Inspector
            </div>

            <div class="search-group">
                <input type="text" id="search-input" class="search-input" placeholder="Search..." />
            </div>
        
            <div class="property-group1" id="GuiContainer" style="display: none;">
                <div id="gui-container">
                   <!--Gui Interface-->
                </div>
            </div>
            <div class="property-group">
                <h3>Transform</h3>
                <div class="property-row">
                    <span class="property-label">Pos</span>
                    <div class="vector-inputs">
                        <input type="number" class="property-input" id="posX" step="0.1">
                        <input type="number" class="property-input" id="posY" step="0.1">
                        <input type="number" class="property-input" id="posZ" step="0.1">
                    </div>
                </div>
                <div class="property-row">
                    <span class="property-label">Rot</span>
                    <div class="vector-inputs">
                        <input type="number" class="property-input" id="rotX" step="0.1">
                        <input type="number" class="property-input" id="rotY" step="0.1">
                        <input type="number" class="property-input" id="rotZ" step="0.1">
                    </div>
                </div>
                <div class="property-row">
                    <span class="property-label">Scl</span>
                    <div class="vector-inputs">
                        <input type="number" class="property-input" id="scaleX" step="0.1">
                        <input type="number" class="property-input" id="scaleY" step="0.1">
                        <input type="number" class="property-input" id="scaleZ" step="0.1">
                    </div>
                </div>
            </div>

          
          
            <div class="physics-controls"  id="physics-controls" style="display: none;">
                <h3>Physics Forces</h3>
                <button class="panel-button" id="apply-physics">Apply Physics</button>

                <div class="control-group">
                    <div class="slider-container">
                        <label>Gravity:</label>
                        <input type="range" id="gravity-strength" min="-20" max="20" value="-9.81" step="0.1">
                        <span id="gravity-value">-9.81</span>
                    </div>
                </div>
                <div class="control-group">
                    <h4>Wind Zone</h4>
                    <div class="slider-container">
                        <label>Strength:</label>
                        <input type="range" id="wind-strength" min="0" max="50" value="10" step="0.1">
                        <span id="wind-value">10</span>
                    </div>
                    <div class="slider-container">
                        <label>Radius:</label>
                        <input type="range" id="wind-radius" min="1" max="50" value="10" step="0.5">
                        <span id="radius-value">10</span>
                    </div>
                </div>
                <div class="force-buttons">
                    <button class="force-button" id="add-wind">Add Wind Zone</button>
                    <button class="force-button" id="add-vortex">Add Vortex</button>
                </div>
                <div class="card">
                    <h2>Cloth Physics Controls</h2>
                    <div id="controls">
                        <button class="panel-button" id="addCloth">Add cloth</button>
                        <button class="panel-button"  id="toggleWind">Change Wind</button>
                        <button class="panel-button" id="removeCloth">Remove cloth</button>
                    </div>
                </div>              
            </div>
            <style>
                .card { width: 100%; padding: 5px;  }
                .slider-container { margin-bottom: 15px; }
                .label { display: flex; justify-content: space-between; }
                .separator { border-top: 1px solid #ddd; margin: 15px 0; }
                .switch { cursor: pointer; }
            </style>
           


            <script>
                document.getElementById('apply-physics').addEventListener('click', () => {
               if (!selectedObject) {
                console.warn("No object selected.");
                return;
              }

            physicsManager.addPhysicsToObject(selectedObject, {
                mass: 5,
                friction: 0.9,
                restitution: 0.7
            });

           console.log("Physics applied to", selectedObject.name);
           });


  function applyPhysicsToSelectedObject(object) {
    const shape = getCannonShapeFromObject(object);
    if (!shape) {
        console.error("Unable to determine physics shape for object.");
        return;
    }

    const body = new CANNON.Body({
        mass: 5, // Set mass to make it fall
        shape: shape,
        position: new CANNON.Vec3(object.position.x, object.position.y, object.position.z),
        quaternion: new CANNON.Quaternion(object.quaternion.x, object.quaternion.y, object.quaternion.z, object.quaternion.w),
    });

    world.addBody(body);
    object.userData.physicsBody = body;
}

// Function to determine the appropriate CANNON.js shape
function getCannonShapeFromObject(object) {
    if (object.geometry instanceof THREE.BoxGeometry) {
        const size = new THREE.Vector3();
        object.geometry.computeBoundingBox();
        object.geometry.boundingBox.getSize(size);
        return new CANNON.Box(new CANNON.Vec3(size.x / 2, size.y / 2, size.z / 2));
    }
    if (object.geometry instanceof THREE.SphereGeometry) {
        return new CANNON.Sphere(object.geometry.parameters.radius);
    }
    return null;
}

</script>


<div class="viewport-container" style="display: none;">                
    <div class="model-preview-container">
        <canvas id="preview-canvas"></canvas>
        <div class="model-info">
            <span class="model-name"></span>
            <div class="model-stats"></div>
        </div>
    </div>
</div>
            
            <div class="modeling-tools" id="modelingTools" style="display: none;">
                <div class="panel-header">
                    <span>Mesh Manipulation Tools</span>
                    <span class="expand-button">▼</span>
                </div>
                <div class="panel-content">
                   
                    
                    <div class="selection-controls">
                        <button id="toggle-modeling" class="panel-button">Modeling Mode</button>
                        <div class="button-container">
                            <button id="select-vertex" class="panel-button-tool" disabled>
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                    <!-- Adjusted Cube -->
                                    <path d="M4 6L12 4L20 6L20 14L12 16L4 14L4 6Z" fill="none" stroke="currentColor" stroke-width="2"/>
                                    <path d="M4 6L12 8L20 6" fill="none" stroke="currentColor" stroke-width="2"/>
                                    <path d="M12 8L12 16" fill="none" stroke="currentColor" stroke-width="2"/>
                                    
                                    <!-- Vertex (red circle) -->
                                    <circle cx="12" cy="8" r="1" fill="red"/>
                                </svg>
                            </button>
                        
                            <button id="select-edge" class="panel-button-tool" disabled>
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                    <!-- Adjusted Cube -->
                                    <path d="M4 6L12 4L20 6L20 14L12 16L4 14L4 6Z" fill="none" stroke="currentColor" stroke-width="2"/>
                                    <path d="M4 6L12 8L20 6" fill="none" stroke="currentColor" stroke-width="2"/>
                                    <path d="M12 8L12 16" fill="none" stroke="currentColor" stroke-width="2"/>
                                    
                                    <!-- Edge (blue lines) -->
                                    <line x1="4" y1="6" x2="12" y2="8" stroke="blue" stroke-width="2"/>
                                    <line x1="12" y1="8" x2="20" y2="6" stroke="blue" stroke-width="2"/>
                                </svg>
                            </button>
                        
                            <button id="select-face" class="panel-button-tool" disabled>
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                    <!-- Adjusted Cube -->
                                    <path d="M4 6L12 4L20 6L20 14L12 16L4 14L4 6Z" fill="none" stroke="currentColor" stroke-width="2"/>
                                    <path d="M4 6L12 8L20 6" fill="none" stroke="currentColor" stroke-width="2"/>
                                    <path d="M12 8L12 16" fill="none" stroke="currentColor" stroke-width="2"/>
                                    
                                    <!-- Face (green square) -->
                                    <rect x="8" y="10" width="6" height="6" fill="green"/>
                                </svg>
                            </button>
                        </div>
                        <div id="controls">
                            <h3>Building</h3>
                            <label class="control-label">Width : <input type="number" id="building-width" value="5"></label>
                            <label class="control-label"> Height : <input type="number" id="building-height" value="10"></label>
                            <label class="control-label">Depth : <input type="number" id="building-depth" value="5"></label>
                        </div>
                    </div>

                    <div>
                        <label>Vertex Size:</label>
                        <input type="range" id="vertexSizeSlider" min="0.1" max="2" step="0.1" value="0.5">
                    </div>
                    <div>
                        <label>Edge Thickness:</label>
                        <input type="range" id="edgeThicknessSlider" min="1" max="5" step="1" value="2">
                    </div>
                    <div>
                        <label>Subdivision Levels:</label>
                        <input type="range" id="subdivisionLevelsSlider" min="0" max="4" step="1" value="1">
                    </div>
                    <div>
                        <label>Face Opacity:</label>
                        <input type="range" id="faceOpacitySlider" min="0" max="1" step="0.1" value="0.5">
                    </div>
                </div>
            </div>

            


            <div class="panel" id="lights" style="display: none;">
                <div class="panel-header">
                    <span>Lights</span>
                    <span class="expand-button">▼</span>
                </div>
                <div class="panel-content">
                    <button id="addPointLight" class="panel-button">
                        <img src="piontlight.png" alt="">
                    </button>
                    <button id="addSunLight" class="panel-button">
                        <img src="sun.png" alt="">
                    </button>
                    <button id="addSpotLight" class="panel-button">
                        <img src="headlight.png">
                    </button>
                    <button id="addAreaLight" class="panel-button">
                        <img src="arealight.png" alt="">
                    </button>
                    <button id="addDirectionalLight" class="panel-button">
                        <img src="directional-light.png" alt="">
                    </button>
                    <button id="addHemisphereLight" class="panel-button">
                        <img src="HemisphereLight.png" alt="">
                    </button>
                    <button id="addLensflareLight" class="panel-button">
                        <img src="Lensflare.png" alt="">
                    </button>
                    <button id="addVolumetricLight" class="panel-button">
                        <img src="volumitriclight.png" alt="">
                    </button>
                    
                    <!-- Light Controls -->
                    <div class="light-controls">
                        <div class="control-group">
                            <label class="control-label">Light Intensity</label>
                            <input type="range" id="lightIntensity" min="0" max="2" step="0.1" value="1">
                        </div>
                        <div class="control-group">
                            <label class="control-label">Light Color</label>
                            <input type="color" id="lightColor" value="#ffffff">
                        </div>
                    </div>
                </div>
            </div>

            <div class="panel" id="Cameras" style="display: none;">
                <div class="panel-header">
                    <span>Camera</span>
                    <span class="expand-button">▼</span>
                </div>
                <div class="panel-content">
                    
                    
                    <div class="button-container">
                        <!-- Add Camera (Standard Camera) -->
                        <button id="addCamera" class="panel-button-tool title="Add Camera">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Camera body -->
                                <rect x="4" y="6" width="16" height="12" rx="2" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Lens -->
                                <circle cx="12" cy="12" r="3" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Top trapezoid (viewfinder) -->
                                <path d="M8 6L10 4L14 4L16 6" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Plus sign -->
                                <path d="M20 12H22M21 11V13" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Add Camera Orto (Orthographic Camera) -->
                        <button id="addCameraOrto" class="panel-button-tool" title="Add Ortho Camera">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Camera body -->
                                <rect x="4" y="6" width="16" height="12" rx="2" fill="none" stroke="#1db34d" stroke-width="2"/>
                                <!-- Orthographic lines (indicating projection) -->
                                <line x1="10" y1="9" x2="10" y2="15" stroke="#1db34d" stroke-width="2"/>
                                <line x1="14" y1="9" x2="14" y2="15" stroke="#1db34d" stroke-width="2"/>
                                <!-- Top trapezoid -->
                                <path d="M8 6L10 4L14 4L16 6" fill="none" stroke="#1db34d" stroke-width="2"/>
                                <!-- Plus sign -->
                                <path d="M20 12H22M21 11V13" fill="none" stroke="#1db34d" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Add Cube Camera (Cubic/Panoramic Camera) -->
                        <button id="addCubeCamera" class="panel-button-tool" title="Add Cube Camera">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Cube shape -->
                                <path d="M6 6L12 4L18 6L18 14L12 16L6 14L6 6Z" fill="none" stroke="#1db34d" stroke-width="2"/>
                                <path d="M6 6L12 8L18 6" fill="none" stroke="#1db34d" stroke-width="2"/>
                                <path d="M12 8L12 16" fill="none" stroke="#1db34d" stroke-width="2"/>
                                <!-- Lens on front face -->
                                <circle cx="12" cy="11" r="2" fill="none" stroke="#1db34d" stroke-width="2"/>
                                <!-- Plus sign -->
                                <path d="M20 12H22M21 11V13" fill="none" stroke="#1db34d" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Add Stereo Camera (Dual Lens) -->
                        <button id="addStereoCamera" class="panel-button-tool" title="Add Stereo Camera">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Camera body -->
                                <rect x="4" y="6" width="16" height="12" rx="2" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Two lenses (stereo) -->
                                <circle cx="9" cy="12" r="2" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <circle cx="15" cy="12" r="2" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Top trapezoid -->
                                <path d="M8 6L10 4L14 4L16 6" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Plus sign -->
                                <path d="M20 12H22M21 11V13" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    </div>
                    <div class="input-group">
                        <label id="cameraFOV">FOV</label>
                        <input type="number" value="60">
                    </div>
                    
                    <!-- Camera list will be inserted here -->
                </div>
            </div>

            <div class="panel" id="drawingMode" style="display: none;">
                <div class="panel-header">
                    <span>Drawing</span>
                    <span class="expand-button">▼</span>
                </div>
                <div class="panel-content">
                    <div class="button-container">
                        <!-- Draw Mode (F) -->
                        <button class="panel-button-tool" id="toggle-draw" title="Draw Mode (F)">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Pencil/Brush -->
                                <path d="M6 18L18 6" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Tip -->
                                <path d="M16 8L18 6L20 8" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Subtle 'F' hint (optional) -->
                                <path d="M8 16H10M8 14H9" fill="none" stroke="#ffffff" stroke-width="1"/>
                            </svg>
                        </button>
                    
                        <!-- Extrude Mode (E) -->
                        <button class="panel-button-tool" id="toggle-extrude" title="Extrude Mode (E)">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Base shape -->
                                <rect x="8" y="14" width="8" height="4" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Extruded top -->
                                <rect x="8" y="6" width="8" height="4" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Connecting lines -->
                                <path d="M8 14L8 10M16 14L16 10" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Up arrow -->
                                <path d="M12 10L12 6L14 8" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Clear (L) -->
                        <button class="panel-button-tool" id="clear" title="Clear (L)">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Eraser -->
                                <rect x="6" y="12" width="12" height="6" rx="2" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Clearing lines -->
                                <path d="M8 14L16 14M8 16L16 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Subtle 'L' hint (optional) -->
                                <path d="M18 12V16" fill="none" stroke="#ffffff" stroke-width="1"/>
                            </svg>
                        </button>
                    </div>
                    <div class="slider-container">
                        <input type="range" id="brush-" min="0.1" max="2" step="0.1" value="0.5">
                        <span>Brush Size: 0.5</span>
                    </div>
                    <div class="slider-container">
                        <input type="range" id="snapping" min="0" max="1" step="0.1" value="0.3">
                        <span>Snapping: 0.3</span>
                    </div>
                    <div class="slider-container">
                        <input type="range" id="extrude-height" min="0.1" max="5" step="0.1" value="1">
                        <span>Extrude: 1.0</span>
                    </div>
                </div>
                <div style="background-color: #e74c3c; padding: 4px;  margin: 10px auto; margin-right: 10px; margin-left: 10px;" class="status" id="status">Ready</div>
            </div>
        

            <!-- Material Editor Panel -->
            <div class="material-editor" id="material-editor"  style="display: none;">
                <div class="panel-header">Material Editor</div>
                <div class="property-group">
                    <div class="property-row">
                        <span class="property-label">Color</span>
                        <input type="color" class="property-input" id="materialColor">
                    </div>
                    <div class="property-row">
                        <span class="property-label">Metalness</span>
                        <input type="range" class="property-input" id="materialMetalness" min="0" max="1" step="0.1">
                    </div>
                    <div class="property-row">
                        <span class="property-label">Roughness</span>
                        <input type="range" class="property-input" id="materialRoughness" min="0" max="1" step="0.1">
                    </div>
                    <div class="property-row">
                        <label for="materialOpacity">Opacity:</label>
                        <input type="range" id="materialOpacity" min="0" max="1" step="0.01" value="1">

                        <label for="materialTexture">Texture:</label>
                        <input type="file" id="materialTexture" accept="image/*">
                    </div>
                    <div class="property-row">
                        <h3>MTXT</h3>
                        <div id="materialTextures" style=" margin: 10px auto; width: 100%; height: auto;">

                        </div>
                    </div>
                </div>
            </div>
                <div class="controls" id="snow-sittings" style="display: none;">
                    <div class="panel-header">Advanced Snow System</div>
                    <div class="property-group">
                        <button class="panel-button" id="toggleSnow">Toggle Snow</button>
                        <div class="control-group">
                            <label>Density: <span id="densityValue">1000</span></label>
                            <input type="range" id="density" min="100" max="5000" value="1000">
                        </div>
                        <div class="control-group">
                            <label>Size: <span id="sizeValue">0.1</span></label>
                            <input type="range" id="size" min="0.01" max="0.5" value="0.1" step="0.01">
                        </div>
                        <div class="control-group">
                            <label>Speed: <span id="speedValue">1</span></label>
                            <input type="range" id="speed" min="0.1" max="5" value="1" step="0.1">
                        </div>
                        <div class="control-group">
                            <label>Wind: <span id="windValue">0</span></label>
                            <input type="range" id="wind" min="-5" max="5" value="0" step="0.1">
                        </div>
                        <div class="control-group">
                            <label>Turbulence: <span id="turbulenceValue">0.5</span></label>
                            <input type="range" id="turbulence" min="0" max="2" value="0.5" step="0.1">
                        </div>

                        <div class="weather-effects">
                            <div class="button-container">
                                <!-- Storm -->
                                <button class="panel-button-tool" id="storm" title="Storm">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                        <!-- Swirling wind -->
                                        <path d="M6 12C8 10 10 10 12 12C14 14 16 14 18 12" fill="none" stroke="#ffffff" stroke-width="2"/>
                                        <!-- Lightning bolt -->
                                        <path d="M12 8L14 12L12 16L14 20" fill="none" stroke="#ffffff" stroke-width="2"/>
                                    </svg>
                                </button>
                            
                                <!-- Blizzard -->
                                <button class="panel-button-tool" id="blizzard" title="Blizzard">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                        <!-- Wind lines -->
                                        <path d="M6 12H10M14 12H18" fill="none" stroke="#ffffff" stroke-width="2"/>
                                        <!-- Snowflake -->
                                        <path d="M12 8V16M10 10L14 14M10 14L14 10" fill="none" stroke="#ffffff" stroke-width="2"/>
                                    </svg>
                                </button>
                            
                                <!-- Gentle -->
                                <button class="panel-button-tool" id="gentle" title="Gentle">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                        <!-- Soft flowing curves -->
                                        <path d="M6 14C8 12 10 12 12 14C14 16 16 16 18 14" fill="none" stroke="#ffffff" stroke-width="2"/>
                                        <path d="M6 16C8 14 10 14 12 16C14 18 16 18 18 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                                    </svg>
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="property-group">
                        <div id="controls">
                            <div class="button-container">
                                <!-- Toggle Particles -->
                                <button class="panel-button-tool" id="toggleParticles" title="Toggle Particles">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                        <!-- Particle dots -->
                                        <circle cx="8" cy="10" r="1" fill="#ffffff" stroke="#ffffff" stroke-width="2"/>
                                        <circle cx="12" cy="14" r="1" fill="#ffffff" stroke="#ffffff" stroke-width="2"/>
                                        <circle cx="16" cy="10" r="1" fill="#ffffff" stroke="#ffffff" stroke-width="2"/>
                                        <!-- Toggle switch -->
                                        <rect x="10" y="16" width="4" height="2" fill="none" stroke="#ffffff" stroke-width="2"/>
                                        <line x1="12" y1="16" x2="12" y2="18" stroke="#ffffff" stroke-width="2"/>
                                    </svg>
                                </button>
                            
                                <!-- Increase Particles -->
                                <button class="panel-button-tool" id="increaseParticles" title="Increase Particles">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                        <!-- Particle dots -->
                                        <circle cx="8" cy="14" r="1" fill="#ffffff" stroke="#ffffff" stroke-width="2"/>
                                        <circle cx="12" cy="16" r="1" fill="#ffffff" stroke="#ffffff" stroke-width="2"/>
                                        <circle cx="16" cy="14" r="1" fill="#ffffff" stroke="#ffffff" stroke-width="2"/>
                                        <!-- Up arrow -->
                                        <path d="M12 12L12 6M10 8L12 6L14 8" fill="none" stroke="#ffffff" stroke-width="2"/>
                                    </svg>
                                </button>
                            
                                <!-- Decrease Particles -->
                                <button class="panel-button-tool" id="decreaseParticles" title="Decrease Particles">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                        <!-- Particle dots -->
                                        <circle cx="8" cy="10" r="1" fill="#ffffff" stroke="#ffffff" stroke-width="2"/>
                                        <circle cx="12" cy="8" r="1" fill="#ffffff" stroke="#ffffff" stroke-width="2"/>
                                        <circle cx="16" cy="10" r="1" fill="#ffffff" stroke="#ffffff" stroke-width="2"/>
                                        <!-- Down arrow -->
                                        <path d="M12 12L12 18M10 16L12 18L14 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                                    </svg>
                                </button>
                            
                                <!-- Particle Color (Color Picker) -->
                                <button class="panel-button-tool" title="Particle Color">
                                    <input type="color" id="particleColor" value="#ffcc88" />
                                </button>
                            </div>
                        </div>
                        
                    </div>
                </div>
            
        
            <div class="sculpting-tools" id="sculpting-tools"  style="display: none;">
                <div class="panel-header">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" d="m15.47 13.79l-2.58-1.03L6 15.05l-4-1.54v2.1l4 1.34zm-4.9-2.37L8 8H2v3.61l4 1.34zM6 19.05l-4-1.33V22h20l-4.97-6.62zM17 6V1l-5-1l-3 2v4l3 2zm1.5 1L16 9v3l2.5 2l4.5-2V8z"/></svg>
                    Sculpting Tools
                </div>
                <div class="property-group">
                    <!-- Basic Tools -->
                    <div class="button-container">
                        <!-- Raise/Lower -->
                        <button class="panel-button-tool" id="raiseLower" title="Raise/Lower">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Up arrow -->
                                <path d="M12 6L12 18" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <path d="M8 10L12 6L16 10" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Down arrow -->
                                <path d="M8 14L12 18L16 14" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Smooth (Reused) -->
                        <button class="panel-button-tool" id="smooth" title="Smooth">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Smooth flowing curve -->
                                <path d="M6 16C8 12 10 10 12 12C14 14 16 12 18 8" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Subtle wave -->
                                <path d="M6 14C8 13 10 13 12 14C14 15 16 15 18 14" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Flatten -->
                        <button class="panel-button-tool" id="flatten" title="Flatten">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Flat surface -->
                                <line x1="6" y1="12" x2="18" y2="12" stroke="#ffffff" stroke-width="2"/>
                                <!-- Downward pressure arrows -->
                                <path d="M8 8L8 12L10 10" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <path d="M16 8L16 12L14 10" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Noise -->
                        <button class="panel-button-tool" id="noise" title="Noise">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Jagged noise line -->
                                <path d="M6 12L8 14L10 10L12 14L14 10L16 14L18 12" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Subtle secondary noise -->
                                <path d="M6 14L8 12L10 16L12 12L14 16L16 12L18 14" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    </div>

                    <!-- Advanced Tools -->
                    <div class="button-container">
                        <!-- Pinch (Reused) -->
                        <button class="panel-button-tool" id="pinch" title="Pinch">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Converging arrows -->
                                <path d="M6 8L12 12L6 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <path d="M18 8L12 12L18 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Center pinch point -->
                                <circle cx="12" cy="12" r="1" fill="#ffffff" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Clay -->
                        <button class="panel-button-tool" id="clay" title="Clay">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Clay lump -->
                                <path d="M8 10C6 12 6 16 8 18C10 20 14 20 16 18C18 16 18 12 16 10C14 8 10 8 8 10Z" 
                                      fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Shaping hint -->
                                <path d="M10 12C11 11 13 11 14 12" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Scrape -->
                        <button class="panel-button-tool" id="scrape" title="Scrape">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Scraping edge -->
                                <path d="M6 16L18 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Tool angle -->
                                <path d="M18 16L14 12L10 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Scraped material -->
                                <path d="M8 18L10 18M14 18L16 18" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Fill -->
                        <button class="panel-button-tool" id="fill" title="Fill">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Fill shape -->
                                <rect x="8" y="8" width="8" height="8" rx="2" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Inward flow arrows -->
                                <path d="M12 6V8M12 18V16M6 12H8M18 12H16" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Texture Paint -->
                        <button class="panel-button-tool" id="texturePaint" title="Texture Paint">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Paintbrush handle -->
                                <path d="M6 18L12 6" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Brush tip -->
                                <path d="M10 10C11 9 13 9 14 10" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Texture dots -->
                                <circle cx="12" cy="12" r="1" fill="#ffffff" stroke="#ffffff" stroke-width="2"/>
                                <circle cx="14" cy="14" r="1" fill="#ffffff" stroke="#ffffff" stroke-width="2"/>
                                <circle cx="10" cy="14" r="1" fill="#ffffff" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    </div>
            
                    <!-- Brush Controls -->
                    <div class="brush-controls">
                        <label>Brush Size:
                            <input type="range" id="brushSize" min="0.5" max="5" step="0.1" value="1.5">
                        </label>
                        <label>Brush Strength:
                            <input type="range" id="brushStrength" min="0.01" max="0.5" step="0.01" value="0.1">
                        </label>
                    </div>
            
                    <!-- Symmetry Controls -->
                    <div class="tool-options">
                        <label>
                            <input type="checkbox" id="symmetryToggle"> Enable Symmetry
                        </label>
                        <select id="symmetryAxis">
                            <option value="x">X Axis</option>
                            <option value="z">Z Axis</option>
                        </select>
                    </div>
            
                    <!-- History Controls -->
                    <div class="history-controls">
                        <button class="panel-button" id="undo"><i class="fas fa-undo"></i></button>
                        <button class="panel-button" id="redo"><i class="fas fa-redo"></i></button>
                    </div>
            
                    <!-- Texture Upload -->
                    <input type="file" id="uploadTexture" accept="image/*" style="display: none;">
                    <button class="panel-button" id="selectTexture">Upload Texture</button>
                </div>

                <div class="advanced-tools">
                    <div class="button-container">
                        <!-- Terrace -->
                        <button class="panel-button-tool" id="terrace" title="Terrace">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Stepped levels -->
                                <path d="M6 18H18M6 14H18M6 10H18" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Connecting lines -->
                                <path d="M6 18V10M18 18V10" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Erosion -->
                        <button class="panel-button-tool" id="erosion" title="Erosion">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Wavy, worn lines -->
                                <path d="M6 16C8 14 10 14 12 16C14 18 16 18 18 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <path d="M6 14C8 12 10 12 12 14C14 16 16 16 18 14" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Ridge -->
                        <button class="panel-button-tool" id="ridge" title="Ridge">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Sharp peak -->
                                <path d="M6 18L12 6L18 18" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Base line -->
                                <path d="M6 18H18" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Canyon -->
                        <button class="panel-button-tool" id="canyon" title="Canyon">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Deep valley -->
                                <path d="M6 6L8 18L16 18L18 6" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Center dip -->
                                <path d="M8 18L12 14L16 18" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Plateau -->
                        <button class="panel-button-tool" id="plateau" title="Plateau">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Flat elevated surface -->
                                <path d="M6 14H18" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Slopes to base -->
                                <path d="M6 14L4 18H20L18 14" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Slope -->
                        <button class="panel-button-tool" id="slope" title="Slope">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Angled incline -->
                                <path d="M6 18L18 6" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Base and top lines -->
                                <path d="M6 18H4M18 6H20" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Blur Heights -->
                        <button class="panel-button-tool" id="blur" title="Blur Heights">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Soft wavy lines -->
                                <path d="M6 12C8 10 10 10 12 12C14 14 16 14 18 12" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <path d="M6 14C8 12 10 12 12 14C14 16 16 16 18 14" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Sharpen -->
                        <button class="panel-button-tool" id="sharpen" title="Sharpen">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Crisp peak -->
                                <path d="M6 16L12 8L18 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Base line -->
                                <path d="M6 16H18" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    </div>
                    
                    <div class="tool-settings">
                        <label>Steps:
                            <input type="range" id="terraceSteps" min="2" max="10" value="4">
                        </label>
                        <label>Erosion Strength:
                            <input type="range" id="erosionStrength" min="0.1" max="1.0" value="0.5">
                        </label>
                        <label>Ridge Height:
                            <input type="range" id="ridgeHeight" min="0.1" max="2.0" value="1.0">
                        </label>
                    </div>
                </div>
            </div>

            <div id="sculpting-character-tools" class="character-sclupting" style="display: none;">
                <div class="panel-header">Character Sculpting</div>
                <div class="property-group">
                    <div class="group-header">Brush Settings</div>
                    <div class="brush-controls">
                        <label>Sculpting: <input type="checkbox" id="sculptingToggle" checked></label>
                        <label>Brush Size: <input type="range" id="brushSizeSc" min="0.05" max="1.0" step="0.05" value="0.2"></label>
                        <span id="brushSizeValue">0.2</span>
                        <label>Brush Strength: <input type="range" id="brushStrength" min="0.01" max="0.5" step="0.01" value="0.1"></label>
                        <span id="brushStrengthValue">0.1</span>
                        <label>Brush Falloff: <input type="range" id="brushFalloff" min="0.1" max="2.0" step="0.1" value="0.5"></label>
                        <span id="brushFalloffValue">0.5</span>
                    </div>
                </div>
                <div class="property-group">
                    <div class="group-header">Basic Shape Tools</div>
                    <div class="button-container">
                        <!-- Face Shape -->
                        <button class="panel-button-tool" id="faceShape" title="Face Shape">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Full face outline -->
                                <path d="M12 4C8 4 6 8 6 12C6 16 8 20 12 20C16 20 18 16 18 12C18 8 16 4 12 4Z" 
                                      fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Jawline curve -->
                                <path d="M8 16C9 18 11 19 12 19C13 19 15 18 16 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Nose Sculpt -->
                        <button class="panel-button-tool" id="noseSculpt" title="Nose Sculpt">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Nose profile -->
                                <path d="M12 6V10C12 12 13 14 14 15C13 16 12 17 12 18" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Nostril hint -->
                                <path d="M12 18C11.5 17.5 11 17 11 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Cheek Definition -->
                        <button class="panel-button-tool" id="cheekDefinition" title="Cheek Definition">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Face outline (simplified) -->
                                <path d="M8 6C6 8 6 16 8 18C10 20 14 20 16 18C18 16 18 8 16 6" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Cheekbone highlight -->
                                <path d="M9 12C10 13 11 13 12 12" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <path d="M12 12C13 13 14 13 15 12" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Jaw Sculpt -->
                        <button class="panel-button-tool" id="jawSculpt" title="Jaw Sculpt">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Jawline -->
                                <path d="M8 12C8 16 9 18 12 20C15 18 16 16 16 12" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Chin point -->
                                <path d="M12 20V22" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Forehead Shape -->
                        <button class="panel-button-tool" id="foreheadShape" title="Forehead Shape">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Forehead contour -->
                                <path d="M8 6C8 4 10 4 12 4C14 4 16 4 16 6C16 8 14 10 12 10C10 10 8 8 8 6Z" 
                                      fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Hairline hint -->
                                <path d="M8 6H16" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    </div>
                </div>
        
                <div class="property-group">
                    <div class="group-header">Advanced Shape Tools</div>
                    <div class="button-container">
                        <!-- Chin Sculpt -->
                        <button class="panel-button-tool" id="chinSculpt" title="Chin Sculpt">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Chin outline -->
                                <path d="M10 12C9 14 9 16 12 18C15 16 15 14 14 12" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Chin point -->
                                <path d="M12 18V20" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Temple Sculpt -->
                        <button class="panel-button-tool" id="templeSculpt" title="Temple Sculpt">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Temple area (side of forehead) -->
                                <path d="M8 6C8 4 10 4 12 6C14 4 16 4 16 6" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Side curve -->
                                <path d="M8 6C6 8 6 12 8 14" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <path d="M16 6C18 8 18 12 16 14" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Brow Ridge -->
                        <button class="panel-button-tool" id="browRidge" title="Brow Ridge">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Brow ridge arc -->
                                <path d="M8 8C9 6 11 6 12 8C13 6 15 6 16 8" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Eyebrow hint -->
                                <path d="M8 8C9 9 11 10 12 10C13 10 15 9 16 8" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Eye Socket -->
                        <button class="panel-button-tool" id="eyeSocket" title="Eye Socket">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Eye socket shape -->
                                <path d="M8 10C9 8 11 8 12 10C13 8 15 8 16 10C16 12 14 14 12 14C10 14 8 12 8 10Z" 
                                      fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Pupil hint -->
                                <circle cx="12" cy="12" r="1" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Lip Shape -->
                        <button class="panel-button-tool" id="lipShape" title="Lip Shape">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Upper lip -->
                                <path d="M8 12C9 11 11 10 12 11C13 10 15 11 16 12" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Lower lip -->
                                <path d="M8 12C9 13 11 14 12 14C13 14 15 13 16 12" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    </div>
                </div>
        
                <div class="property-group">
                    <div class="group-header">Advanced Tools</div>
                    <button class="panel-button-tool" id="snakeHook" title="Snake Hook">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                            <!-- Hook with snake-like curve -->
                            <path d="M6 18C8 14 10 12 12 14C14 16 16 14 18 10" fill="none" stroke="#ffffff" stroke-width="2"/>
                            <!-- Hook tip -->
                            <path d="M18 10L20 12L22 10" fill="none" stroke="#ffffff" stroke-width="2"/>
                        </svg>
                    </button>
                    <div class="group-header">Hair Brush Settings</div>
                    <button class="panel-button-tool" id="hairBrush" title="Hair Brush">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                            <!-- Brush handle -->
                            <rect x="10" y="4" width="4" height="8" fill="none" stroke="#ffffff" stroke-width="2"/>
                            <!-- Brush bristles (hair strands) -->
                            <path d="M8 12C8 14 10 16 12 16C14 16 16 14 16 12" fill="none" stroke="#ffffff" stroke-width="2"/>
                            <line x1="10" y1="12" x2="10" y2="18" stroke="#ffffff" stroke-width="2"/>
                            <line x1="12" y1="12" x2="12" y2="18" stroke="#ffffff" stroke-width="2"/>
                            <line x1="14" y1="12" x2="14" y2="18" stroke="#ffffff" stroke-width="2"/>
                        </svg>
                    </button>
                    <div class="hair-controls">
                        <h3>Hair Physics Settings</h3>
                        
                        <div class="control-group">
                          <label for="guideHairDensity">Guide Hair Density</label>
                          <input type="range" id="guideHairDensity" min="0.05" max="0.5" step="0.05" value="0.1">
                          <span class="value-display">0.1</span>
                        </div>
                        
                        <div class="control-group">
                          <label for="simulationQuality">Simulation Quality</label>
                          <select id="simulationQuality">
                            <option value="low">Low (Fast)</option>
                            <option value="medium" selected>Medium</option>
                            <option value="high">High (Slower)</option>
                          </select>
                        </div>
                        
                        <div class="control-group">
                          <button id="optimizePerformance">Optimize Hair</button>
                          <button id="togglePhysics">Toggle Physics</button>
                        </div>
                        
                        <div class="stats">
                          <div>Hair Strands: <span id="strandCount">0</span></div>
                          <div>Guide Hairs: <span id="guideCount">0</span></div>
                          <div>Performance: <span id="physicsTime">0</span> ms</div>
                        </div>
                      </div>
                    <div class="brush-controls">
                        <label title="Adjust the number of hair segments.">Segments: <input type="range" id="hairSegments" min="4" max="16" value="8" step="1"></label>
                        <label>Length: <input type="range" id="hairLength" min="0.02" max="0.2" value="0.05" step="0.01"></label>
                        <label>Density: <input type="range" id="hairDensity" min="3" max="12" value="5" step="1"></label>
                        <label>Curl: <input type="range" id="hairCurl" min="0" max="1" value="0.2" step="0.1"></label>
                        <label>Stiffness: <input type="range" id="hairStiffness" min="0.1" max="1" value="0.8" step="0.1"></label>
                    </div>

                    <div class="property-group">
                        <div class="group-header">Advanced Hair Settings</div>
                        <div class="brush-controls">
                            <label>Wave: <input type="range" id="hairWave" min="0" max="1" value="0.2" step="0.05"></label>
                            <label>Frizz: <input type="range" id="hairFrizz" min="0" max="0.5" value="0.1" step="0.05"></label>
                            <label>Clump Size: <input type="range" id="hairClumpSize" min="1" max="10" value="3" step="1"></label>
                            <label>Noise: <input type="range" id="hairNoise" min="0" max="0.2" value="0.05" step="0.01"></label>
                            <label>Color: <input type="color" id="hairColor" value="#3a1a00"></label>
                            <label>Highlight Color: <input type="color" id="hairSpecular" value="#8B4513"></label>
                            <!-- Rename the second togglePhysics to avoid conflict -->
                            <button class="panel-button" id="enablePhysics">Enable Physics</button>
                        </div>
                    </div>
                </div>

                <div class="property-group">
                    <div class="group-header">Detail Tools</div>
                    <div class="button-container">
                        <!-- Smooth -->
                        <button class="panel-button-tool" id="smooth" title="Smooth">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Smooth flowing curve -->
                                <path d="M6 16C8 12 10 10 12 12C14 14 16 12 18 8" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Subtle wave -->
                                <path d="M6 14C8 13 10 13 12 14C14 15 16 15 18 14" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Pinch -->
                        <button class="panel-button-tool" id="pinch" title="Pinch">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Converging arrows -->
                                <path d="M6 8L12 12L6 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <path d="M18 8L12 12L18 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Center pinch point -->
                                <circle cx="12" cy="12" r="1" fill="#ffffff" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Inflate -->
                        <button class="panel-button-tool" id="inflate" title="Inflate">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Expanding circle -->
                                <circle cx="12" cy="12" r="6" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Arrows outward -->
                                <path d="M12 6V4M12 20V18M6 12H4M20 12H18" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Crease -->
                        <button class="panel-button-tool" id="crease" title="Crease">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Sharp crease line -->
                                <path d="M6 18L12 12L18 18" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Fold hint -->
                                <path d="M6 16L12 10L18 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    </div>
                </div>
                
                <div class="property-group">
                    <div class="group-header">Symmetry</div>
                    <div class="symmetry-controls">
                        <label>
                            <input type="checkbox" id="symmetryToggle" checked>
                            Enable Symmetry
                        </label>
                        <select id="symmetryAxis">
                            <option value="x">X Axis</option>
                            <option value="y">Y Axis</option>
                            <option value="z">Z Axis</option>
                        </select>
                    </div>
                </div>
                
            </div>
            <div class="historySysteme">
                <div class="panel-header">
                    <i class="fas fa-history"></i>
                     Histroy & Controls
                </div>
                <div class="history-panel" id="history-panel">
                    <div class="panel-header">
                        <i class="fas fa-history"></i>
                        History panel
                    </div>
                    <div class="property-row">
                        <div id="history-items"></div>
                    </div>
                </div>
                <!-- Advanced Tools Panel -->
                <div class="advanced-tools" id="advanced-tools">
                    <div class="button-container">
                        <!-- Mirror -->
                        <button class="panel-button-tool" id="mirror" title="Mirror">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Shape (left half) -->
                                <path d="M6 8C8 6 10 8 10 12C10 16 8 18 6 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Symmetry line -->
                                <line x1="12" y1="6" x2="12" y2="18" stroke="#ffffff" stroke-width="2" stroke-dasharray="2"/>
                                <!-- Shape (right half, mirrored) -->
                                <path d="M18 8C16 6 14 8 14 12C14 16 16 18 18 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Array -->
                        <button class="panel-button-tool" id="array" title="Array">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Repeated rectangles -->
                                <rect x="6" y="8" width="4" height="4" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <rect x="12" y="8" width="4" height="4" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <rect x="6" y="14" width="4" height="4" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <rect x="12" y="14" width="4" height="4" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Plus hint -->
                                <path d="M18 12H20M19 11V13" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Boolean -->
                        <button class="panel-button-tool" id="boolean" title="Boolean">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Overlapping shapes -->
                                <circle cx="10" cy="12" r="4" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <rect x="10" y="8" width="8" height="8" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Cutout hint -->
                                <path d="M14 12H16" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    </div>
                </div>
            
            </div>
            <!-- Export Options -->
            <div class="export-panel" id="export-panel">
                <div class="panel-header">
                    Export Options
                </div>
                <div class="export-meth">
                    <select class="property-input" id="exportFormat">
                        <option value="gltf">GLTF/GLB</option>
                        <option value="obj">OBJ</option>
                        <option value="fbx">FBX</option>
                    </select>
                    <button class="tool-button" id="exportButton">Export</button>
                    <button class="tool-button" id="importScene">Export</button>
                </div>
            </div>
        </div>
        
        <div class="animator-container">
            <div class="layers-panel">
                <div class="panel-header">Layers</div>
                <div class="layer-item selected">
                    <span class="layer-icon">▶</span>
                    Base Layer
                </div>
                <div class="layer-item">
                    <span class="layer-icon">▶</span>
                    Left Hand Layer
                </div>
                <div class="layer-item">
                    <span class="layer-icon">▶</span>
                    Right Hand Layer
                </div>
            </div>
    
            <div class="graph-panel">
                <div class="grid"></div>
                <div class="controls1">
                    <button class="control-btn1" id="addState">Add State</button>
                    <button class="control-btn1" id="addTransition">Add Transition</button>
                </div>
            </div>
    
            <div class="parameters-panel">
                <div class="parameter-group">
                    <label class="parameter-label">State Name</label>
                    <input type="text" class="parameter-input" id="stateName">
                </div>
                <div class="parameter-group">
                    <label class="parameter-label">Speed</label>
                    <input type="range" class="parameter-input" min="0" max="2" step="0.1" value="1">
                </div>
                <div class="parameter-group">
                    <label class="parameter-label">Transition Duration</label>
                    <input type="number" class="parameter-input" value="0.25" step="0.05">
                </div>
            </div>
        </div>

    <style>
   .animator-container {
        display: none;
       position: absolute;
       top: 41%;
       left: 40%;
       bottom: 31vh;
       transform: translate(-50%, -48.5%);
       width: 57%;
       height: 70vh; /* Adjust height dynamically */
       max-height: 70vh; 
       background: #2a2a2a;
       border: 1px solid #444;
       z-index: 1000;
       overflow: auto;
       transition: width 0.3s ease, left 0.3s ease, transform 0.3s ease;
    }

    .animator-container.visible {
        display: flex;
        width: 80%; 
        left: 20%; 
        transform: translate(0, -50%);
    }

    /* Layers Panel */
    .layers-panel {
        width: 180px;
        background-color: #383838;
        border-right: 1px solid #222;
        overflow-y: auto;
    }


    .layer-item {
        padding: 8px 12px;
        display: flex;
        align-items: center;
         cursor: pointer;
        user-select: none;
    }

    .layer-item:hover {
        background-color: #454545;
    }

    .layer-item.selected {
         background-color: #2C5D87;
    }

    .layer-icon {
        width: 16px;
        height: 16px;
        margin-right: 8px;
    }

    /* Graph Panel */
    .graph-panel {
        flex: 1;
        background-color: #2D2D2D;
        position: relative;
        overflow-x: auto;
        overflow-y: auto;
    }

    .grid {
        position: absolute;
        width: 100%;
        height: 100%;
        background-size: 20px 20px;
        background-image: 
        linear-gradient(to right, #333 1px, transparent 1px),
        linear-gradient(to bottom, #333 1px, transparent 1px);
    }

    

    .node.entry {
        background-color: #2C632C;
    }

    .node.exit {
        background-color: #633434;
    }

    .node-header {
        padding-bottom: 5px;
        border-bottom: 1px solid #555;
        margin-bottom: 5px;
    }

    .connection {
        position: absolute;
        pointer-events: none;
        z-index: 1;
    }

    .controls1 {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            gap: 5px;
}

        .control-btn1 {
            background-color: #4A4A4A;
            border: none;
            color: white;
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 3px;
        }

        .control-btn1:hover {
            background-color: #555;
        }


        /* Parameters Panel */
        .parameters-panel {
            width: 200px;
            background-color: #383838;
            border-left: 1px solid #222;
            padding: 10px;
        }

        .parameter-group {
            margin-bottom: 15px;
        }

        .parameter-label {
            display: block;
            margin-bottom: 5px;
            color: #ccc;
        }

        .parameter-input {
            width: 100%;
            padding: 5px;
            background-color: #2D2D2D;
            border: 1px solid #444;
            color: white;
            border-radius: 3px;
        }
        </style>
        <script>
           document.getElementById("toggleAnimator").addEventListener("click", function() {
                document.querySelector(".animator-container").classList.toggle("visible");
             });
             class AnimationState {
    constructor(name, animation, transitions = []) {
        this.name = name;
        this.animation = animation;
        this.transitions = transitions;
        this.blendTime = 0.2; // Default blend duration
    }
}

class AnimationController {
    constructor(model) {
        this.model = model;
        this.mixer = new THREE.AnimationMixer(model);
        this.states = new Map();
        this.currentState = null;
    }

    addState(name, animation) {
        const state = new AnimationState(name, animation);
        this.states.set(name, state);
        return state;
    }

    transition(fromState, toState, duration) {
        const currentAction = this.mixer.clipAction(fromState.animation);
        const nextAction = this.mixer.clipAction(toState.animation);
        
        // Crossfade between animations
        currentAction.fadeOut(duration);
        nextAction.reset().fadeIn(duration).play();
        
        this.currentState = toState;
    }
}

class AnimatorInterface {
    constructor() {
        this.controllers = new Map();
        this.connections = new Map();
        this.parameters = new Map();
    }

    createController(model) {
        const controller = new AnimationController(model);
        this.controllers.set(model.uuid, controller);
        return controller;
    }

    addTransition(fromState, toState, conditions) {
        fromState.transitions.push({
            targetState: toState,
            conditions: conditions
        });
    }
}
              class AnimatorGraph {
            constructor() {
                this.nodes = new Map();
                this.connections = new Map();
                this.graphPanel = document.querySelector('.graph-panel');
                this.isDragging = false;
                this.selectedNode = null;
                this.offset = { x: 0, y: 0 };

                this.initializeEventListeners();
                this.createDefaultStates();
            }

            createDefaultStates() {
                // Create Entry state
                this.createNode('Entry', 100, 100, true);
                
                // Create default states
                this.createNode('Idle', 300, 100);
                this.createNode('Walking', 500, 100);
                this.createNode('Running', 700, 100);
                
                // Create connections
                this.createConnection('Entry', 'Idle');
                this.createConnection('Idle', 'Walking');
                this.createConnection('Walking', 'Running');
            }

            createNode(name, x, y, isEntry = false) {
                const node = document.createElement('div');
                node.className = `node ${isEntry ? 'entry' : ''}`;
                node.innerHTML = `
                    <div class="node-header">${name}</div>
                    <div class="node-content">
                        Speed: 1.0
                    </div>
                `;
                node.style.left = `${x}px`;
                node.style.top = `${y}px`;
                
                this.nodes.set(name, node);
                this.graphPanel.appendChild(node);
                
                return node;
            }

            createConnection(fromName, toName) {
                const connection = document.createElement('svg');
                connection.classList.add('connection');
                connection.setAttribute('width', '100%');
                connection.setAttribute('height', '100%');
                
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                line.setAttribute('stroke', '#666');
                line.setAttribute('stroke-width', '2');
                line.setAttribute('fill', 'none');
                
                connection.appendChild(line);
                this.graphPanel.appendChild(connection);
                
                this.connections.set(`${fromName}-${toName}`, {
                    element: connection,
                    line: line,
                    from: fromName,
                    to: toName
                });
                
                this.updateConnection(fromName, toName);
            }

            updateConnection(fromName, toName) {
                const connection = this.connections.get(`${fromName}-${toName}`);
                if (!connection) return;

                const fromNode = this.nodes.get(fromName);
                const toNode = this.nodes.get(toName);
                
                const fromRect = fromNode.getBoundingClientRect();
                const toRect = toNode.getBoundingClientRect();
                
                const x1 = fromRect.left + fromRect.width;
                const y1 = fromRect.top + fromRect.height / 2;
                const x2 = toRect.left;
                const y2 = toRect.top + toRect.height / 2;
                
                const path = `M ${x1} ${y1} C ${x1 + 50} ${y1}, ${x2 - 50} ${y2}, ${x2} ${y2}`;
                connection.line.setAttribute('d', path);
            }

            initializeEventListeners() {
                this.graphPanel.addEventListener('mousedown', (e) => {
                    if (e.target.classList.contains('node')) {
                        this.isDragging = true;
                        this.selectedNode = e.target;
                        const rect = this.selectedNode.getBoundingClientRect();
                        this.offset = {
                            x: e.clientX - rect.left,
                            y: e.clientY - rect.top
                        };
                    }
                });

                document.addEventListener('mousemove', (e) => {
                    if (this.isDragging && this.selectedNode) {
                        const x = e.clientX - this.offset.x;
                        const y = e.clientY - this.offset.y;
                        
                        this.selectedNode.style.left = `${x}px`;
                        this.selectedNode.style.top = `${y}px`;
                        
                        // Update connections
                        this.connections.forEach((connection, key) => {
                            if (key.includes(this.selectedNode.querySelector('.node-header').textContent)) {
                                this.updateConnection(connection.from, connection.to);
                            }
                        });
                    }
                });

                document.addEventListener('mouseup', () => {
                    this.isDragging = false;
                    this.selectedNode = null;
                });

                // Add State button
                document.getElementById('addState').addEventListener('click', () => {
                    const stateName = prompt('Enter state name:');
                    if (stateName) {
                        const x = Math.random() * 500 + 200;
                        const y = Math.random() * 300 + 100;
                        this.createNode(stateName, x, y);
                    }
                });
            }
        }

        // Initialize the animator
        const animator = new AnimatorGraph();
        </script>
         <!-- Timeline -->
         <div class="timeline">
            <div class="status-bar">
                <span id="fps">FPS: 60</span>
                <span id="objects">Objects: 0</span>
                <span id="triangles">Triangles: 0</span>

            </div>
            <div class="timeline-controls">
                <button class="tool-button" id="play">
                    <i class="fas fa-play"></i>
                </button>
                <button class="tool-button" id="pause">
                    <i class="fas fa-pause"></i>
                </button>
                <button class="tool-button" id="stop">
                    <i class="fas fa-stop"></i>
                </button>
                <span id="time-display">00:00:00</span>
                <div class="zoom-controls">
                    <button class="tool-button" id="zoom-out">-</button>
                    <button class="tool-button" id="zoom-in">+</button>
                </div>
            </div>
            <div class="timeline-track">
                <div class="timeline-scale"></div>
                <div class="timeline-content">
                    <div class="playhead"></div>
                </div>
            </div>
        </div>

    </div>

    <div class="node-editor">
        <div class="node-editor-header">
            <span>Node Editor</span>
            <button id="node-editor-close">×</button>
        </div>
        <div class="node-toolbar">
            <button class="toolbar-button" title="Add Object" data-type="object">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                    <!-- Cube -->
                    <path d="M6 6L12 4L18 6L18 14L12 16L6 14L6 6Z" fill="none" stroke="#ffffff" stroke-width="2"/>
                    <path d="M6 6L12 8L18 6" fill="none" stroke="#ffffff" stroke-width="2"/>
                    <!-- Plus sign -->
                    <path d="M20 12H22M21 11V13" fill="none" stroke="#ffffff" stroke-width="2"/>
                </svg>
            </button>
            <button class="toolbar-button" title="Add Physics" data-type="physics">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                    <!-- Falling ball -->
                    <circle cx="12" cy="12" r="2" fill="none" stroke="#ffffff" stroke-width="2"/>
                    <!-- Motion lines -->
                    <path d="M12 8V10M10 6L11 9M14 6L13 9" fill="none" stroke="#ffffff" stroke-width="2"/>
                    <!-- Plus sign -->
                    <path d="M20 12H22M21 11V13" fill="none" stroke="#ffffff" stroke-width="2"/>
                </svg>
            </button>
            <button class="toolbar-button" title="Add Effect" data-type="effect">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                    <!-- Sparkle/wave -->
                    <path d="M12 8C14 10 16 10 18 12C16 14 14 14 12 16C10 14 8 14 6 12C8 10 10 10 12 8Z" 
                          fill="none" stroke="#ffffff" stroke-width="2"/>
                    <!-- Plus sign -->
                    <path d="M20 12H22M21 11V13" fill="none" stroke="#ffffff" stroke-width="2"/>
                </svg>
            </button>
            <button class="toolbar-button" title="Add Material" data-type="material">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                    <!-- Textured square -->
                    <rect x="6" y="6" width="12" height="12" fill="none" stroke="#ffffff" stroke-width="2"/>
                    <path d="M8 8L10 10M14 14L16 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                    <!-- Plus sign -->
                    <path d="M20 12H22M21 11V13" fill="none" stroke="#ffffff" stroke-width="2"/>
                </svg>
            </button>
            <button class="toolbar-button" title="Add Transform" data-type="transform">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                    <!-- Transform arrows -->
                    <path d="M12 6V8M12 16V18M6 12H8M16 12H18" fill="none" stroke="#ffffff" stroke-width="2"/>
                    <path d="M10 8L12 6L14 8M10 16L12 18L14 16M8 10L6 12L8 14M16 10L18 12L16 14" 
                          fill="none" stroke="#ffffff" stroke-width="2"/>
                    <!-- Plus sign -->
                    <path d="M20 12H22M21 11V13" fill="none" stroke="#ffffff" stroke-width="2"/>
                </svg>
            </button>
            <button class="toolbar-button" title="Add Animation" data-type="animation">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                    <!-- Play button -->
                    <path d="M8 6L16 12L8 18Z" fill="none" stroke="#ffffff" stroke-width="2"/>
                    <!-- Plus sign -->
                    <path d="M20 12H22M21 11V13" fill="none" stroke="#ffffff" stroke-width="2"/>
                </svg>
            </button>
            <button class="toolbar-button" title="Add light" data-type="light">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                    <!-- Light bulb -->
                    <path d="M12 6C10 6 8 8 8 10C8 12 10 14 12 14C14 14 16 12 16 10C16 8 14 6 12 6Z" 
                          fill="none" stroke="#ffffff" stroke-width="2"/>
                    <path d="M10 14H14V16H10V14Z" fill="none" stroke="#ffffff" stroke-width="2"/>
                    <!-- Plus sign -->
                    <path d="M20 12H22M21 11V13" fill="none" stroke="#ffffff" stroke-width="2"/>
                </svg>
            </button>
        </div>
        <div class="node-canvas" id="node-canvas"></div>
    </div>

   

    <div class="camera-preview" id="cameraPreview">
        <div class="preview-controls">
            <button id="minimizePreview"><i class="fas fa-window-minimize"></i></button>
            <button id="expandPreview"><i class="fas fa-expand-arrows-alt"></i></button>
        </div>
    </div>
    

    <!-- Context Menu -->
    <div class="context-menu" id="context-menu"> 
        <div class="context-menu-item" >Copy (Ctrl+C)</div>
        <div class="context-menu-item" >Paste (Ctrl+V)</div>
        <div class="context-menu-item">Delete (Del)</div>
        <div class="context-menu-item" >Duplicate (Ctrl+D)</div>
    </div>
   
    <div id="code-editor-panel">
        <div class="resize-handle"></div>
        <div class="editor-header">
            <h3>Code Editor</h3>
            <button class="editor-btn" id="close-editor">&times;</button>
        </div>
        <div class="editor-tabs">
            <button class="editor-tab active" data-tab="js">JavaScript</button>
            <button class="editor-tab" data-tab="html">HTML</button>
            <button class="editor-tab" data-tab="css">CSS</button>
        </div>
        <div class="split-container">
            <div class="main-editor">
                <textarea id="js-editor"></textarea>
                <textarea id="html-editor" style="display: none;"></textarea>
                <textarea id="css-editor" style="display: none;"></textarea>
            </div>
            <div class="console-container" id="console-container">
                <div class="console-header">Console</div>
                <div class="console-content" id="console-content"></div>
            </div>
        </div>
        <div class="editor-footer">
            <input type="text" id="filename-input" placeholder="Enter object name">
            <button class="editor-btn" id="run-code">Run (Ctrl+Enter)</button>
            <button class="editor-btn" id="clear-console">Clear Console</button>
        </div>
        <div class="status-bar-code">Ready</div>
    </div>

    <div id="preview-container">
        <button id="close-preview">✖</button>
    </div>

    <div class="context-menu1" id="context-menu1">
        <div class="context-menu-item1" data-action="delete">Delete Node</div>
        <div class="context-menu-item1" data-action="duplicate">Duplicate Node</div>
    </div>

    <script>
        const toggleButton = document.getElementById('toggle-inspector');
        const inspectorPanel = document.getElementById('inspector-panel');
        const timeline1 = document.querySelector('.timeline');
        const nodeEditorExpend = document.querySelector('.node-editor');
        const animatorEditor = document.querySelector('.animator-container');
        const axisControls = document.querySelector('.axis-controls');
        toggleButton.addEventListener('click', () => {
            const isInspectorOpen = !inspectorPanel.classList.contains('closed');
            
            inspectorPanel.classList.toggle('closed');
            
            if (isInspectorOpen) {
                // Expand timeline when inspector is closed
                timeline1.classList.add('expanded');
                nodeEditorExpend.classList.add('expanded');
                axisControls.classList.add('expanded');
                animatorEditor.classList.add('expanded');
            } else {
                // Restore timeline size when inspector is open
                timeline1.classList.remove('expanded');
                nodeEditorExpend.classList.remove('expanded');
                axisControls.classList.remove('expanded');
                animatorEditor.classList.remove('expanded');
            }
        });
        
    </script>

    <script>
    class PhysicsManager {
    constructor(scene, world) {
        this.scene = scene;
        this.world = world;
        this.physicsBodies = new Map();
        this.forces = new Set();
        this.collisionGroups = {
            DEFAULT: 1,
            TERRAIN: 2,
            DYNAMIC_OBJECTS: 4,
            KINEMATIC: 8,
            WIND_AFFECTED: 16
        };
        
        this.materials = {
            default: new CANNON.Material({
                friction: 0.5,
                restitution: 0.3
            }),
            bouncy: new CANNON.Material({
                friction: 0.3,
                restitution: 0.8
            }),
            rough: new CANNON.Material({
                friction: 0.8,
                restitution: 0.1
            })
        };

        // Debug visualization settings
        this.debugMode = false;
        this.debugBodies = new Map();
    }

    initPhysicsWorld() {
        this.world.gravity.set(0, -9.81, 0);
        this.world.broadphase = new CANNON.SAPBroadphase(this.world);
        this.world.solver.iterations = 20;
        this.world.allowSleep = true;

        // Contact material behaviors
        Object.values(this.materials).forEach((mat1) => {
            Object.values(this.materials).forEach((mat2) => {
                const contact = new CANNON.ContactMaterial(mat1, mat2, {
                    friction: Math.min(mat1.friction, mat2.friction),
                    restitution: Math.max(mat1.restitution, mat2.restitution),
                    contactEquationStiffness: 1e7,
                    contactEquationRelaxation: 3
                });
                this.world.addContactMaterial(contact);
            });
        });

        // Ground plane setup
        const groundShape = new CANNON.Plane();
        const groundBody = new CANNON.Body({
            mass: 0,
            material: this.materials.default,
            shape: groundShape,
            collisionFilterGroup: this.collisionGroups.TERRAIN,
            collisionFilterMask: this.collisionGroups.DEFAULT | this.collisionGroups.DYNAMIC_OBJECTS
        });
        groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI/2);
        this.world.addBody(groundBody);

        return this;
    }

    addPhysicsToObject(object, options = {}) {
        const box = new THREE.Box3().setFromObject(object);
        const size = new THREE.Vector3();
        box.getSize(size);

        let shape;
        if (object.geometry instanceof THREE.BoxGeometry) {
            shape = new CANNON.Box(new CANNON.Vec3(size.x/2, size.y/2, size.z/2));
        } else if (object.geometry instanceof THREE.SphereGeometry) {
            shape = new CANNON.Sphere(object.geometry.parameters.radius);
        } else if (object.geometry instanceof THREE.CylinderGeometry) {
            shape = new CANNON.Cylinder(
                object.geometry.parameters.radiusTop,
                object.geometry.parameters.radiusBottom,
                object.geometry.parameters.height,
                object.geometry.parameters.radialSegments
            );
        } else {
            // Default to box if geometry type is unknown
            shape = new CANNON.Box(new CANNON.Vec3(size.x/2, size.y/2, size.z/2));
        }

        const bodyOptions = {
            mass: options.mass || 1,
            position: new CANNON.Vec3(object.position.x, object.position.y, object.position.z),
            shape: shape,
            material: this.materials[options.material] || this.materials.default,
            linearDamping: options.linearDamping || 0.1,
            angularDamping: options.angularDamping || 0.1,
            collisionFilterGroup: options.group || this.collisionGroups.DYNAMIC_OBJECTS,
            collisionFilterMask: options.mask || 
                (this.collisionGroups.DEFAULT | this.collisionGroups.TERRAIN | this.collisionGroups.DYNAMIC_OBJECTS)
        };

        const body = new CANNON.Body(bodyOptions);

        if (options.velocity) {
            body.velocity.copy(options.velocity);
        }

        if (options.angularVelocity) {
            body.angularVelocity.copy(options.angularVelocity);
        }

        this.world.addBody(body);
        this.physicsBodies.set(object, body);

        // Set up collision event listeners
        body.addEventListener("collide", (event) => {
            if (options.onCollide) {
                options.onCollide(event);
            }
            this.handleCollision(event, object);
        });

        object.userData.physics = {
            enabled: true,
            body: body
        };

        return body;
    }

    handleCollision(event, object) {
        const impact = event.contact.getImpactVelocityAlongNormal();
        
        // Visual feedback for collision
        if (Math.abs(impact) > 5) {
            this.createCollisionEffect(event.contact.bi.position);
        }

        // Sound feedback could be added here
        if (Math.abs(impact) > 3) {
            // Play collision sound based on impact force
        }
    }

    createCollisionEffect(position) {
        const particles = new THREE.Points(
            new THREE.BufferGeometry(),
            new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.1,
                transparent: true,
                opacity: 0.8
            })
        );

        const particleCount = 20;
        const positions = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount * 3; i += 3) {
            const offset = new THREE.Vector3(
                (Math.random() - 0.5) * 0.5,
                (Math.random() - 0.5) * 0.5,
                (Math.random() - 0.5) * 0.5
            );
            positions[i] = position.x + offset.x;
            positions[i + 1] = position.y + offset.y;
            positions[i + 2] = position.z + offset.z;
        }

        particles.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        this.scene.add(particles);

        // Animate and remove particles
        const startTime = Date.now();
        const animate = () => {
            const elapsed = Date.now() - startTime;
            if (elapsed > 1000) {
                this.scene.remove(particles);
                return;
            }

            const positions = particles.geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                positions[i + 1] += 0.01; // Move particles upward
            }
            particles.geometry.attributes.position.needsUpdate = true;
            particles.material.opacity = 1 - (elapsed / 1000);

            requestAnimationFrame(animate);
        };
        animate();
    }

    createWindZone(position, direction, strength, radius) {
        const windForce = {
            type: 'wind',
            position: position.clone(),
            direction: direction.normalize(),
            strength: strength,
            radius: radius,
            apply: (body) => {
                // Calculate distance to body
                const distance = position.distanceTo(body.position);
                
                if (distance <= radius) {
                    // Scale force based on distance from center
                    const forceMagnitude = strength * (1 - distance / radius);
                    const force = direction.clone().multiplyScalar(forceMagnitude);
                    
                    // Apply force to physics body
                    body.applyForce(
                        new CANNON.Vec3(force.x, force.y, force.z),
                        body.position
                    );
                }
            }
        };
        this.forces.push(windForce);
        return windForce;
    }

    createVortexZone(position, axis, strength, radius) {
        const vortexForce = {
            type: 'vortex',
            position: position.clone(),
            axis: axis.normalize(),
            strength: strength,
            radius: radius,
            apply: (body) => {
                const bodyPos = new THREE.Vector3(
                    body.position.x,
                    body.position.y,
                    body.position.z
                );
                
                const distance = position.distanceTo(bodyPos);
                
                if (distance <= radius) {
                    // Calculate tangential direction for vortex
                    const toCenter = bodyPos.clone().sub(position);
                    const tangent = toCenter.cross(axis).normalize();
                    
                    // Scale force based on distance
                    const forceMagnitude = strength * (distance / radius);
                    const force = tangent.multiplyScalar(forceMagnitude);
                    
                    body.applyForce(
                        new CANNON.Vec3(force.x, force.y, force.z),
                        body.position
                    );
                }
            }
        };
        this.forces.push(vortexForce);
        return vortexForce;
    }

    applyForces(bodies) {
        this.forces.forEach(force => {
            bodies.forEach(body => force.apply(body));
        });
    }

  
    updatePhysics() {
        // Apply forces before stepping the world
        for (const force of this.forces) {
            for (const body of this.world.bodies) {
                if (body.mass > 0) { // Only apply to non-static bodies
                    force.apply(body);
                }
            }
        }
        this.physicsBodies.forEach((body) => {
            this.forces.forEach(force => {
                if (force.active && body.mass > 0) {
                    force.apply(body);
                }
            });
        });

        this.world.step(1/60);

        // Update object positions
        this.physicsBodies.forEach((body, object) => {
            object.position.copy(body.position);
            object.quaternion.copy(body.quaternion);
        });
    }
  
}




function createWindZoneVisual(position, radius, strength) {
    const group = new THREE.Group();
    
    // Main cylinder with improved visibility
    const cylinderGeometry = new THREE.CylinderGeometry(radius, radius, radius * 2, 32, 1, true);
    const cylinderMaterial = new THREE.MeshBasicMaterial({
        color: 0x00ff88,
        transparent: true,
        opacity: 0.2,
        wireframe: true,
        side: THREE.DoubleSide
    });
    const cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
    
    // Direction arrows
    const arrowCount = 8;
    const arrowGroup = new THREE.Group();
    for (let i = 0; i < arrowCount; i++) {
        const arrowHelper = new THREE.ArrowHelper(
            new THREE.Vector3(1, 0, 0),
            new THREE.Vector3(0, 0, 0),
            radius * 0.8,
            0x00ff88,
            radius * 0.2,
            radius * 0.1
        );
        arrowHelper.position.y = (Math.random() - 0.5) * radius;
        arrowHelper.position.z = (Math.random() - 0.5) * radius;
        arrowGroup.add(arrowHelper);
    }

    // Particle system for wind visualization
    const particleCount = 100;
    const particleGeometry = new THREE.BufferGeometry();
    const particlePositions = new Float32Array(particleCount * 3);
    const particleSizes = new Float32Array(particleCount);
    
    for (let i = 0; i < particleCount; i++) {
        const x = (Math.random() - 0.5) * radius * 2;
        const y = (Math.random() - 0.5) * radius * 2;
        const z = (Math.random() - 0.5) * radius * 2;
        
        particlePositions[i * 3] = x;
        particlePositions[i * 3 + 1] = y;
        particlePositions[i * 3 + 2] = z;
        particleSizes[i] = Math.random() * 0.2 + 0.1;
    }
    
    particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
    particleGeometry.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));
    
    const particleMaterial = new THREE.PointsMaterial({
        color: 0x00ff88,
        size: 0.1,
        transparent: true,
        opacity: 0.6,
        sizeAttenuation: true
    });
    
    const particles = new THREE.Points(particleGeometry, particleMaterial);
    
    group.add(cylinder);
    group.add(arrowGroup);
    group.add(particles);
    group.position.copy(position);
    addObjectToScene(group, 'Wind Zone');
    // Animation
    let time = 0;
    group.animate = () => {
        time += 0.016 * strength;
        
        // Animate particles
        const positions = particles.geometry.attributes.position.array;
        for (let i = 0; i < particleCount; i++) {
            positions[i * 3] += 0.1 * strength;
            if (positions[i * 3] > radius) {
                positions[i * 3] = -radius;
            }
        }
        particles.geometry.attributes.position.needsUpdate = true;
        
        // Rotate arrows
        arrowGroup.children.forEach((arrow, i) => {
            arrow.position.x = Math.sin(time + i) * radius * 0.2;
        });
        
        // Pulse cylinder
        cylinder.scale.x = 1 + Math.sin(time) * 0.1;
        cylinder.scale.z = 1 + Math.sin(time) * 0.1;
    };

    return group;
}

function createVortexVisual(position, radius, strength) {
    const group = new THREE.Group();

    // Main torus
    const torusGeometry = new THREE.TorusGeometry(radius * 0.7, radius * 0.05, 16, 100);
    const torusMaterial = new THREE.MeshBasicMaterial({
        color: 0x3F51B5,
        transparent: true,
        opacity: 0.5,
        wireframe: true
    });
    const torus = new THREE.Mesh(torusGeometry, torusMaterial);

    // Spiral lines
    const spiralCount = 3;
    const pointsPerSpiral = 100;
    const spiralGroup = new THREE.Group();
    
    for (let s = 0; s < spiralCount; s++) {
        const spiralPoints = [];
        const angleOffset = (s * Math.PI * 2) / spiralCount;
        
        for (let i = 0; i < pointsPerSpiral; i++) {
            const t = i / (pointsPerSpiral - 1);
            const angle = t * Math.PI * 4 + angleOffset;
            const radiusAt = radius * (0.2 + t * 0.8);
            
            spiralPoints.push(new THREE.Vector3(
                radiusAt * Math.cos(angle),
                t * radius * 2 - radius,
                radiusAt * Math.sin(angle)
            ));
        }
        
        const spiralGeometry = new THREE.BufferGeometry().setFromPoints(spiralPoints);
        const spiralMaterial = new THREE.LineBasicMaterial({
            color: 0x5C6BC0,
            transparent: true,
            opacity: 0.7
        });
        const spiralLine = new THREE.Line(spiralGeometry, spiralMaterial);
        spiralGroup.add(spiralLine);
    }

    // Particle system
    const particleCount = 300;
    const particleGeometry = new THREE.BufferGeometry();
    const particlePositions = new Float32Array(particleCount * 3);
    const particleData = [];
    
    for (let i = 0; i < particleCount; i++) {
        const angle = Math.random() * Math.PI * 2;
        const radiusAt = radius * (0.2 + Math.random() * 0.8);
        const height = (Math.random() - 0.5) * radius * 2;
        
        particlePositions[i * 3] = Math.cos(angle) * radiusAt;
        particlePositions[i * 3 + 1] = height;
        particlePositions[i * 3 + 2] = Math.sin(angle) * radiusAt;
        
        particleData.push({
            angle,
            radius: radiusAt,
            height,
            speed: (0.5 + Math.random() * 0.5) * strength
        });
    }
    
    particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
    
    const particleMaterial = new THREE.PointsMaterial({
        color: 0x5C6BC0,
        size: 0.1,
        transparent: true,
        opacity: 0.8
    });
    
    const particles = new THREE.Points(particleGeometry, particleMaterial);

    group.add(torus);
    group.add(spiralGroup);
    group.add(particles);
    group.position.copy(position);
    addObjectToScene(group, 'Vortex Wind');
    // Animation
    let time = 0;
    group.animate = () => {
        time += 0.016 * strength;
        
        // Rotate torus
        torus.rotation.y += 0.02 * strength;
        
        // Rotate spiral lines
        spiralGroup.rotation.y += 0.01 * strength;
        
        // Animate particles
        const positions = particles.geometry.attributes.position.array;
        for (let i = 0; i < particleCount; i++) {
            const data = particleData[i];
            data.angle += data.speed * 0.02;
            
            positions[i * 3] = Math.cos(data.angle) * data.radius;
            positions[i * 3 + 1] = data.height + Math.sin(time + i) * 0.1;
            positions[i * 3 + 2] = Math.sin(data.angle) * data.radius;
        }
        particles.geometry.attributes.position.needsUpdate = true;
    };

    return group;
}
        
        function addDemonstrationObjects() {
            // Add some boxes and spheres with different materials
            for (let i = 0; i < 5; i++) {
                const size = 1 + Math.random() * 0.5;
                const geometry = Math.random() > 0.5 ? 
                    new THREE.BoxGeometry(size, size, size) :
                    new THREE.SphereGeometry(size/2, 16, 16);
                
                const material = new THREE.MeshStandardMaterial({
                    color: new THREE.Color().setHSL(Math.random(), 0.7, 0.5),
                    roughness: 0.7,
                    metalness: 0.3
                });

                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(
                    (Math.random() - 0.5) * 10,
                    5 + i * 2,
                    (Math.random() - 0.5) * 10
                );
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                addObjectToScene(mesh, 'Physic demostration shapes')

                scene.add(mesh);
                physicsManager.addPhysicsToObject(mesh, {
                    mass: 1,
                    friction: 0.9,
                    restitution: 0.7
                });
            }
        }

      
        function initPhysics() {
           world = new CANNON.World();
           world.gravity.set(0, -9.81, 0); // Apply gravity

           physicsManager = new PhysicsManager(scene, world).initPhysicsWorld();
          
            // Create a static floor for physics
            const floorShape = new CANNON.Plane();
            const floorBody = new CANNON.Body({
               mass: 0, // Static object (does not move)
               shape: floorShape,
               position: new CANNON.Vec3(0, 0, 0),
               quaternion: new CANNON.Quaternion().setFromEuler(-Math.PI / 2, 0, 0),
            });

            world.addBody(floorBody);

            // visual plane for the floor
            const floorGeometry = new THREE.PlaneGeometry(1000, 1000);
            const floorMaterial = new THREE.MeshStandardMaterial({
               color: 0xffffff,
               transparent: true,
               opacity: 0,
               side: THREE.DoubleSide,
            });
            const floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
            floorMesh.rotation.x = -Math.PI / 2;
            floorMesh.receiveShadow = true;

            scene.add(floorMesh);

// Add to PhysicsManager class
PhysicsManager.prototype.initClothSystem = function() {
    this.clothSystem = new ClothSystem(this);
    return this.clothSystem;
};



// Update physics loop
const originalUpdatePhysics = PhysicsManager.prototype.updatePhysics;
PhysicsManager.prototype.updatePhysics = function() {
    originalUpdatePhysics.call(this);
    if (this.clothSystem) {
        this.clothSystem.updateCloth();
    }
};

            //Listeners
            document.getElementById('gravity-strength').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                world.gravity.set(0, value, 0); // ✅ Update gravity dynamically
                document.getElementById('gravity-value').textContent = value.toFixed(2);
            });

             // Apply Wind
             document.getElementById('add-wind').addEventListener('click', () => {
               const strength = parseFloat(document.getElementById('wind-strength').value);
               const radius = parseFloat(document.getElementById('wind-radius').value);
               const position = controls.target.clone();
               const direction = new THREE.Vector3(1, 0, 0);
    
               const windVisual = createWindZoneVisual(position, radius, strength);
               scene.add(windVisual);
    
               const windForce = physicsManager.createWindZone(position, direction, strength, radius);
               windForce.visual = windVisual;
            });

            // Apply Vortex
            document.getElementById('add-vortex').addEventListener('click', () => {
                const strength = parseFloat(document.getElementById('wind-strength').value);
                const radius = parseFloat(document.getElementById('wind-radius').value);
                const position = controls.target.clone();
                const axis = new THREE.Vector3(0, 1, 0);
    
                const vortexVisual = createVortexVisual(position, radius, strength);
                scene.add(vortexVisual);
    
                const vortexForce = physicsManager.createVortexZone(position, axis, strength, radius);
                vortexForce.visual = vortexVisual;
            });



    }

        
    </script>

  
<script>
// Character Sculpting Constants and State
const CHARACTER_TOOLS = {
    FACE_SHAPE: 'faceShape',
    NOSE_SCULPT: 'noseSculpt',
    CHEEK_DEFINITION: 'cheekDefinition',
    JAW_SCULPT: 'jawSculpt',
    FOREHEAD_SHAPE: 'foreheadShape',
    CHIN_SCULPT: 'chinSculpt',
    TEMPLE_SCULPT: 'templeSculpt',
    BROW_RIDGE: 'browRidge',
    EYE_SOCKET: 'eyeSocket',
    LIP_SHAPE: 'lipShape',
    SMOOTH: 'smooth',
    PINCH: 'pinch',
    INFLATE: 'inflate',
    CREASE: 'crease',
    SNAKE_HOOK: 'snakeHook',
    HAIR_BRUSH: 'hairBrush'
};

// Hair system state
let physicsEnabled = false;
let physicsAnimationId = null;
let hairBrushActive = false;
let maxHairStrandsPerOperation = 10; // Limit strands added per brush stroke

const hairBrushSettings = {
    numSegments: 5,
    segmentLength: 0.05,
    stiffness: 0.8,
    gravity: 0.5, // Reduced from 0.9
    windStrength: 0.3, // Reduced from 0.6
    turbulence: 0.1, // Reduced from 0.2
    springStiffness: 0.8,
    damping: 0.4, // Increased from 0.3
    airResistance: 0.05, // Increased from 0.02
    thickness: 0.004, // Reduced from 0.005
    density: 50, // Reduced from 100
    maxStrands: 1000, // Reduced from 5000
    curl: 0.2,
    randomness: 0.1,
    clumpSize: 3,
    frizz: 0.1,
    wave: 0.2,
    hairStrands: [],
    guides: [],
    materialType: 'standard',
    hairColor: 0x3a1a00,
    specularColor: 0x8B4513,
    useInstancing: true, // Option to toggle between instanced and merged geometry
    lastUpdateTime: 0,
    updateInterval: 100, // ms between updates
    batchSize: 50 // Process this many strands per frame
};



// Optimized hair strand class
class HairStrand {
    constructor(rootPosition, normal) {
        this.segments = [];
        this.initialDirection = normal.clone();
        this.springConstant = hairBrushSettings.stiffness;
        this.damping = hairBrushSettings.damping;
        this.airResistance = hairBrushSettings.airResistance;
        this.rootPosition = rootPosition.clone();
        this.normal = normal.clone();
        this.needsUpdate = true;
        this.lastUpdateTime = 0;
        
        this.initializeSegments();
    }
    
    initializeSegments() {
        let currentPos = this.rootPosition.clone();
        
        for (let i = 0; i < hairBrushSettings.numSegments; i++) {
            const t = i / hairBrushSettings.numSegments;
            
            // Create natural curved shape with controlled randomness
            const wave = Math.sin(i * hairBrushSettings.wave * Math.PI) * hairBrushSettings.curl;
            const spiral = new THREE.Vector3(
                Math.cos(t * 2 * Math.PI * hairBrushSettings.curl),
                Math.sin(t * 2 * Math.PI * hairBrushSettings.curl),
                0
            ).multiplyScalar(hairBrushSettings.curl * 0.1);

            const offset = new THREE.Vector3(
                Math.sin(i + wave) * hairBrushSettings.randomness,
                Math.cos(i + wave) * hairBrushSettings.randomness,
                Math.sin((i + wave) * 0.5) * hairBrushSettings.randomness
            ).add(spiral);

            // Add more frizz toward the tips
            const frizzScale = Math.pow(t, 0.5);
            const frizz = new THREE.Vector3(
                (Math.random() - 0.5) * hairBrushSettings.frizz * frizzScale,
                (Math.random() - 0.5) * hairBrushSettings.frizz * frizzScale,
                (Math.random() - 0.5) * hairBrushSettings.frizz * frizzScale
            );

            this.segments.push({
                position: currentPos.clone(),
                prevPosition: currentPos.clone(),
                velocity: new THREE.Vector3(),
                force: new THREE.Vector3(),
                mass: 1 - (t * 0.5), // Tips are lighter
                locked: i === 0, // Root is locked
                normal: this.normal.clone()
            });

            // Calculate next segment position
            const direction = this.normal.clone()
                .add(offset)
                .add(frizz)
                .normalize()
                .multiplyScalar(hairBrushSettings.segmentLength * (1 - t * 0.2));

            currentPos.add(direction);
        }
    }

    update(deltaTime) {
        if (!physicsEnabled) return false;
        
        const now = performance.now();
        if (now - this.lastUpdateTime < 16) return false;
        this.lastUpdateTime = now;
        
        const gravity = new THREE.Vector3(0, -hairBrushSettings.gravity * 9.81, 0);
        const windTime = Date.now() * 0.0005;
        const wind = new THREE.Vector3(
            Math.sin(windTime) * hairBrushSettings.windStrength,
            0,
            Math.cos(windTime * 1.3) * hairBrushSettings.windStrength
        );
        
        let hasChanged = false;
        
        for (let i = 1; i < this.segments.length; i++) {
            const segment = this.segments[i];
            if (segment.locked) continue;
            
            segment.force.set(0, 0, 0);
            
            const massFactor = 1 - (i / this.segments.length) * 0.7;
            segment.force.add(gravity.clone().multiplyScalar(segment.mass * massFactor));
            
            const windFactor = 1 - (i / this.segments.length) * 0.5;
            segment.force.add(wind.clone().multiplyScalar(windFactor * hairBrushSettings.airResistance));
            
            const targetPos = this.segments[i - 1].position.clone()
                .add(this.initialDirection.clone()
                    .multiplyScalar(hairBrushSettings.segmentLength)
                    .applyAxisAngle(new THREE.Vector3(0, 0, 1), hairBrushSettings.curl * Math.PI * i / this.segments.length));
            const springForce = targetPos.sub(segment.position).multiplyScalar(hairBrushSettings.stiffness);
            segment.force.add(springForce);
            
            if (Math.random() > 0.8) {
                const frizzForce = new THREE.Vector3(
                    (Math.random() - 0.5) * hairBrushSettings.frizz,
                    (Math.random() - 0.5) * hairBrushSettings.frizz,
                    (Math.random() - 0.5) * hairBrushSettings.frizz
                ).multiplyScalar(1 - i / this.segments.length);
                segment.force.add(frizzForce);
            }

            const distToRoot = segment.position.distanceTo(this.rootPosition);
            if (distToRoot < 1.02 && i === 1) {
                segment.position.copy(this.rootPosition.clone().add(this.initialDirection.clone().multiplyScalar(0.02)));
                segment.velocity.set(0, 0, 0);
            } else if (distToRoot < 1.02) {
                const normal = segment.position.clone().normalize();
                segment.position.copy(normal.multiplyScalar(1.02));
                segment.velocity.projectOnPlane(normal).multiplyScalar(0.5);
                hasChanged = true;
            }

            const acceleration = segment.force.clone().divideScalar(segment.mass);
            segment.velocity.add(acceleration.multiplyScalar(deltaTime));
            segment.velocity.multiplyScalar(1 - this.damping);
            
            const oldPos = segment.position.clone();
            segment.position.add(segment.velocity.clone().multiplyScalar(deltaTime));
            
            if (oldPos.distanceToSquared(segment.position) > 0.00001) {
                hasChanged = true;
            }
        }
        
        if (hasChanged) {
            this.applyConstraints();
        }
        
        return hasChanged;
    }


    applyConstraints() {
        // Maintain segment lengths
        for (let i = 0; i < this.segments.length - 1; i++) {
            const segA = this.segments[i];
            const segB = this.segments[i + 1];
            
            const diff = segB.position.clone().sub(segA.position);
            const currentLength = diff.length();
            
            if (Math.abs(currentLength - hairBrushSettings.segmentLength) < 0.001) {
                continue; // Skip if length is already correct (optimization)
            }
            
            const correction = diff.normalize().multiplyScalar(
                hairBrushSettings.segmentLength - currentLength
            ).multiplyScalar(this.springConstant);

            // Apply correction based on locked state
            if (!segA.locked) segA.position.sub(correction.clone().multiplyScalar(0.5));
            if (!segB.locked) segB.position.add(correction.clone().multiplyScalar(0.5));
        }
        
        // Optional: Add shape memory - try to maintain original angles
        this.applyShapeMemory();
    }
    
    applyShapeMemory() {
        // Simple version: pull segments toward initial direction
        const memoryStrength = 0.03; // Subtle effect
        
        for (let i = 1; i < this.segments.length; i++) {
            const segment = this.segments[i];
            if (segment.locked) continue;
            
            // Calculate ideal position based on root and initial direction
            const t = i / hairBrushSettings.numSegments;
            const idealOffset = this.initialDirection.clone()
                .multiplyScalar(hairBrushSettings.segmentLength * i);
            const idealPos = this.rootPosition.clone().add(idealOffset);
            
            // Pull slightly toward ideal position (stronger at root, weaker at tip)
            const pullStrength = memoryStrength * (1 - t * 0.8);
            segment.position.lerp(idealPos, pullStrength);
        }
    }

    getMatrix() {
        const points = this.segments.map(seg => seg.position);
        const curve = new THREE.CatmullRomCurve3(points);
        const matrix = new THREE.Matrix4().setPosition(this.rootPosition);
        const quaternion = new THREE.Quaternion().setFromUnitVectors(
            new THREE.Vector3(0, 1, 0),
            this.normal
        );
        matrix.makeRotationFromQuaternion(quaternion);
        return { matrix, curve, points };
    }
}

// Hair mesh management
let hairInstanceMesh = null;
let mergedHairGeometry = null;
let hairMesh = null;

// Create hair mesh using instancing (more efficient)
function createInstancedHairMesh() {
    if (hairInstanceMesh) {
        hairInstanceMesh.geometry.dispose();
        hairInstanceMesh.material.dispose();
        sculptingSphere.remove(hairInstanceMesh);
        hairInstanceMesh = null;
    }
    
    const strandCurve = new THREE.CatmullRomCurve3([
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(0, hairBrushSettings.segmentLength * hairBrushSettings.numSegments * 0.25, 0),
        new THREE.Vector3(0, hairBrushSettings.segmentLength * hairBrushSettings.numSegments * 0.5, 0),
        new THREE.Vector3(0, hairBrushSettings.segmentLength * hairBrushSettings.numSegments * 0.75, 0),
        new THREE.Vector3(0, hairBrushSettings.segmentLength * hairBrushSettings.numSegments, 0)
    ]);
    
    const strandGeometry = new THREE.TubeGeometry(
        strandCurve,
        hairBrushSettings.numSegments,
        hairBrushSettings.thickness * (0.8 + Math.random() * hairBrushSettings.clumpSize * 0.1),
        8, // More radial segments for detail
        false
    );

    const material = new THREE.MeshPhysicalMaterial({
        color: hairBrushSettings.hairColor,
        roughness: 0.3,
        metalness: 0.2,
        clearcoat: 0.4,
        clearcoatRoughness: 0.25,
        sheen: 1.0,
        sheenRoughness: 0.3,
        sheenColor: hairBrushSettings.specularColor,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.95
    });

    hairInstanceMesh = new THREE.InstancedMesh(strandGeometry, material, hairBrushSettings.maxStrands);
    hairInstanceMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    hairInstanceMesh.castShadow = true;
    hairInstanceMesh.receiveShadow = false;
    hairInstanceMesh.frustumCulled = false;

    const dummyMatrix = new THREE.Matrix4();
    for (let i = 0; i < hairBrushSettings.maxStrands; i++) {
        hairInstanceMesh.setMatrixAt(i, dummyMatrix);
    }
    
    hairInstanceMesh.instanceMatrix.needsUpdate = true;
    if (sculptingSphere) sculptingSphere.add(hairInstanceMesh);
    console.log("Instanced hair mesh created with capacity:", hairBrushSettings.maxStrands);
    return hairInstanceMesh;
}

// Alternative: Create merged hair geometry (better for fewer strands)
function createMergedHairGeometry() {
    console.log("Creating merged hair geometry...");
    
    // Clean up previous mesh
    if (hairMesh) {
        hairMesh.geometry.dispose();
        hairMesh.material.dispose();
        sculptingSphere.remove(hairMesh);
        hairMesh = null;
    }
    
    // Create material with hair appearance
    const material = new THREE.MeshPhysicalMaterial({
        color: hairBrushSettings.hairColor,
        roughness: 0.3,
        metalness: 0.2,
        clearcoat: 0.4,
        clearcoatRoughness: 0.25,
        sheen: 1.0,
        sheenRoughness: 0.3,
        sheenColor: hairBrushSettings.specularColor,
        side: THREE.DoubleSide
    });
    
    // Initialize empty geometry
    mergedHairGeometry = new THREE.BufferGeometry();
    hairMesh = new THREE.Mesh(mergedHairGeometry, material);
    hairMesh.castShadow = true;
    hairMesh.receiveShadow = false;
    sculptingSphere.add(hairMesh);
    
    return hairMesh;
}

// Efficiently update hair visualization
function updateHairMesh() {
    const now = performance.now();
    
    // Throttle updates for performance
    if (now - hairBrushSettings.lastUpdateTime < hairBrushSettings.updateInterval && 
        !hairBrushActive) {
        return;
    }
    
    hairBrushSettings.lastUpdateTime = now;
    
    if (hairBrushSettings.useInstancing) {
        updateInstancedHair();
    } else {
        updateMergedHair();
    }
}

// Update instanced hair representation
function updateInstancedHair() {
    if (!hairInstanceMesh) {
        console.warn("hairInstanceMesh is not initialized!");
        return;
    }

    const strands = hairBrushSettings.hairStrands;
    const strandCount = Math.min(strands.length, hairBrushSettings.maxStrands);
    
    // Process in batches
    const batchStart = Math.floor(Date.now() / 100) % Math.max(1, Math.floor(strandCount / hairBrushSettings.batchSize)) * hairBrushSettings.batchSize;
    const batchEnd = Math.min(batchStart + hairBrushSettings.batchSize, strandCount);
    
    // Only update a subset of strands per frame
    for (let i = batchStart; i < batchEnd; i++) {
        if (i < strandCount) {
            const strand = strands[i];
            const { matrix } = strand.getMatrix();
            hairInstanceMesh.setMatrixAt(i, matrix);
        }
    }
    
    hairInstanceMesh.instanceMatrix.needsUpdate = true;
}

// Update merged geometry hair representation
function updateMergedHair() {
    if (!hairMesh || !mergedHairGeometry) {
        console.warn("hairMesh or mergedHairGeometry not initialized!");
        return;
    }
    
    // Only rebuild complete geometry occasionally
    const now = Date.now();
    if (now - hairBrushSettings.lastRebuild < 500 && !hairBrushActive) {
        return;
    }
    hairBrushSettings.lastRebuild = now;
    
    const strands = hairBrushSettings.hairStrands;
    const strandCount = Math.min(strands.length, hairBrushSettings.maxStrands);
    
    // For small strand counts, using merged geometry can be faster
    const geometries = [];
    for (let i = 0; i < strandCount; i++) {
        const strand = strands[i];
        const { points } = strand.getMatrix();
        
        // Create curve from points
        const curve = new THREE.CatmullRomCurve3(points);
        
        // Create tube geometry
        const tubeGeometry = new THREE.TubeGeometry(
            curve,
            hairBrushSettings.numSegments,
            hairBrushSettings.thickness * (0.8 + Math.random() * 0.4), // Slight variation
            4,
            false
        );
        
        geometries.push(tubeGeometry);
    }
    
    // Merge all geometries
    mergedHairGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries(geometries);
    hairMesh.geometry = mergedHairGeometry;
}

// Apply hair brush with efficient strand creation
function applyHairBrush(event, vertices, position, normal) {
    if (!hairBrushActive || event.buttons !== 1 || !position || !normal || !sculptingEnabled) return;
    
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(new THREE.Vector2(
        (event.clientX / window.innerWidth) * 2 - 1,
        -(event.clientY / window.innerHeight) * 2 + 1
    ), camera);
    
    const intersects = raycaster.intersectObject(sculptingSphere);
    if (intersects.length > 0 && sculptingSphere) {
        const intersect = intersects[0];
        const hitPosition = intersect.point.clone();
        const hitNormal = intersect.face.normal.clone().normalize();

        const brushRadius = characterBrushSize * 0.5; // Scale for visibility
        const density = hairBrushSettings.density / 100;
        const area = Math.PI * brushRadius * brushRadius;
        const strandsToAdd = Math.min(
            Math.floor(area * density),
            maxHairStrandsPerOperation,
            hairBrushSettings.maxStrands - hairBrushSettings.hairStrands.length
        );

        let strandsAdded = 0;
        for (let i = 0; i < strandsToAdd; i++) {
            const theta = Math.random() * 2 * Math.PI;
            const r = brushRadius * Math.sqrt(Math.random());
            
            const tangent = new THREE.Vector3(1, 0, 0).cross(hitNormal).normalize();
            if (tangent.lengthSq() < 0.01) tangent.set(0, 0, 1).cross(hitNormal).normalize();
            const bitangent = new THREE.Vector3().crossVectors(hitNormal, tangent).normalize();
            
            const offsetPosition = hitPosition.clone().add(
                tangent.clone().multiplyScalar(Math.cos(theta) * r)
            ).add(
                bitangent.clone().multiplyScalar(Math.sin(theta) * r)
            );
            
            const normalVariation = new THREE.Vector3(
                (Math.random() - 0.5) * 0.1,
                (Math.random() - 0.5) * 0.1,
                (Math.random() - 0.5) * 0.1
            );
            const strandNormal = hitNormal.clone().add(normalVariation).normalize();
            
            const strand = new HairStrand(offsetPosition, strandNormal);
            strand.initialDirection.copy(hitNormal);
            
            if (!hairBrushSettings.hairStrands.some(s => s.rootPosition.distanceTo(offsetPosition) < 0.01)) {
                hairBrushSettings.hairStrands.push(strand);
                strandsAdded++;
            }
        }

        if (!hairInstanceMesh) {
            createInstancedHairMesh();
        }
        if (!sculptingSphere.children.includes(hairInstanceMesh)) {
            sculptingSphere.add(hairInstanceMesh);
        }
        updateHairMesh(); // Force update
        console.log(`Added ${strandsAdded} strands at ${hitPosition.x}, ${hitPosition.y}, ${hitPosition.z}, Total strands: ${hairBrushSettings.hairStrands.length}`);

        // Update UI stats
        document.getElementById('strandCount').textContent = hairBrushSettings.hairStrands.length;
    }

    setTimeout(() => {
        hairBrushActive = false;
    }, 100);
}

// Efficiently update hair physics with animation frame management
function updateHairPhysics(deltaTime = 1/60) {
    if (!physicsEnabled) {
        if (physicsAnimationId) {
            cancelAnimationFrame(physicsAnimationId);
            physicsAnimationId = null;
        }
        return;
    }
    
    const batchSize = hairBrushSettings.batchSize;
    const startIndex = Math.floor(Date.now() / 32) % Math.max(1, Math.ceil(hairBrushSettings.hairStrands.length / batchSize)) * batchSize;
    const endIndex = Math.min(startIndex + batchSize, hairBrushSettings.hairStrands.length);
    
    let needsUpdate = false;
    
    for (let i = startIndex; i < endIndex; i++) {
        if (i < hairBrushSettings.hairStrands.length) {
            const changed = hairBrushSettings.hairStrands[i].update(deltaTime);
            needsUpdate = needsUpdate || changed;
        }
    }
    
    if (needsUpdate || hairBrushActive) {
        updateHairMesh();
    }
    
    physicsAnimationId = requestAnimationFrame(() => updateHairPhysics(deltaTime));
}

// Add initial gravity setting if not present in hairBrushSettings
if (!hairBrushSettings.gravity) {
    hairBrushSettings.gravity = 0.1; // Adjustable gravity strength
}
if (!hairBrushSettings.damping) {
    hairBrushSettings.damping = 0.1; // Default damping
}
if (!hairBrushSettings.windStrength) {
    hairBrushSettings.windStrength = 0.05; // Default wind strength
}
if (!hairBrushSettings.turbulence) {
    hairBrushSettings.turbulence = 0.02; // Default turbulence
}

// Character modeling variables
let selectedCharacterTool = null;
let isCharacterSculpting = false;
let characterBrushSize = 0.2;
let characterBrushStrength = 0.1;
let characterBrushFalloff = 0.5;
let sculptingSphere = null;
let characterUndoStack = [];
let characterRedoStack = [];

function setupLighting() {
    // Clear existing lights if any (optional, depends on your scene setup)
    scene.children = scene.children.filter(child => !(child instanceof THREE.Light));

    // 1. Ambient Light (soft base illumination)
    const ambientLight = new THREE.AmbientLight(0x404040, 0.5); // Soft gray light, moderate intensity
    scene.add(ambientLight);

    // 2. Key Light (main directional light)
    const keyLight = new THREE.DirectionalLight(0xffffff, 0.8);
    keyLight.position.set(5, 5, 5); // Positioned above and to the front-right
    keyLight.castShadow = true;
    keyLight.shadow.mapSize.width = 2048; // Higher resolution shadows
    keyLight.shadow.mapSize.height = 2048;
    keyLight.shadow.camera.near = 0.5;
    keyLight.shadow.camera.far = 50;
    keyLight.shadow.camera.left = -10;
    keyLight.shadow.camera.right = 10;
    keyLight.shadow.camera.top = 10;
    keyLight.shadow.camera.bottom = -10;
    keyLight.shadow.bias = -0.0001; // Reduce shadow acne
    scene.add(keyLight);

    // 3. Fill Light (softer light to reduce shadow harshness)
    const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
    fillLight.position.set(-5, 3, -5); // Positioned to the front-left
    fillLight.castShadow = false; // No shadows from fill light
    scene.add(fillLight);

    // 4. Rim Light (backlight for edge definition)
    const rimLight = new THREE.DirectionalLight(0xffffff, 0.6);
    rimLight.position.set(0, 5, -7); // Positioned behind and above
    rimLight.castShadow = false; // No shadows from rim light
    scene.add(rimLight);

    // Optional: Add a helper to visualize light positions (remove in production)
    // scene.add(new THREE.DirectionalLightHelper(keyLight, 1));
    // scene.add(new THREE.DirectionalLightHelper(fillLight, 1));
    // scene.add(new THREE.DirectionalLightHelper(rimLight, 1));
}

// Add main sculpting sphere
function addSculptingSphere() {
    console.log("Adding sculpting sphere...");
    const geometry = new THREE.SphereGeometry(1, 256, 256);
    const material = new THREE.MeshStandardMaterial({
        color: 0xF5DEB3,
        roughness: 0.6,
        metalness: 0.05,
        flatShading: false,
        emissive: 0x331A00,
        emissiveIntensity: 0.02,
        transmission: 0.1,
        thickness: 0.5,
        envMapIntensity: 0.5
    });

    sculptingSphere = new THREE.Mesh(geometry, material);
    sculptingSphere.name = 'SculptingSphere';
    sculptingSphere.castShadow = true;
    sculptingSphere.receiveShadow = true;
    sculptingSphere.userData.isSculptable = true;

    scene.add(sculptingSphere); // Ensure added to scene
    createCharacterBrushPreview();
    setupCharacterSculptingEvents();
    addObjectToScene(sculptingSphere, 'Sculpting_Sphere');

    if (hairBrushSettings.useInstancing) {
        createInstancedHairMesh();
    } else {
        createMergedHairGeometry();
    }

    setupLighting();
    return sculptingSphere;
}

// Create brush preview for better user feedback
function createCharacterBrushPreview() {
    if (window.characterBrushPreview) {
        scene.remove(window.characterBrushPreview);
    }

    // Create brush preview group
    const brushPreview = new THREE.Group();
    
    // Inner sphere for brush center
    const innerSphereGeometry = new THREE.SphereGeometry(characterBrushSize * 0.25, 16, 16);
    const innerSphereMaterial = new THREE.MeshBasicMaterial({
        color: 0x00FFFF,
        transparent: true,
        opacity: 0.5,
        depthTest: false
    });
    const innerSphere = new THREE.Mesh(innerSphereGeometry, innerSphereMaterial);

    // Falloff ring to show brush falloff area
    const falloffRingGeometry = new THREE.RingGeometry(
        characterBrushSize * 0.5, 
        characterBrushSize * 0.7, 
        32
    );
    const falloffRingMaterial = new THREE.MeshBasicMaterial({
        color: 0x00FF00,
        transparent: true,
        opacity: 0.3,
        side: THREE.DoubleSide,
        depthTest: false
    });
    const falloffRing = new THREE.Mesh(falloffRingGeometry, falloffRingMaterial);

    // Main ring for brush boundary
    const mainRingGeometry = new THREE.RingGeometry(
        characterBrushSize * 0.7, 
        characterBrushSize * 1, 
        32
    );
    const mainRingMaterial = new THREE.MeshBasicMaterial({
        color: 0xFF4500,
        transparent: true,
        opacity: 0.6,
        side: THREE.DoubleSide,
        depthTest: false
    });
    const mainRing = new THREE.Mesh(mainRingGeometry, mainRingMaterial);

    // Animated glow ring for better visibility
    const glowRingGeometry = new THREE.RingGeometry(
        characterBrushSize * 0.9, 
        characterBrushSize * 1.3, 
        32
    );
    const glowRingMaterial = new THREE.ShaderMaterial({
        uniforms: { 
            time: { value: 0 }, 
            color: { value: new THREE.Color(0xFFD700) } 
        },
        vertexShader: `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            uniform float time;
            uniform vec3 color;
            varying vec2 vUv;
            void main() {
                float glow = 0.5 + 0.5 * sin(time + vUv.x * 3.1416);
                gl_FragColor = vec4(color * glow, 0.4);
            }
        `,
        transparent: true,
        depthTest: false
    });
    const glowRing = new THREE.Mesh(glowRingGeometry, glowRingMaterial);

    // Add all elements to the brush preview
    brushPreview.add(innerSphere);
    brushPreview.add(falloffRing);
    brushPreview.add(mainRing);
    brushPreview.add(glowRing);
    brushPreview.visible = false;

    // Store reference to brush preview
    window.characterBrushPreview = brushPreview;
    scene.add(brushPreview);

    // Start animation for glow effect
    animateBrushGlow(glowRingMaterial);
}

// Animate brush glow for better visibility
function animateBrushGlow(material) {
    let lastTime = 0;
    
    function animate(time) {
        // Skip animation if not visible
        if (!window.characterBrushPreview || !window.characterBrushPreview.visible) {
            requestAnimationFrame(animate);
            return;
        }
        
        // Update shader time uniform
        material.uniforms.time.value += 0.05;
        requestAnimationFrame(animate);
    }
    
    animate(0);
}

// Update brush preview position and visibility
function updateCharacterBrushPreview(event) {
    if (!sculptingSphere || !window.characterBrushPreview) return;

    // Get mouse position in normalized device coordinates
    const mouse = new THREE.Vector2(
        (event.clientX / window.innerWidth) * 2 - 1,
        -(event.clientY / window.innerHeight) * 2 + 1
    );

    // Cast ray from camera through mouse position
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(sculptingSphere);

    if (intersects.length > 0) {
        // Position brush preview at intersection point
        const intersect = intersects[0];
        const point = intersect.point;
        const normal = intersect.face.normal;

           // Orient brush preview to follow surface normal
           window.characterBrushPreview.position.copy(point);
        
        // Create orientation matrix based on surface normal
        const orientMatrix = new THREE.Matrix4();
        const lookAt = new THREE.Vector3().addVectors(point, normal);
        orientMatrix.lookAt(point, lookAt, new THREE.Vector3(0, 1, 0));
        
        // Apply orientation to brush preview
        window.characterBrushPreview.quaternion.setFromRotationMatrix(orientMatrix);
        
        // Scale brush preview based on distance to camera for consistent visual size
        const distanceToCamera = camera.position.distanceTo(point);
        const scaleFactor = distanceToCamera * 0.05;
        window.characterBrushPreview.scale.set(scaleFactor, scaleFactor, scaleFactor);
        
        // Make brush preview visible when over sculpting surface
        window.characterBrushPreview.visible = true;
        
        // Store intersection data for potential sculpting operations
        window.lastIntersect = {
            point: point.clone(),
            normal: normal.clone(),
            face: intersect.face,
            object: intersect.object
        };
    } else {
        // Hide brush preview when not over sculpting surface
        window.characterBrushPreview.visible = false;
        window.lastIntersect = null;
    }
}

let sculptingEnabled = true;

// Setup sculpting event listeners
function setupCharacterSculptingEvents() {
    const canvas = renderer.domElement;
    
    // Existing tool selection code
    document.querySelectorAll('.panel-button').forEach(button => {
        button.addEventListener('click', () => {
            selectedCharacterTool = button.id;
            updateToolUI();
            if (selectedCharacterTool === CHARACTER_TOOLS.HAIR_BRUSH) {
                hairBrushActive = true;
            }
        });
    });

    // Mouse events
    canvas.addEventListener('mousedown', onCharacterSculptStart);
    canvas.addEventListener('mousemove', onCharacterSculptMove);
    canvas.addEventListener('mouseup', onCharacterSculptEnd);
    
    // Physics toggle
    document.getElementById('togglePhysics').addEventListener('click', () => {
        physicsEnabled = !physicsEnabled;
        if (physicsEnabled) {
            updateHairPhysics();
        }
        updateToolUI();
    });


    document.getElementById('sculptingToggle').addEventListener('change', (e) => {
        sculptingEnabled = e.target.checked;
    });

    // Existing brush controls
    document.getElementById('brushSizeSc').addEventListener('input', (e) => {
        characterBrushSize = parseFloat(e.target.value);
        document.getElementById('brushSizeValue').textContent = e.target.value;
        updateBrushPreviewSize();
    });

    document.getElementById('brushStrength').addEventListener('input', (e) => {
        characterBrushStrength = parseFloat(e.target.value);
        document.getElementById('brushStrengthValue').textContent = e.target.value;
    });

    document.getElementById('brushFalloff').addEventListener('input', (e) => {
        characterBrushFalloff = parseFloat(e.target.value);
        document.getElementById('brushFalloffValue').textContent = e.target.value;
    });

    setupHairControls();
}

function updateBrushPreviewSize() {
    if (window.characterBrushPreview) {
        const innerSphere = window.characterBrushPreview.children[0];
        const falloffRing = window.characterBrushPreview.children[1];
        const mainRing = window.characterBrushPreview.children[2];
        const glowRing = window.characterBrushPreview.children[3];

        innerSphere.geometry = new THREE.SphereGeometry(characterBrushSize * 0.25, 16, 16);
        falloffRing.geometry = new THREE.RingGeometry(characterBrushSize * 0.5, characterBrushSize * 0.7, 32);
        mainRing.geometry = new THREE.RingGeometry(characterBrushSize * 0.7, characterBrushSize * 1, 32);
        glowRing.geometry = new THREE.RingGeometry(characterBrushSize * 0.9, characterBrushSize * 1.3, 32);
    }
}

// Update UI based on selected tool
function updateToolUI() {
    document.querySelectorAll('.panel-button').forEach(button => {
        button.classList.toggle('active', button.id === selectedCharacterTool);
    });
    document.getElementById('togglePhysics').textContent = 
        physicsEnabled ? 'Disable Physics' : 'Enable Physics';
}

// Setup hair control listeners
function setupHairControls() {
    const controls = [
        'guideHairDensity', 'hairSegments', 'hairLength', 'hairDensity',
        'hairCurl', 'hairStiffness', 'hairWave', 'hairFrizz', 
        'hairClumpSize', 'hairNoise', 'hairColor', 'hairSpecular'
    ];

    controls.forEach(controlId => {
        const element = document.getElementById(controlId);
        element.addEventListener('input', (e) => {
            updateHairSettings(controlId, e.target.value);
            if (controlId.includes('hairColor') || controlId.includes('hairSpecular')) {
                updateHairMaterial();
            }
        });
    });

    document.getElementById('simulationQuality').addEventListener('change', (e) => {
        updateSimulationQuality(e.target.value);
    });
}

// Update hair settings based on UI input
function updateHairSettings(controlId, value) {
    switch(controlId) {
        case 'guideHairDensity': hairBrushSettings.density = parseFloat(value) * 100; break; // Scale to match density
        case 'hairSegments': 
            hairBrushSettings.numSegments = parseInt(value);
            hairBrushSettings.hairStrands.forEach(strand => strand.initializeSegments());
            break;
        case 'hairLength': 
            hairBrushSettings.segmentLength = parseFloat(value);
            hairBrushSettings.hairStrands.forEach(strand => strand.initializeSegments());
            break;
        case 'hairDensity': hairBrushSettings.density = parseInt(value) * 10; break; // Scale density
        case 'hairCurl': hairBrushSettings.curl = parseFloat(value); break;
        case 'hairStiffness': hairBrushSettings.stiffness = parseFloat(value); break;
        case 'hairWave': hairBrushSettings.wave = parseFloat(value); break;
        case 'hairFrizz': hairBrushSettings.frizz = parseFloat(value); break;
        case 'hairClumpSize': hairBrushSettings.clumpSize = parseInt(value); break;
        case 'hairNoise': hairBrushSettings.randomness = parseFloat(value); break;
        case 'hairColor': hairBrushSettings.hairColor = parseInt(value.replace('#', '0x')); break;
        case 'hairSpecular': hairBrushSettings.specularColor = parseInt(value.replace('#', '0x')); break;
    }
    updateHairMaterial();
    updateHairMesh();
    updateHairStrands();
}

function updateHairMaterial() {
    if (hairInstanceMesh) {
        hairInstanceMesh.material.color.setHex(hairBrushSettings.hairColor);
        hairInstanceMesh.material.sheenColor.setHex(hairBrushSettings.specularColor);
    }
    if (hairMesh) {
        hairMesh.material.color.setHex(hairBrushSettings.hairColor);
        hairMesh.material.sheenColor.setHex(hairBrushSettings.specularColor);
    }
}


function updateHairStrands() {
    hairBrushSettings.hairStrands.forEach(strand => {
        strand.initializeSegments(); // Reapply settings to existing strands
    });
    updateHairMesh();
}



// Update simulation quality settings
function updateSimulationQuality(value) {
    switch(value) {
        case 'low':
            hairBrushSettings.batchSize = 25;
            hairBrushSettings.updateInterval = 200;
            break;
        case 'medium':
            hairBrushSettings.batchSize = 50;
            hairBrushSettings.updateInterval = 100;
            break;
        case 'high':
            hairBrushSettings.batchSize = 100;
            hairBrushSettings.updateInterval = 50;
            break;
    }
}

// Sculpting event handlers
function onCharacterSculptStart(event) {
    if (!selectedCharacterTool || !sculptingSphere) return;
    
    isCharacterSculpting = true;
    saveUndoState();
    
    const vertices = sculptingSphere.geometry.attributes.position.array;
    const position = getMousePosition(event);
    const normal = getMouseNormal(event);
    
    applySculptingTool(event, vertices, position, normal);
}

function onCharacterSculptMove(event) {
    updateCharacterBrushPreview(event);
    
    if (!isCharacterSculpting || !selectedCharacterTool) return;
    
    const vertices = sculptingSphere.geometry.attributes.position.array;
    const position = getMousePosition(event);
    const normal = getMouseNormal(event);
    
    applySculptingTool(event, vertices, position, normal);
    prevMouseEvent = event; // Always update prevMouseEvent during sculpting
}

function onCharacterSculptEnd(event) {
    isCharacterSculpting = false;
    if (selectedCharacterTool === CHARACTER_TOOLS.HAIR_BRUSH) {
        hairBrushActive = false;
    }
    sculptingSphere.geometry.attributes.position.needsUpdate = true;
}

// Get mouse position on surface
function getMousePosition(event) {
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(getMouseCoords(event), camera);
    const intersects = raycaster.intersectObject(sculptingSphere);
    return intersects.length > 0 ? intersects[0].point : null;
}

// Get surface normal at mouse position
function getMouseNormal(event) {
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(getMouseCoords(event), camera);
    const intersects = raycaster.intersectObject(sculptingSphere);
    return intersects.length > 0 ? intersects[0].face.normal : null;
}

// Convert screen coords to NDC
function getMouseCoords(event) {
    return new THREE.Vector2(
        (event.clientX / window.innerWidth) * 2 - 1,
        -(event.clientY / window.innerHeight) * 2 + 1
    );
}

// Apply selected sculpting tool
function applySculptingTool(event, vertices, position, normal) {
    if (!position || !normal) return;

    switch(selectedCharacterTool) {
        case CHARACTER_TOOLS.FACE_SHAPE:
        case CHARACTER_TOOLS.NOSE_SCULPT:
        case CHARACTER_TOOLS.CHEEK_DEFINITION:
        case CHARACTER_TOOLS.JAW_SCULPT:
        case CHARACTER_TOOLS.FOREHEAD_SHAPE:
        case CHARACTER_TOOLS.CHIN_SCULPT:
        case CHARACTER_TOOLS.TEMPLE_SCULPT:
        case CHARACTER_TOOLS.BROW_RIDGE:
        case CHARACTER_TOOLS.EYE_SOCKET:
        case CHARACTER_TOOLS.LIP_SHAPE:
            sculptVertices(vertices, position, normal);
            break;
        case CHARACTER_TOOLS.SMOOTH:
            smoothVertices(vertices, position);
            break;
        case CHARACTER_TOOLS.PINCH:
            pinchVertices(vertices, position);
            break;
        case CHARACTER_TOOLS.INFLATE:
            inflateVertices(vertices, position);
            break;
        case CHARACTER_TOOLS.CREASE:
            creaseVertices(vertices, position);
            break;
        case CHARACTER_TOOLS.SNAKE_HOOK:
            snakeHookVertices(vertices, position);
            break;
        case CHARACTER_TOOLS.HAIR_BRUSH:
            applyHairBrush(event, vertices, position, normal);
            break;
    }
}

// Core sculpting functions
function sculptVertices(vertices, position, normal) {
    const symmetry = document.getElementById('symmetryToggle').checked;
    const axis = document.getElementById('symmetryAxis').value;
    
    for (let i = 0; i < vertices.length; i += 3) {
        const vertex = new THREE.Vector3(vertices[i], vertices[i + 1], vertices[i + 2]);
        const distance = vertex.distanceTo(position);
        
        if (distance < characterBrushSize) {
            const falloff = 1 - Math.pow(distance / characterBrushSize, characterBrushFalloff);
            const displacement = normal.clone().multiplyScalar(characterBrushStrength * falloff);
            
            vertices[i] += displacement.x;
            vertices[i + 1] += displacement.y;
            vertices[i + 2] += displacement.z;
            
            if (symmetry) {
                applySymmetry(vertices, i, axis);
            }
        }
    }
    sculptingSphere.geometry.attributes.position.needsUpdate = true;
    sculptingSphere.geometry.computeVertexNormals(); // Update normals for proper lighting
}

function smoothVertices(vertices, position) {
    const tempVertices = new Float32Array(vertices);
    for (let i = 0; i < vertices.length; i += 3) {
        const vertex = new THREE.Vector3(vertices[i], vertices[i + 1], vertices[i + 2]);
        if (vertex.distanceTo(position) < characterBrushSize) {
            let avg = new THREE.Vector3();
            let count = 0;
            
            for (let j = 0; j < vertices.length; j += 3) {
                if (i !== j) {
                    const neighbor = new THREE.Vector3(vertices[j], vertices[j + 1], vertices[j + 2]);
                    if (neighbor.distanceTo(vertex) < characterBrushSize * 0.5) {
                        avg.add(neighbor);
                        count++;
                    }
                }
            }
            
            if (count > 0) {
                avg.divideScalar(count);
                const falloff = 1 - (vertex.distanceTo(position) / characterBrushSize);
                tempVertices[i] = THREE.MathUtils.lerp(vertices[i], avg.x, falloff * 0.5);
                tempVertices[i + 1] = THREE.MathUtils.lerp(vertices[i + 1], avg.y, falloff * 0.5);
                tempVertices[i + 2] = THREE.MathUtils.lerp(vertices[i + 2], avg.z, falloff * 0.5);
            }
        }
    }
    vertices.set(tempVertices);
    sculptingSphere.geometry.attributes.position.needsUpdate = true;
}

function pinchVertices(vertices, position) {
    for (let i = 0; i < vertices.length; i += 3) {
        const vertex = new THREE.Vector3(vertices[i], vertices[i + 1], vertices[i + 2]);
        const distance = vertex.distanceTo(position);
        
        if (distance < characterBrushSize) {
            const falloff = 1 - (distance / characterBrushSize);
            const direction = position.clone().sub(vertex).normalize();
            const displacement = direction.multiplyScalar(characterBrushStrength * falloff * 0.5);
            
            vertices[i] += displacement.x;
            vertices[i + 1] += displacement.y;
            vertices[i + 2] += displacement.z;
        }
    }
    sculptingSphere.geometry.attributes.position.needsUpdate = true;
}

function inflateVertices(vertices, position) {
    for (let i = 0; i < vertices.length; i += 3) {
        const vertex = new THREE.Vector3(vertices[i], vertices[i + 1], vertices[i + 2]);
        const distance = vertex.distanceTo(position);
        
        if (distance < characterBrushSize) {
            const falloff = 1 - (distance / characterBrushSize);
            const direction = vertex.clone().normalize();
            const displacement = direction.multiplyScalar(characterBrushStrength * falloff);
            
            vertices[i] += displacement.x;
            vertices[i + 1] += displacement.y;
            vertices[i + 2] += displacement.z;
        }
    }
    sculptingSphere.geometry.attributes.position.needsUpdate = true;
}

function creaseVertices(vertices, position) {
    for (let i = 0; i < vertices.length; i += 3) {
        const vertex = new THREE.Vector3(vertices[i], vertices[i + 1], vertices[i + 2]);
        const distance = vertex.distanceTo(position);
        
        if (distance < characterBrushSize) {
            const falloff = 1 - Math.pow(distance / characterBrushSize, 2);
            const direction = vertex.clone().sub(position).normalize();
            const displacement = direction.multiplyScalar(-characterBrushStrength * falloff);
            
            vertices[i] += displacement.x;
            vertices[i + 1] += displacement.y;
            vertices[i + 2] += displacement.z;
        }
    }
    sculptingSphere.geometry.attributes.position.needsUpdate = true;
}

let prevMouseEvent = null;

function snakeHookVertices(vertices, position) {
    if (!prevMouseEvent) return; // Skip if no previous position

    const mousePos = getMouseCoords(event);
    const prevMousePos = getMouseCoords(prevMouseEvent);
    const movement = new THREE.Vector2().subVectors(mousePos, prevMousePos);

    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mousePos, camera);
    const intersects = raycaster.intersectObject(sculptingSphere);
    if (!intersects.length) return;

    const newPosition = intersects[0].point;

    for (let i = 0; i < vertices.length; i += 3) {
        const vertex = new THREE.Vector3(vertices[i], vertices[i + 1], vertices[i + 2]);
        const distance = vertex.distanceTo(position);
        
        if (distance < characterBrushSize) {
            const falloff = 1 - (distance / characterBrushSize);
            const direction = newPosition.clone().sub(position).normalize();
            const displacement = direction.multiplyScalar(characterBrushStrength * falloff * movement.length() * 5);
            
            vertices[i] += displacement.x;
            vertices[i + 1] += displacement.y;
            vertices[i + 2] += displacement.z;
        }
    }
    sculptingSphere.geometry.attributes.position.needsUpdate = true;
    sculptingSphere.geometry.computeVertexNormals(); // Update normals
    prevMouseEvent = event; // Update previous event
}

// Symmetry handling
function applySymmetry(vertices, index, axis) {
    const vertex = new THREE.Vector3(vertices[index], vertices[index + 1], vertices[index + 2]);
    const symmetricVertex = vertex.clone();
    
    switch(axis) {
        case 'x': symmetricVertex.x = -symmetricVertex.x; break;
        case 'y': symmetricVertex.y = -symmetricVertex.y; break;
        case 'z': symmetricVertex.z = -symmetricVertex.z; break;
    }
    
    let closestIndex = -1;
    let minDistance = Infinity;
    
    for (let i = 0; i < vertices.length; i += 3) {
        const v = new THREE.Vector3(vertices[i], vertices[i + 1], vertices[i + 2]);
        const distance = v.distanceTo(symmetricVertex);
        if (distance < minDistance) {
            minDistance = distance;
            closestIndex = i;
        }
    }
    
    if (closestIndex >= 0) {
        vertices[closestIndex] = symmetricVertex.x;
        vertices[closestIndex + 1] = symmetricVertex.y;
        vertices[closestIndex + 2] = symmetricVertex.z;
    }
}

// Undo/Redo system
function saveUndoState() {
    const vertices = sculptingSphere.geometry.attributes.position.array.slice();
    characterUndoStack.push({
        vertices: vertices,
        hairStrands: hairBrushSettings.hairStrands.map(strand => ({
            rootPosition: strand.rootPosition.clone(),
            normal: strand.normal.clone(),
            segments: strand.segments.map(seg => ({
                position: seg.position.clone(),
                velocity: seg.velocity.clone()
            }))
        }))
    });
    if (characterUndoStack.length > 50) characterUndoStack.shift();
    characterRedoStack = [];
}

function undo() {
    if (characterUndoStack.length === 0) return;
    
    const currentState = {
        vertices: sculptingSphere.geometry.attributes.position.array.slice(),
        hairStrands: hairBrushSettings.hairStrands.map(strand => ({
            rootPosition: strand.rootPosition.clone(),
            normal: strand.normal.clone(),
            segments: strand.segments.map(seg => ({
                position: seg.position.clone(),
                velocity: seg.velocity.clone()
            }))
        }))
    };
    
    characterRedoStack.push(currentState);
    const state = characterUndoStack.pop();
    
    sculptingSphere.geometry.attributes.position.array.set(state.vertices);
    sculptingSphere.geometry.attributes.position.needsUpdate = true;
    
    hairBrushSettings.hairStrands = state.hairStrands.map(data => {
        const strand = new HairStrand(data.rootPosition, data.normal);
        strand.segments = data.segments.map(seg => ({
            position: seg.position.clone(),
            velocity: seg.velocity.clone(),
            prevPosition: seg.position.clone(),
            force: new THREE.Vector3(),
            mass: 1,
            locked: false,
            normal: data.normal.clone()
        }));
        return strand;
    });
    updateHairMesh();
}

function redo() {
    if (characterRedoStack.length === 0) return;
    
    const currentState = {
        vertices: sculptingSphere.geometry.attributes.position.array.slice(),
        hairStrands: hairBrushSettings.hairStrands.map(strand => ({
            rootPosition: strand.rootPosition.clone(),
            normal: strand.normal.clone(),
            segments: strand.segments.map(seg => ({
                position: seg.position.clone(),
                velocity: seg.velocity.clone()
            }))
        }))
    };
    
    characterUndoStack.push(currentState);
    const state = characterRedoStack.pop();
    
    sculptingSphere.geometry.attributes.position.array.set(state.vertices);
    sculptingSphere.geometry.attributes.position.needsUpdate = true;
    
    hairBrushSettings.hairStrands = state.hairStrands.map(data => {
        const strand = new HairStrand(data.rootPosition, data.normal);
        strand.segments = data.segments.map(seg => ({
            position: seg.position.clone(),
            velocity: seg.velocity.clone(),
            prevPosition: seg.position.clone(),
            force: new THREE.Vector3(),
            mass: 1,
            locked: false,
            normal: data.normal.clone()
        }));
        return strand;
    });
    updateHairMesh();
}



function initRenderer() {
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Soft shadows like Blender
    renderer.toneMapping = THREE.ACESFilmicToneMapping; // Better color response
    renderer.toneMappingExposure = 1.0;
}

// Initialize the sculpting system
function initCharacterSculpting() {
    initRenderer(); // Ensure renderer is properly configured
    addSculptingSphere();
    animate();
}

// Start the system
initCharacterSculpting();

// Add keyboard shortcuts
document.addEventListener('keydown', (event) => {
    if (event.ctrlKey && event.key === 'z') undo();
    if (event.ctrlKey && event.key === 'y') redo();
});
</script>

   
    <script>
        class TerrainBrushSystem {
            constructor(scene, camera, renderer, terrain) {
                this.scene = scene;
                this.camera = camera;
                this.renderer = renderer;
                this.terrain = terrain;
                
                // Brush states
                this.isActive = false;
                this.isPainting = false;
                this.lastPaintPosition = new THREE.Vector3();
                
                // Brush settings
                this.settings = {
                    radius: 2,
                    density: 5,
                    spacing: 0.5,
                    scaleMin: 0.8,
                    scaleMax: 1.2,
                    rotationMin: 0,
                    rotationMax: 360,
                    heightOffset: 0,
                    paintDelay: 50, // ms between paint operations
                };
        
                // Storage for models
                this.models = new Map();
                this.activeModel = null;
                
                // Initialize systems
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.brushPreview = this.createBrushPreview2();
                this.scene.add(this.brushPreview);
                
                // Initialize event listeners
                this.initializeEventListeners();
                this.lastPaintTime = 0;
                
                // Undo/Redo system
                this.undoStack = [];
                this.redoStack = [];
                this.currentPaintOperation = [];
            }
        
            createBrushPreview2() {
                const group = new THREE.Group();
        
                // Main circle
                const circleGeometry = new THREE.CircleGeometry(1, 32);
                const circleMaterial = new THREE.MeshBasicMaterial({
                    color: 0xFF7F7F,
                    transparent: true,
                    opacity: 0.6,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });
                const circle = new THREE.Mesh(circleGeometry, circleMaterial);
                circle.rotation.x = -Math.PI / 2;
                circle.renderOrder = 1;
        
                // Outer ring
                const ringGeometry = new THREE.RingGeometry(0.95, 1, 32);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: 0xFFFFFF,
                    transparent: true,
                    opacity: 0.7,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = -Math.PI / 2;
                ring.renderOrder = 2;
        
                // Center dot
                const dotGeometry = new THREE.CircleGeometry(0.05, 16);
                const dotMaterial = new THREE.MeshBasicMaterial({
                    color: 0xFFFFFF,
                    transparent: true,
                    opacity: 0.9,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });
                const dot = new THREE.Mesh(dotGeometry, dotMaterial);
                dot.rotation.x = -Math.PI / 2;
                dot.position.y = 0.01;
                dot.renderOrder = 3;
        
                group.add(circle);
                group.add(ring);
                group.add(dot);
                group.visible = false;
        
                return group;
            }
        
            initializeEventListeners() {
                // Mouse events
                this.renderer.domElement.addEventListener('mousemove', this.onMouseMove.bind(this));
                this.renderer.domElement.addEventListener('mousedown', this.onMouseDown.bind(this));
                this.renderer.domElement.addEventListener('mouseup', this.onMouseUp.bind(this));
                
                // Keyboard shortcuts
                window.addEventListener('keydown', (e) => {
                    if (e.key === 'b' || e.key === 'B') {
                        this.toggleBrush();
                    }
                    if (e.key === 'z' && e.ctrlKey) {
                        this.undo();
                    }
                    if (e.key === 'y' && e.ctrlKey) {
                        this.redo();
                    }
                });
        
                // UI Controls
                this.setupUIControls();
            }
        
            setupUIControls() {
                // Brush size control
                const sizeSlider = document.getElementById('brush-size');
                if (sizeSlider) {
                    sizeSlider.addEventListener('input', (e) => {
                        this.settings.radius = parseFloat(e.target.value);
                        this.updateBrushPreview();
                    });
                }
        
                // Density control
                const densitySlider = document.getElementById('brush-density');
                if (densitySlider) {
                    densitySlider.addEventListener('input', (e) => {
                        this.settings.density = parseInt(e.target.value);
                    });
                }
        
                // Model upload
                const modelUpload = document.getElementById('model-upload');
                if (modelUpload) {
                    modelUpload.addEventListener('change', this.handleModelUpload.bind(this));
                }
            }
        
            handleModelUpload(event) {
                const file = event.target.files[0];
                if (!file) return;
        
                const loader = new THREE.GLTFLoader();
                const reader = new FileReader();
        
                reader.onload = (e) => {
                    loader.load(e.target.result, (gltf) => {
                        const model = gltf.scene;
                        const modelName = file.name.split('.')[0];
                        
                        // Center and normalize model
                        const box = new THREE.Box3().setFromObject(model);
                        const center = box.getCenter(new THREE.Vector3());
                        const size = box.getSize(new THREE.Vector3());
                        const maxDim = Math.max(size.x, size.y, size.z);
                        
                        model.position.sub(center);
                        model.scale.multiplyScalar(1 / maxDim);
                        
                        this.models.set(modelName, model);
                        this.activeModel = model;
                        
                        console.log(`Model ${modelName} loaded successfully`);
                    });
                };
        
                reader.readAsDataURL(file);
            }
        
            onMouseMove(event) {
                if (!this.isActive) return;
        
                this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        
                this.updateBrushPosition();
                
                if (this.isPainting) {
                    this.paint();
                }
            }
        
            onMouseDown(event) {
                if (event.button !== 0 || !this.isActive || !this.activeModel) return;
                this.isPainting = true;
                this.currentPaintOperation = [];
                this.paint();
            }
        
            onMouseUp() {
                if (this.isPainting && this.currentPaintOperation.length > 0) {
                    this.undoStack.push(this.currentPaintOperation);
                    this.redoStack = [];
                }
                this.isPainting = false;
            }
        
            updateBrushPosition() {
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObject(this.terrain);
        
                if (intersects.length > 0) {
                    const point = intersects[0].point;
                    this.brushPreview.position.copy(point);
                    this.brushPreview.scale.setScalar(this.settings.radius);
                    this.brushPreview.visible = true;
                } else {
                    this.brushPreview.visible = false;
                }
            }
        
            paint() {
                if (!this.activeModel || !this.isPainting) return;
        
                const now = Date.now();
                if (now - this.lastPaintTime < this.settings.paintDelay) return;
                this.lastPaintTime = now;
        
                const intersects = this.raycaster.intersectObject(this.terrain);
                if (intersects.length === 0) return;
        
                const center = intersects[0].point;
                const instanceCount = Math.floor(this.settings.density * (this.settings.radius * this.settings.radius));
        
                for (let i = 0; i < instanceCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * this.settings.radius;
                    
                    const position = new THREE.Vector3(
                        center.x + Math.cos(angle) * radius,
                        center.y + this.settings.heightOffset,
                        center.z + Math.sin(angle) * radius
                    );
        
                    // Check minimum distance from last placement
                    if (position.distanceTo(this.lastPaintPosition) < this.settings.spacing) {
                        continue;
                    }
        
                    const instance = this.activeModel.clone();
                    instance.position.copy(position);
        
                    // Random rotation
                    const rotation = THREE.MathUtils.degToRad(
                        this.settings.rotationMin + 
                        Math.random() * (this.settings.rotationMax - this.settings.rotationMin)
                    );
                    instance.rotation.y = rotation;
        
                    // Random scale
                    const scale = this.settings.scaleMin + 
                        Math.random() * (this.settings.scaleMax - this.settings.scaleMin);
                    instance.scale.setScalar(scale);
        
                    this.scene.add(instance);
                    this.currentPaintOperation.push(instance);
                    this.lastPaintPosition.copy(position);
                }
            }
        
            undo() {
                if (this.undoStack.length === 0) return;
                
                const objects = this.undoStack.pop();
                this.redoStack.push(objects);
                
                objects.forEach(obj => {
                    this.scene.remove(obj);
                });
            }
        
            redo() {
                if (this.redoStack.length === 0) return;
                
                const objects = this.redoStack.pop();
                this.undoStack.push(objects);
                
                objects.forEach(obj => {
                    this.scene.add(obj);
                });
            }
        
            toggleBrush() {
                this.isActive = !this.isActive;
                this.brushPreview.visible = this.isActive;
            }
        
            updateBrushPreview() {
                this.brushPreview.scale.setScalar(this.settings.radius);
            }
        }

    </script>
   
    <script src="index.js"></script>
    <script src="js/cloth.js"></script>
    <script src="js/node-editor-ex.js"></script>
    <script src="js/lighting-stystem.js"></script>
    <script src="js/code-editor.js"></script>
    <script src="js/export.js"></script>
    <script src="js/animation-path.js"></script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/TransformControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/geometries/TextGeometry.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@latest/build/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/RGBELoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.17"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.139.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.139.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.139.0/examples/js/controls/TransformControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.139.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.139.0/examples/js/loaders/RGBELoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.139.0/examples/js/pmrem/PMREMGenerator.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.139.0/examples/js/pmrem/PMREMCubeUVPacker.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FBXLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/examples/js/controls/TransformControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r146/three.min.js"></script>
  
    <!-- Physics -->
    <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.7/build/dat.gui.min.js"></script>

    <!--Gui-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.139.0/examples/js/objects/Sky.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.17.0/dist/lil-gui.min.js"></script>
    <!-- Particle effects -->
    <script src="https://cdn.jsdelivr.net/npm/three-spritetext@1.6.5/dist/three-spritetext.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script  src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon-es/0.17.0/cannon-es.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/postprocessing/OutlinePass.js"></script>
   <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/loaders/FBXLoader.js"></script>
   
   <script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/GLTFLoader.js"></script>
   <script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/OBJLoader.js"></script>
   <script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/FBXLoader.js"></script>

   <!-- Required for FBX -->
   <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/helpers/SkeletonHelper.js"></script>
   <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/loaders/FBXLoader.min.js"></script>
   <script src="https://cdn.jsdelivr.net/npm/fflate@0.7.4/umd/index.min.js"></script>
   <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/inflate.min.js"></script>


  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/postprocessing/UnrealBloomPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/postprocessing/SSAOPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/shaders/CopyShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/postprocessing/ShaderPass.js"></script>
    
  <!--Exporters-->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
  
  <!-- Exporters & Loaders -->
  <script src="https://cdn.jsdelivr.net/npm/three/examples/js/exporters/GLTFExporter.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three/examples/js/exporters/OBJExporter.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three/examples/js/exporters/FBXExporter.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/GLTFLoader.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/OBJLoader.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/FBXLoader.min.js"></script>
  
  <!--Proccesing-->
  <script src="https://cdn.jsdelivr.net/npm/three-subdivide"></script>
<script>
// First, add these global variables at the top of your 



let objects = [];
let snowParticles = [];
let groundLevel = 0;
let snowDensity = 1500;
let snowSize = 0.2;
let snowSpeed = 0.5;
let windForce = 0.5;
let turbulence = 0.5;
let stormMode = false;
let snowMaterial;


let isSnowing = true;
let params = {
    density: 1500,
    size: 0.15,
    speed: 0.6,
    wind: 0.3,
    turbulence: 0.5,
    groundLevel: -10,
    mode: 'normal'
};

const textureLoader = new THREE.TextureLoader();
const snowflakeTexture = textureLoader.load('https://threejs.org/examples/textures/sprites/snowflake2.png');

let snowAccumulation = new Map(); // Store accumulated snow particles
const maxAccumulatedParticles = 1000; // Maximum particles that can accumulate at one spot
const meltingRate = 0.01; // Rate at which snow melts
const gridY = params.groundLevel; // Y position of the grid

function createSnow() {
    const snowGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(params.density * 3);
    const velocities = new Float32Array(params.density * 3);
    const randomFactors = new Float32Array(params.density);

    for (let i = 0; i < params.density; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 50;
        positions[i * 3 + 1] = Math.random() * 50;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 50;

        velocities[i * 3] = (Math.random() - 0.5) * 0.05;
        velocities[i * 3 + 1] = -Math.random() * params.speed;
        velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.05;

        randomFactors[i] = Math.random();
    }

    snowGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    snowGeometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
    snowGeometry.setAttribute('random', new THREE.BufferAttribute(randomFactors, 1));

    const snowMaterial = new THREE.PointsMaterial({
        size: params.size,
        color: 0xffffff,
        transparent: true,
        opacity: 0.8,
        depthWrite: false,
        alphaTest: 0.1,
        map: snowflakeTexture,
        blending: THREE.AdditiveBlending
    });

    // In your createSnow function, add these attributes:
snowGeometry.setAttribute('random', new THREE.Float32BufferAttribute(
    new Float32Array(params.density).map(() => Math.random()),
    1
));

// Optional: Add size variation
snowGeometry.setAttribute('size', new THREE.Float32BufferAttribute(
    new Float32Array(params.density).fill(params.size),
    1
));

// Optional: Add opacity variation
snowGeometry.setAttribute('opacity', new THREE.Float32BufferAttribute(
    new Float32Array(params.density).fill(1.0),
    1
));

    const snow = new THREE.Points(snowGeometry, snowMaterial);
    snowParticles.push(snow);
    scene.add(snow);
}


function createSnowflakeTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 32;
    canvas.height = 32;
    const ctx = canvas.getContext('2d');

    ctx.beginPath();
    ctx.arc(16, 16, 14, 0, Math.PI * 2);
    ctx.fillStyle = 'white';
    ctx.fill();

    return new THREE.CanvasTexture(canvas);
}

function updateSnow() {
    const time = Date.now() * 0.001; // Current time for animations
    
    snowParticles.forEach(particle => {
        const positions = particle.geometry.attributes.position.array;
        const velocities = particle.geometry.attributes.velocity.array;
        const randomFactors = particle.geometry.attributes.random.array;

        for (let i = 0; i < positions.length; i += 3) {
            // Add swirling effect
            const swirl = Math.sin(time + positions[i] * 0.1) * 0.2;
            const vortex = Math.cos(time + positions[i + 2] * 0.1) * 0.2;
            
            // Variable wind based on height
            const heightFactor = Math.max(0, (positions[i + 1] - params.groundLevel) / 50);
            const windEffect = params.wind * heightFactor;
            
            // Add spiral motion
            const angle = time * 0.5 + randomFactors[i / 3] * Math.PI * 2;
            const radius = Math.max(0, (positions[i + 1] - params.groundLevel) / 10);
            const spiralX = Math.cos(angle) * radius * 0.1;
            const spiralZ = Math.sin(angle) * radius * 0.1;
            
            // Add turbulent motion
            const turbX = Math.sin(time * 2 + positions[i] * 0.1) * params.turbulence;
            const turbZ = Math.cos(time * 2 + positions[i + 2] * 0.1) * params.turbulence;
            
            // Update positions with combined effects
            positions[i] += velocities[i] * windEffect + swirl + spiralX + turbX;
            positions[i + 1] += velocities[i + 1] * params.speed * (0.8 + Math.sin(time + randomFactors[i / 3]) * 0.2);
            positions[i + 2] += velocities[i + 2] * windEffect + vortex + spiralZ + turbZ;

            // Ground collision with bounce effect
            if (positions[i + 1] < params.groundLevel) {
                // Random bounce chance
                if (Math.random() < 0.3) {
                    // Small bounce
                    positions[i + 1] = params.groundLevel;
                    velocities[i + 1] = Math.abs(velocities[i + 1]) * 0.2;
                    
                    // Horizontal scatter on impact
                    velocities[i] = (Math.random() - 0.5) * 0.2;
                    velocities[i + 2] = (Math.random() - 0.5) * 0.2;
                    
                    // Fade out effect (if using opacity attribute)
                    if (particle.geometry.attributes.opacity) {
                        particle.geometry.attributes.opacity.array[i / 3] *= 0.9;
                    }
                } else {
                    // Reset to top with random offset
                    positions[i + 1] = 50 + Math.random() * 10;
                    positions[i] = (Math.random() - 0.5) * 50;
                    positions[i + 2] = (Math.random() - 0.5) * 50;
                    
                    // Reset velocities with slight randomization
                    velocities[i] = (Math.random() - 0.5) * 0.05;
                    velocities[i + 1] = -Math.random() * params.speed;
                    velocities[i + 2] = (Math.random() - 0.5) * 0.05;
                    
                    // Reset opacity if using it
                    if (particle.geometry.attributes.opacity) {
                        particle.geometry.attributes.opacity.array[i / 3] = 1.0;
                    }
                }
            }

            // Add size variation based on height
            if (particle.geometry.attributes.size) {
                const size = 1.0 + Math.sin(time + randomFactors[i / 3] * 10) * 0.3;
                particle.geometry.attributes.size.array[i / 3] = params.size * size;
            }
        }

        // Update all modified attributes
        particle.geometry.attributes.position.needsUpdate = true;
        if (particle.geometry.attributes.size) particle.geometry.attributes.size.needsUpdate = true;
        if (particle.geometry.attributes.opacity) particle.geometry.attributes.opacity.needsUpdate = true;
    });
}


function setupWeatherEffects() {
    const effects = {
        storm: { speed: 3, wind: 3, turbulence: 2 },
        blizzard: { speed: 4, wind: 4, turbulence: 2.5 },
        gentle: { speed: 0.5, wind: 0.2, turbulence: 0.3 }
    };

    Object.keys(effects).forEach(effect => {
        document.getElementById(effect).addEventListener('click', () => {
            const settings = effects[effect];
            Object.keys(settings).forEach(param => {
                params[param] = settings[param];
                document.getElementById(param).value = settings[param];
                document.getElementById(`${param}Value`).textContent = settings[param];
            });
        });
    });
}

        function updateSnowSize() {
            snowParticles.forEach(particles => {
                particles.material.size = params.size;
            });
        }

        function recreateSnow() {
            snowParticles.forEach(particles => {
                scene.remove(particles);
            });
            snowParticles = [];
            createSnow();
        }


</script>

<script>
 


let scene, camera, renderer, controls, transformControls, raycaster, mouse;
let selectedObject = null;
let isPlaying = false;
let clock = new THREE.Clock();




let particles, particlesGeometry,  particlesMaterial;
const particlesCount = 10000;
let particleColor = 0xffcc88;
let isParticlesVisible = true; 
let isLocked = false;

let textureLoaded = null; 



function toggleParticles() {
    if (particles) {
        isParticlesVisible = !isParticlesVisible;
        particles.visible = isParticlesVisible;
        console.log(`Particles ${isParticlesVisible ? "enabled" : "disabled"}`);
    } else {
        console.warn("Particles have not been initialized yet.");
    }
}


function createParticles() {
    if (!textureLoaded) {
        textureLoaded = new THREE.TextureLoader().load(
            'https://threejs.org/examples/textures/sprites/spark1.png'
        );
    }

    particlesGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particlesCount * 3);
    const sizes = new Float32Array(particlesCount);

    for (let i = 0; i < particlesCount; i++) {
        // Gaussian distribution for natural spread
        positions[i * 3] = (Math.random() - 0.5) * 100 + gaussianRandom() * 20;
        positions[i * 3 + 1] = (Math.random() - 0.5) * 100 + gaussianRandom() * 20;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 100 + gaussianRandom() * 20;

        // Randomized size variation
        sizes[i] = Math.random() * 0.5 + 0.1;
    }

    particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    particlesGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

    if (!particlesMaterial) {
        particlesMaterial = new THREE.PointsMaterial({
            color: particleColor,
            size: 0.3,
            sizeAttenuation: true,
            transparent: true,
            opacity: 0.8, // Slight fade-in effect
            map: textureLoaded,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
        });
    }

    particles = new THREE.Points(particlesGeometry, particlesMaterial);
    scene.add(particles);
    isParticlesVisible = true;
}

/**
 * Generates a Gaussian (normal) distribution random number.
 * Creates more naturally clustered particles.
 */
function gaussianRandom(mean = 0, stdev = 1) {
    let u = 1 - Math.random(); // Uniform(0,1] random number
    let v = 1 - Math.random();
    let z = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    return mean + z * stdev;
}


function changeParticlesCount(amount) {
    particlesCount = Math.max(1000, particlesCount + amount);  // Minimum particlesCount is 1000
    updateParticles();
}

function changeParticleColor(color) {
    particleColor = new THREE.Color(color);
    particles.material.color.set(particleColor);  // Update particle color
}




let isDrawing = false;
let drawMode = false;
let extrudeMode = false;
let points = [];
let previewMesh = null;
let previewLine = null;
let quadMeshes = [];
let snapThreshold = 0.3;
let extrudeHeight = 1.0;
cameraOrbitSpeed = 0.005;
let currentCameraPosition = new THREE.Vector3();
let targetCameraPosition = new THREE.Vector3();
let cameraVelocity = new THREE.Vector3();

let mouseDown = false;
let selectedFace = null;
let orbitControls = true;
let transformControlsActive = false;



let isModelingMode = false;
let selectionMode = 'vertex';
let activeObject = null;
let selectedElements = [];
let vertexHelpers = new THREE.Group();
let edgeHelpers = new THREE.Group();
let faceHelpers = new THREE.Group();

function createGradientBackground() {
    const canvas = document.createElement('canvas');
    canvas.width = 2;
    canvas.height = 256;
    const context = canvas.getContext('2d');

    const gradient = context.createLinearGradient(0, 0, 0, 256);
    gradient.addColorStop(0, '#1a1a1a');
    gradient.addColorStop(1, '#3a3a3a');

    context.fillStyle = gradient;
    context.fillRect(0, 0, 2, 256);

    const texture = new THREE.CanvasTexture(canvas);
    scene.background = texture;
}


function init() {
    // Scene setup
    scene = new THREE.Scene();
    createGradientBackground();
    // Camera setup
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 5;

    updateCameraPosition();
    // Renderer setup
    renderer = new THREE.WebGLRenderer({ 
        antialias: true,
        // Enable tone mapping for better HDR rendering
        toneMapping: THREE.ACESFilmicToneMapping,
        toneMappingExposure: 1.0,
        powerPreference: "high-performance",
        stencil: true,
        depth: true,
    });

    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('renderer-container').appendChild(renderer.domElement);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.autoClear = false;
    renderer.antialias = true; // تنعيم الحواف
    renderer.setPixelRatio(window.devicePixelRatio); // دقة أفضل
    renderer.toneMappingExposure = 1.0;

   


    // Remove OrbitControls (if you prefer full manual control)
    if (controls) {
        controls.dispose();
        controls = null;
    }

    transformControls = new THREE.TransformControls(camera, renderer.domElement);
    scene.add(transformControls);

   


    // Axes helper
    const axesHelper = new THREE.AxesHelper(5);
    scene.add(axesHelper);

    // Raycaster and mouse setup
    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();

    // Controls
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    transformControls = new THREE.TransformControls(camera, renderer.domElement);
    scene.add(transformControls);
    controls.enableDamping = true;
    controls.dampingFactor = 0.25;
    controls.screenSpacePanning = false;
    controls.enabled = true;

    // 3. Set up the interaction between the two
    transformControls.addEventListener('mouseDown', function() {
        transformControlsActive = true;
        if (controls && !isLocked) {
            controls.enabled = false;
        }
        console.log("Transform started, orbit controls disabled");
    });
    
    transformControls.addEventListener('mouseUp', function() {
        transformControlsActive = false;
        if (controls && !isLocked) {
            controls.enabled = true;
        }
        console.log("Transform ended, orbit controls restored");
    });
    
    // This is still helpful as a backup
    transformControls.addEventListener('dragging-changed', function(event) {
        if (controls && !isLocked) {
            controls.enabled = !event.value;
        }
    });

  
    const nodeEditor = new NodeEditor(scene, camera, raycaster);
    // Pass nodeEditor to global scope if needed
    window.nodeEditor = nodeEditor;

    document.addEventListener('keydown', (e) => {
        if (e.ctrlKey && e.key === 'z') nodeEditor.undo();
        if (e.ctrlKey && e.key === 'y') nodeEditor.redo();
    });

    //modeling helpers
    scene.add(vertexHelpers);
    scene.add(edgeHelpers);
    scene.add(faceHelpers);



    // Enhanced lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
    scene.add(ambientLight);

    const spotLight = new THREE.SpotLight(0xffffff, 2);
    spotLight.position.set(5, 10, 5);
    spotLight.castShadow = true;
    spotLight.shadow.mapSize.width = 2048;
    spotLight.shadow.mapSize.height = 2048;
    spotLight.angle = Math.PI / 6;
    spotLight.penumbra = 0.5;
    spotLight.shadow.bias = -0.0001;
    spotLight.shadow.normalBias = 0.05;
    scene.add(spotLight);

    const rectLight = new THREE.RectAreaLight(0xffffff, 2, 10, 10);
    rectLight.position.set(0, 5, 0);
    rectLight.lookAt(0, 0, 0);
    scene.add(rectLight);


    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(10, 20, 10);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 4096;
    directionalLight.shadow.mapSize.height = 4096;
    directionalLight.shadow.bias = -0.0001;
    directionalLight.shadow.normalBias = 0.02;
    scene.add(directionalLight);

    const pointLight = new THREE.PointLight(0xffffff, 1, 100);
    pointLight.position.set(10, 10, 10);
    scene.add(pointLight);

    // Grid helper
    const advancedGrid = createAdvancedGridHelper(1000, 1000);
    scene.add(advancedGrid);

    const lineMaterial = new THREE.LineBasicMaterial({
        color: 0xffff00,
        linewidth: 2
    });

    previewLine = new THREE.Line(
        new THREE.BufferGeometry(),
        lineMaterial
    );
    scene.add(previewLine);


    // Enhanced fog
    scene.fog = new THREE.FogExp2(0x2a2a2a, 1, 50);
    // GUI setup
    const settings = addGUI(scene, renderer, camera);
   
    // Event listeners and initialization
    window.addEventListener('DOMContentLoaded', () => {
    const lockButton = document.getElementById('toggle-lock');
    if (lockButton) {
        lockButton.addEventListener('click', toggleLock);
        console.log("Lock button listener attached");
    } else {
        console.error("Lock button not found!");
    }
    });

    document.addEventListener('DOMContentLoaded', () => {
    // Wait a short time to ensure THREE.js is initialized
    setTimeout(() => {
        initPathAnimationSystem();
        addPathAnimationStyles();
    }, 1000);
    });


    setupSceneElements();
    initModeling();
    createSnow();
    setupEventListeners();
    initPhysics();
    addDemonstrationObjects();
    createParticles();
    animate();
    optimizeScene();
    initBrush();
    initCharacterSculpting();
}



function initModeling() {
    initTransformControls();
    setupModelingEventListeners();
}

const zoomSpeed = 0.05; // Finer control over zoom sensitivity
const rotationSpeed = 0.005; // Smoother rotation
const moveSpeed = 0.1; // Consistent movement speed
let cameraDistance = 10;
let cameraTheta = Math.PI / 4;
let cameraPhi = Math.PI / 3;
const cameraTarget = new THREE.Vector3(0, 0, 0);
let isDraggingCam = false;
let lastMouseX, lastMouseY;
let velocity = new THREE.Vector3(); // For smooth movement
const dampingFactor = 0.1; // For inertia



function updateCameraPosition() {
    const x = cameraDistance * Math.sin(cameraPhi) * Math.sin(cameraTheta);
    const y = cameraDistance * Math.cos(cameraPhi);
    const z = cameraDistance * Math.sin(cameraPhi) * Math.cos(cameraTheta);
    camera.position.set(x, y, z);
    camera.lookAt(cameraTarget);
}

// Smooth Zoom with Damping
function zoomCamera(delta) {
    const zoomFactor = 1 - delta * zoomSpeed;
    cameraDistance *= zoomFactor;
    cameraDistance = THREE.MathUtils.clamp(cameraDistance, 1, 100); // Limit zoom range
    updateCameraPosition();
}

// Smooth Rotation with Inertia
function rotateCamera(deltaX, deltaY) {
    cameraTheta -= deltaX * rotationSpeed;
    cameraPhi -= deltaY * rotationSpeed;
    cameraPhi = THREE.MathUtils.clamp(cameraPhi, 0.1, Math.PI - 0.1); // Prevent flipping
    updateCameraPosition();
}

// Keyboard Movement Controls
function moveCamera(direction) {
    const forward = new THREE.Vector3();
    camera.getWorldDirection(forward);
    
    // اتجاه اليمين باستخدام cross مع المحور Y
    const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();

    switch (direction) {
        case "forward": // Up Arrow / W
            camera.position.add(forward.multiplyScalar(moveSpeed));
            break;
        case "backward": // Down Arrow / S
            camera.position.add(forward.multiplyScalar(-moveSpeed));
            break;
        case "left": // Left Arrow / A
            camera.position.add(right.multiplyScalar(-moveSpeed));
            break;
        case "right": // Right Arrow / D
            camera.position.add(right.multiplyScalar(moveSpeed));
            break;
    }
}



document.addEventListener("keydown", (event) => {
    switch (event.code) {
        case "ArrowUp":
        case "KeyW":
            moveCamera("forward");
            break;
        case "ArrowDown":
        case "KeyS":
            moveCamera("backward");
            break;
        case "ArrowLeft":
        case "KeyA":
            moveCamera("left");
            break;
        case "ArrowRight":
        case "KeyD":
            moveCamera("right");
            break;
    }
});


// Add model to scene
function addModelToScene(model) {
    // Process model materials and enable shadows
    model.traverse((node) => {
        if (node.isMesh) {
            node.castShadow = true;
            node.receiveShadow = true;
            
            // Ensure materials update correctly
            if (node.material) {
                node.material.needsUpdate = true;
                if (Array.isArray(node.material)) {
                    node.material.forEach(mat => mat.needsUpdate = true);
                }
            }
        }
    });

    // Add model to the scene
    scene.add(model);
    objects.push(model);

    // Setup animations if present
    if (model.animations && model.animations.length > 0) {
        const mixer = new THREE.AnimationMixer(model);
        model.userData.mixer = mixer;
        model.animations.forEach(clip => {
            const action = mixer.clipAction(clip);
            action.play();
        });
    }

    // Update hierarchy (if needed)
    updateHierarchy();
}



function setupSceneElements() {
    scene.fog = new THREE.FogExp2(0x1c1c1c, 0.02);
    
    const axesHelper = new THREE.AxesHelper(5);
    scene.add(axesHelper);

    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();
}


function animateParticles() {
    const positions = particles.geometry.attributes.position.array;
    const time = Date.now() * 0.001;

    for (let i = 0; i < particlesCount * 3; i += 3) {
        positions[i] += Math.sin(time + positions[i + 2] * 0.1) * 0.01;
        positions[i + 1] += Math.cos(time + positions[i] * 0.1) * 0.01;
        positions[i + 2] += Math.sin(time * 0.5 + positions[i] * 0.1) * 0.01;
    }

    particles.geometry.attributes.position.needsUpdate = true;
}



function addGUI(scene, renderer, camera) {
    const gui = new dat.GUI({
        autoPlace: false
    });

    // Settings object with expanded controls
    const settings = {
        // Scene Settings
        background: 0x2a2a2a,
        density: 0.02,
        
        // HDRI Settings
        useHDR: false,
        selectedHDRI: 'sunset',
        hdriIntensity: 1.0,
        hdriRotation: 0,
        
        // Camera Settings
        fov: camera.fov,
        nearPlane: camera.near,
        farPlane: camera.far,
        
        // Shadow Settings
        enableShadows: true,
        shadowMapSize: 2048,
        shadowBias: -0.0001,
        
        // Lighting Settings
        lightIntensity: 1,
        ambientLightColor: 0xffffff,
        ambientLightIntensity: 0.5,
        pointLightColor: 0xffffff,
        pointLightIntensity: 1,
        pointLightDistance: 100,
        pointLightDecay: 2,
        directionalLightColor: 0xffffff,
        directionalLightIntensity: 1,
        directionalLightPosition: { x: 5, y: 5, z: 5 },
        
        // Material Settings
        materialReflectivity: 0.5,
        roughness: 0.5,
        metalness: 0.5,
        envMapIntensity: 1.0,
        
        // Post-Processing
        enablePostProcessing: true,
        bloomEnabled: true,
        bloomIntensity: 1.0,
        bloomThreshold: 0.9,
        bloomRadius: 0.8,
        
        // DOF Settings
        dofEnabled: false,
        focusDistance: 10,
        focalLength: 24,
        bokehScale: 2.0,
        
        // Performance
        enableStats: false,
        pixelRatio: 1.0
    };

    // HDRI Files Map
    const hdriFiles = {
        'sunset': 'sunset_1k.hdr',
        'forest': 'forest_1k.hdr',
        'studio': 'studio_1k.hdr',
        'night': 'night_1k.hdr',
        'indoor': 'indoor_1k.hdr'
    };

    // Scene Settings
    const sceneFolder = gui.addFolder('Scene Settings');
    sceneFolder.addColor(settings, 'background').onChange(updateBackground);
    sceneFolder.add(settings, 'density', 0.001, 0.1).step(0.001).onChange(updateFog);
    sceneFolder.open();

    // HDRI Settings
    const hdriFolder = gui.addFolder('HDRI Settings');
    hdriFolder.add(settings, 'useHDR').onChange(updateHDRI);
    hdriFolder.add(settings, 'selectedHDRI', Object.keys(hdriFiles)).onChange(updateHDRI);
    hdriFolder.add(settings, 'hdriIntensity', 0, 5).step(0.1).onChange(updateHDRIIntensity);
    hdriFolder.add(settings, 'hdriRotation', 0, Math.PI * 2).step(0.1).onChange(updateHDRIRotation);
    hdriFolder.open();

    // Camera Settings
    const cameraFolder = gui.addFolder('Camera Settings');
    cameraFolder.add(settings, 'fov', 20, 120).onChange(updateCamera);
    cameraFolder.add(settings, 'nearPlane', 0.1, 10).onChange(updateCamera);
    cameraFolder.add(settings, 'farPlane', 100, 5000).onChange(updateCamera);
    cameraFolder.open();

    // Shadow Settings
    const shadowFolder = gui.addFolder('Shadow Settings');
    shadowFolder.add(settings, 'enableShadows').onChange(updateShadows);
    shadowFolder.add(settings, 'shadowMapSize', [512, 1024, 2048, 4096]).onChange(updateShadowMapSize);
    shadowFolder.add(settings, 'shadowBias', -0.01, 0.01).step(0.0001).onChange(updateShadowBias);
    shadowFolder.open();

    // Lighting Settings
    const lightingFolder = gui.addFolder('Lighting Settings');
    
    // Ambient Light
    const ambientFolder = lightingFolder.addFolder('Ambient Light');
    ambientFolder.addColor(settings, 'ambientLightColor').onChange(updateAmbientLight);
    ambientFolder.add(settings, 'ambientLightIntensity', 0, 2).onChange(updateAmbientLight);

    // Point Light
    const pointFolder = lightingFolder.addFolder('Point Light');
    pointFolder.addColor(settings, 'pointLightColor').onChange(updatePointLight);
    pointFolder.add(settings, 'pointLightIntensity', 0, 5).onChange(updatePointLight);
    pointFolder.add(settings, 'pointLightDistance', 0, 1000).onChange(updatePointLight);
    pointFolder.add(settings, 'pointLightDecay', 0, 5).onChange(updatePointLight);

    // Directional Light
    const dirFolder = lightingFolder.addFolder('Directional Light');
    dirFolder.addColor(settings, 'directionalLightColor').onChange(updateDirectionalLight);
    dirFolder.add(settings, 'directionalLightIntensity', 0, 5).onChange(updateDirectionalLight);
    dirFolder.add(settings.directionalLightPosition, 'x', -20, 20).onChange(updateDirectionalLight);
    dirFolder.add(settings.directionalLightPosition, 'y', -20, 20).onChange(updateDirectionalLight);
    dirFolder.add(settings.directionalLightPosition, 'z', -20, 20).onChange(updateDirectionalLight);

    lightingFolder.open();

    // Material Settings
    const materialFolder = gui.addFolder('Material Settings');
    materialFolder.add(settings, 'materialReflectivity', 0, 1).onChange(updateMaterials);
    materialFolder.add(settings, 'roughness', 0, 1).onChange(updateMaterials);
    materialFolder.add(settings, 'metalness', 0, 1).onChange(updateMaterials);
    materialFolder.add(settings, 'envMapIntensity', 0, 5).onChange(updateMaterials);
    materialFolder.open();

    // Post-Processing Settings
    const postFolder = gui.addFolder('Post-Processing');
    postFolder.add(settings, 'enablePostProcessing').onChange(updatePostProcessing);
    
    // Bloom Settings
    const bloomFolder = postFolder.addFolder('Bloom');
    bloomFolder.add(settings, 'bloomEnabled').onChange(updateBloom);
    bloomFolder.add(settings, 'bloomIntensity', 0, 5).onChange(updateBloom);
    bloomFolder.add(settings, 'bloomThreshold', 0, 1).onChange(updateBloom);
    bloomFolder.add(settings, 'bloomRadius', 0, 1).onChange(updateBloom);

    // DOF Settings
    const dofFolder = postFolder.addFolder('Depth of Field');
    dofFolder.add(settings, 'dofEnabled').onChange(updateDOF);
    dofFolder.add(settings, 'focusDistance', 0.1, 50).onChange(updateDOF);
    dofFolder.add(settings, 'focalLength', 12, 100).onChange(updateDOF);
    dofFolder.add(settings, 'bokehScale', 0, 10).onChange(updateDOF);

    postFolder.open();

    // Performance Settings
    const performanceFolder = gui.addFolder('Performance');
    performanceFolder.add(settings, 'enableStats').onChange(updateStats);
    performanceFolder.add(settings, 'pixelRatio', 0.5, 2).step(0.25).onChange(updatePixelRatio);
    performanceFolder.open();

    // Update functions
    function updateBackground(value) {
        if (!settings.useHDR) {
            scene.background = new THREE.Color(value);
            updateFog(settings.density);
        }
    }

    function updateFog(value) {
        scene.fog = new THREE.FogExp2(settings.background, value);
    }

    function updateHDRI() {
        if (settings.useHDR) {
            const hdrLoader = new THREE.RGBELoader();
            hdrLoader.setDataType(THREE.FloatType)
                .load(`https://dl.polyhaven.org/file/ph-assets/HDRIs/1k/${settings.selectedHDRI}/${hdriFiles[settings.selectedHDRI]}`, function(texture) {
                    const pmremGenerator = new THREE.PMREMGenerator(renderer);
                    pmremGenerator.compileEquirectangularShader();
                    
                    const envMap = pmremGenerator.fromEquirectangular(texture).texture;
                    
                    scene.background = envMap;
                    scene.environment = envMap;
                    
                    texture.dispose();
                    pmremGenerator.dispose();
                });
        } else {
            scene.background = new THREE.Color(settings.background);
            scene.environment = null;
            updateFog(settings.density);
        }
    }

    function updateHDRIIntensity(value) {
        if (scene.environment) {
            scene.environment.intensity = value;
        }
    }

    function updateHDRIRotation(value) {
        if (scene.environment) {
            scene.environment.rotation.y = value;
        }
    }

    function updateCamera() {
        camera.fov = settings.fov;
        camera.near = settings.nearPlane;
        camera.far = settings.farPlane;
        camera.updateProjectionMatrix();
    }

    function updateShadows(value) {
        renderer.shadowMap.enabled = value;
        scene.traverse((object) => {
            if (object.castShadow !== undefined) {
                object.castShadow = value;
                object.receiveShadow = value;
            }
        });
    }

    function updateShadowMapSize(value) {
        scene.traverse((object) => {
            if (object instanceof THREE.Light && object.shadow) {
                object.shadow.mapSize.width = value;
                object.shadow.mapSize.height = value;
                object.shadow.map?.dispose();
                object.shadow.map = null;
            }
        });
    }

    function updateShadowBias(value) {
        scene.traverse((object) => {
            if (object instanceof THREE.Light && object.shadow) {
                object.shadow.bias = value;
            }
        });
    }

    function updateAmbientLight() {
        scene.traverse((object) => {
            if (object instanceof THREE.AmbientLight) {
                object.color.set(settings.ambientLightColor);
                object.intensity = settings.ambientLightIntensity;
            }
        });
    }

    function updatePointLight() {
        scene.traverse((object) => {
            if (object instanceof THREE.PointLight) {
                object.color.set(settings.pointLightColor);
                object.intensity = settings.pointLightIntensity;
                object.distance = settings.pointLightDistance;
                object.decay = settings.pointLightDecay;
            }
        });
    }

    function updateDirectionalLight() {
        scene.traverse((object) => {
            if (object instanceof THREE.DirectionalLight) {
                object.color.set(settings.directionalLightColor);
                object.intensity = settings.directionalLightIntensity;
                object.position.set(
                    settings.directionalLightPosition.x,
                    settings.directionalLightPosition.y,
                    settings.directionalLightPosition.z
                );
            }
        });
    }

    function updateMaterials() {
        scene.traverse((object) => {
            if (object.material) {
                if (object.material.reflectivity !== undefined) {
                    object.material.reflectivity = settings.materialReflectivity;
                }
                if (object.material.roughness !== undefined) {
                    object.material.roughness = settings.roughness;
                }
                if (object.material.metalness !== undefined) {
                    object.material.metalness = settings.metalness;
                }
                if (object.material.envMapIntensity !== undefined) {
                    object.material.envMapIntensity = settings.envMapIntensity;
                }
                object.material.needsUpdate = true;
            }
        });
    }

    function updatePostProcessing() {
        // Implement post-processing toggle
    }

    function updateBloom() {
        // Implement bloom updates
    }

    function updateDOF() {
        // Implement DOF updates
    }

    function updateStats() {
        // Implement stats toggle
    }

    function updatePixelRatio(value) {
        renderer.setPixelRatio(value);
    }

    // Append GUI to container
    const guiContainer = document.getElementById('gui-container');
    guiContainer.appendChild(gui.domElement);

    // Return settings object for external access
    return settings;
}


//Modelign Shapes

let subdivisionLevel = 0;

function createMajorAxes(size) {
    const axesGroup = new THREE.Group();
    
    // X-axis (red)
    const xAxis = createAxisLine(size, 0xff0000, new THREE.Vector3(1, 0, 0));
    // Z-axis (blue)
    const zAxis = createAxisLine(size, 0x0000ff, new THREE.Vector3(0, 0, 1));
    // Y-axis (green)
    const yAxis = createAxisLine(size, 0x00ff00, new THREE.Vector3(0, 1, 0));

    axesGroup.add(xAxis);
    axesGroup.add(yAxis);
    axesGroup.add(zAxis);

    return axesGroup;
}

function createAdvancedGridHelper(size = 1000, divisions = 1000) {
    const gridGroup = new THREE.Group();

    // Main grid
    const mainGridHelper = new THREE.GridHelper(size, divisions);
    mainGridHelper.material = new THREE.LineBasicMaterial({
        color: 0x555555,
        opacity: 0.6,
        transparent: true,
        linewidth: 0.5
    });

    // Secondary grid (larger squares)
    const secondaryGridHelper = new THREE.GridHelper(size, divisions / 10);
    secondaryGridHelper.material = new THREE.LineBasicMaterial({
        color: 0x444444,
        opacity: 0.8,
        transparent: true,
        linewidth: 1
    });

    // Major axes
    const axesGroup = createMajorAxes(size);
    
    // Create measurement labels
    const labelsGroup = createMeasurementLabels(size);

    // Add everything to the group
    gridGroup.add(mainGridHelper);
    gridGroup.add(secondaryGridHelper);
    gridGroup.add(axesGroup);
    gridGroup.add(labelsGroup);

    // Dynamic visibility based on camera distance
    gridGroup.onBeforeRender = function(renderer, scene, camera) {
        const distance = camera.position.length();
        const maxDistance = size / 1.5;
        
        // Fade out based on distance
        const mainFade = THREE.MathUtils.smoothstep(distance, maxDistance * 0.5, maxDistance);
        const secondaryFade = THREE.MathUtils.smoothstep(distance, maxDistance * 0.3, maxDistance * 0.8);
        
        mainGridHelper.material.opacity = 0.6 * (1 - mainFade);
        secondaryGridHelper.material.opacity = 0.8 * (1 - secondaryFade);
        
        // Scale visibility of different grid elements based on distance
        if (distance < size * 0.2) {
            mainGridHelper.visible = true;
            secondaryGridHelper.visible = true;
            labelsGroup.visible = true;
        } else if (distance < size * 0.5) {
            mainGridHelper.visible = false;
            secondaryGridHelper.visible = true;
            labelsGroup.visible = true;
        } else {
            mainGridHelper.visible = false;
            secondaryGridHelper.visible = true;
            labelsGroup.visible = false;
        }
    };

    return gridGroup;
}


function createMeasurementLabels(size) {
    const labelsGroup = new THREE.Group();
    const interval = size / 10;
    
    // Create text sprites for measurement labels
    for (let i = -size/2; i <= size/2; i += interval) {
        if (i === 0) continue; // Skip 0
        
        // X-axis labels
        const xLabel = createTextSprite(i.toString());
        xLabel.position.set(i, 0, -20);
        labelsGroup.add(xLabel);
        
        // Z-axis labels
        const zLabel = createTextSprite(i.toString());
        zLabel.position.set(-20, 0, i);
        labelsGroup.add(zLabel);
    }

    return labelsGroup;
}

function createAxisLine(size, color, direction) {
    const geometry = new THREE.BufferGeometry();
    const vertices = new Float32Array([
        -size/2 * direction.x, -size/2 * direction.y, -size/2 * direction.z,
        size/2 * direction.x, size/2 * direction.y, size/2 * direction.z
    ]);
    geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
    
    const material = new THREE.LineBasicMaterial({
        color: color,
        linewidth: 2,
        opacity: 0.8,
        transparent: true
    });

    return new THREE.Line(geometry, material);
}

function createTextSprite(message) {
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.width = 256;
    canvas.height = 256;
    
    context.font = "Bold 36px Arial";
    context.fillStyle = "rgba(255,255,255,0.95)";
    context.fillText(message, 128, 128);
    
    const texture = new THREE.CanvasTexture(canvas);
    const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
    const sprite = new THREE.Sprite(spriteMaterial);
    sprite.scale.set(50, 50, 1);
    
    return sprite;
}



function toggleLock() {
    isLocked = !isLocked;
    
    if (controls) {
        // If locked, disable controls regardless of transform state
        if (isLocked) {
            controls.enabled = false;
        } 
        // If unlocked, enable controls only if not currently transforming
        else if (!transformControlsActive) {
            controls.enabled = true;
        }
    }
    
    // Update UI
    const lockButton = document.getElementById('toggle-lock');
    if (lockButton) {
        lockButton.innerHTML = isLocked 
            ? '<i class="fas fa-lock"></i>' 
            : '<i class="fas fa-unlock"></i>';
        lockButton.style.backgroundColor = isLocked ? '#e74c3c' : '#2ecc71';
    }
    
    console.log("Camera lock toggled:", isLocked, "Controls enabled:", controls.enabled);
}







function setCameraView(direction) {
    let targetPosition = { x: 0, y: 0, z: 0 };

    switch (direction) {
        case 'x': 
            targetPosition = { x: 10, y: 0, z: 0 };
            break;
        case 'y': 
            targetPosition = { x: 0, y: 10, z: 0 };
            break;
        case 'z': 
            targetPosition = { x: 0, y: 0, z: 10 };
            break;
        case 'top': 
            targetPosition = { x: 0, y: 10, z: 0 };
            break;
        case 'bottom':
            targetPosition = { x: 0, y: -10, z: 0 };
            break;
        case 'diagonal': 
            targetPosition = { x: 10, y: 10, z: 10 };
            break;
        default:
            console.error('Invalid direction');
            return;
    }

    // استخدام GSAP لتحريك الكاميرا بسلاسة
    gsap.to(camera.position, {
        x: targetPosition.x,
        y: targetPosition.y,
        z: targetPosition.z,
        duration: 1.5, // مدة الحركة بالثواني
        onUpdate: () => camera.lookAt(0, 0, 0) // تحديث زاوية الكاميرا أثناء الحركة
    });
}



function toggleExtrudeMode() {
    if (drawMode) toggleDrawMode();
    extrudeMode = !extrudeMode;
    
    if (extrudeMode) {
        controls.enabled = false;
        transformControls.enabled = false;
        transformControls.detach();
        selectedObject = null;
    } else {
        controls.enabled = true;
        transformControls.enabled = true;
        selectedFace = null;
    }
    
    document.getElementById('toggle-extrude').classList.toggle('active', extrudeMode);
    updateStatus();
}


function exitCurrentMode() {
    if (drawMode) toggleDrawMode();
    if (extrudeMode) toggleExtrudeMode();
    
    // Restore normal controls
    controls.enabled = true;
    transformControls.enabled = true;
    
    points = [];
    updatePreviewLine();
    selectedFace = null;
    brushCursor.visible = false;
    updateStatus();
}

function toggleDrawMode() {
    if (extrudeMode) toggleExtrudeMode();
    drawMode = !drawMode;
    
    if (drawMode) {
        controls.enabled = false;
        transformControls.enabled = false;
        transformControls.detach();
        selectedObject = null;
        brushCursor.visible = true;
    } else {
        controls.enabled = true;
        transformControls.enabled = true;
        points = [];
        updatePreviewLine();
        brushCursor.visible = false;
    }
   
    document.getElementById('toggle-draw').classList.toggle('active', drawMode);
    updateStatus();
}


function updateStatus() {
    let statusText = "Ready";
    if (drawMode) {
        statusText = `Drawing: ${points.length} points`;
    } else if (extrudeMode) {
        statusText = "Select a face to extrude";
        if (selectedFace) {
            statusText = "Click to extrude selected face";
        }
    }
    document.getElementById('status').textContent = statusText;
}

function updatePreviewLine() {
    if (points.length > 0) {
        const positions = [];
        points.forEach(point => {
            positions.push(point.x, point.y, point.z);
        });
        
        // Close the shape if we have enough points
        if (points.length >= 3) {
            positions.push(points[0].x, points[0].y, points[0].z);
        }

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        previewLine.geometry.dispose();
        previewLine.geometry = geometry;
    } else {
        previewLine.geometry.dispose();
        previewLine.geometry = new THREE.BufferGeometry();
    }
}

function clearGeometry() {
    quadMeshes.forEach(mesh => {
        mesh.geometry.dispose();
        mesh.material.dispose();
        scene.remove(mesh);
    });
    quadMeshes = [];
    points = [];
    updatePreviewLine();
    selectedFace = null;
    updateStatus();
}


function onMouseDown(event) {
    if (isLocked) return;
    event.preventDefault();
    mouseDown = true;
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    if (drawMode) {
        isDrawing = true;
        addPoint(event);
    } else if (extrudeMode) {
        selectFaceToExtrude();
    } else if (!drawMode && !extrudeMode) {
        orbitControls.enabled = true;
    }
}

function onMouseMove(event) {
    if (isLocked) return;
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    // Update brush cursor position
    updateBrushPosition(event);

    if (drawMode && isDrawing) {
        addPoint(event);
    }

    // Highlight face when in extrude mode
    if (extrudeMode && !mouseDown) {
        highlightFace();
    }
}

function onMouseUp(event) {
    if (isLocked) return;
    mouseDown = false;
    
    if (drawMode && isDrawing) {
        isDrawing = false;
        if (points.length >= 4) {
            createQuad();
            points = [];
            updatePreviewLine();
            updateStatus();
        }
    } else if (extrudeMode && selectedFace) {
        extrudeFace();
    }
}


function initQuadBrush() {
    // Preview line for drawing
    const lineMaterial = new THREE.LineBasicMaterial({
        color: 0xffff00,
        linewidth: 2
    });
    
    previewLine = new THREE.Line(
        new THREE.BufferGeometry(),
        lineMaterial
    );
    scene.add(previewLine);
    
    // Reset quad-related variables
    points = [];
    quadMeshes = [];
    drawMode = false;
    extrudeMode = false;
}


function onMouseWheel(event) {
   event.preventDefault();
            
    // Adjust camera zoom
    cameraDistance = THREE.MathUtils.clamp(
        cameraDistance + event.deltaY * 0.01,
        5, 30
    );
            
    updateCameraPosition();
}
    
function addPoint(event) {
    raycaster.setFromCamera(mouse, camera);
    
    // Try to snap to existing points or grid
    let snappedPoint = null;
    
    // First try to snap to existing points
    if (points.length > 0 && snapThreshold > 0) {
        for (const point of points) {
            const screenPoint = point.clone().project(camera);
            const distance = Math.sqrt(
                Math.pow(screenPoint.x - mouse.x, 2) + 
                Math.pow(screenPoint.y - mouse.y, 2)
            );
            
            if (distance < snapThreshold * 0.1) {
                snappedPoint = point.clone();
                break;
            }
        }
    }
    
    // If no point snap, check for mesh or grid intersections
    if (!snappedPoint) {
        // Include all scene objects that should be considered for drawing
        const intersectObjects = [...quadMeshes, ...objects];
        const intersects = raycaster.intersectObjects(intersectObjects, true);
        
        if (intersects.length > 0) {
            snappedPoint = intersects[0].point.clone();
            
            // Add some height offset to avoid z-fighting
            snappedPoint.y += 0.01;
            
            // Grid snapping
            if (snapThreshold > 0) {
                snappedPoint.x = Math.round(snappedPoint.x / snapThreshold) * snapThreshold;
                snappedPoint.z = Math.round(snappedPoint.z / snapThreshold) * snapThreshold;
            }
        }
    }
    
    if (snappedPoint) {
        // Check if this is close to first point (to close the loop)
        if (points.length >= 3) {
            const firstPoint = points[0];
            if (snappedPoint.distanceTo(firstPoint) < 0.5) {
                createQuad();
                points = [];
                updatePreviewLine();
                isDrawing = false;
                updateStatus();
                return;
            }
        }
        
        // Only add point if it's far enough from the last point
        if (points.length === 0 || 
            snappedPoint.distanceTo(points[points.length - 1]) > 0.1) {
            points.push(snappedPoint);
            updatePreviewLine();
            updateStatus();
        }
    }
}



function selectFaceToExtrude() {
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(quadMeshes);
    
    if (intersects.length > 0) {
        const face = intersects[0].face;
        const mesh = intersects[0].object;
        
        selectedFace = {
            mesh: mesh,
            faceIndex: face.a, // Store the first vertex index of the face
            normal: face.normal.clone()
        };
        
        updateStatus();
    }
}


function highlightFace() {
    // Reset any previously selected face
    quadMeshes.forEach(mesh => {
        if (mesh.material.emissive) {
            mesh.material.emissive.setRGB(0, 0, 0);
        }
    });
    
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(quadMeshes);
    
    if (intersects.length > 0) {
        const mesh = intersects[0].object;
        
        // Highlight by setting emissive color
        if (mesh.material.emissive) {
            mesh.material.emissive.setRGB(0.2, 0.2, 0);
        }
    }
}

function extrudeFace() {
    if (!selectedFace) return;
    
    const mesh = selectedFace.mesh;
    const geometry = mesh.geometry;
    const normal = selectedFace.normal;
    
    // Get the indices of the face to extrude (assuming quads)
    const faceIndex = selectedFace.faceIndex;
    const indices = [];
    
    // For a quad, find the indices that make up the face
    if (geometry.index) {
        for (let i = 0; i < geometry.index.count; i += 3) {
            if (geometry.index.array[i] === faceIndex ||
                geometry.index.array[i+1] === faceIndex ||
                geometry.index.array[i+2] === faceIndex) {
                indices.push(
                    geometry.index.array[i],
                    geometry.index.array[i+1],
                    geometry.index.array[i+2]
                );
                // Get next triangle if it's part of the same quad
                if (i+3 < geometry.index.count && 
                    (geometry.index.array[i+3] === geometry.index.array[i] ||
                     geometry.index.array[i+3] === geometry.index.array[i+1] ||
                     geometry.index.array[i+3] === geometry.index.array[i+2])) {
                    indices.push(
                        geometry.index.array[i+3],
                        geometry.index.array[i+4],
                        geometry.index.array[i+5]
                    );
                }
                break;
            }
        }
    }
    
    if (indices.length === 0) return;
    
    // Get unique vertex indices
    const uniqueIndices = [...new Set(indices)];
    
    // Create new geometry
    const newGeometry = new THREE.BufferGeometry();
    
    // Get position attribute
    const positions = geometry.getAttribute('position');
    const newPositions = [];
    
    // Original vertices
    uniqueIndices.forEach(index => {
        newPositions.push(
            positions.getX(index),
            positions.getY(index),
            positions.getZ(index)
        );
    });
    
    // Extruded vertices
    uniqueIndices.forEach(index => {
        newPositions.push(
            positions.getX(index) + normal.x * extrudeHeight,
            positions.getY(index) + normal.y * extrudeHeight,
            positions.getZ(index) + normal.z * extrudeHeight
        );
    });
    
    // Create new index buffer for the sides
    const newIndices = [];
    
    // The front face (original quad)
    newIndices.push(0, 1, 2, 0, 2, 3);
    
    // The back face (extruded quad)
    newIndices.push(4, 6, 5, 4, 7, 6);
    
    // The four side faces
    newIndices.push(0, 4, 1, 1, 4, 5);
    newIndices.push(1, 5, 2, 2, 5, 6);
    newIndices.push(2, 6, 3, 3, 6, 7);
    newIndices.push(3, 7, 0, 0, 7, 4);
    
    newGeometry.setAttribute('position', new THREE.Float32BufferAttribute(newPositions, 3));
    newGeometry.setIndex(newIndices);
    newGeometry.computeVertexNormals();
    
    const material = new THREE.MeshPhongMaterial({
        color: 0x808080,
        side: THREE.DoubleSide,
        flatShading: true
    });
    
    const newMesh = new THREE.Mesh(newGeometry, material);
    scene.add(newMesh);
    quadMeshes.push(newMesh);
    
    // Remove the original face/mesh
    scene.remove(mesh);
    quadMeshes = quadMeshes.filter(m => m !== mesh);
    mesh.geometry.dispose();
    mesh.material.dispose();
    
    selectedFace = null;
    updateStatus();
}

function createQuad() {
    if (points.length < 4) return;

    // Use the first 4 points or simplify if more
    const validPoints = points.length > 4 ? simplifyPoints(points) : points.slice(0, 4);
    
    const geometry = new THREE.BufferGeometry();
    const vertices = [];
    const indices = [];

    // Create vertices
    for (let i = 0; i < validPoints.length; i++) {
        vertices.push(validPoints[i].x, validPoints[i].y, validPoints[i].z);
    }

    // Create faces - first triangle
    indices.push(0, 1, 2);
    
    // If we have 4 points, add second triangle
    if (validPoints.length >= 4) {
        indices.push(0, 2, 3);
    }

    geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
    geometry.setIndex(indices);
    geometry.computeVertexNormals();

    const material = new THREE.MeshPhongMaterial({
        color: 0x808080,
        side: THREE.DoubleSide,
        flatShading: true
    });

    const quad = new THREE.Mesh(geometry, material);
    scene.add(quad);
    addObjectToScene(quad, "Quad geomitry")
    quadMeshes.push(quad);
    
    // Make it selectable in your existing system
    objects.push(quad);
}

function simplifyPoints(inputPoints) {
    if (inputPoints.length <= 4) return inputPoints;
    
    // Simple algorithm to find corners
    const result = [inputPoints[0]];
    
    // Find point furthest from first point
    let maxDist = 0;
    let furthestIdx = 0;
    for (let i = 1; i < inputPoints.length; i++) {
        const dist = inputPoints[0].distanceTo(inputPoints[i]);
        if (dist > maxDist) {
            maxDist = dist;
            furthestIdx = i;
        }
    }
    result.push(inputPoints[furthestIdx]);
    
    // Find point furthest from line between first and second point
    maxDist = 0;
    furthestIdx = 0;
    const line = new THREE.Line3(result[0], result[1]);
    for (let i = 1; i < inputPoints.length; i++) {
        if (i === result[1]) continue;
        const closest = new THREE.Vector3();
        line.closestPointToPoint(inputPoints[i], true, closest);
        const dist = closest.distanceTo(inputPoints[i]);
        if (dist > maxDist) {
            maxDist = dist;
            furthestIdx = i;
        }
    }
    result.push(inputPoints[furthestIdx]);
    
    // Find the fourth point
    maxDist = 0;
    furthestIdx = 0;
    for (let i = 1; i < inputPoints.length; i++) {
        if (result.includes(inputPoints[i])) continue;
        
        // Calculate area of quad with this point
        const area = calculateQuadArea([
            result[0], result[1], result[2], inputPoints[i]
        ]);
        
        if (area > maxDist) {
            maxDist = area;
            furthestIdx = i;
        }
    }
    result.push(inputPoints[furthestIdx]);
    
    return result;
}

function calculateQuadArea(points) {
    if (points.length !== 4) return 0;
    
    // Calculate area using cross product
    const v1 = points[2].clone().sub(points[0]);
    const v2 = points[3].clone().sub(points[1]);
    return v1.cross(v2).length() / 2;
}


 
// Event listeners setup
function setupEventListeners() {
    // Tool buttons
    document.getElementById('translate').addEventListener('click', () => setTransformMode('translate'));
    document.getElementById('rotate').addEventListener('click', () => setTransformMode('rotate'));
    document.getElementById('scale').addEventListener('click', () => setTransformMode('scale'));
   
    // Event delegation for cleaner code
    document.querySelector('.toolbar-group').addEventListener('click', (event) => {
    const mode = event.target.id;
    if (TRANSFORM_MODES.includes(mode)) {
        setTransformMode(mode);
    }
    });
    
    // Add objects buttons
    document.getElementById('addCube').addEventListener('click', addCube);
    document.getElementById('addSphere').addEventListener('click', addSphere);
    document.getElementById('addSculptingSphere').addEventListener('click', addSculptingSphere);

    document.getElementById("addSculptingSphere").addEventListener("click", function() {
       const sculptingTools = document.getElementById("sculpting-character-tools");
      // Toggle visibility
      if (sculptingTools.style.display === "none" || sculptingTools.style.display === "") {
        sculptingTools.style.display = "block";
      } else {
        sculptingTools.style.display = "none";
    }
    });

    document.getElementById("addTerrain").addEventListener("click", function() {
       const sculptingTools = document.getElementById("sculpting-tools");
      // Toggle visibility
      if (sculptingTools.style.display === "none" || sculptingTools.style.display === "") {
        sculptingTools.style.display = "block";
      } else {
        sculptingTools.style.display = "none";
    }
    });

    document.getElementById("materialsEditor").addEventListener("click", function() {
       const materialsEditor = document.getElementById("material-editor");
      // Toggle visibility
      if (materialsEditor.style.display === "none" || materialsEditor.style.display === "") {
        materialsEditor.style.display = "block";
      } else {
        materialsEditor.style.display = "none";
    }
    });

    document.getElementById("guiControls").addEventListener("click", function() {
       const guiControlsEditor = document.getElementById("GuiContainer");
      // Toggle visibility
      if (guiControlsEditor.style.display === "none" || guiControlsEditor.style.display === "") {
        guiControlsEditor.style.display = "block";
      } else {
        guiControlsEditor.style.display = "none";
    }
    });

    document.getElementById("cameraControls").addEventListener("click", function() {
       const cameraControls = document.getElementById("Cameras");
      // Toggle visibility
      if (cameraControls.style.display === "none" || cameraControls.style.display === "") {
        cameraControls.style.display = "block";
      } else {
        cameraControls.style.display = "none";
    }
    });

    document.getElementById("lightControls").addEventListener("click", function() {
       const lightControls = document.getElementById("lights");
      // Toggle visibility
      if (lightControls.style.display === "none" || lightControls.style.display === "") {
        lightControls.style.display = "block";
      } else {
        lightControls.style.display = "none";
    }
    });

    document.getElementById("modelingControls").addEventListener("click", function() {
       const modelingTools = document.getElementById("modelingTools");
      // Toggle visibility
      if (modelingTools.style.display === "none" || modelingTools.style.display === "") {
        modelingTools.style.display = "block";
      } else {
        modelingTools.style.display = "none";
    }
    });

    document.getElementById("drawingControls").addEventListener("click", function() {
       const drawingTools = document.getElementById("drawingMode");
      // Toggle visibility
      if (drawingTools.style.display === "none" || drawingTools.style.display === "") {
         drawingTools.style.display = "block";
      } else {
        drawingTools.style.display = "none";
    }
    });

    document.getElementById("physicsControls").addEventListener("click", function() {
       const physicsControls = document.getElementById("physics-controls");
      // Toggle visibility
      if (physicsControls.style.display === "none" || physicsControls.style.display === "") {
        physicsControls.style.display = "block";
      } else {
        physicsControls.style.display = "none";
    }
    });

    document.getElementById("snow-controls").addEventListener("click", function() {
       const snowTools = document.getElementById("snow-sittings");
      // Toggle visibility
      if (snowTools.style.display === "none" || snowTools.style.display === "") {
        snowTools.style.display = "block";
      } else {
        snowTools.style.display = "none";
    }
    });

    document.getElementById('addPlane').addEventListener('click', addPlane);
    document.getElementById('addCylinder').addEventListener('click', addCylinder);
    document.getElementById('addPyramid').addEventListener('click', addPyramid);
    document.getElementById('addRectangularPrism').addEventListener('click', addRectangularPrism);
    document.getElementById('addTorus').addEventListener('click', addTorus)
    document.getElementById('addLight').addEventListener('click', addLight);
    document.getElementById('addCameraInit').addEventListener('click', addCameraInit);
   
    //Particls
    document.addEventListener("DOMContentLoaded", () => {
       document.getElementById("toggleParticles").addEventListener("click", toggleParticles);
    });

    //cloths
    document.getElementById('addCloth').addEventListener('click', () => {
        if (!selectedObject) {
           console.warn("No object selected for cloth application");
           return;
        }
    
        if (!physicsManager.clothSystem) {
            physicsManager.initClothSystem();
        }
        physicsManager.clothSystem.createClothForObject(selectedObject);
    });

    document.getElementById('removeCloth').addEventListener('click', () => {
       if (!selectedObject || !physicsManager.clothSystem) return;
       physicsManager.clothSystem.removeClothFromObject(selectedObject);
    });
  
    renderer.domElement.addEventListener('mousemove', onModelingMouseMove);
    renderer.domElement.addEventListener('click', onModelingClick);

    window.addEventListener('resize', onWindowResize, false);
        window.addEventListener('keydown', (e) => {
            if (e.key === 'f' || e.key === 'F') {
                toggleDrawMode();
            }
            if (e.key === 'e' || e.key === 'E') {
                toggleExtrudeMode();
            }
            if (e.key === 'l' || e.key === 'L') {
                clearGeometry();
            }
            if (e.key === 'Escape') {
                exitCurrentMode();
            }
    });
            
    document.getElementById('toggle-draw').addEventListener('click', toggleDrawMode);
    document.getElementById('toggle-extrude').addEventListener('click', toggleExtrudeMode);
    document.getElementById('clear').addEventListener('click', clearGeometry);
            
    document.getElementById('brush-size').addEventListener('input', (e) => {
        brushSize = parseFloat(e.target.value);
        e.target.nextElementSibling.textContent = `Brush Size: ${brushSize.toFixed(1)}`;
    });
            
    document.getElementById('snapping').addEventListener('input', (e) => {
        snapThreshold = parseFloat(e.target.value);
        e.target.nextElementSibling.textContent = `Snapping: ${snapThreshold.toFixed(1)}`;
    });
            
    document.getElementById('extrude-height').addEventListener('input', (e) => {
         extrudeHeight = parseFloat(e.target.value);
        e.target.nextElementSibling.textContent = `Extrude: ${extrudeHeight.toFixed(1)}`;
    });

    const canvas = renderer.domElement;
    canvas.addEventListener('mousedown', onMouseDown);
    canvas.addEventListener('mousemove', onMouseMove);
    canvas.addEventListener('mouseup', onMouseUp);
    canvas.addEventListener('wheel', onMouseWheel);
    
    //Dust
    document.addEventListener('DOMContentLoaded', function() {
        document.getElementById('toggleParticles').addEventListener('click', toggleParticles);
    });

    document.getElementById('increaseParticles').addEventListener('click', () => changeParticlesCount(1000));  // Increase by 1000
    document.getElementById('decreaseParticles').addEventListener('click', () => changeParticlesCount(-1000));  // Decrease by 1000
    document.getElementById('particleColor').addEventListener('input', (e) => changeParticleColor(e.target.value));  // Color picker

    //Snow 
    document.getElementById('density').addEventListener('input', (e) => {
    params.density = parseInt(e.target.value);
    document.getElementById('densityValue').textContent = params.density;
    recreateSnow();
    });
    

    document.addEventListener('keydown', (event) => {
    if (event.key === 's') {
        stormMode = !stormMode;
    }
    });

    
    document.getElementById('size').addEventListener('input', (e) => {
        params.size = parseFloat(e.target.value);
        document.getElementById('sizeValue').textContent = params.size;
         updateSnowSize();
    });

    document.getElementById('speed').addEventListener('input', (e) => {
        params.speed = parseFloat(e.target.value);
         document.getElementById('speedValue').textContent = params.speed;
    });

    document.getElementById('wind').addEventListener('input', (e) => {
        params.wind = parseFloat(e.target.value);
        document.getElementById('windValue').textContent = params.wind;
    });

    document.getElementById('turbulence').addEventListener('input', (e) => {
        params.turbulence = parseFloat(e.target.value);
        document.getElementById('turbulenceValue').textContent = params.turbulence;
    });

    document.getElementById('toggleSnow').addEventListener('click', () => {
    isSnowing = !isSnowing;
    if (isSnowing) {
        createSnow();
    } else {
        snowParticles.forEach(particle => scene.remove(particle));
        snowParticles = [];
    }
    });

    function resetSnow() {
       snowParticles.forEach(p => scene.remove(p));
       snowParticles = [];
       createSnow();
    }

    setupWeatherEffects();

    //hierarchy resizing
    document.addEventListener('DOMContentLoaded', () => {
        setupHierarchyResize();
    });
    
    // add Physics listeners here
    document.querySelectorAll('.preview-item').forEach(item => {
        item.addEventListener('click', (e) => {
            document.querySelectorAll('.preview-item').forEach(i => i.classList.remove('active'));
            e.target.closest('.preview-item').classList.add('active');
            
            const type = e.target.closest('.preview-item').dataset.type;
            if (window.brushSystem) {
                window.brushSystem.setModelType(type);
            }
        });
    });

    // Add model upload handler
    document.getElementById('model-upload').addEventListener('change', (e) => {
        const file = e.target.files[0];
        const loader = new THREE.GLTFLoader();
        
        loader.load(URL.createObjectURL(file), (gltf) => {
            if (window.brushSystem) {
                window.brushSystem.loadedModels.set('current', gltf.scene);
                window.brushSystem.loadedModels.set('custom', gltf.scene);
            }
        });
    });

 
   
    window.addEventListener('resize', onWindowResize);
    // In setupEventListeners()
    document.getElementById('raiseLower').addEventListener('click', () => {
        selectedTool = TOOLS.RAISE_LOWER;
        updateToolUI('raiseLower');
    });
    document.getElementById('smooth').addEventListener('click', () => {
        selectedTool = TOOLS.SMOOTH;
        updateToolUI('smooth');
    });
    document.getElementById('flatten').addEventListener('click', () => {
        selectedTool = TOOLS.FLATTEN;
        updateToolUI('flatten');
    });
    document.getElementById('noise').addEventListener('click', () => {
        selectedTool = TOOLS.NOISE;
        updateToolUI('noise');
    });
    document.getElementById('pinch').addEventListener('click', () => {
        selectedTool = TOOLS.PINCH;
        updateToolUI('pinch');
    });
    document.getElementById('clay').addEventListener('click', () => {
        selectedTool = TOOLS.CLAY;
        updateToolUI('clay');
    });
    document.getElementById('scrape').addEventListener('click', () => {
        selectedTool = TOOLS.SCRAPE;
        updateToolUI('scrape');
    });
    document.getElementById('fill').addEventListener('click', () => {
        selectedTool = TOOLS.FILL;
        updateToolUI('fill');
    });

    //NWE ADVANCED TOOLS
    document.getElementById('terrace').addEventListener('click', () => {
        selectedTool = TOOLS.TERRACE;
        updateToolUI('terrace');
    });
    document.getElementById('erosion').addEventListener('click', () => {
        selectedTool = TOOLS.EROSION;
        updateToolUI('erosion');
    });
    document.getElementById('ridge').addEventListener('click', () => {
        selectedTool = TOOLS.RIDGE;
        updateToolUI('ridge');
    });
    document.getElementById('canyon').addEventListener('click', () => {
        selectedTool = TOOLS.CANYON;
        updateToolUI('canyon');
    });
    document.getElementById('plateau').addEventListener('click', () => {
        selectedTool = TOOLS.PLATEAU;
        updateToolUI('plateau');
    });
    document.getElementById('slope').addEventListener('click', () => {
        selectedTool = TOOLS.SLOPE;
        updateToolUI('slope');
    });
    document.getElementById('blur').addEventListener('click', () => {
        selectedTool = TOOLS.BLUR;
        updateToolUI('blur');
    });
    document.getElementById('sharpen').addEventListener('click', () => {
        selectedTool = TOOLS.SHARPEN;
        updateToolUI('sharpen');
    });

    // Settings of textures
    document.getElementById('selectTexture').addEventListener('click', () => {
        document.getElementById('uploadTexture').click();
    });


    
    document.getElementById('uploadTexture').addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const image = new Image();
                image.onload = () => {
                    // Create a texture that can be used for both preview and painting
                    uploadedTexture = new THREE.Texture(image);
                    uploadedTexture.needsUpdate = true;
                    
                    // Optional: Create a preview of the uploaded texture
                    const previewCanvas = document.getElementById('texturePreview');
                    if (previewCanvas) {
                        const ctx = previewCanvas.getContext('2d');
                        ctx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
                        ctx.drawImage(image, 0, 0, previewCanvas.width, previewCanvas.height);
                    }
                    
                    console.log('Texture loaded and ready for painting');
                };
                image.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
    });

    // Texture paint tool activation
    document.getElementById('texturePaint').addEventListener('click', () => {
        selectedTool = TOOLS.TEXTURE_PAINT;
        updateToolUI('texturePaint');
    });
    
    // Add this new function to update UI
    function updateToolUI(toolId) {
        document.querySelectorAll('.panel-button').forEach(button => {
            button.classList.remove('active');
        });
        document.getElementById(toolId).classList.add('active');
    }
    

    // Terrain creation button
    document.getElementById('addTerrain').addEventListener('click', createTerrain);

    // Brush size controls
    document.getElementById('brushSize').addEventListener('input', (e) => {
        brushSize = parseFloat(e.target.value);
    });

    document.getElementById('brushStrength').addEventListener('input', (e) => {
        brushStrength = parseFloat(e.target.value);
    });

   

    // Mouse move for brush preview
    renderer.domElement.addEventListener('mousemove', updateBrushPreview);

    // Add pointer events for sculpting and painting
    renderer.domElement.addEventListener('pointerdown', (event) => {
        isSculpting = true;
        if (selectedTool === 'texturePaint') {
            applyTexturePaint(event);
        } else if (selectedTool === 'colorPaint') {
            applyColorPaint(event);
        } else {
            applySculpting(event);
        }
    });

    renderer.domElement.addEventListener('pointermove', (event) => {
        if (isSculpting) {
            if (selectedTool === 'texturePaint') {
                applyTexturePaint(event);
            } else if (selectedTool === 'colorPaint') {
                applyColorPaint(event);
            } else {
                applySculpting(event);
            }
        }
    });
    

    renderer.domElement.addEventListener('pointerup', () => {
        isSculpting = false;
    });

    
    // Add listeners for advanced sculpting tools
    
    
    // Symmetry controls
    document.getElementById('symmetryToggle').addEventListener('change', (e) => {
        symmetryEnabled = e.target.checked;
    });
    
    document.getElementById('symmetryAxis').addEventListener('change', (e) => {
        symmetryAxis = e.target.value;
    });
    
    // History controls
    document.getElementById('undo').addEventListener('click', () => {
        if (undoStack.length > 0) {
            const currentState = terrain.geometry.attributes.position.array.slice();
            redoStack.push(currentState);
            
            const previousState = undoStack.pop();
            terrain.geometry.attributes.position.array.set(previousState);
            terrain.geometry.attributes.position.needsUpdate = true;
            terrain.geometry.computeVertexNormals();
        }
    });
    
    document.getElementById('redo').addEventListener('click', () => {
        if (redoStack.length > 0) {
            const currentState = terrain.geometry.attributes.position.array.slice();
            undoStack.push(currentState);
            
            const nextState = redoStack.pop();
            terrain.geometry.attributes.position.array.set(nextState);
            terrain.geometry.attributes.position.needsUpdate = true;
            terrain.geometry.computeVertexNormals();
        }
    });


    // Add helper function to find symmetry vertex index
    function findSymmetryVertexIndex(originalIndex, vertices) {
        const original = new THREE.Vector3(
            vertices.getX(originalIndex),
            vertices.getY(originalIndex),
            vertices.getZ(originalIndex)
        );
        
        // Create world position for more accurate symmetry
        const worldPosition = original.clone();
        terrain.localToWorld(worldPosition);
        
        // Create symmetry point
        const symmetryPoint = worldPosition.clone();
        symmetryPoint[symmetryAxis] *= -1;
        
        // Transform back to local space
        terrain.worldToLocal(symmetryPoint);
        
        let closestIndex = -1;
        let minDistance = Infinity;
        
        for (let i = 0; i < vertices.count; i++) {
            if (i === originalIndex) continue;
    
            const vertex = new THREE.Vector3(
                vertices.getX(i),
                vertices.getY(i),
                vertices.getZ(i)
            );
            
            // More precise symmetry detection
            const tolerance = 0.001;
            const isSymmetric = Math.abs(vertex[symmetryAxis] + original[symmetryAxis]) < tolerance;
            
            if (isSymmetric) {
                const otherAxes = ['x', 'y', 'z'].filter(axis => axis !== symmetryAxis);
                const matchesOtherAxes = otherAxes.every(axis => 
                    Math.abs(vertex[axis] - original[axis]) < tolerance
                );
                
                if (matchesOtherAxes) {
                    return i;
                }
                
                const distance = vertex.distanceTo(symmetryPoint);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestIndex = i;
                }
            }
        }
        
        return closestIndex;
    }
    
   
    
    // File operations
    document.getElementById('newScene').addEventListener('click', newScene);
    document.getElementById('saveScene').addEventListener('click', saveScene);
    document.getElementById('loadScene').addEventListener('click', loadScene);
    document.getElementById('exportButton').addEventListener('click', exportScene);
    document.getElementById('importScene').addEventListener('click', importScene);

    
    // Timeline controls
    document.getElementById('play').addEventListener('click', playAnimation);
    document.getElementById('pause').addEventListener('click', pauseAnimation);
    document.getElementById('stop').addEventListener('click', stopAnimation); 
 
     // Transform controls events
     transformControls.addEventListener('dragging-changed', function(event) {
         controls.enabled = !event.value;
     });
 
     transformControls.addEventListener('change', updateInspector);
 }



 let isTransforming = false;
 function setupTransformControls() {
    if (transformControls && controls) {
        // This event fires when starting/ending a transform operation
        transformControls.addEventListener('dragging-changed', function(event) {
            isTransforming = event.value;
            
            // Only disable controls if we're not in locked mode already
            if (!isLocked) {
                controls.enabled = !isTransforming;
            }
            
            console.log("Transform dragging:", isTransforming, "Controls enabled:", controls.enabled);
        });
        
        // Additional event listener to ensure controls get re-enabled
        transformControls.addEventListener('mouseUp', function() {
            if (!isLocked && isTransforming) {
                isTransforming = false;
                controls.enabled = true;
                console.log("Transform mouseUp - Controls re-enabled");
            }
        });
    }
}

// Initialize the transform controls
function initTransformControls() {
    transformControls.setSize(0.75);
    transformControls.setSpace('local'); // Use local space for intuitive control
    transformControls.setMode('translate'); // Default mode; can be changed to 'rotate' or 'scale'
    scene.add(vertexHelpers);
    scene.add(edgeHelpers);
    scene.add(faceHelpers);

    transformControls.addEventListener('objectChange', () => {
        if (activeObject && transformControls.object) {
            updateMeshGeometry();
        }
    });

    transformControls.addEventListener('dragging-changed', (event) => {
        if (controls) {
            controls.enabled = !event.value;
        }
    });

    // Add key bindings for transform modes
    window.addEventListener('keydown', (event) => {
        if (!isModelingMode) return;
        switch (event.key) {
            case 't': transformControls.setMode('translate'); break;
            case 'r': transformControls.setMode('rotate'); break;
            case 's': transformControls.setMode('scale'); break;
        }
    });
}

// Toggle modeling mode
function toggleModelingMode() {
    isModelingMode = !isModelingMode;
    const modelingButtons = ['select-vertex', 'select-edge', 'select-face'];
    modelingButtons.forEach(id => {
        document.getElementById(id).disabled = !isModelingMode;
    });

    if (isModelingMode && activeObject) {
        showMeshStructure(activeObject);
    } else {
        clearMeshStructure();
        transformControls.detach();
    }
}



function setSelectionMode(mode) {
    if (!isModelingMode) return;
    selectionMode = mode;
    clearSelection();
    if (activeObject) {
        showMeshStructure(activeObject);
    }
}


function showMeshStructure(object) {
    clearMeshStructure();
    if (!object || !object.geometry) return;
    
    activeObject = object;
    const geometry = object.geometry;
    const positions = geometry.attributes.position;
    const matrix = object.matrixWorld;
    
    const vertexSize = parseFloat(document.getElementById('vertexSizeSlider').value) * 0.1; // Increased for testing
    const edgeThickness = parseFloat(document.getElementById('edgeThicknessSlider').value);
    const faceOpacity = parseFloat(document.getElementById('faceOpacitySlider').value);
    
    if (selectionMode === 'vertex' || selectionMode === 'all') {
        for (let i = 0; i < positions.count; i++) {
            const vertex = new THREE.Vector3().fromBufferAttribute(positions, i).applyMatrix4(matrix);
            const sphereGeom = new THREE.SphereGeometry(vertexSize);
            const sphereMat = new THREE.MeshBasicMaterial({ color: 0x2222FF, transparent: true, opacity: 0.8 });
            const vertexMesh = new THREE.Mesh(sphereGeom, sphereMat);
            vertexMesh.position.copy(vertex);
            vertexMesh.userData = { type: 'vertex', vertexIndex: i };
            vertexHelpers.add(vertexMesh);
        }
    }
    updateEdgeFaceHelpers(); // Call to populate edges and faces
}

function clearMeshStructure() {
    vertexHelpers.clear();
    edgeHelpers.clear();
    faceHelpers.clear();
}


function onModelingMouseMove(event) {
    if (!isModelingMode || !activeObject) return;

    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);

    // Reset all materials to default
    resetHighlights();
    
    // Highlight elements based on selection mode
    switch (selectionMode) {
        case 'vertex':
            highlightVertices();
            break;
        case 'edge':
            highlightEdges();
            break;
        case 'face':
            highlightFaces();
            break;
    }
}



function onModelingClick(event) {
    if (!isModelingMode || !activeObject) return;

    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);

    switch (selectionMode) {
        case 'vertex':
            selectVertex();
            break;
        case 'edge':
            selectEdge();
            break;
        case 'face':
            selectFace();
            break;
    }
}
        
// Highlight vertices on hover
function highlightVertices() {
    resetHighlights(); // Reset before highlighting
    const intersects = raycaster.intersectObjects(vertexHelpers.children);
    if (intersects.length > 0) {
        intersects[0].object.material.color.set(0xFF0000);
    }
}

// Highlight edges on hover
function highlightEdges() {
    resetHighlights();
    const intersects = raycaster.intersectObjects(edgeHelpers.children);
    if (intersects.length > 0) {
        intersects[0].object.material.color.set(0xFF0000);
    }
}

// Highlight faces on hover
function highlightFaces() {
    resetHighlights();
    const intersects = raycaster.intersectObjects(faceHelpers.children);
    if (intersects.length > 0) {
        intersects[0].object.material.color.set(0xFF0000);
    }
}


function resetHighlights() {
    vertexHelpers.children.forEach(child => {
        if (selectedElements.length === 0 || !selectedElements.includes(child)) {
            child.material.color.set(0x2222FF);
        }
    });
    
    edgeHelpers.children.forEach(child => {
        if (selectedElements.length === 0 || 
            !selectedElements.some(elem => elem.userData.edge === child)) {
            child.material.color.set(0xE67E22);
        }
    });
    
    faceHelpers.children.forEach(child => {
        if (selectedElements.length === 0 || 
            !selectedElements.some(elem => elem.userData.face === child)) {
            child.material.color.set(0x44DD88);
        }
    });
}

function selectVertex() {
    // Adjust raycaster threshold for larger spheres
    raycaster.params.Points = { threshold: 0.5 }; // Increase if needed

    const intersects = raycaster.intersectObjects(vertexHelpers.children);
    
    if (intersects.length > 0) {
        const vertexMesh = intersects[0].object;

        // Clear previous selection
        clearSelection();

        // Mark as selected
        selectedElements = [vertexMesh];
        vertexMesh.material.color.set(0xFF0000);

        // Attach transform controls
        transformControls.attach(vertexMesh);
        console.log("Selected vertex:", vertexMesh.userData.vertexIndex);
    } else {
        console.log("No vertex intersected");
    }
}

function selectEdge() {
    const intersects = raycaster.intersectObjects(edgeHelpers.children);
    if (intersects.length > 0) {
        // Clear previous selection
        clearSelection();
        
        const edge = intersects[0].object;
        const edgeCenter = new THREE.Object3D();
        
        // Get vertices from the edge
        const indices = edge.userData.indices;
        
        // Store vertices in world space
        const vertices = indices.map(index => 
            new THREE.Vector3().fromBufferAttribute(activeObject.geometry.attributes.position, index)
                .applyMatrix4(activeObject.matrixWorld)
        );
        
        // Calculate edge center
        const center = vertices[0].clone().add(vertices[1]).multiplyScalar(0.5);
        edgeCenter.position.copy(center);
        scene.add(edgeCenter);

        // Store original state with deep copies
        edgeCenter.userData = {
            type: 'edge',
            edge: edge,
            originalPosition: center.clone(),
            originalRotation: edgeCenter.quaternion.clone(),
            originalScale: edgeCenter.scale.clone(),
            indices: indices,
            originalVertices: vertices  // Store the original vertex positions
        };

        // Mark as selected
        selectedElements = [edgeCenter];
        edge.material.color.set(0xFF0000);
        
        // Attach transform controls
        transformControls.attach(edgeCenter);
    }
}

function selectFace() {
    const intersects = raycaster.intersectObjects(faceHelpers.children);
    
    if (intersects.length > 0) {
        // Clear previous selection
        clearSelection();
        
        const face = intersects[0].object;
        const faceCenter = new THREE.Object3D();
        
        // Get face vertices
        const indices = face.userData.indices;
        const vertices = indices.map(index => 
            new THREE.Vector3().fromBufferAttribute(
                activeObject.geometry.attributes.position, index
            ).applyMatrix4(activeObject.matrixWorld)
        );
        
        // Calculate the center of the face
        const center = new THREE.Vector3();
        vertices.forEach(v => center.add(v));
        center.divideScalar(vertices.length);
        
        faceCenter.position.copy(center);
        scene.add(faceCenter);
        
        // Store the original state and metadata
        faceCenter.userData = {
            type: 'face',
            face: face,
            originalPosition: center.clone(),
            originalRotation: faceCenter.quaternion.clone(),
            originalScale: faceCenter.scale.clone(),
            indices: indices,
            originalVertices: vertices  // Store the original vertex positions
        };
        
        // Mark as selected
        selectedElements = [faceCenter];
        face.material.color.set(0xFF0000);
        
        // Attach transform controls
        transformControls.attach(faceCenter);
    }
}

function updateMeshGeometry() {
    if (!activeObject || selectedElements.length === 0) return;
    
    const selectedElement = selectedElements[0];
    const geometry = activeObject.geometry;
    const positions = geometry.attributes.position;
    const mode = transformControls.getMode();

    // Store original matrix for converting back to local space correctly
    const originalMatrix = activeObject.matrixWorld.clone();
    const inverseMatrix = new THREE.Matrix4().copy(originalMatrix).invert();

    if (selectedElement.userData.type === 'vertex') {
        // Handle vertex transformation
        const vertexIndex = selectedElement.userData.vertexIndex;
        const worldPos = selectedElement.position.clone();
        const localPos = worldPos.clone().applyMatrix4(inverseMatrix);
        positions.setXYZ(vertexIndex, localPos.x, localPos.y, localPos.z);
    } else if (selectedElement.userData.type === 'edge' || selectedElement.userData.type === 'face') {
        const indices = selectedElement.userData.indices;
        const originalVertices = selectedElement.userData.originalVertices || [];
        const center = selectedElement.userData.originalPosition.clone();

        if (mode === 'translate') {
            // Calculate transformation delta in world space
            const delta = selectedElement.position.clone().sub(selectedElement.userData.originalPosition);
            
            // Apply delta to each affected vertex
            indices.forEach((index, i) => {
                // Use stored original vertices if available
                let worldVertex;
                if (originalVertices[i]) {
                    worldVertex = originalVertices[i].clone().add(delta);
                } else {
                    // Fallback if original vertices weren't stored
                    const vertex = new THREE.Vector3().fromBufferAttribute(positions, index);
                    worldVertex = vertex.clone().applyMatrix4(originalMatrix).add(delta);
                }
                
                // Convert back to local space
                const localVertex = worldVertex.clone().applyMatrix4(inverseMatrix);
                positions.setXYZ(index, localVertex.x, localVertex.y, localVertex.z);
            });
        } else if (mode === 'rotate') {
            // Create a matrix from the rotation quaternion
            const rotationMatrix = new THREE.Matrix4().makeRotationFromQuaternion(selectedElement.quaternion);
            
            // Apply rotation around center point to each vertex
            indices.forEach((index, i) => {
                let worldVertex;
                if (originalVertices[i]) {
                    // Get vector from center to vertex
                    const vertexRelativeToCenter = originalVertices[i].clone().sub(center);
                    // Apply rotation matrix
                    vertexRelativeToCenter.applyMatrix4(rotationMatrix);
                    // Move back relative to center
                    worldVertex = vertexRelativeToCenter.add(center);
                } else {
                    // Fallback
                    const vertex = new THREE.Vector3().fromBufferAttribute(positions, index);
                    const worldPos = vertex.clone().applyMatrix4(originalMatrix);
                    const vertexRelativeToCenter = worldPos.clone().sub(center);
                    vertexRelativeToCenter.applyMatrix4(rotationMatrix);
                    worldVertex = vertexRelativeToCenter.add(center);
                }
                
                // Convert back to local space
                const localVertex = worldVertex.clone().applyMatrix4(inverseMatrix);
                positions.setXYZ(index, localVertex.x, localVertex.y, localVertex.z);
            });
        } else if (mode === 'scale') {
            // Create a scaling matrix
            const scaleMatrix = new THREE.Matrix4().makeScale(
                selectedElement.scale.x,
                selectedElement.scale.y,
                selectedElement.scale.z
            );
            
            // Apply scaling from center point to each vertex
            indices.forEach((index, i) => {
                let worldVertex;
                if (originalVertices[i]) {
                    // Get vector from center to vertex
                    const vertexRelativeToCenter = originalVertices[i].clone().sub(center);
                    // Apply scaling matrix
                    vertexRelativeToCenter.applyMatrix4(scaleMatrix);
                    // Move back relative to center
                    worldVertex = vertexRelativeToCenter.add(center);
                } else {
                    // Fallback
                    const vertex = new THREE.Vector3().fromBufferAttribute(positions, index);
                    const worldPos = vertex.clone().applyMatrix4(originalMatrix);
                    const vertexRelativeToCenter = worldPos.clone().sub(center);
                    vertexRelativeToCenter.applyMatrix4(scaleMatrix);
                    worldVertex = vertexRelativeToCenter.add(center);
                }
                
                // Convert back to local space
                const localVertex = worldVertex.clone().applyMatrix4(inverseMatrix);
                positions.setXYZ(index, localVertex.x, localVertex.y, localVertex.z);
            });
        }
    }

    // Update the buffer attribute
    positions.needsUpdate = true;
    
    // Recalculate normals and bounds
    geometry.computeVertexNormals();
    geometry.computeBoundingSphere();

    // Update the mesh structure display
    showMeshStructure(activeObject);
}


function updateEdgeFaceHelpers() {
    // Clear existing helpers
    edgeHelpers.clear();
    faceHelpers.clear();

    if (!activeObject || !activeObject.geometry) return;
    
    const geometry = activeObject.geometry;
    const positions = geometry.attributes.position;
    const matrix = activeObject.matrixWorld;
    const edgeThickness = parseFloat(document.getElementById('edgeThicknessSlider').value);
    const faceOpacity = parseFloat(document.getElementById('faceOpacitySlider').value);

    // Create edge helpers
    if (selectionMode === 'edge' || selectionMode === 'all') {
        if (geometry.index) {
            const edgeSet = new Set();
            const indices = geometry.index.array;
            
            for (let i = 0; i < indices.length; i += 3) {
                for (let j = 0; j < 3; j++) {
                    const start = indices[i + j];
                    const end = indices[i + (j + 1) % 3];
                    
                    // Create unique edge ID to avoid duplicates
                    const edgeKey = start < end ? `${start}_${end}` : `${end}_${start}`;
                    
                    if (!edgeSet.has(edgeKey)) {
                        edgeSet.add(edgeKey);
                        
                        // Get vertices in world space
                        const startVert = new THREE.Vector3().fromBufferAttribute(positions, start).applyMatrix4(matrix);
                        const endVert = new THREE.Vector3().fromBufferAttribute(positions, end).applyMatrix4(matrix);
                        
                        // Create edge visualization
                        const edgeGeom = new THREE.BufferGeometry().setFromPoints([startVert, endVert]);
                        const edgeMat = new THREE.LineBasicMaterial({ 
                            color: 0xE67E22, 
                            linewidth: edgeThickness
                        });
                        
                        const edge = new THREE.Line(edgeGeom, edgeMat);
                        edge.userData = { 
                            type: 'edge', 
                            indices: [start, end] 
                        };
                        
                        edgeHelpers.add(edge);
                    }
                }
            }
        }
    }

    // Create face helpers
    if (selectionMode === 'face' || selectionMode === 'all') {
        if (geometry.index) {
            const indices = geometry.index.array;
            
            for (let i = 0; i < indices.length; i += 3) {
                const vA = new THREE.Vector3().fromBufferAttribute(positions, indices[i]).applyMatrix4(matrix);
                const vB = new THREE.Vector3().fromBufferAttribute(positions, indices[i + 1]).applyMatrix4(matrix);
                const vC = new THREE.Vector3().fromBufferAttribute(positions, indices[i + 2]).applyMatrix4(matrix);
                
                // Create face visualization
                const faceGeom = new THREE.BufferGeometry().setFromPoints([vA, vB, vC]);
                const faceMat = new THREE.MeshBasicMaterial({ 
                    color: 0x44DD88, 
                    transparent: true, 
                    opacity: faceOpacity, 
                    side: THREE.DoubleSide 
                });
                
                const faceMesh = new THREE.Mesh(faceGeom, faceMat);
                faceMesh.userData = { 
                    type: 'face', 
                    indices: [indices[i], indices[i + 1], indices[i + 2]],
                    faceIndex: i / 3 
                };
                
                faceHelpers.add(faceMesh);
            }
        }
    }
}

function setupModelingEventListeners() {
    window.addEventListener('mousemove', onModelingMouseMove);
    window.addEventListener('click', onModelingClick);
    
    // Add listeners for UI controls
    document.getElementById('toggle-modeling').addEventListener('click', toggleModelingMode);
    document.getElementById('select-vertex').addEventListener('click', () => setSelectionMode('vertex'));
    document.getElementById('select-edge').addEventListener('click', () => setSelectionMode('edge'));
    document.getElementById('select-face').addEventListener('click', () => setSelectionMode('face'));
    document.addEventListener('mousemove', resetHighlights);
    // Add listeners for sliders
    document.getElementById('vertexSizeSlider').addEventListener('input', () => {
        if (activeObject) showMeshStructure(activeObject);
    });
    document.getElementById('edgeThicknessSlider').addEventListener('input', () => {
        if (activeObject) showMeshStructure(activeObject);
    });
    document.getElementById('faceOpacitySlider').addEventListener('input', () => {
        if (activeObject) showMeshStructure(activeObject);
    });
    document.getElementById('subdivisionLevelsSlider').addEventListener('input', updateSubdivision);
}


function updateSubdivision() {
    if (!activeObject) return;
    
    const subdivisionLevel = parseInt(document.getElementById('subdivisionLevelsSlider').value);
    
    // Only apply subdivision if we have a valid mesh
    if (activeObject && activeObject.geometry) {
        // Detach transform controls
        transformControls.detach();
        
        // Create a new subdivided geometry
        const modifier = new THREE.SubdivisionModifier(subdivisionLevel);
        const newGeometry = modifier.modify(activeObject.geometry);
        
        // Update the mesh with the new geometry
        activeObject.geometry.dispose();
        activeObject.geometry = newGeometry;
        
        // Update the mesh structure
        showMeshStructure(activeObject);
    }
}


 // Object creation functions
 function addCube() {
    const geometry = new THREE.BoxGeometry();
    const material = new THREE.MeshStandardMaterial({ color: 0x00ff00 , side: THREE.DoubleSide });
    const cube = new THREE.Mesh(geometry, material);
    cube.castShadow = true;
    cube.receiveShadow = true;
    cube.position.set(0, 0.5, 0); // Start above ground
    addObjectToScene(cube, 'Cube');
}


 function addPlane() {
    const geometry = new THREE.PlaneGeometry(10, 10); // Width: 10, Height: 10
    const material = new THREE.MeshStandardMaterial({ color: 0x87CEEB, side: THREE.DoubleSide });
    const plane = new THREE.Mesh(geometry, material);
    plane.rotation.x = -Math.PI / 2; // Rotate to lay flat on the ground
    addObjectToScene(plane, 'Plane');
}




let symmetryEnabled = false;
let symmetryAxis = 'x';
let undoStack = [];
let redoStack = [];
let lastSavedState = null;
let autoSaveInterval = 5000; 


let brushSize = 1.5; // Default brush size
let brushStrength = 0.1; // Default brush strength
let brushPreview; // Brush preview mesh


let terrain; // Reference to the terrain
let selectedTool = null; // Current active tool
let isSculpting = false; // Flag for sculpting state
let uploadedTexture = null; // Stores the uploaded texture for painting

const TOOLS = {
    RAISE_LOWER: 'raiseLower',
    SMOOTH: 'smooth',
    FLATTEN: 'flatten',
    NOISE: 'noise',
    PINCH: 'pinch',
    CLAY: 'clay',
    SCRAPE: 'scrape',
    FILL: 'fill',
    TEXTURE_PAINT: 'texturePaint',
    TERRACE: 'terrace',
    EROSION: 'erosion',
    RIDGE: 'ridge',
    CANYON: 'canyon',
    PLATEAU: 'plateau',
    SLOPE: 'slope',
    BLUR: 'blur',
    SHARPEN: 'sharpen'
};



function applySymmetry(originalVertex, index, vertices) {
    if (!symmetryEnabled) return;

    const symmetryVertex = originalVertex.clone();
    symmetryVertex[symmetryAxis] *= -1;

    // search symitry point
    const tolerance = 0.0001;
    for (let i = 0; i < vertices.count; i++) {
        if (i === index) continue;
        
        const vertex = new THREE.Vector3(
            vertices.getX(i),
            vertices.getY(i),
            vertices.getZ(i)
        );

        if (Math.abs(vertex[symmetryAxis] + originalVertex[symmetryAxis]) < tolerance &&
            Math.abs(vertex[(symmetryAxis === 'x' ? 'z' : 'x')] - originalVertex[(symmetryAxis === 'x' ? 'z' : 'x')]) < tolerance) {
            vertices.setXYZ(i, symmetryVertex.x, symmetryVertex.y, symmetryVertex.z);
            break;
        }
    }
}



function createTerrain() {
    // Create geometry
    const geometry = new THREE.PlaneGeometry(50, 50, 100, 100);
    geometry.rotateX(-Math.PI / 2);

    // Create initial texture
    const canvas = document.createElement('canvas');
    canvas.width = 1024;
    canvas.height = 1024;
    const ctx = canvas.getContext('2d');

    // Fill with green color
    ctx.fillStyle = '#87CEEB'; 
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const texture = new THREE.CanvasTexture(canvas);
    texture.needsUpdate = true;

    // Create material with proper settings
    material = new THREE.MeshStandardMaterial({ 
        color: 0x87CEEB,
        map: texture,
        side: THREE.DoubleSide 
    });

    // Create mesh
    terrain = new THREE.Mesh(geometry, material);
    terrain.userData.textureCanvas = canvas;
    terrain.userData.textureContext = ctx;
    terrain.geometry.attributes.position.needsUpdate = true;
    terrain.receiveShadow = true;
    terrain.castShadow = true;


    scene.add(terrain);
    addObjectToScene(terrain, 'Terrain');


    createBrushPreview();

    // Initialize brush system
    if (!window.brushSystem) {
        window.brushSystem = new TerrainBrushSystem(scene, camera, renderer, terrain);
    }   
}




// Create advanced brush preview
function createBrushPreview() {
    if (brushPreview) {
        scene.remove(brushPreview);
    }

    // Create inner circle
    const innerGeometry = new THREE.CircleGeometry(1, 32);
    const innerMaterial = new THREE.MeshBasicMaterial({
        color: 0x4A90E2,
        transparent: true,
        opacity: 0.3,
        side: THREE.DoubleSide
    });
    
    // Create outer circle (falloff indicator)
    const outerGeometry = new THREE.RingGeometry(0.8, 1, 32);
    const outerMaterial = new THREE.MeshBasicMaterial({
        color: 0x4A90E2,
        transparent: true,
        opacity: 0.15,
        side: THREE.DoubleSide
    });

    // Create direction indicator for certain tools
    const directionGeometry = new THREE.ConeGeometry(0.2, 0.5, 32);
    const directionMaterial = new THREE.MeshBasicMaterial({
        color: 0xEE82EE,
        transparent: true,
        opacity: 0.5
    });

    const innerCircle = new THREE.Mesh(innerGeometry, innerMaterial);
    const outerCircle = new THREE.Mesh(outerGeometry, outerMaterial);
    const directionIndicator = new THREE.Mesh(directionGeometry, directionMaterial);

    brushPreview = new THREE.Group();
    brushPreview.add(innerCircle);
    brushPreview.add(outerCircle);
    brushPreview.add(directionIndicator);
    
    brushPreview.rotation.x = -Math.PI / 2;
    brushPreview.visible = false;
    scene.add(brushPreview);
}


// Update brush preview with advanced features
function updateBrushPreview(event) {
    if (!terrain || !brushPreview) return;

    const mouse = new THREE.Vector2(
        (event.clientX / window.innerWidth) * 2 - 1,
        -(event.clientY / window.innerHeight) * 2 + 1
    );

    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(terrain);

    if (intersects.length > 0) {
        const intersect = intersects[0];
        brushPreview.position.copy(intersect.point);
        brushPreview.scale.set(brushSize, brushSize, 1);

        // Update direction indicator based on normal
        const normal = intersect.face.normal.clone();
        normal.transformDirection(terrain.matrixWorld);
        
        // Only show brush preview when a sculpting tool is selected
        brushPreview.visible = Object.values(TOOLS).includes(selectedTool);

        // Show symmetry preview if enabled
        if (symmetryEnabled) {
            // Create or update symmetry preview
            if (!brushPreview.userData.symmetryPreview) {
                brushPreview.userData.symmetryPreview = brushPreview.clone();
                scene.add(brushPreview.userData.symmetryPreview);
            }
            
            const symmetryPosition = intersect.point.clone();
            symmetryPosition[symmetryAxis] *= -1;
            brushPreview.userData.symmetryPreview.position.copy(symmetryPosition);
            brushPreview.userData.symmetryPreview.scale.copy(brushPreview.scale);
            brushPreview.userData.symmetryPreview.visible = true;
        } else if (brushPreview.userData.symmetryPreview) {
            brushPreview.userData.symmetryPreview.visible = false;
        }
    } else {
        brushPreview.visible = false;
        if (brushPreview.userData.symmetryPreview) {
            brushPreview.userData.symmetryPreview.visible = false;
        }
    }
}

// Save terrain state for undo/redo
function saveTerrainState() {
    const positions = terrain.geometry.attributes.position.array.slice();
    undoStack.push(positions);
    redoStack.length = 0; // Clear redo stack when new action is performed
    
    // Limit undo stack size
    if (undoStack.length > 20) {
        undoStack.shift();
    }
}

// Advanced sculpting functions
function pinchTerrain(vertex, position, influence) {
    const direction = new THREE.Vector3().subVectors(position, vertex);
    vertex.add(direction.multiplyScalar(influence * brushStrength));
}

function clayTerrain(vertex, position, influence, normal) {
    const offset = normal.multiplyScalar(brushStrength * influence);
    if (vertex.y < position.y) {
        vertex.add(offset);
    }
}

function scrapeTerrain(vertex, position, influence, normal) {
    const offset = normal.multiplyScalar(-brushStrength * influence);
    if (vertex.y > position.y) {
        vertex.add(offset);
    }
}

function fillTerrain(vertex, position, influence) {
    if (vertex.y < position.y) {
        vertex.y += brushStrength * influence;
    }
}



function startSculpting(event) {
    isSculpting = true;
    applySculpting(event);
    applySculpting1(event);
}

function stopSculpting() {
    isSculpting = false;
}

// تحسين دالة معالجة النحت
function applySculpting(event) {
    if (!isSculpting || !selectedTool || !terrain) return;

    const mouse = new THREE.Vector2(
        (event.clientX / window.innerWidth) * 2 - 1,
        -(event.clientY / window.innerHeight) * 2 + 1
    );
    
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(terrain);
    
    if (intersects.length > 0) {
        // Save state for undo/redo
        if (!lastSavedState || Date.now() - lastSavedState > autoSaveInterval) {
            saveTerrainState();
            lastSavedState = Date.now();
        }
        
        const intersect = intersects[0];
        const vertices = terrain.geometry.attributes.position;
        const position = intersect.point.clone();
        const normal = intersect.face.normal.clone().transformDirection(terrain.matrixWorld);
        
        // Transform position to local space
        terrain.worldToLocal(position);
        
        for (let i = 0; i < vertices.count; i++) {
            const vertex = new THREE.Vector3(
                vertices.getX(i),
                vertices.getY(i),
                vertices.getZ(i)
            );
            
            const distance = vertex.distanceTo(position);
            if (distance < brushSize) {
                const influence = Math.pow(1 - (distance / brushSize), 2); // Smoother falloff
                const originalVertex = vertex.clone();
                
                // Apply tool effect
                switch (selectedTool) {
                    case TOOLS.RAISE_LOWER:
                        vertex.y += brushStrength * influence;
                        break;
                    case TOOLS.SMOOTH:
                        vertex.y += (position.y - vertex.y) * influence * brushStrength;
                        break;
                    case TOOLS.FLATTEN:
                        vertex.y += (position.y - vertex.y) * influence;
                        break;
                    case TOOLS.NOISE:
                        vertex.y += (Math.random() - 0.5) * brushStrength * influence * 2;
                        break;
                    case TOOLS.PINCH:
                        const toCenter = new THREE.Vector3().subVectors(position, vertex);
                        vertex.add(toCenter.multiplyScalar(influence * brushStrength));
                        break;
                    case TOOLS.CLAY:
                        if (vertex.y < position.y) {
                            vertex.add(normal.clone().multiplyScalar(brushStrength * influence));
                        }
                        break;
                    case TOOLS.SCRAPE:
                        if (vertex.y > position.y) {
                            vertex.add(normal.clone().multiplyScalar(-brushStrength * influence));
                        }
                        break;
                    case TOOLS.FILL:
                        if (vertex.y < position.y) {
                            vertex.y += brushStrength * influence;
                        }
                        break;

                        case TOOLS.TERRACE:
                        applyTerrace(vertex, position, influence);
                        break;
                    case TOOLS.EROSION:
                        applyErosion(vertex, position, influence, vertices, i);
                        break;
                    case TOOLS.RIDGE:
                        applyRidge(vertex, position, influence);
                        break;
                    case TOOLS.CANYON:
                        applyCanyon(vertex, position, influence);
                        break;
                    case TOOLS.PLATEAU:
                        applyPlateau(vertex, position, influence);
                        break;
                    case ADVANCED_TOOLS.SLOPE:
                        applySlope(vertex, position, influence, normal);
                        break;
                    case TOOLS.BLUR:
                        applyBlur(vertex, position, influence, vertices, i);
                        break;
                    case TOOLS.SHARPEN:
                        applySharpen(vertex, position, influence, vertices, i);
                        break;
                }
                
                vertices.setXYZ(i, vertex.x, vertex.y, vertex.z);
                
                // Apply symmetry
                if (symmetryEnabled) {
                    const symmetryPosition = position.clone();
                    symmetryPosition[symmetryAxis] *= -1;
                    
                    for (let i = 0; i < vertices.count; i++) {
                        const vertex = new THREE.Vector3(
                            vertices.getX(i),
                            vertices.getY(i),
                            vertices.getZ(i)
                        );
                        
                        const distance = vertex.distanceTo(position);
                        const symmetryDistance = vertex.distanceTo(symmetryPosition);
                        
                        if (distance < brushSize) {
                            const influence = Math.pow(1 - (distance / brushSize), 2);
                            
                            // Apply tool effect to original position
                            switch (selectedTool) {
                                case TOOLS.PINCH:
                                    pinchTerrain(vertex, position, influence);
                                    break;
                                    case TOOLS.RAISE_LOWER:
                                    vertex.y += brushStrength * influence;
                                    break;
                                case TOOLS.SMOOTH:
                                    vertex.y += (position.y - vertex.y) * influence * brushStrength;
                                    break;
                                case TOOLS.FLATTEN:
                                    vertex.y += (position.y - vertex.y) * influence;
                                    break;
                                case TOOLS.NOISE:
                                    vertex.y += (Math.random() - 0.5) * brushStrength * influence * 2;
                                    break;
                                
                                case TOOLS.CLAY:
                                    if (vertex.y < position.y) {
                                        vertex.add(normal.clone().multiplyScalar(brushStrength * influence));
                                    }
                                    break;
                                case TOOLS.SCRAPE:
                                    if (vertex.y > position.y) {
                                        vertex.add(normal.clone().multiplyScalar(-brushStrength * influence));
                                    }
                                    break;
                                case TOOLS.FILL:
                                    if (vertex.y < position.y) {
                                        vertex.y += brushStrength * influence;
                                    }
                                    break;
            
                                    case TOOLS.TERRACE:
                                    applyTerrace(vertex, position, influence);
                                    break;
                                case TOOLS.EROSION:
                                    applyErosion(vertex, position, influence, vertices, i);
                                    break;
                                case TOOLS.RIDGE:
                                    applyRidge(vertex, position, influence);
                                    break;
                                case TOOLS.CANYON:
                                    applyCanyon(vertex, position, influence);
                                    break;
                                case TOOLS.PLATEAU:
                                    applyPlateau(vertex, position, influence);
                                    break;
                                case ADVANCED_TOOLS.SLOPE:
                                    applySlope(vertex, position, influence, normal);
                                    break;
                                case TOOLS.BLUR:
                                    applyBlur(vertex, position, influence, vertices, i);
                                    break;
                                case TOOLS.SHARPEN:
                                    applySharpen(vertex, position, influence, vertices, i);
                                    break;
                               
                            }
                            
                            vertices.setXYZ(i, vertex.x, vertex.y, vertex.z);
                        }
                        
                        // Separately apply to symmetry position
                        if (symmetryDistance < brushSize) {
                            const symmetryInfluence = Math.pow(1 - (symmetryDistance / brushSize), 2);
                            
                            switch (selectedTool) {
                                case TOOLS.PINCH:
                                    pinchTerrain(vertex, symmetryPosition, symmetryInfluence);
                                    break;

                                    case TOOLS.RAISE_LOWER:
                                    vertex.y += brushStrength * influence;
                                    break;
                                case TOOLS.SMOOTH:
                                    vertex.y += (position.y - vertex.y) * influence * brushStrength;
                                    break;
                                case TOOLS.FLATTEN:
                                    vertex.y += (position.y - vertex.y) * influence;
                                    break;
                                case TOOLS.NOISE:
                                    vertex.y += (Math.random() - 0.5) * brushStrength * influence * 2;
                                    break;
                                
                                case TOOLS.CLAY:
                                    if (vertex.y < position.y) {
                                        vertex.add(normal.clone().multiplyScalar(brushStrength * influence));
                                    }
                                    break;
                                case TOOLS.SCRAPE:
                                    if (vertex.y > position.y) {
                                        vertex.add(normal.clone().multiplyScalar(-brushStrength * influence));
                                    }
                                    break;
                                case TOOLS.FILL:
                                    if (vertex.y < position.y) {
                                        vertex.y += brushStrength * influence;
                                    }
                                    break;
            
                                    case TOOLS.TERRACE:
                                    applyTerrace(vertex, position, influence);
                                    break;
                                case TOOLS.EROSION:
                                    applyErosion(vertex, position, influence, vertices, i);
                                    break;
                                case TOOLS.RIDGE:
                                    applyRidge(vertex, position, influence);
                                    break;
                                case TOOLS.CANYON:
                                    applyCanyon(vertex, position, influence);
                                    break;
                                case TOOLS.PLATEAU:
                                    applyPlateau(vertex, position, influence);
                                    break;
                                case ADVANCED_TOOLS.SLOPE:
                                    applySlope(vertex, position, influence, normal);
                                    break;
                                case TOOLS.BLUR:
                                    applyBlur(vertex, position, influence, vertices, i);
                                    break;
                                case TOOLS.SHARPEN:
                                    applySharpen(vertex, position, influence, vertices, i);
                                    break;
                                
                            }
                            
                            vertices.setXYZ(i, vertex.x, vertex.y, vertex.z);
                        }
                    }
                }
            }
        }
        
        vertices.needsUpdate = true;
        terrain.geometry.computeVertexNormals();
    }
}



function applyTexturePaint(event) {
    if (!terrain || !terrain.userData.blendMapCanvas || textureArray.length === 0) return;

    const mouse = new THREE.Vector2(
        (event.clientX / window.innerWidth) * 2 - 1,
        -(event.clientY / window.innerHeight) * 2 + 1
    );

    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(terrain);

    if (intersects.length > 0) {
        const intersect = intersects[0];
        const uv = intersect.uv;
        const ctx = terrain.userData.blendMapContext;
        const canvas = terrain.userData.blendMapCanvas;
        
        const x = uv.x * canvas.width;
        const y = (1 - uv.y) * canvas.height;
        const radius = brushSize * canvas.width / 2;

        // Create brush gradient
        const gradient = ctx.createRadialGradient(
            x, y, 0,
            x, y, radius
        );

        gradient.addColorStop(0, `rgba(255, 255, 255, ${brushStrength})`);
        gradient.addColorStop(0.7, `rgba(255, 255, 255, ${brushStrength * 0.5})`);
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

        ctx.save();

        // Clear area for new texture
        ctx.globalCompositeOperation = 'destination-out';
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();

        // Apply new texture blend
        ctx.globalCompositeOperation = 'source-over';
        
        // Create color for active texture channel
        const color = new Array(4).fill(0);
        color[activeTextureIndex] = 255;
        ctx.fillStyle = `rgba(${color.join(',')})`;
        
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();

        // Update terrain texture
        blendMap.needsUpdate = true;
    }
}






function addSphere() {
    const geometry = new THREE.SphereGeometry(0.5, 32, 32);
    const material = new THREE.MeshStandardMaterial({ color: 0xff0000, side: THREE.DoubleSide });
    const sphere = new THREE.Mesh(geometry, material);
    sphere.castShadow = true;
    sphere.receiveShadow = true;
    sphere.position.set(0, 0.5, 0);
    addObjectToScene(sphere, 'Sphere');
    meshes.push(sphere);
}
 
 function addCylinder() {
     const geometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 32);
     const material = new THREE.MeshStandardMaterial({ color: 0x0000ff, side: THREE.DoubleSide });
     const cylinder = new THREE.Mesh(geometry, material);
     cylinder.castShadow = true;
     cylinder.receiveShadow = true;
     cylinder.position.set(0, 0.5, 0);
     addObjectToScene(cylinder, 'Cylinder');
    meshes.push(cylinder);
 }
 
 // Function to add a Pyramid
function addPyramid() {
    const geometry = new THREE.ConeGeometry(1, 2, 4); // Base radius 1, height 2, 4 sides
    const material = new THREE.MeshStandardMaterial({ color: 0xFFD700, side: THREE.DoubleSide });
    const pyramid = new THREE.Mesh(geometry, material);
    pyramid.castShadow = true;
    pyramid.receiveShadow = true;
    pyramid.position.set(0, 1, 0);
    addObjectToScene(pyramid, 'Pyramid');
    meshes.push(pyramid);
}

// Function to add a Rectangular Prism
function addRectangularPrism() {
    const geometry = new THREE.BoxGeometry(1, 2, 3); // Adjust dimensions for rectangular prism
    const material = new THREE.MeshStandardMaterial({ color: 0x8A2BE2, side: THREE.DoubleSide  });
    const rectangularPrism = new THREE.Mesh(geometry, material);
    rectangularPrism.castShadow = true;
    rectangularPrism.receiveShadow = true;
    rectangularPrism.position.set(0, 1, 0);
    addObjectToScene(rectangularPrism, 'Rectangular Prism');
    meshes.push(rectangularPrism);
}

// Function to add a Torus (Donut Shape)
function addTorus() {
    const geometry = new THREE.TorusGeometry(1, 0.4, 16, 100); // Radius 1, tube radius 0.4
    const material = new THREE.MeshStandardMaterial({ color: 0xFF4500, side: THREE.DoubleSide  });
    const torus = new THREE.Mesh(geometry, material);
    torus.castShadow = true;
    torus.receiveShadow = true;
    torus.position.set(0, 1, 0);
    addObjectToScene(torus, 'Torus');
    meshes.push(torus);
}

 function addLight() {
    const light = new THREE.PointLight(0xffffff, 1);
    light.position.set(0, 2, 0);
    addObjectToScene(light, 'Light');
 }
 
function addCameraInit() {
    const newCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    newCamera.position.set(0, 0, 5);
    addObjectToScene(newCamera, 'Camera');
}




// Advanced tool implementations
function applyTerrace(vertex, position, influence) {
    const steps = parseInt(document.getElementById('terraceSteps').value);
    const heightDiff = position.y - vertex.y;
    const stepHeight = heightDiff / steps;
    
    // Calculate closest step
    const currentStep = Math.round(vertex.y / stepHeight);
    const targetHeight = currentStep * stepHeight;
    
    // Smooth transition between steps
    vertex.y += (targetHeight - vertex.y) * influence * brushStrength;
}

function applyErosion(vertex, position, influence, vertices, index) {
    const erosionStrength = parseFloat(document.getElementById('erosionStrength').value);
    const radius = brushSize * 2;
    let avgHeight = 0;
    let count = 0;
    
    // Sample neighboring vertices
    for (let i = 0; i < vertices.count; i++) {
        const neighborVertex = new THREE.Vector3(
            vertices.getX(i),
            vertices.getY(i),
            vertices.getZ(i)
        );
        
        const distance = vertex.distanceTo(neighborVertex);
        if (distance < radius && distance > 0) {
            avgHeight += neighborVertex.y;
            count++;
        }
    }
    
    if (count > 0) {
        avgHeight /= count;
        const heightDiff = vertex.y - avgHeight;
        vertex.y -= heightDiff * erosionStrength * influence;
    }
}

function applyRidge(vertex, position, influence) {
    const ridgeHeight = parseFloat(document.getElementById('ridgeHeight').value);
    const distance = Math.abs(vertex.x - position.x);
    const falloff = 1 - Math.min(distance / brushSize, 1);
    
    if (falloff > 0) {
        // Create ridge shape using sine function
        const ridge = Math.sin(falloff * Math.PI) * ridgeHeight;
        vertex.y += ridge * influence * brushStrength;
    }
}

function applyCanyon(vertex, position, influence) {
    const depth = brushStrength * 2;
    const distance = Math.abs(vertex.x - position.x);
    const falloff = 1 - Math.min(distance / brushSize, 1);
    
    if (falloff > 0) {
        // Create canyon shape using exponential function
        const canyon = Math.exp(-falloff * 2) * depth;
        vertex.y -= canyon * influence;
    }
}

function applyPlateau(vertex, position, influence) {
    const targetHeight = position.y;
    const threshold = brushSize * 0.3;
    const distance = vertex.distanceTo(position);
    
    if (distance < threshold) {
        // Flat plateau area
        vertex.y += (targetHeight - vertex.y) * influence;
    } else if (distance < brushSize) {
        // Smooth transition to plateau
        const falloff = 1 - ((distance - threshold) / (brushSize - threshold));
        vertex.y += (targetHeight - vertex.y) * falloff * influence;
    }
}

function applySlope(vertex, position, influence, normal) {
    const angle = Math.PI / 4; // 45-degree slope
    const direction = new THREE.Vector3().subVectors(position, vertex);
    const distance = direction.length();
    
    if (distance < brushSize) {
        const targetHeight = position.y - Math.tan(angle) * distance;
        vertex.y += (targetHeight - vertex.y) * influence;
    }
}

function applyBlur(vertex, position, influence, vertices, index) {
    const radius = brushSize * 1.5;
    let avgHeight = 0;
    let totalWeight = 0;
    
    // Gaussian blur
    for (let i = 0; i < vertices.count; i++) {
        const neighborVertex = new THREE.Vector3(
            vertices.getX(i),
            vertices.getY(i),
            vertices.getZ(i)
        );
        
        const distance = vertex.distanceTo(neighborVertex);
        if (distance < radius) {
            const weight = Math.exp(-(distance * distance) / (2 * radius * radius));
            avgHeight += neighborVertex.y * weight;
            totalWeight += weight;
        }
    }
    
    if (totalWeight > 0) {
        avgHeight /= totalWeight;
        vertex.y += (avgHeight - vertex.y) * influence * brushStrength;
    }
}

function applySharpen(vertex, position, influence, vertices, index) {
    const radius = brushSize;
    let avgHeight = 0;
    let count = 0;
    
    // Calculate local average height
    for (let i = 0; i < vertices.count; i++) {
        const neighborVertex = new THREE.Vector3(
            vertices.getX(i),
            vertices.getY(i),
            vertices.getZ(i)
        );
        
        const distance = vertex.distanceTo(neighborVertex);
        if (distance < radius && distance > 0) {
            avgHeight += neighborVertex.y;
            count++;
        }
    }
    
    if (count > 0) {
        avgHeight /= count;
        const heightDiff = vertex.y - avgHeight;
        vertex.y += heightDiff * influence * brushStrength;
    }
}



function addObjectToScene(object, name) {
    object.userData.selectable = true; // Mark object as selectable
    object.name = name + '_' + objects.length;
    objects.push(object);
    scene.add(object);
    updateHierarchy();
    selectObject(object);

    if (isModelingMode) {
        activeObject = object;
        showMeshStructure(activeObject);
    }
}

const COLORS = { 
    HIGHLIGHT: 0x00e5ff,  // Neon Cyan (Beautiful Highlight)
    SELECTED: 0x00ff80    // Emerald Green (Elegant Selection)
};

// Material for highlighted objects (e.g., during operations)
const highlightMaterial = new THREE.MeshStandardMaterial({
    color: COLORS.HIGHLIGHT,
    emissive: COLORS.HIGHLIGHT,
    emissiveIntensity: 0.3,  // Soft glow effect
    side: THREE.DoubleSide,
    transparent: true,
    opacity: 0.6,  // More visible
    roughness: 0.2,
    metalness: 0.2
});

// 🔹 Selected Material (Emissive glow with subtle pulse)
const selectedMaterial = new THREE.MeshStandardMaterial({
    color: COLORS.SELECTED,
    emissive: COLORS.SELECTED, 
    emissiveIntensity: 0.7,  // Brighter glow
    side: THREE.DoubleSide,
    roughness: 0.1,
    metalness: 0.3
});

// 🔹 Smooth Material Transitions with Animated Glow
function animateMaterialChange(object, targetMaterial) {
    if (!object) return;

    gsap.to(object.material.color, {
        r: targetMaterial.color.r,
        g: targetMaterial.color.g,
        b: targetMaterial.color.b,
        duration: 0.4
    });

    gsap.to(object.material.emissive, {
        r: targetMaterial.emissive.r,
        g: targetMaterial.emissive.g,
        b: targetMaterial.emissive.b,
        duration: 0.6
    });

    gsap.to(object.material, {
        emissiveIntensity: targetMaterial === selectedMaterial ? 1 : 0.3,  // Pulsating glow on selection
        duration: 0.8,
        repeat: targetMaterial === selectedMaterial ? -1 : 0,
        yoyo: targetMaterial === selectedMaterial
    });

    object.material.needsUpdate = true;
}


// State management
let hoveredObject = null;
const originalMaterials = new WeakMap();
const selectionHandlers = new Set();


// Selection management functions
function addSelectionHandler(handler) {
    selectionHandlers.add(handler);
}

function removeSelectionHandler(handler) {
    selectionHandlers.delete(handler);
}

function notifySelectionHandlers(object) {
    selectionHandlers.forEach(handler => handler(object));
}

// Add this function to properly clean up when clearing selections
function clearSelection() {
    // Remove any temporary objects used for transformations
    selectedElements.forEach(element => {
        if (element.userData.type === 'edge' || element.userData.type === 'face') {
            scene.remove(element);
        }
    });
    
    // Detach transform controls
    transformControls.detach();
    
    // Reset colors
    resetHighlights();
    
    // Clear selection array
    selectedElements = [];
}




function restoreOriginalMaterial(object) {
    if (object && originalMaterials.has(object)) {
        const originalMaterial = originalMaterials.get(object);
        object.material = originalMaterial;
        originalMaterials.delete(object);
    }
}



function selectObject(newObject) {
    activeObject = newObject;
        if (isModelingMode) {
           showMeshStructure(newobject);
    }
    try {
        if (newObject) {
            ensureObjectUUID(newObject);
        }
        // If selecting the same object, do nothing
        if (selectedObject === newObject) return selectedObject;

        // Clear hover state if the hovered object is being selected
        if (hoveredObject === newObject) {
            hoveredObject = null;
        }

        // Restore previous selection's material
        if (selectedObject) {
            restoreOriginalMaterial(selectedObject);
            
            if (selectedObject.helper) {
                selectedObject.helper.visible = false;
            }
        }

       

        selectedObject = newObject;

        // Handle new selection
        if (selectedObject) {
            // Store and apply selection material
           


            if (selectedObject.helper) {
                selectedObject.helper.visible = true;
            }

            transformControls.attach(selectedObject);

            if (selectedObject.isLight) {
                updateLightUI(selectedObject);
            } else if (selectedObject.isCamera) {
                updateCameraUI(selectedObject);
            }
        } else {
            transformControls.detach();
        }

        // Notify handlers of selection change
        notifySelectionHandlers(selectedObject);
        
        updateInspector();
        updateHierarchySelection();
        return selectedObject;

    } catch (error) {
        console.error('Error in selectObject:', error);
        throw error;
    }
}


function setHoverObject(object) {
    // If trying to hover the selected object, ignore
    if (object === selectedObject) return;
    
    // If current hover is same as new hover, do nothing
    if (hoveredObject === object) return;

    // Clear previous hover state
    if (hoveredObject) {
        restoreOriginalMaterial(hoveredObject);
    }

    hoveredObject = object;

    // Apply hover material only if object exists and isn't selected
    if (object && object !== selectedObject) {
        if (object.material && !object.isLight) {
        }
    }
}


// Hierarchy view functions
function getObjectIcon(obj) {
    if (obj.isLight) return '💡';
    if (obj.isCamera) return '🎥';
    if (obj.isMesh) return '📦';
    if (obj.isGroup) return '📁';
    return '⚪';
}

function createHierarchyItem(obj, level = 0, isLastChild = false, siblings = []) {
    const item = document.createElement('div');
    item.className = 'hierarchy-item';
    item.dataset.uuid = obj.uuid || generateUUID();
    item.dataset.level = level;

    // Add hierarchy line
    const line = document.createElement('div');
    line.className = 'hierarchy-line';
    line.style.left = `${level * 20 + 10}px`; // Position line based on level
    
    if (isLastChild) {
        line.style.display = 'none'; // Hide line for last child
    }
    item.appendChild(line);

    // Add horizontal connector line
    if (level > 0) {
        const connector = document.createElement('div');
        connector.className = 'hierarchy-connector';
        connector.style.left = `${level * 20 + 10}px`; // Start from vertical line
        connector.style.width = `10px`; // Length of horizontal line
        item.appendChild(connector);
    }

    if (isLastChild) {
       line.style.height = '50%'; // Only show top half of the line for last child
       line.style.bottom = 'auto'; // Don't extend to bottom
    }
    const content = document.createElement('div');
    content.className = 'hierarchy-item-content';
    content.style.paddingLeft = `${level * 20 + 25}px`; // Adjust padding to account for line

    // Add expand/collapse toggle for objects with children
    if (obj.children && obj.children.length > 0) {
        const toggle = document.createElement('span');
        toggle.className = 'hierarchy-toggle';
        toggle.innerHTML = obj.expanded ? '▼' : '▶';
        toggle.onclick = (e) => {
            e.stopPropagation();
            obj.expanded = !obj.expanded;
            updateHierarchy();
        };
        content.appendChild(toggle);
    }

    item.oncontextmenu = (e) => {
        e.preventDefault();
        e.stopPropagation();
    
        // Create and show context menu
        showContextMenu(e.clientX, e.clientY, obj);
    
        return false;
    };

    // Add icon and name
    const icon = document.createElement('span');
    icon.className = 'hierarchy-icon';
    icon.innerHTML = getObjectIcon(obj);
    content.appendChild(icon);

    const name = document.createElement('span');
    name.className = 'hierarchy-name';
    name.style.cssText = 'max-width: 110px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;';
    name.textContent = obj.name || `${obj.type || 'Object'}_${obj.id}`;
    content.appendChild(name);

    // Add visibility toggle
    const visibilityToggle = document.createElement('button');
    visibilityToggle.className = 'hierarchy-visibility';
    visibilityToggle.innerHTML = obj.visible ? '👁️' : '👁️‍🗨️';
    visibilityToggle.onclick = (e) => {
        e.stopPropagation();
        obj.visible = !obj.visible;
        visibilityToggle.innerHTML = obj.visible ? '👁️' : '👁️‍🗨️';
    };
    content.appendChild(visibilityToggle);

    // Add properties if available
    if (obj.geometry || obj.material) {
        const properties = document.createElement('div');
        properties.className = 'hierarchy-properties';

        if (obj.geometry) {
            const vertCount = document.createElement('span');
            vertCount.className = 'property';
            vertCount.textContent = `Verts: ${obj.geometry.attributes.position.count}`;
            properties.appendChild(vertCount);
        }

        if (obj.material) {
            const matType = document.createElement('span');
            matType.className = 'property';
            matType.textContent = `Mat: ${obj.material.type}`;
            properties.appendChild(matType);
        }

        content.appendChild(properties);
    }

    item.appendChild(content);

    if (selectedObject && selectedObject.uuid === obj.uuid) {
        item.classList.add('selected');
    }

    // Selection handling
    item.onclick = (e) => {
        e.stopPropagation();
        selectObject(obj);
    };

    // Hover handling
    item.onmouseenter = () => {
        if (obj !== selectedObject) {
            setHoverObject(obj);
        }
    };

    item.onmouseleave = () => {
        if (obj !== selectedObject) {
            setHoverObject(null);
        }
    };

    // Drag and drop handling
    setupDragAndDrop(item, obj);

    // Highlight if selected
    if (selectedObject === obj) {
        item.classList.add('selected');
    }

    return item;
}

function showContextMenu(x, y, obj) {
    const menu = document.createElement('div');
    menu.className = 'hierarchy-context-menu';
    menu.style.left = `${x}px`;
    menu.style.top = `${y}px`;
    
    const options = [
        { label: 'Rename', action: () => renameObject(obj) },
        { label: 'Duplicate', action: () => duplicateObject(obj) },
        { label: 'Delete', action: () => deleteObject(obj) },
        { label: 'Create Child', action: () => createChildObject(obj) }
    ];
    
    options.forEach(option => {
        const item = document.createElement('div');
        item.className = 'context-menu-item';
        item.textContent = option.label;
        item.onclick = () => {
            option.action();
            document.body.removeChild(menu);
        };
        menu.appendChild(item);
    });
    
    document.body.appendChild(menu);
    
    // Close menu when clicking elsewhere
    setTimeout(() => {
        window.addEventListener('click', function closeMenu() {
            if (document.body.contains(menu)) {
                document.body.removeChild(menu);
            }
            window.removeEventListener('click', closeMenu);
        });
    }, 0);
}

function showDropIndicator(targetItem, position) {
    // Remove any existing indicators
    document.querySelectorAll('.drop-indicator').forEach(el => el.remove());
    
    const indicator = document.createElement('div');
    indicator.className = 'drop-indicator';
    
    if (position === 'inside') {
        targetItem.classList.add('drop-target');
    } else {
        // Position indicator above or below target
        indicator.style.top = position === 'before' ? 
            `${targetItem.offsetTop - 2}px` : 
            `${targetItem.offsetTop + targetItem.offsetHeight - 2}px`;
        
        document.getElementById('hierarchy-content').appendChild(indicator);
    }
}

document.getElementById('hierarchy-search-input').addEventListener('input', function() {
    const searchTerm = this.value.toLowerCase();
    highlightMatchingItems(searchTerm);
});

document.getElementById('hierarchy-search-clear').addEventListener('click', function() {
    document.getElementById('hierarchy-search-input').value = '';
    highlightMatchingItems('');
});

function highlightMatchingItems(searchTerm) {
    const items = document.querySelectorAll('.hierarchy-item');
    
    if (!searchTerm) {
        items.forEach(item => {
            item.style.display = '';
            item.classList.remove('search-match');
        });
        return;
    }
    
    items.forEach(item => {
        const name = item.querySelector('.hierarchy-name').textContent.toLowerCase();
        if (name.includes(searchTerm)) {
            item.style.display = '';
            item.classList.add('search-match');
        } else {
            item.style.display = 'none';
        }
    });
}

function setupHierarchyResize() {
    const hierarchyPanel = document.getElementById('hierarchy-panel');
    const resizeHandle = hierarchyPanel.querySelector('.resize-handle-hierarchy');

    let isResizing = false;
    let startX = 0;
    let startWidth = 0;

    resizeHandle.addEventListener('mousedown', (e) => {
        isResizing = true;
        startX = e.clientX;
        startWidth = hierarchyPanel.offsetWidth;
        document.body.style.cursor = 'ew-resize';
    });

    document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;

        const newWidth = startWidth + (e.clientX - startX);
        const minWidth = window.innerWidth * 0.2; // 20% of viewport width
        const maxWidth = window.innerWidth * 0.5; // 50% of viewport width
        const hierarchyWidth = Math.min(Math.max(newWidth, minWidth), maxWidth);

        // Set hierarchy panel width
        hierarchyPanel.style.width = `${hierarchyWidth}px`;

        // Calculate remaining width
        const totalWidth = window.innerWidth;
        const sidebarWidth = totalWidth - hierarchyWidth - timeline.offsetWidth;
        const sidebarThreshold = totalWidth * 0.1; // Hide sidebar if less than 10% width

        // Adjust sidebar
        if (sidebarWidth > sidebarThreshold) {
            sidebar.style.width = `${sidebarWidth}px`;
            sidebar.style.left = `${hierarchyWidth}px`;
            sidebar.classList.remove('hidden');
        } else {
            sidebar.classList.add('hidden');
        }

        // Adjust timeline
        const timelineWidth = totalWidth - hierarchyWidth;
        timeline.style.width = `${timelineWidth}px`;
        timeline.style.left = `${hierarchyWidth}px`;
    });

    document.addEventListener('mouseup', () => {
        if (isResizing) {
            isResizing = false;
            document.body.style.cursor = 'default';
        }
    });
}


function ensureObjectUUID(obj) {
    if (!obj.uuid) {
        obj.uuid = THREE.MathUtils.generateUUID();
    }
    return obj.uuid;
}

// Drag and drop handling
let draggedItem = null;
let dropTarget = null;

function setupDragAndDrop(item, obj) {
    item.ondragstart = (e) => {
        draggedItem = obj;
        item.classList.add('dragging');
        e.dataTransfer.setData('text/plain', obj.uuid);
    };

    item.ondragend = () => {
        item.classList.remove('dragging');
        draggedItem = null;
        clearDropTargets();
    };

    item.ondragover = (e) => {
        e.preventDefault();
        if (draggedItem && canDrop(draggedItem, obj)) {
            item.classList.add('drop-target');
            dropTarget = obj;
        }
    };

    item.ondragleave = () => {
        item.classList.remove('drop-target');
        dropTarget = null;
    };

    item.ondrop = (e) => {
        e.preventDefault();
        if (draggedItem && dropTarget) {
            handleDrop(draggedItem, dropTarget);
        }
        clearDropTargets();
    };
}

function canDrop(draggedObj, targetObj) {
    if (draggedObj === targetObj) return false;
    let parent = targetObj.parent;
    while (parent) {
        if (parent === draggedObj) return false;
        parent = parent.parent;
    }
    return true;
}



function handleDrop(draggedObj, targetObj) {
    const oldParent = draggedObj.parent;
    oldParent.remove(draggedObj);
    targetObj.add(draggedObj);
    updateHierarchy();
}

function clearDropTargets() {
    const dropTargets = document.querySelectorAll('.drop-target');
    dropTargets.forEach(el => el.classList.remove('drop-target'));
    dropTarget = null;
}

function updateHierarchy() {
    const container = document.getElementById('hierarchy-content');
    container.innerHTML = '';

    function addChildrenToHierarchy(parent, level, siblings = []) {
        const children = parent.children || [];
        children.forEach((child, index) => {
            const isLastChild = index === children.length - 1;
            const item = createHierarchyItem(child, level, isLastChild, siblings);
            container.appendChild(item);
            if (child.expanded && child.children && child.children.length > 0) {
                addChildrenToHierarchy(child, level + 1, children);
            }
        });
    }

    objects.forEach((obj, index) => {
        const isLastChild = index === objects.length - 1;
        container.appendChild(createHierarchyItem(obj, 0, isLastChild, objects));
        if (obj.expanded && obj.children && obj.children.length > 0) {
            addChildrenToHierarchy(obj, 1, objects);
        }
    });

    // After updating the hierarchy, ensure the selection is updated
    updateHierarchySelection();
}

// Material cache for highlighting

 function updateInspector() {
     if (!selectedObject) return;
 
     document.getElementById('posX').value = selectedObject.position.x;
     document.getElementById('posY').value = selectedObject.position.y;
     document.getElementById('posZ').value = selectedObject.position.z;
 
     document.getElementById('rotX').value = selectedObject.rotation.x;
     document.getElementById('rotY').value = selectedObject.rotation.y;
     document.getElementById('rotZ').value = selectedObject.rotation.z;
 
     document.getElementById('scaleX').value = selectedObject.scale.x;
     document.getElementById('scaleY').value = selectedObject.scale.y;
     document.getElementById('scaleZ').value = selectedObject.scale.z;
 }
 
 function updateHierarchySelection() {
    const items = document.querySelectorAll('.hierarchy-item');

    items.forEach(item => {
        item.classList.remove('selected');
    });

    if (selectedObject) {
        const selectedItem = document.querySelector(`.hierarchy-item[data-uuid="${selectedObject.uuid}"]`);
        if (selectedItem) {
            selectedItem.classList.add('selected');

            let parent = selectedItem.parentElement;
            while (parent) {
                const parentItem = parent.closest('.hierarchy-item');
                if (parentItem) {
                    const toggle = parentItem.querySelector('.hierarchy-toggle');
                    if (toggle && toggle.innerHTML === '▶') {
                        const parentObj = objects.find(obj => obj.uuid === parentItem.dataset.uuid);
                        if (parentObj) {
                            parentObj.expanded = true;
                            updateHierarchy();
                            return;
                        }
                    }
                }
                parent = parent.parentElement;
            }
        }
    }
}

 
// Available Transform Modes
const TRANSFORM_MODES = ['translate', 'rotate', 'scale', 'mirror', 'snap', 'shear', 'reset'];

// Function to Set Transform Mode
function setTransformMode(mode) {
    if (!TRANSFORM_MODES.includes(mode)) return;

    transformControls.setMode(mode);
    
    document.querySelectorAll('.toolbar-group button').forEach(btn => {
        btn.classList.remove('active');
        gsap.to(btn, { scale: 1, duration: 0.2 });  // Reset size
    });

    const activeBtn = document.getElementById(mode);
    activeBtn.classList.add('active');

    // Smooth animation for button feedback
    gsap.to(activeBtn, { scale: 1.2, duration: 0.3, yoyo: true, repeat: 1 });

    // Apply Special Modes
    applySpecialTransform(mode);
}

// Function to Apply Special Transformations
function applySpecialTransform(mode) {
    const object = transformControls.object;
    if (!object) return;

    switch (mode) {
        case 'mirror': 
            object.scale.x *= -1; // Flip along X-axis
            break;

        case 'snap':
            object.position.x = Math.round(object.position.x / 5) * 5; // Snap to 5 units
            object.position.y = Math.round(object.position.y / 5) * 5;
            object.position.z = Math.round(object.position.z / 5) * 5;
            break;

        case 'shear': 
            object.scale.x += 0.1;  // Skew effect
            object.scale.y -= 0.05;
            break;

        case 'reset': 
            object.position.set(0, 0, 0);
            object.rotation.set(0, 0, 0);
            object.scale.set(1, 1, 1);
            break;
    }

    object.matrixWorldNeedsUpdate = true;
}


 // File operations
 function newScene() {
    objects.forEach(obj => scene.remove(obj));
    objects = [];
    selectedObject = null;
    updateHierarchy();
    updateInspector();
    localStorage.removeItem("savedScene"); // Reset saved scene
}



// ✅ **Auto-save Scene**
function autoSaveScene() {
    const sceneData = serializeScene();
    try {
        localStorage.setItem("savedScene", JSON.stringify(sceneData));
        console.log("✅ Scene auto-saved!");
    } catch (error) {
        console.error("❌ Failed to auto-save scene:", error);
    }
}

// ✅ **Load Scene from Local Storage**
function loadSavedScene() {
    try {
        const savedData = localStorage.getItem("savedScene");
        if (savedData) {
            restoreScene(JSON.parse(savedData));
            console.log("✅ Scene loaded from localStorage!");
        }
    } catch (error) {
        console.error("❌ Failed to load saved scene:", error);
    }
}

// ✅ **Save Scene Manually (Download as JSON)**
function saveScene() {
    const sceneData = serializeScene();
    const blob = new Blob([JSON.stringify(sceneData, null, 2)], { type: 'application/json' });
    saveAs(blob, "scene.json");
}

// ✅ **Load Scene from File**
function loadScene() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    input.onchange = (e) => {
        const file = e.target.files[0];
        const reader = new FileReader();
        reader.onload = (event) => {
            restoreScene(JSON.parse(event.target.result));
            console.log("✅ Scene loaded from JSON!");
        };
        reader.readAsText(file);
    };
    input.click();
}

// ✅ **Serialize Scene**
function serializeScene() {
    return {
        objects: objects.map(obj => ({
            type: obj.type,
            geometry: obj.geometry ? obj.geometry.parameters : null,
            material: obj.material ? {
                color: obj.material.color.getHex(),
                wireframe: obj.material.wireframe
            } : null,
            position: obj.position.toArray(),
            rotation: obj.rotation.toArray(),
            scale: obj.scale.toArray(),
            name: obj.name
        })),
        timestamp: Date.now()
    };
}

// ✅ **Restore Scene**
function restoreScene(sceneData) {
    newScene();
    sceneData.objects.forEach(objData => {
        let obj;
        switch (objData.type) {
            case 'Mesh':
                obj = new THREE.Mesh(
                    new THREE.BoxGeometry(
                        objData.geometry.width,
                        objData.geometry.height,
                        objData.geometry.depth
                    ),
                    new THREE.MeshStandardMaterial({ color: objData.material.color })
                );
                break;
        }
        if (obj) {
            obj.position.fromArray(objData.position);
            obj.rotation.fromArray(objData.rotation);
            obj.scale.fromArray(objData.scale);
            obj.name = objData.name;
            addObjectToScene(obj);
        }
    });
}

// ✅ **Export Scene as GLTF, OBJ, FBX, and ZIP**
function exportScene() {
    const format = document.getElementById('exportFormat').value;
    switch (format) {
        case 'gltf':
            exportGLTF();
            break;
        case 'obj':
            exportOBJ();
            break;
        case 'fbx':
            exportFBX();
            break;
        case 'zip':
            exportAsZip();
            break;
    }
}

// ✅ **Export as GLTF**
function exportGLTF() {
    const exporter = new THREE.GLTFExporter();
    exporter.parse(scene, (result) => {
        const blob = new Blob([JSON.stringify(result)], { type: 'application/json' });
        saveAs(blob, "scene.gltf");
    });
}

// ✅ **Export as OBJ**
function exportOBJ() {
    const exporter = new THREE.OBJExporter();
    const result = exporter.parse(scene);
    const blob = new Blob([result], { type: 'text/plain' });
    saveAs(blob, "scene.obj");
}

// ✅ **Export as FBX**
function exportFBX() {
    const exporter = new THREE.FBXExporter();
    const result = exporter.parse(scene);
    const blob = new Blob([result], { type: 'application/octet-stream' });
    saveAs(blob, "scene.fbx");
}

// ✅ **Export Scene as Compressed ZIP**
function exportAsZip() {
    const zip = new JSZip();
    zip.file("scene.json", JSON.stringify(serializeScene(), null, 2));

    zip.generateAsync({ type: "blob" }).then((content) => {
        saveAs(content, "scene.zip");
    });
}

// ✅ **Import Scene**
function importScene() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json,.gltf,.glb,.obj,.fbx,.zip';
    input.onchange = (e) => {
        const file = e.target.files[0];
        const reader = new FileReader();
        reader.onload = (event) => {
            if (file.name.endsWith('.json')) {
                restoreScene(JSON.parse(event.target.result));
            } else if (file.name.endsWith('.gltf') || file.name.endsWith('.glb')) {
                loadGLTF(event.target.result);
            } else if (file.name.endsWith('.obj')) {
                loadOBJ(event.target.result);
            } else if (file.name.endsWith('.fbx')) {
                loadFBX(event.target.result);
            } else if (file.name.endsWith('.zip')) {
                loadZIP(event.target.result);
            }
        };
        reader.readAsText(file);
    };
    input.click();
}

// ✅ **Warn Before Leaving (If Unsaved Changes)**
window.addEventListener("beforeunload", (event) => {
    if (localStorage.getItem("savedScene")) {
        event.preventDefault();
        event.returnValue = "You have unsaved changes. Do you want to leave?";
    }
});

// ✅ **Auto-save every 2 minutes**
setInterval(autoSaveScene, 2 * 60 * 1000);

// ✅ **Load scene from local storage on startup**
window.addEventListener("load", loadSavedScene);







 // Utility functions
 function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    if (orientationWidget) {
        orientationWidget.position.set(-window.innerWidth/2 + 70, window.innerHeight/2 - 70, 0);
    }
 }
 
// Store references to elements once
const objectsElem = document.getElementById('objects');
const fpsElem = document.getElementById('fps');
const trianglesElem = document.getElementById('triangles');

let lastTime = performance.now();
let frameCount = 0;
let fps = 0;

function updateStats() {
    // Update object count
    objectsElem.textContent = `Objects: ${objects.length}`;

    // FPS Calculation
    const now = performance.now();
    frameCount++;
    if (now - lastTime >= 1000) {
        fps = frameCount;
        frameCount = 0;
        lastTime = now;
    }
    fpsElem.textContent = `FPS: ${fps}`;

    // Calculate total triangles
    let triangles = 0;
    scene.traverse(object => {
        if (object.geometry?.attributes?.position) {
            triangles += object.geometry.attributes.position.count / 3;
        }
    });
    trianglesElem.textContent = `Triangles: ${triangles}`;
}

 

let zoomLevel = 1;
let timelineOffset = 0;

let dragStart = 0;
let selectedSegment = null;

const timeline = document.querySelector('.timeline-track');
const playhead = document.querySelector('.playhead');
const timelineScale = document.querySelector('.timeline-scale');
const timelineContent = document.querySelector('.timeline-content');

function playAnimation() {
    isPlaying = true;
    clock.start();
    updatePlayhead();
}

function pauseAnimation() {
    isPlaying = false;
    clock.stop();
}

function stopAnimation() {
    isPlaying = false;
    clock.stop();
    playhead.style.left = '0%';
    document.getElementById('time-display').textContent = '00:00:00';
}

function updatePlayhead() {
    if (!isPlaying) return;
    
    const time = clock.getElapsedTime();
    const position = (time / 300) * 100; // 5 minutes total
    
    if (position <= 100) {
        playhead.style.left = `${position}%`;
        requestAnimationFrame(updatePlayhead);
    } else {
        stopAnimation();
    }
}
 // Zoom controls
 document.getElementById('zoom-in').addEventListener('click', () => {
    zoomLevel = Math.min(zoomLevel * 1.5, 4);
    timelineContent.style.transform = `scaleX(${zoomLevel})`;
});

document.getElementById('zoom-out').addEventListener('click', () => {
    zoomLevel = Math.max(zoomLevel / 1.5, 1);
    timelineContent.style.transform = `scaleX(${zoomLevel})`;
});

// Timeline dragging
timeline.addEventListener('mousedown', (e) => {
    isDragging = true;
    dragStart = e.clientX - timelineOffset;
    timeline.style.cursor = 'grabbing';
});

document.addEventListener('mousemove', (e) => {
    if (isDragging) {
        const offset = e.clientX - dragStart;
        timelineOffset = offset;
        timelineContent.style.transform = `translateX(${offset}px) scaleX(${zoomLevel})`;
    }
});

document.addEventListener('mouseup', () => {
    isDragging = false;
    timeline.style.cursor = 'grab';
});

// Segment selection
timelineContent.addEventListener('click', (e) => {
    if (e.target.classList.contains('recording-segment')) {
        if (selectedSegment) {
            selectedSegment.classList.remove('selected');
        }
        selectedSegment = e.target;
        selectedSegment.classList.add('selected');
    }
});


// Initialize timeline scale
function initializeTimelineScale() {
    const totalSeconds = 300; // 5 minutes
    const majorMarkerInterval = 30; // Every 30 seconds
    
    for (let i = 0; i <= totalSeconds; i += 5) {
        const marker = document.createElement('div');
        marker.className = `timeline-scale-marker ${i % majorMarkerInterval === 0 ? 'major' : ''}`;
        marker.style.left = `${(i / totalSeconds) * 100}%`;
        
        if (i % majorMarkerInterval === 0) {
            const label = document.createElement('div');
            label.className = 'timeline-scale-label';
            label.textContent = `${Math.floor(i / 60)}:${String(i % 60).padStart(2, '0')}`;
            marker.appendChild(label);
        }
        
        timelineScale.appendChild(marker);
    }
}

function recordSceneData() {
    if (isPlaying && selectedSegment) {
        const time = clock.getElapsedTime();
        const position = (time / 300) * 100; // 5 minutes total
        selectedSegment.style.width = `${position}%`;
    }
}

function animate () {
    requestAnimationFrame(animate);

    if (controls && controls.enabled) {
        controls.update();
    }

    animateParticles();
    recordSceneData();
    if (isSnowing) {
        updateSnow();
    }

    // Update animations
    if (world) world.step(1 / 60); // Physics simulation step
    const delta = clock.getDelta();

    scene.traverse((object) => {
        if (object.userData && object.userData.mixer) {
          object.userData.mixer.update(delta);
        }
    });


    if (physicsEnabled) updateHairPhysics();

    scene.traverse((obj) => {
        if (obj.userData.animate) {
            obj.rotation.y += 0.01;
            obj.position.y += Math.sin(Date.now() * 0.001) * 0.01;
        }
    });


    scene.traverse(object => {
        if (object.userData.physicsBody) {
            object.position.copy(object.userData.physicsBody.position);
            object.quaternion.copy(object.userData.physicsBody.quaternion);
        }
    });


    if (world && physicsManager) {
        world.step(1/60);
        physicsManager.updatePhysics();
    }


    // Update scene objects
    scene.traverse(obj => {
        if (obj.userData.needsUpdate) {
            if (obj.userData.mixer) obj.userData.mixer.update(delta);
            if (obj.userData.physicsBody) {
                obj.position.copy(obj.userData.physicsBody.position);
                obj.quaternion.copy(obj.userData.physicsBody.quaternion);
            }
        }
    });


    nodeEditor.update(1/60);

    if (window.materialSettings && window.materialSettings.enableTextureAnimation) {
        window.materialSettings.updateMaterialAnimation();
    }


    scene.traverse((object) => {
        if (object.animate && typeof object.animate === 'function') {
            object.animate();
        }
    });

    if (isPlaying) {
        const time = clock.getElapsedTime();
        const minutes = Math.floor(time / 60);
        const seconds = Math.floor(time % 60);
        const milliseconds = Math.floor((time % 1) * 100);
        document.getElementById('time-display').textContent = 
            `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}:${milliseconds.toString().padStart(2, '0')}`;
    }


    updateStats();
    updateHelpers(); 
    renderer.render(scene, camera);

    if (activeCamera && previewRenderer) {
        previewRenderer.render(scene, activeCamera);
    }

    composer.render();
};



 // Initialize the editor when the page loads
 init();
    </script>
    <script>
        function initializeUI() {
            // Ensure timeline and inspector are visible
            const timeline = document.querySelector('.timeline');
            const inspector = document.querySelector('.inspector-panel');
            if (timeline) timeline.style.display = 'flex';
            if (inspector) inspector.style.display = 'flex';
        }

        // Material Editor with GUI Display
        function setupMaterialEditor() {
            const materialColor = document.getElementById('materialColor');
            const materialMetalness = document.getElementById('materialMetalness');
            const materialRoughness = document.getElementById('materialRoughness');
            const materialOpacity = document.getElementById('materialOpacity');
            const materialTexture = document.getElementById('materialTexture');
            materialColor.addEventListener('input', updateMaterial);
            materialMetalness.addEventListener('input', updateMaterial);
            materialRoughness.addEventListener('input', updateMaterial);
            materialOpacity.addEventListener('input', updateMaterial);
            materialTexture.addEventListener('change', updateTexture);
        
            const gui = new dat.GUI({ autoPlace: false });
            const settings = {
                texture: 'glass'
            };
        
            gui.add(settings, 'texture', ['glass', 'metal', 'water', 'crystal', 'plastic', 'ceramic', 'wood', 'marble', 'gold', 'chrome', 'holographic', 'matte']).onChange((value) => {
                updateTextureMaterials(value);
            });
        
            // Style the GUI container
            gui.domElement.style.position = 'relative';
            gui.domElement.style.marginTop = '10px';
        
            // Get the materialTextures div and append the GUI
            const materialTextures = document.getElementById('materialTextures');
            materialTextures.appendChild(gui.domElement);
        }
        
       

        // Enhanced textures object with more materials
        const textures = {
            glass: new THREE.MeshPhysicalMaterial({
                color: 0xA0D8EF,
                roughness: 0.1,
                metalness: 0.1,
                clearcoat: 1.0,
                clearcoatRoughness: 0.1,
                transmission: 0.95,
                thickness: 0.5,
                reflectivity: 1.0,
                transparent: true,
                opacity: true,
                attenuationColor: 0xA0D8EF, 
                attenuationDistance: 0.75 ,
                envMap: loadEnvironmentMap(),
                refractionRatio: 1.5
            }),
        
            metal: new THREE.MeshPhysicalMaterial({
                color: 0xAAAAAA,
                roughness: 0.05,
                metalness: 1.0,
                clearcoat: 0.7,
                clearcoatRoughness: 0.02,
                anisotropy: 0.8,
                envMap: loadEnvironmentMap()
            }),
        
            water: new THREE.MeshPhysicalMaterial({
                color: 0x1e90ff,
                roughness: 0.01,
                metalness: 0.0,
                transmission: 1,
                thickness: 0.1,
                transparent: true,
                opacity: 0.9,
                envMap: loadEnvironmentMap(),
                reflectivity: 0.9,
                refractionRatio: 1.33,

            }),
        
            crystal: new THREE.MeshPhysicalMaterial({
                color: 0x7F7FFF,
                roughness: 0.01,
                metalness: 0.0,
                transmission: 1.0,
                thickness: 1.0,
                transparent: true,
                opacity: 0.95,
                envMap: loadEnvironmentMap(),
                clearcoat: 1.0,
                clearcoatRoughness: 0.01,
                attenuationColor: 0x7F7FFF,
                attenuationDistance: 1.0,
                iridescence: 0.8,
                iridescenceIOR: 2.0,
                iridescenceThicknessRange: [200, 500]
            }),
        
            
            plastic: new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                roughness: 0.3,
                metalness: 0.0,
                clearcoat: 0.8,
                clearcoatRoughness: 0.2
            }),
        
            ceramic: new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                roughness: 0.1,
                metalness: 0.0,
                clearcoat: 1.0,
                clearcoatRoughness: 0.1,
                sheen: 1.0,
                sheenRoughness: 0.3,
                sheenColor: 0xffffff
            }),
        
            wood: new THREE.MeshStandardMaterial({
                color: 0x885533,
                roughness: 0.8,
                metalness: 0.0,
                map: loadWoodTexture()
            }),
        
            marble: new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                roughness: 0.15,
                metalness: 0.0,
                transmission: 0.5,
                thickness: 0.5,
                clearcoat: 0.8,
                clearcoatRoughness: 0.2
            }),
        
            gold: new THREE.MeshPhysicalMaterial({
                color: 0xffd700,
                roughness: 0.1,
                metalness: 1.0,
                envMap: loadEnvironmentMap(),
                clearcoat: 0.5,
                clearcoatRoughness: 0.1
            }),
        
            chrome: new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                roughness: 0.0,
                metalness: 1.0,
                envMap: loadEnvironmentMap(),
                clearcoat: 1.0,
                clearcoatRoughness: 0.0
            }),
        
            holographic: new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                roughness: 0.2,
                metalness: 0.5,
                transmission: 0.5,
                thickness: 0.5,
                attenuationColor: 0xff00ff,
                attenuationDistance: 0.5,
                iridescence: 1.0,
                iridescenceIOR: 2.0,
                iridescenceThicknessRange: [100, 400]
            }),
        
            matte: new THREE.MeshStandardMaterial({
                color: 0x808080,
                roughness: 1.0,
                metalness: 0.0
            })
            
        };
    
        function loadEnvironmentMap() {
            return new THREE.CubeTextureLoader().load([
                'textures/skybox/px.jpg',
                'textures/skybox/nx.jpg',
                'textures/skybox/py.jpg',
                'textures/skybox/ny.jpg',
                'textures/skybox/pz.jpg',
                'textures/skybox/nz.jpg'
            ]);
        }
        
    
        function loadWoodTexture() {
            return new THREE.TextureLoader().load('textures/wood/woodgrain.jpg');
        }


        function updateMaterial() {
            if (!selectedObject || !selectedObject.material) return;
        
            selectedObject.material.color.setHex(parseInt(materialColor.value.substr(1), 16));
            selectedObject.material.metalness = parseFloat(materialMetalness.value);
            selectedObject.material.roughness = parseFloat(materialRoughness.value);
            selectedObject.material.opacity = parseFloat(materialOpacity.value);
            selectedObject.material.emissive.setHex(parseInt(materialEmissive.value.substr(1), 16));
            selectedObject.material.emissiveIntensity = parseFloat(materialEmissiveIntensity.value);
            selectedObject.material.clearcoat = parseFloat(materialClearcoat.value);
            selectedObject.material.iridescence = parseFloat(materialIridescence.value);
            selectedObject.material.transparent = selectedObject.material.opacity < 1;
            selectedObject.material.needsUpdate = true;
        }
    
     
        function updateTexture(event) {
            if (!selectedObject || !selectedObject.material) return;
        
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const texture = new THREE.TextureLoader().load(e.target.result);
                    texture.encoding = THREE.sRGBEncoding;
                    selectedObject.material.map = texture;
                    selectedObject.material.needsUpdate = true;
                };
                reader.readAsDataURL(file);
            }
        }
    
        function updateTextureMaterials(textureName) {
            if (!selectedObject || !selectedObject.material) return;
            
            const newMaterial = textures[textureName].clone();
            selectedObject.material = newMaterial;
            selectedObject.material.needsUpdate = true;
        }

        // History System
const history = [];
let currentHistoryIndex = -1;

// Utility function to add an action to history and update UI
function recordHistoryAction(type, objectName, undoAction = null, redoAction = null) {
    const action = {
        type: type,
        object: objectName,
        undo: undoAction,
        redo: redoAction
    };
    history.push(action);
    currentHistoryIndex = history.length - 1;
    updateHistoryPanel();
}

function undo() {
    if (currentHistoryIndex >= 0) {
        const action = history[currentHistoryIndex];
        if (action.undo) action.undo();
        currentHistoryIndex--;
        updateHistoryPanel();
    }
}

function redo() {
    if (currentHistoryIndex < history.length - 1) {
        currentHistoryIndex++;
        const action = history[currentHistoryIndex];
        if (action.redo) action.redo();
        updateHistoryPanel();
    }
}

function clearHistory() {
    history.length = 0;
    currentHistoryIndex = -1;
    updateHistoryPanel();
}

function updateHistoryPanel() {
    const historyPanel = document.getElementById('history-items');
    if (!historyPanel) {
        console.error("History panel not found!");
        return;
    }

    historyPanel.innerHTML = ''; // Clear previous history items

    history.forEach((action, index) => {
        const historyItem = document.createElement('div');
        historyItem.classList.add('history-item'); // Uses the styled class
        historyItem.textContent = `${index + 1}. ${action.type || 'Action'}`;

        historyItem.addEventListener('click', () => {
            if (action.undo) action.undo();
            updateHistoryPanel();
        });

        historyPanel.appendChild(historyItem);
    });
}




// Snapping System
function enableSnapping() {
    const gridSize = 1;
    transformControls.addEventListener('change', () => {
        if (selectedObject) {
            selectedObject.position.x = Math.round(selectedObject.position.x / gridSize) * gridSize;
            selectedObject.position.y = Math.round(selectedObject.position.y / gridSize) * gridSize;
            selectedObject.position.z = Math.round(selectedObject.position.z / gridSize) * gridSize;
        }
    });
}

// Advanced Object Manipulation
function mirrorObject(axis = 'x') {
    if (!selectedObject) return;
    const clone = selectedObject.clone();
    clone.scale[axis] *= -1;
    addObjectToScene(clone);
    recordHistoryAction('Mirror', clone.name);
}

function createArray() {
    if (!selectedObject) return;
    const count = 3; // Can be made configurable
    const spacing = 2;

    for (let i = 1; i <= count; i++) {
        const clone = selectedObject.clone();
        clone.position.x += spacing * i;
        addObjectToScene(clone);
        recordHistoryAction('Array', clone.name);
    }
}

// Clipboard Operations
let clipboardData = null;

function setupClipboardOperations() {
    // Object manipulation handler with history logging
    function handleObjectAction(type, callback) {
        return () => {
            if (!selectedObject && type !== 'Paste') return;
            const objectName = type === 'Paste' ? clipboardData?.name : selectedObject.name;
            let undoAction = null;
            let redoAction = null;

            if (type === 'Delete') {
                const index = objects.indexOf(selectedObject);
                undoAction = () => {
                    if (index > -1) {
                        objects.splice(index, 0, selectedObject);
                        scene.add(selectedObject);
                    }
                };
                redoAction = () => {
                    if (index > -1) {
                        objects.splice(index, 1);
                        scene.remove(selectedObject);
                    }
                };
            }

            callback();
            recordHistoryAction(type, objectName, undoAction, redoAction);
        };
    }

    // Clipboard and object manipulation functions
    const clipboardActions = {
        copy: handleObjectAction('Copy', () => {
            if (selectedObject) clipboardData = selectedObject.clone();
        }),

        paste: handleObjectAction('Paste', () => {
            if (clipboardData) {
                const pastedObject = clipboardData.clone();
                pastedObject.position.x += 1;
                pastedObject.name = pastedObject.name.replace(/\d+$/, '') + '_' + objects.length;
                addObjectToScene(pastedObject);
            }
        }),

        delete: handleObjectAction('Delete', () => {
            if (selectedObject) {
                const index = objects.indexOf(selectedObject);
                if (index > -1) {
                    // Remove helper if exists
                    if (selectedObject.helper) {
                        scene.remove(selectedObject.helper);
                        selectedObject.helper.dispose();
                    }

                    // Remove all child meshes
                    selectedObject.traverse((child) => {
                        if (child instanceof THREE.Mesh) {
                            child.geometry.dispose();
                            child.material.dispose();
                        }
                    });

                    objects.splice(index, 1);
                    scene.remove(selectedObject);
                    transformControls.detach();

                    if (selectedObject instanceof THREE.Camera && activeCamera === selectedObject) {
                        activeCamera = null;
                    }

                    selectedObject = null;
                    updateHierarchy();
                }
            }
        }),

        duplicate: handleObjectAction('Duplicate', () => {
            if (selectedObject) {
                const duplicate = selectedObject.clone();
                duplicate.position.x += 1;
                duplicate.name = duplicate.name.replace(/\d+$/, '') + '_' + objects.length;
                addObjectToScene(duplicate);
            }
        })
    };

    // Keyboard shortcuts for clipboard operations
    document.addEventListener('keydown', (e) => {
        if (e.ctrlKey || e.metaKey) {
            switch (e.key.toLowerCase()) {
                case 'c':
                    e.preventDefault();
                    clipboardActions.copy();
                    break;
                case 'v':
                    e.preventDefault();
                    clipboardActions.paste();
                    break;
                case 'd':
                    e.preventDefault();
                    clipboardActions.duplicate();
                    break;
            }
        }
        if (e.key === 'Delete') {
            clipboardActions.delete();
        }
    });

    // Context menu configuration
    const contextMenuConfig = [
        { label: 'Copy (Ctrl+C)', action: clipboardActions.copy },
        { label: 'Paste (Ctrl+V)', action: clipboardActions.paste },
        { label: 'Delete (Del)', action: clipboardActions.delete },
        { label: 'Duplicate (Ctrl+D)', action: clipboardActions.duplicate },
        {
            label: 'Transform Controls',
            subMenu: [
                { label: 'Translate', action: () => setTransformMode('translate'), id: 'context-translate' },
                { label: 'Rotation', action: () => setTransformMode('rotate'), id: 'context-rotate' },
                { label: 'Scale', action: () => setTransformMode('scale'), id: 'context-scale' }
            ]
        },
        {
            label: 'Utility Tools',
            subMenu: [
                { label: 'Enable Snapping', action: enableSnapping, id: 'enable-snapping' },
                { label: 'Optimize Scene', action: optimizeScene, id: 'optimize-scene' },
                { label: 'Mirror Object', action: () => mirrorObject(), id: 'mirror-object' },
                { label: 'Create Array', action: createArray, id: 'create-array' },
                { label: 'Clear History', action: clearHistory, id: 'clear-history' }
            ]
        }
    ];

    // Generate context menu dynamically
    const contextMenu = document.getElementById('context-menu');
    if (contextMenu) {
        contextMenu.innerHTML = contextMenuConfig.map(item => `
            <div class="context-menu-item" ${item.subMenu ? 'id="' + (item.label === 'Transform Controls' ? 'transform-controls-item' : 'utility-controls-item') + '"' : ''}>
                ${item.label}
                ${item.subMenu ? '<i class="fa-solid fa-caret-right" style="margin-left: 20px;"></i>' : ''}
                ${item.subMenu ? `
                    <div class="sub-menu" id="${item.label === 'Transform Controls' ? 'transform-sub-menu' : 'utility-sub-menu'}">
                        ${item.subMenu.map(subItem => `
                            <div class="context-menu-item" id="${subItem.id}">${subItem.label}</div>
                        `).join('')}
                    </div>
                ` : ''}
            </div>
        `).join('');

        // Attach event listeners for sub-menu items
        contextMenuConfig.forEach(item => {
            if (item.subMenu) {
                item.subMenu.forEach(subItem => {
                    const element = document.getElementById(subItem.id);
                    if (element) {
                        element.addEventListener('click', subItem.action);
                    }
                });
            }
        });
    }

    // Expose functions globally
    Object.assign(window, {
        copyObject: clipboardActions.copy,
        pasteObject: clipboardActions.paste,
        deleteObject: clipboardActions.delete,
        duplicateObject: clipboardActions.duplicate,
        enableSnapping,
        optimizeScene,
        mirrorObject,
        createArray,
        clearHistory
    });
}


// Performance Optimization
function optimizeScene() {
    function mergeGeometries() {
        const geometries = [];
        const materials = [];
        const matrix = [];

        scene.traverse((object) => {
            if (object.isMesh) {
                geometries.push(object.geometry);
                materials.push(object.material);
                matrix.push(object.matrixWorld.clone());
                scene.remove(object);
            }
        });

        if (geometries.length > 1) {
            const mergedGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries(geometries);
            const mergedMesh = new THREE.Mesh(mergedGeometry, materials[0]);
            mergedMesh.applyMatrix4(matrix[0]);
            scene.add(mergedMesh);
        }
    }

    function implementLOD(object) {
        if (!object.isMesh) return;

        const lod = new THREE.LOD();
        lod.addLevel(object, 0);

        const modifier = new THREE.SimplifyModifier();
        const mediumGeometry = object.geometry.clone();
        const mediumMesh = new THREE.Mesh(
            modifier.modify(mediumGeometry, Math.floor(mediumGeometry.attributes.position.count * 0.5)),
            object.material
        );
        lod.addLevel(mediumMesh, 50);

        const lowGeometry = object.geometry.clone();
        const lowMesh = new THREE.Mesh(
            modifier.modify(lowGeometry, Math.floor(lowGeometry.attributes.position.count * 0.1)),
            object.material
        );
        lod.addLevel(lowMesh, 100);

        object.parent.add(lod);
        object.parent.remove(object);
    }

    function createInstancedMesh(geometry, material, count) {
        const instancedMesh = new THREE.InstancedMesh(geometry, material, count);
        const dummy = new THREE.Object3D();

        for (let i = 0; i < count; i++) {
            dummy.position.set(
                (Math.random() - 0.5) * 100,
                (Math.random() - 0.5) * 100,
                (Math.random() - 0.5) * 100
            );
            dummy.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );
            dummy.updateMatrix();
            instancedMesh.setMatrixAt(i, dummy.matrix);
        }

        instancedMesh.instanceMatrix.needsUpdate = true;
        scene.add(instancedMesh);
    }

    // تطبيق التحسينات
    mergeGeometries();

    scene.traverse((object) => {
        if (object.isMesh) implementLOD(object);
    });

    // إضافة مشهد ضخم باستخدام InstancedMesh
    const geometry = new THREE.BoxGeometry(1, 1, 1);
    const material = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
    createInstancedMesh(geometry, material, 10000);
}


// Initialize everything
function initializeAll() {
    initializeUI();
    setupClipboardOperations();
    const objectPool = optimizeScene();
    
    // Store objectPool for later use
    window.objectPool = objectPool;
}

// Call initialization when the page loads
window.addEventListener('load', initializeAll);

// Context Menu
function setupContextMenu() {
    document.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        const contextMenu = document.getElementById('context-menu');
        contextMenu.style.display = 'block';
        contextMenu.style.left = e.pageX + 'px';
        contextMenu.style.top = e.pageY + 'px';
    });

    document.addEventListener('click', () => {
        document.getElementById('context-menu').style.display = 'none';
    });
}

// Initialize new features
function initializeAdvancedFeatures() {
    setupMaterialEditor();
    enableSnapping();
    setupContextMenu();
    initializeTextures();
}

// Call initialization
initializeAdvancedFeatures();
    </script>
    <script>

        // Camera Preview
        let activeCamera = null; 
        const expandButton = document.getElementById('expandPreview');
        const previewRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        const previewContainer = document.getElementById('cameraPreview');
        previewRenderer.setSize(previewContainer.clientWidth, previewContainer.clientHeight);
        previewRenderer.setPixelRatio(window.devicePixelRatio); // High DPI support
        previewContainer.appendChild(previewRenderer.domElement);
    
    
        function initializePanelControls() {
            const lightIntensityControl = document.getElementById('lightIntensity');
            const lightColorControl = document.getElementById('lightColor');

            // Update light properties when controls change
            function updateLightControls() {
                if (selectedObject && (selectedObject instanceof THREE.Light)) {
                    selectedObject.intensity = parseFloat(lightIntensityControl.value);
                    selectedObject.color.setStyle(lightColorControl.value);
                    if (selectedObject.helper) {
                        selectedObject.helper.update();
                    }
                }
            }

            lightIntensityControl.addEventListener('input', updateLightControls);
            lightColorControl.addEventListener('input', updateLightControls);

            function updatePreviewSize() {
              const rect = previewContainer.getBoundingClientRect();
               previewRenderer.setSize(rect.width, rect.height);
                if (activeCamera) {
                  activeCamera.aspect = rect.width / rect.height;
                  activeCamera.updateProjectionMatrix();
                }
            }

           // Toggle preview size
           document.getElementById('expandPreview').addEventListener('click', () => {
                previewContainer.classList.toggle('expanded');
                updatePreviewSize();
            });

           
            // Resize observer for dynamic adjustments
            new ResizeObserver(updatePreviewSize).observe(previewContainer);
            
       
           
            // Light controls initialization
            document.getElementById('addPointLight').addEventListener('click', () => {
                const light = new THREE.PointLight(0xffffff, 1);
                light.position.set(0, 5, 0);
                light.castShadow = true;
                
                // Create visual representation
                const sphereGeometry = new THREE.SphereGeometry(0.2);
                const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true });
                const visualMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
                light.add(visualMesh);
                
                // Add helper
                const helper = new THREE.PointLightHelper(light, 0.5);
                scene.add(helper);
                light.helper = helper;
                
                // Add to scene
                light.name = `PointLight_${objects.length}`;
                addObjectToScene(light, 'Point Light');
                document.querySelector('.controls-panel').appendChild(controls);
                light.controls = controls;
                updateHierarchy();
            });

            document.getElementById('addSpotLight').addEventListener('click', () => {
                const light = new THREE.SpotLight(0xffffff, 1);
                light.position.set(0, 5, 0);
                light.angle = Math.PI / 4;
                light.castShadow = true;
                
                // Create visual representation
                const coneGeometry = new THREE.ConeGeometry(0.2, 0.5);
                const coneMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true });
                const visualMesh = new THREE.Mesh(coneGeometry, coneMaterial);
                light.add(visualMesh);
                
                // Add helper
                const helper = new THREE.SpotLightHelper(light);
                scene.add(helper);
                light.helper = helper;
                
                // Add to scene
                light.name = `SpotLight_${objects.length}`;
                addObjectToScene(light, 'Spot Light');
                updateHierarchy();
            });

            document.getElementById('addAreaLight').addEventListener('click', () => {
                const light = new THREE.RectAreaLight(0xffffff, 1, 2, 2);
                light.position.set(0, 5, 0);
                
                // Create visual representation
                const planeGeometry = new THREE.PlaneGeometry(0.4, 0.4);
                const planeMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true });
                const visualMesh = new THREE.Mesh(planeGeometry, planeMaterial);
                light.add(visualMesh);
                
                // Add helper
                const helper = new THREE.RectAreaLightHelper(light);
                scene.add(helper);
                light.helper = helper;
                
                // Add to scene
                light.name = `AreaLight_${objects.length}`;
                addObjectToScene(light, 'Area Light');
                updateHierarchy();
            });

             document.getElementById('addSunLight').addEventListener('click', () => {
               const { sunSystem, updateDayNightCycle } = createSimpleSunLight();
               scene.add(sunSystem);

               // تحديث حلقة الأنيميشن
                function animate() {
                   updateDayNightCycle();
                   requestAnimationFrame(animate);
                }
                requestAnimationFrame(animate);

                // Add to scene management
                sunSystem.name = `SunSystem_${objects.length}`;
                addObjectToScene(sunSystem, 'Sun System');
                updateHierarchy();
            });

            document.getElementById('addDirectionalLight').addEventListener('click', () => {
                const light = new THREE.DirectionalLight(0xffffff, 1);
                light.position.set(0, 5, 0);
                light.castShadow = true;
                
                // Create visual representation
                const boxGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
                const boxMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true });
                const visualMesh = new THREE.Mesh(boxGeometry, boxMaterial);
                light.add(visualMesh);
                
                // Add helper
                const helper = new THREE.DirectionalLightHelper(light, 1);
                scene.add(helper);
                light.helper = helper;
                
                // Add to scene
                light.name = `DirectionalLight_${objects.length}`;
                addObjectToScene(light, 'Directional Light');
                updateHierarchy();
            });

            // New Light Types
            document.getElementById('addHemisphereLight').addEventListener('click', () => {
                const light = new THREE.HemisphereLight(0xffffbb, 0x080820, 1);
                light.position.set(0, 5, 0);
                
                // Create visual representation
                const sphereGeometry = new THREE.SphereGeometry(0.3);
                const sphereMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffffbb,
                    wireframe: true,
                    vertexColors: true
                });
                const visualMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
                light.add(visualMesh);
                
                // Add helper
                const helper = new THREE.HemisphereLightHelper(light, 1);
                scene.add(helper);
                light.helper = helper;
                
                light.name = `HemisphereLight_${objects.length}`;
                addObjectToScene(light, 'Hemisphere Light');
                updateHierarchy();
            });
        
            document.getElementById('addLensflareLight').addEventListener('click', () => {
                const light = new THREE.PointLight(0xffffff, 1.5, 2000);
                light.position.set(0, 10, 0);
                
                // Create lensflare effect
                const textureLoader = new THREE.TextureLoader();
                const textureFlare = textureLoader.load('path_to_lensflare_texture.png');
                
                const lensflare = new THREE.Lensflare();
                lensflare.addElement(new THREE.LensflareElement(textureFlare, 512, 0));
                light.add(lensflare);
                
                // Visual representation
                const sphereGeometry = new THREE.SphereGeometry(0.2);
                const sphereMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00,
                    wireframe: true
                });
                const visualMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
                light.add(visualMesh);
                
                light.name = `LensflareLight_${objects.length}`;
                addObjectToScene(light, 'Lensflare Light');
                updateHierarchy();
            });
        
            document.getElementById('addVolumetricLight').addEventListener('click', () => {
                const light = new THREE.SpotLight(0xffffff, 1);
                light.position.set(0, 5, 0);
                light.angle = Math.PI / 6;
                light.penumbra = 0.3;
                light.decay = 2;
                light.distance = 50;
                
                // Create volumetric effect
                const geometry = new THREE.CylinderGeometry(0, 2, 10, 32);
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        lightColor: { value: new THREE.Color(0xffffff) },
                        intensity: { value: 1.0 }
                    },
                    vertexShader: `
                        varying vec3 vNormal;
                        void main() {
                            vNormal = normalize(normalMatrix * normal);
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform vec3 lightColor;
                        uniform float intensity;
                        varying vec3 vNormal;
                        void main() {
                            float opacity = pow(1.0 - abs(dot(vNormal, vec3(0.0, 1.0, 0.0))), 2.0);
                            gl_FragColor = vec4(lightColor, opacity * intensity * 0.2);
                        }
                    `,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    side: THREE.DoubleSide
                });
                
                const volumetricCone = new THREE.Mesh(geometry, material);
                light.add(volumetricCone);
                
                // Add helper
                const helper = new THREE.SpotLightHelper(light);
                scene.add(helper);
                light.helper = helper;
                
                light.name = `VolumetricLight_${objects.length}`;
                addObjectToScene(light, 'Volumetric Light');
                updateHierarchy();
            });

            
            // Camera Management System
            document.getElementById('addCameraOrto').addEventListener('click', () => {
            const aspectRatio = window.innerWidth / window.innerHeight;
    const orthoCamera = new THREE.OrthographicCamera(
        -10 * aspectRatio, 10 * aspectRatio,
        10, -10,
        0.1, 100
    );

    orthoCamera.position.set(15, 10, 15);
    orthoCamera.lookAt(0, 0, 0);

    // Create main group that will contain both camera model and helper
    const mainGroup = new THREE.Group();

    // Camera model group
    const cameraGroup = new THREE.Group();

    const bodyGeometry = new THREE.BoxGeometry(1, 0.6, 0.8);
    const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xffbd54 });
    const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
    cameraGroup.add(bodyMesh);

    const lensGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.4, 16);
    const lensMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
    const lensMesh = new THREE.Mesh(lensGeometry, lensMaterial);
    lensMesh.rotation.z = Math.PI / 2;
    lensMesh.position.x = 0.7;
    cameraGroup.add(lensMesh);

    cameraGroup.scale.set(0.5, 0.5, 0.5);
    mainGroup.add(cameraGroup);

    // Improved pyramid helper
    const pyramidGeometry = new THREE.BufferGeometry();
    
    // Define pyramid dimensions
    const baseWidth = 8;    // Width of the base
    const baseHeight = 8;   // Height of the base
    const pyramidLength = 12; // Length of the pyramid

    const pyramidVertices = new Float32Array([
        // Pyramid tip (at camera position)
        0, 0, 0,

        // Base vertices (forming a rectangle)
        -baseWidth/2, -baseHeight/2, -pyramidLength,  // bottom left
        baseWidth/2, -baseHeight/2, -pyramidLength,   // bottom right
        baseWidth/2, baseHeight/2, -pyramidLength,    // top right
        -baseWidth/2, baseHeight/2, -pyramidLength,   // top left
    ]);

    // Define the indices for drawing lines
    const pyramidIndices = [
        // Lines from tip to base corners
        0, 1,  // tip to bottom left
        0, 2,  // tip to bottom right
        0, 3,  // tip to top right
        0, 4,  // tip to top left

        // Base rectangle
        1, 2,  // bottom edge
        2, 3,  // right edge
        3, 4,  // top edge
        4, 1   // left edge
    ];

    pyramidGeometry.setAttribute('position', new THREE.BufferAttribute(pyramidVertices, 3));
    pyramidGeometry.setIndex(pyramidIndices);

    const pyramidMaterial = new THREE.LineBasicMaterial({ 
        color: 0xffbd54,
        linewidth: 1
    });
    
    const pyramidHelper = new THREE.LineSegments(pyramidGeometry, pyramidMaterial);
    
    // Add guide lines for better visualization
    const guideGeometry = new THREE.BufferGeometry();
    const numGuides = 4;
    const guideVertices = [];
    const guideIndices = [];
    
    // Create vertical guide lines
    for (let i = 1; i < numGuides; i++) {
        const x = -baseWidth/2 + (baseWidth * i/numGuides);
        guideVertices.push(
            0, 0, 0,  // Start at tip
            x, -baseHeight/2, -pyramidLength  // End at base
        );
        guideIndices.push(guideVertices.length/3 - 2, guideVertices.length/3 - 1);
        
        guideVertices.push(
            0, 0, 0,  // Start at tip
            x, baseHeight/2, -pyramidLength  // End at base
        );
        guideIndices.push(guideVertices.length/3 - 2, guideVertices.length/3 - 1);
    }

    guideGeometry.setAttribute('position', new THREE.Float32BufferAttribute(guideVertices, 3));
    guideGeometry.setIndex(guideIndices);

    const guideMaterial = new THREE.LineBasicMaterial({ 
        color: 0xffbd54,
        opacity: 0.3,
        transparent: true
    });
    
    const guideLines = new THREE.LineSegments(guideGeometry, guideMaterial);
    pyramidHelper.add(guideLines);

    mainGroup.add(pyramidHelper);

    // Position and orient main group
    mainGroup.position.copy(orthoCamera.position);
    scene.add(mainGroup);

    function syncWithCamera() {
        mainGroup.position.copy(orthoCamera.position);
        
        const target = new THREE.Vector3(0, 0, 0);
        mainGroup.lookAt(target);
        mainGroup.rotateOnAxis(new THREE.Vector3(0, 1, 0), Math.PI);
    }

    const handleResize = () => {
        const newAspectRatio = window.innerWidth / window.innerHeight;
        orthoCamera.left = -10 * newAspectRatio;
        orthoCamera.right = 10 * newAspectRatio;
        orthoCamera.updateProjectionMatrix();
    };

    window.addEventListener('resize', handleResize);

    const gridHelper = new THREE.GridHelper(20, 20);
    scene.add(gridHelper);
    
    const axesHelper = new THREE.AxesHelper(10);
    scene.add(axesHelper);

    addObjectToScene(orthoCamera, 'Ortho_camera');
    updateHierarchy();
    setupCameraControls(orthoCamera);

    if (activeCamera) {
        transitionToCamera(orthoCamera);
    }

    activeCamera = orthoCamera;

    function animate() {
        requestAnimationFrame(animate);
        syncWithCamera();
    }
    animate();
});


// CubeCamera Implementation
document.getElementById('addCubeCamera').addEventListener('click', () => {
    //cube camera with 256x256 resolution for each face
    const cubeCamera = new THREE.PerspectiveCamera(90, window.innerWidth/window.innerHeight, 0.1, 100);
    cubeCamera.position.set(5, 2, 5);

    // Create main group
    const mainGroup = new THREE.Group();

    // Camera model
    const cameraGroup = new THREE.Group();

    // Create central cube for camera body
    const bodyGeometry = new THREE.BoxGeometry(1, 1, 1);
    const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x4287f5 });
    const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
    cameraGroup.add(bodyMesh);

    // Add small lenses on each face
    const lensPositions = [
        [0.5, 0, 0],  // right
        [-0.5, 0, 0], // left
        [0, 0.5, 0],  // top
        [0, -0.5, 0], // bottom
        [0, 0, 0.5],  // front
        [0, 0, -0.5]  // back
    ];

    lensPositions.forEach(pos => {
        const lensGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.2, 16);
        const lensMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
        const lensMesh = new THREE.Mesh(lensGeometry, lensMaterial);
        
        lensMesh.position.set(...pos);
        
        // Rotate lens based on position
        if (pos[0] !== 0) {
            lensMesh.rotation.z = Math.PI / 2;
        } else if (pos[1] !== 0) {
            lensMesh.rotation.x = Math.PI / 2;
        }
        
        cameraGroup.add(lensMesh);
    });

    cameraGroup.scale.set(0.5, 0.5, 0.5);
    mainGroup.add(cameraGroup);

    // Add helper box to show capture area
    const helperGeometry = new THREE.BoxGeometry(8, 8, 8);
    const helperMaterial = new THREE.LineBasicMaterial({ color: 0x4287f5 });
    const helperWireframe = new THREE.LineSegments(
        new THREE.WireframeGeometry(helperGeometry),
        helperMaterial
    );
    mainGroup.add(helperWireframe);

    mainGroup.position.copy(cubeCamera.position);
    scene.add(mainGroup);

    // Sync function
    function syncWithCamera() {
        mainGroup.position.copy(cubeCamera.position);
    }

    addObjectToScene(cubeCamera, 'Cube_camera');
    updateHierarchy();
    setupCameraControls(cubeCamera);

    if (activeCamera) {
        transitionToCamera(cubeCamera);
    }

    activeCamera = cubeCamera;
    // Animation loop
    function animate() {
        requestAnimationFrame(animate);
        syncWithCamera();
    }
    animate();
});

// StereoCamera Implementation
  document.getElementById('addStereoCamera').addEventListener('click', () => {
    //StereoCamera
    const stereoCamera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100);
     stereoCamera.position.set(5, 2, 5);
    
    // Position the camera
    stereoCamera.position = new THREE.Vector3(5, 2, 5);

    // Create main group
    const mainGroup = new THREE.Group();

    // Camera model group
    const cameraGroup = new THREE.Group();

    // Create base for stereo camera
    const baseGeometry = new THREE.BoxGeometry(2, 0.3, 0.5);
    const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
    const baseMesh = new THREE.Mesh(baseGeometry, baseMaterial);
    cameraGroup.add(baseMesh);

    // Add two camera lenses
    const lensGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.3, 16);
    const lensMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });

    // Left lens
    const leftLens = new THREE.Mesh(lensGeometry, lensMaterial);
    leftLens.position.set(-0.5, 0, 0.25);
    leftLens.rotation.x = Math.PI / 2;
    cameraGroup.add(leftLens);

    // Right lens
    const rightLens = new THREE.Mesh(lensGeometry, lensMaterial);
    rightLens.position.set(0.5, 0, 0.25);
    rightLens.rotation.x = Math.PI / 2;
    cameraGroup.add(rightLens);

    cameraGroup.scale.set(0.5, 0.5, 0.5);
    mainGroup.add(cameraGroup);

    // Add frustum helpers for both eyes
    const frustumSize = 4;
    
    // Helper for left eye
    const leftFrustum = createFrustumHelper(frustumSize, 0xff0000);
    leftFrustum.position.x = -stereoCamera.eyeSep / 2;
    mainGroup.add(leftFrustum);

    // Helper for right eye
    const rightFrustum = createFrustumHelper(frustumSize, 0x00ff00);
    rightFrustum.position.x = stereoCamera.eyeSep / 2;
    mainGroup.add(rightFrustum);

    mainGroup.position.set(5, 2, 5);
    mainGroup.lookAt(0, 0, 0);
    scene.add(mainGroup);

    function createFrustumHelper(size, color) {
        const geometry = new THREE.BufferGeometry();
        const vertices = new Float32Array([
            0, 0, 0,  // tip
            -size/2, -size/2, -size,  // base bottom-left
            size/2, -size/2, -size,   // base bottom-right
            size/2, size/2, -size,    // base top-right
            -size/2, size/2, -size    // base top-left
        ]);

        const indices = [
            0, 1, 0, 2, 0, 3, 0, 4,  // lines from tip to base
            1, 2, 2, 3, 3, 4, 4, 1   // base square
        ];

        geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
        geometry.setIndex(indices);

        return new THREE.LineSegments(
            geometry,
            new THREE.LineBasicMaterial({ color: color })
        );
    }

    function syncWithCamera() {
        mainGroup.position.copy(stereoCamera.position);
        mainGroup.lookAt(0, 0, 0);
    }


    addObjectToScene(stereoCamera, 'Stereo_camera');
    updateHierarchy();

    setupCameraControls(stereoCamera);

    if (activeCamera) {
        transitionToCamera(stereoCamera);
    }

    activeCamera = stereoCamera;
    // Animation loop
    function animate() {
        requestAnimationFrame(animate);
        syncWithCamera();
    }
    animate();
});

            document.getElementById('addCamera').addEventListener('click', () => {
            const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 5);
            camera.lookAt(0, 0, 0);
            
            const cameraGroup = new THREE.Group();
            
            // Main Camera Body
            const bodyGeometry = new THREE.BoxGeometry(0.6, 0.3, 0.5);
            const bodyMaterial = new THREE.MeshPhysicalMaterial({ 
                color: 0x2c3e50,
                metalness: 0.8,
                roughness: 0.2,
                clearcoat: 1,
                clearcoatRoughness: 0.1
            });
            const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
            cameraGroup.add(bodyMesh);
            
            // Camera Grip
            const gripGeometry = new THREE.CylinderGeometry(0.08, 0.06, 0.4, 8);
            const gripMaterial = new THREE.MeshPhysicalMaterial({ 
                color: 0x34495e,
                metalness: 0.6,
                roughness: 0.8,
                clearcoat: 0.5
            });
            const gripMesh = new THREE.Mesh(gripGeometry, gripMaterial);
            gripMesh.position.y = -0.2;
            cameraGroup.add(gripMesh);
            
            function animateLensFocus() {
            const maxExtension = 0.2;
            lensGroup.userData.focusing = true;
            
            const animate = () => {
                const time = performance.now() * 0.001;
                const extension = Math.sin(time) * maxExtension;
                
                lensElements.forEach((lens, index) => {
                    lens.position.z = lensPositions[index] + extension;
                });
                
                if (lensGroup.userData.focusing) {
                    requestAnimationFrame(animate);
                }
            };
            animate();
            }
            
            // Add focus trigger on right-click
            cameraGroup.userData.onRightClick = () => {
            if (!lensGroup.userData.focusing) {
            animateLensFocus();
            } else {
            lensGroup.userData.focusing = false;
            }
            };
            
            // Lens System
            const lensGroup = new THREE.Group();
            
            // Main Lens
            const lensElements = [];
            const lensPositions = [0.3, 0.4, 0.5];
            
            lensPositions.forEach((pos, index) => {
                const element = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.12 - (index * 0.01), 0.13 - (index * 0.01), 0.05, 32),
                    new THREE.MeshPhysicalMaterial({
                        color: 0x88ccff,
                        metalness: 0.1,
                        roughness: 0.1,
                        transmission: 0.9,
                        thickness: 0.02,
                        clearcoat: 1
                    })
                );
                element.rotation.x = Math.PI / 2;
                element.position.z = pos;
                lensElements.push(element);
                lensGroup.add(element);
            });
            
            // Lens Glass
            const lensGlassGeometry = new THREE.CircleGeometry(0.15, 32);
            const glassMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x88ccff,
                metalness: 0.9,
                roughness: 0.1,
                transmission: 0.9,
                thickness: 0.1,
                clearcoat: 1
            });
            
            
            
            // Lens Ring
            const ringGeometry = new THREE.TorusGeometry(0.15, 0.02, 16, 60);
            const ringMaterial = new THREE.MeshPhysicalMaterial({ 
                color: 0x444444,
                metalness: 0.8,
                roughness: 0.4,
                clearcoat: 1
            });
            const ringMesh = new THREE.Mesh(ringGeometry, ringMaterial);
            ringMesh.position.z = 0.45;
            lensGroup.add(ringMesh);
            
            cameraGroup.add(lensGroup);
            
            // Viewfinder
            const viewfinderGeometry = new THREE.BoxGeometry(0.3, 0.2, 0.2);
            const viewfinderMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x2c3e50,
                metalness: 0.8,
                roughness: 0.2,
                clearcoat: 1
            });
            const viewfinderMesh = new THREE.Mesh(viewfinderGeometry, viewfinderMaterial);
            viewfinderMesh.position.y = 0.25;
            cameraGroup.add(viewfinderMesh);
            
            // OLED Screen
            // Replace the existing screenMaterial definition with this
            const createLCDContent = () => {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 192;
            const ctx = canvas.getContext('2d');
            
            
            const updateLCD = () => {
                ctx.fillStyle = '#001122';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#00ff00';
                ctx.font = '24px monospace';
                ctx.fillText(`ISO: 100`, 10, 30);
                ctx.fillText(`f/2.8`, 10, 60);
                ctx.fillText(`1/125`, 10, 90);
                
                ctx.strokeStyle = '#00ff00';
                ctx.strokeRect(200, 10, 40, 20);
                ctx.fillRect(202, 12, 36 * 0.8, 16);
            };
            
            updateLCD();
            return new THREE.CanvasTexture(canvas);
            };
            
            const screenMaterial = new THREE.MeshBasicMaterial({
            map: createLCDContent(),
            emissive: 0x222222,
            emissiveIntensity: 0.5
            });
            
             // Control Dials
             const dialGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.02, 32, 1, false, 0, Math.PI * 2);
            const dialMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x95a5a6,
                metalness: 0.9,
                roughness: 0.3,
                clearcoat: 1
            });
            
            // Mode Dial
            const modeDial = new THREE.Mesh(dialGeometry, dialMaterial);
            modeDial.rotation.x = Math.PI / 2;
            modeDial.position.set(0.2, 0.15, 0);
            cameraGroup.add(modeDial);
            
            // Command Dial
            const commandDial = new THREE.Mesh(dialGeometry, dialMaterial);
            commandDial.rotation.x = Math.PI / 2;
            commandDial.position.set(-0.2, 0.15, 0);
            cameraGroup.add(commandDial);
            
            cameraGroup.scale.set(0.5, 0.5, 0.5);
            cameraGroup.position.set(0, 0, 0);
            camera.add(cameraGroup);
            
            
            // Hot Shoe
            const hotShoeGeometry = new THREE.BoxGeometry(0.2, 0.05, 0.2);
            const hotShoeMesh = new THREE.Mesh(hotShoeGeometry, gripMaterial);
            hotShoeMesh.position.y = 0.35;
            cameraGroup.add(hotShoeMesh);
            
            cameraGroup.scale.set(0.5, 0.5, 0.5);
            cameraGroup.position.set(0, 0, 0);
            camera.add(cameraGroup);
            
            // Enhanced Camera Helper with thicker lines
            const helper = new THREE.CameraHelper(camera);
            helper.material.linewidth = 3; // Increased line width
            helper.material.color.setHex(0xff6600); // Brighter orange color
            helper.visible = true;
            scene.add(helper);
            camera.helper = helper;
            
            
            // Add camera to the scene
            camera.name = `Camera_${objects.length}`;
            addObjectToScene(camera, 'camera');
            updateHierarchy();
            
            setupCameraControls(camera);
            
            if (activeCamera) {
                transitionToCamera(camera);
            }
            
            activeCamera = camera;
            
            
            // Add pop-up flash
            const flashGroup = new THREE.Group();
            const flashBase = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, 0.05, 0.1),
            new THREE.MeshPhysicalMaterial({ color: 0x2c3e50, metalness: 0.8 })
            );
            
            const flashHead = new THREE.Mesh(
            new THREE.BoxGeometry(0.2, 0.1, 0.05),
            new THREE.MeshPhysicalMaterial({ color: 0x2c3e50, metalness: 0.8 })
            );
            flashHead.position.y = 0.05;
            
            const flashBulb = new THREE.Mesh(
            new THREE.CylinderGeometry(0.03, 0.03, 0.02, 16),
            new THREE.MeshPhysicalMaterial({
            color: 0xffffff,
            emissive: 0xffffff,
            emissiveIntensity: 0
            })
            );
            flashBulb.rotation.x = Math.PI / 2;
            flashHead.add(flashBulb);
            
            flashGroup.add(flashBase, flashHead);
            flashGroup.position.set(0, 0.4, -0.1);
            cameraGroup.add(flashGroup);
            
            // Add strap lugs
            const strapLugGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.1, 8);
            const strapLugMaterial = new THREE.MeshPhysicalMaterial({
            color: 0x95a5a6,
            metalness: 0.9
            });
            
            [-0.3, 0.3].forEach(x => {
            const lug = new THREE.Mesh(strapLugGeometry, strapLugMaterial);
            lug.rotation.z = Math.PI / 2;
            lug.position.set(x, 0.1, 0);
            cameraGroup.add(lug);
            });
            
            // Add dial animations
            function animateDials() {
            modeDial.rotation.z += 0.02;
            commandDial.rotation.z -= 0.015;
            }
            
            cameraGroup.userData.controlsActive = false;
            cameraGroup.userData.onControlClick = () => {
            cameraGroup.userData.controlsActive = !cameraGroup.userData.controlsActive;
            };
            
            // Create DOF helper
            const createDOFVisualization = () => {
            const dofGroup = new THREE.Group();
            
            
            const focalPlane = new THREE.Mesh(
                new THREE.PlaneGeometry(2, 2),
                new THREE.MeshBasicMaterial({ 
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.2
                })
            );
            focalPlane.position.z = -5;
            
            dofGroup.add(focalPlane);
            scene.add(dofGroup);
            
            return dofGroup;
            };
            
            const dofHelper = createDOFVisualization();
            
            function animate() {
            requestAnimationFrame(animate);
            if (cameraGroup.userData.controlsActive) {
            animateDials();
            }
            }
            // Start animation
            animate();
            });
            
            
            
            function setupCameraControls(camera) {
            const fovInput = document.querySelector('#cameraFOV input');
            if (fovInput) {
            fovInput.value = camera.fov;
            fovInput.addEventListener('input', () => {
            camera.fov = parseFloat(fovInput.value);
            camera.updateProjectionMatrix();
            if (camera.helper) camera.helper.update();
            });
            }
            
            
            const nearInput = document.querySelector('#cameraNear input');
            const farInput = document.querySelector('#cameraFar input');
            
            if (nearInput) {
                nearInput.value = camera.near;
                nearInput.addEventListener('input', () => {
                    camera.near = parseFloat(nearInput.value);
                    camera.updateProjectionMatrix();
                    if (camera.helper) camera.helper.update();
                });
            }
            
            if (farInput) {
                farInput.value = camera.far;
                farInput.addEventListener('input', () => {
                    camera.far = parseFloat(farInput.value);
                    camera.updateProjectionMatrix();
                    if (camera.helper) camera.helper.update();
                });
            }
            }

            function transitionToCamera(targetCamera) {
const duration = 1.5;
const startPosition = activeCamera.position.clone();
const startRotation = activeCamera.rotation.clone();
const startQuaternion = activeCamera.quaternion.clone();

const endPosition = targetCamera.position.clone();
const endRotation = targetCamera.rotation.clone();
const endQuaternion = targetCamera.quaternion.clone();

let time = 0;
const easing = t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;

function animateTransition() {
    time += 0.016;
    const alpha = easing(Math.min(time / duration, 1));

    activeCamera.position.lerpVectors(startPosition, endPosition, alpha);
    THREE.Quaternion.slerp(startQuaternion, endQuaternion, activeCamera.quaternion, alpha);

    if (time < duration) {
        requestAnimationFrame(animateTransition);
    } else {
        activeCamera.position.copy(endPosition);
        activeCamera.rotation.copy(endRotation);
        if (activeCamera.helper) activeCamera.helper.update();
        if (activeCamera.projectionLine) {
            const positions = new Float32Array([
                activeCamera.position.x, activeCamera.position.y, activeCamera.position.z,
                0, 0, 0
            ]);
            activeCamera.projectionLine.geometry.setAttribute('position', 
                new THREE.BufferAttribute(positions, 3));
            activeCamera.projectionLine.geometry.attributes.position.needsUpdate = true;
        }
    }
}

animateTransition();
}
        }


       
        // Add this to your init() function or call it when the page loads
        window.addEventListener('load', initializePanelControls);
         document.querySelectorAll('.panel-header').forEach(header => {
            header.addEventListener('click', () => {
                const content = header.nextElementSibling;
                const button = header.querySelector('.expand-button');
                if (content.style.display === 'none') {
                    content.style.display = 'block';
                    button.textContent = '▼';
                } else {
                    content.style.display = 'none';
                    button.textContent = '▶';
                }
            });
        });

        // Toggle assets panel
       

        // Switch tabs
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
        });
    });



        // functions to update the UI
        function updateLightUI(light) {
            // Update light-specific controls in the UI
            const fovInput = document.querySelector('#cameraFOV input');
            if (fovInput) {
                fovInput.disabled = true;
            }

           
        }
        
        function updateCameraUI(camera) {
            // Update camera-specific controls in the UI
            const fovInput = document.querySelector('#cameraFOV input');
            if (fovInput) {
                fovInput.disabled = false;
                fovInput.value = camera.fov;
            }

           
        }
        
        // Call this in your init function
        function initializeLightAndCameraSystem() {
            setupLightControls();
    
            
            // Make renderer support shadows
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        }
        
        // Add this to your animation loop
        function updateHelpers() {
            objects.forEach(obj => {
                if (obj.helper) {
                    obj.helper.update();
                }
            });
        }

    </script>

<script src="js/proccessing.js"></script>
<script src="js/camera-path.js"></script>

</body>
</html>
