<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Advanced 3D Editor</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/remixicon/fonts/remixicon.css">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Outlined" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <!--Mirror librarys-->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/theme/monokai.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/hint/show-hint.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/fold/foldgutter.min.css">

     <!--Nanite-->
     <script src="https://threejs.org/examples/jsm/utils/BufferGeometryUtils.js"></script>
     <script src="https://threejs.org/examples/jsm/modifiers/SimplifyModifier.js"></script>
     <script src="https://unpkg.com/three@0.126.0/examples/js/modifiers/SubdivisionModifier.js"></script>
    
    <!--Coding librarys-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/javascript/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/xml/xml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/css/css.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/edit/closebrackets.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/edit/matchbrackets.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/hint/show-hint.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/hint/javascript-hint.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/fold/foldcode.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/fold/foldgutter.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/fold/brace-fold.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tern/0.24.3/tern.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/acorn/8.7.0/acorn.min.js"></script>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon-es/0.20.0/cannon-es.min.js"></script>
    <script src="https://unpkg.com/three@0.155.0/examples/js/renderers/WebGPURenderer.js"></script>

    <link href='https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css' rel='stylesheet'>
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/preview.css">
    <link rel="stylesheet" href="css/tools.css">
    <link rel="stylesheet" href="css/search.css">
    <link rel="stylesheet" href="css/gui.css">
    <link rel="stylesheet" href="css/assets-panel.css">
    <link rel="stylesheet" href="css/code-editor.css">
    <link rel="stylesheet" href="css/meuni-bar.css">
    <link rel="stylesheet" href="css/timeline.css">
    <link rel="stylesheet" href="css/stor.css">
    <link rel="stylesheet" href="css/sound-editor.css">
</head>
<body>
    
    <div class="editor-container">
       
        <div id="toggle-status" class="toolbar-group">
               
        </div>
        <!-- Top Toolbar -->
        <div class="sidebar"> 
                <button class="tool-btn" id="toggle-lock">
                   <i class="fas fa-unlock"></i>
                </button>
                <button class="tool-btn" id="toggle-selection" title="Toggle Selection Focus">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="3"></circle>
                        <path d="M8 12H5"></path>
                        <path d="M19 12h-3"></path>
                        <path d="M12 8V5"></path>
                        <path d="M12 19v-3"></path>
                        <!-- Small toggle arrows -->
                        <path d="M7 10l-2 -2l2 -2"></path>
                        <path d="M17 14l2 2l-2 2"></path>
                    </svg>
                </button>

               </button>
                <button class="tool-btn" id="guiControls">
                    Gui
                </button>
                <button  class="tool-btn" id="toggle-editor">
                    <i class="fa-solid fa-code-merge"></i>
                </button>
                <button class="tool-btn" id="preview-button">
                    <i class="fa-solid fa-gamepad"></i>
                </button>
                <button class="tool-btn" id="translate">
                    <i class="fas fa-arrows-alt"></i>
                </button>
                <button class="tool-btn" id="rotate">
                    <i class="fas fa-sync"></i>
                </button>
                <button class="tool-btn" id="scale">
                    <i class="fas fa-expand-arrows-alt"></i>
                </button>
                <button class="tool-btn" id="materialsEditor">
                    <i class="fas fa-fill-drip"></i> 
                </button>
                <button class="tool-btn" id="addSculptingSphere">
                    <i class="fas fa-paint-brush icon"></i>
                </button>
                <button class="tool-btn" id="snow-controls">
                    <i class="fas fa-snowflake"></i>
                </button>
                <button class="tool-btn" id="lightControls">
                    <i class="fas fa-sun"></i> 
                </button>
                <button class="tool-btn" id="cameraControls">
                   <i class="fas fa-video"></i> 
                </button>
                <button class="tool-btn" id="togglePreview">
                    <i class="fas fa-eye"></i>
                </button>
                <button class="tool-btn" id="physicsControls">
                    <i class="fas fa-atom"></i>
                </button>
                <button class="tool-btn" id="modelingControls">
                    <i class='bx bx-buildings'></i>
                </button>
                <button class="tool-btn" id="drawingControls">
                    <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24"><path fill="currentColor" d="M1.999 15V2h13v5h-2V4h-9v9h3v2zm6 5V8h12v5.5h-2V10h-8v8h3.5v2zm8.778 3.684L13.41 13.378l10.258 3.407l-4.656 2.227z"/></svg>
                </button>
                <button class="tool-btn" id="soundControls">
                    <i class='fa-solid fa-volume-high'></i>
                </button>
        </div>
    
        
        <div class="toolbar">
            <div class="logo">
              <svg class="logo__svg" viewBox="0 0 70 70" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                        <linearGradient id="logoGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" stop-color="var(--color-primary-dark)"/>
                            <stop offset="100%" stop-color="var(--color-accent)"/>
                        </linearGradient>
                        <linearGradient id="logoHighlight" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" stop-color="var(--color-primary)" />
                            <stop offset="100%" stop-color="var(--color-accent-dark)" />
                        </linearGradient>
                         <filter id="logoGlow" x="-50%" y="-50%" width="200%" height="200%">
                            <feGaussianBlur in="SourceAlpha" stdDeviation="2" result="blur"/>
                            <feOffset in="blur" dx="1" dy="1" result="offsetBlur"/>
                            <feSpecularLighting in="blur" surfaceScale="5" specularConstant=".75" specularExponent="20" lighting-color="#bbbbbb" result="specOut">
                                <fePointLight x="-5000" y="-10000" z="20000"/>
                            </feSpecularLighting>
                            <feComposite in="specOut" in2="SourceAlpha" operator="in" result="specOut"/>
                            <feComposite in="SourceGraphic" in2="specOut" operator="arithmetic" k1="0" k2="1" k3="1" k4="0" result="litPaint"/>
                            <feMerge>
                                <feMergeNode in="offsetBlur"/>
                                <feMergeNode in="litPaint"/>
                            </feMerge>
                        </filter>
                    </defs>
                    <g filter="url(#logoGlow)">
                         <!-- Abstract cube-like M -->
                        <path fill="url(#logoGradient)" 
                              d="M10 60 L10 15 L20 10 L35 10 L40 15 L40 30 L30 35 L30 55 L35 60 L10 60 Z 
                                 M40 15 L45 10 L60 10 L60 55 L55 60 L40 55 L40 15 Z" />
                        <path fill="url(#logoHighlight)" opacity="0.6"
                              d="M12 58 L12 17 L20 12 L35 12 L38 17 L38 30 L30 33 L30 53 L35 58 L12 58 Z 
                                 M42 17 L45 12 L58 12 L58 53 L55 58 L42 53 L42 17 Z" />
                    </g>
                </svg>
            </div>
            <div class="toolbar-group">
                <button class="tool-button" id="newScene">
                    <i class="fas fa-file"></i> New
                </button>
                <button class="tool-button" id="saveScene">
                    <i class="fas fa-save"></i> Save
                </button>
                <button class="tool-button" id="loadScene">
                    <i class="fas fa-folder-open"></i> Load
                </button>
                <button class="tool-button" onclick="toggleAssetsPanel()">
                    Assets
                </button>
                <button class="tool-button">Export</button>
                <button class="tool-button" id="toggle-inspector">Inspector</button>
            </div>
            <div class="toolbar-group">
                <button class="tool-button" id="menuButton" style="background-color: #555; margin: 8px auto; width: 25px; height: 25px;">
                    <i class="fas fa-bars"></i>
                </button>
                <div id="submenuMainBar" class="submenu-main-bar">
                    <div class="menu-item-br" data-submenu="fileMenu">File</div>
                    <div class="menu-item-br" data-submenu="editMenu">Edit</div>
                    <div class="menu-item-br" data-submenu="helpMenu">Help</div>
                </div>
        
                <!-- Child Submenus -->
                <div id="fileMenu" class="child-submenu">
                    <div>New</div>
                    <div>Open</div>
                    <div>Save</div>
                    <div>Export</div>
                </div>
        
                <div id="editMenu" class="child-submenu">
                    <div>Undo</div>
                    <div>Redo</div>
                    <div>Copy</div>
                    <div>Paste</div>
                </div>
        
                <div id="helpMenu" class="child-submenu">
                    <div>Documentation</div>
                    <div>About</div>
                    <div>Support</div>
                </div>

                <button id="toggleContainerButton" class="tool-button" style="background-color: #555;  cursor: pointer; margin: 8px auto; width: 25px; height: 25px;">
                    <svg id="toggle-status" style="justify-content: center; align-items: center; " xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 25 25">
                        <path id="icon-path" d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1-13h2v6h-2z" fill="#00bcd4"/>
                    </svg>
                </button>
            </div>
            <div id="toolbar-group-shapes" class="toolbar-group">
                <button class="tool-button" id="shapeButton">Shape</button>
                <div id="shapeMenu" class="menu">
                    <button class="tool-button" id="addCube">
                        <i class='bx bx-cube-alt'></i> Cube
                    </button>
                    <button class="tool-button" id="addPlane">
                        <i class="fas fa-square"></i>  Plane<!-- Icon for Plane -->
                    </button>
                    <button class="tool-button" id="addTerrain">
                        <i class="fas fa-border-all"></i>  Terrain <!-- Icon for Plane -->
                    </button>
                    <button class="tool-button" id="addSphere">
                        <i class="fas fa-circle"></i>  Sphere
                    </button>
                    <button class="tool-button" id="addCylinder">
                        <i class='bx bx-cylinder' style='color:#ffffff'></i>  Cylinder
                    </button>
                    <button class="tool-button" id="addRectangularPrism">
                        <i class='bx bx-cuboid'></i> Prism
                    </button>
                    <button class="tool-button" id="addPyramid">
                        <i class='bx bxs-pyramid'></i> Pyramid
                    </button>
                    <button class="tool-button" id="addTorus">
                        <i class="fas fa-ring"></i>  Torus
                    </button>
                </div>
            </div>
        
            <script>

document.addEventListener("DOMContentLoaded", function() {
    const menuButton = document.getElementById("menuButton");
    const submenuMainBar = document.getElementById("submenuMainBar");
    const menuItems = document.querySelectorAll(".menu-item-br");
    const childSubmenus = document.querySelectorAll(".child-submenu");

    // Toggle main menu
    menuButton.addEventListener("click", function(e) {
        submenuMainBar.classList.toggle("active");
        e.stopPropagation();
    });

    // Handle menu item hover
    menuItems.forEach(item => {
        item.addEventListener("mouseenter", function() {
            closeChildMenus();
            const submenuId = this.getAttribute("data-submenu");
            const targetSubmenu = document.getElementById(submenuId);
            if (targetSubmenu) {
                targetSubmenu.classList.add("active");

                // Position submenu relative to the parent
                let rect = this.getBoundingClientRect();
                targetSubmenu.style.top = `${rect.top}px`;
                targetSubmenu.style.left = `${rect.right + 5}px`;
            }
        });
    });

    // Close menus when clicking outside
    document.addEventListener("click", function(e) {
        if (!e.target.closest('.toolbar-group')) {
            submenuMainBar.classList.remove("active");
            closeChildMenus();
        }
    });

    // Close all child submenus
    function closeChildMenus() {
        childSubmenus.forEach(submenu => {
            submenu.classList.remove("active");
        });
    }

    // Prevent submenu from closing when clicking inside
    submenuMainBar.addEventListener("click", function(e) {
        e.stopPropagation();
    });
});
             


            document.addEventListener("DOMContentLoaded", function () {
                document.getElementById('shapeButton').addEventListener('click', function(event) {
                    event.stopPropagation();
                    var menu = document.getElementById('shapeMenu');
                    menu.classList.toggle('show');
                });

                var cameraButton = document.getElementById('cameraTools');
                var cameraMenu = document.getElementById('cameraMenu');

                if (cameraButton && cameraMenu) {
                    cameraButton.addEventListener('click', function(event) {
                       event.stopPropagation();
                       cameraMenu.classList.toggle('show');
                    });
                }


                document.addEventListener('click', function() {
                    var shapeMenu = document.getElementById('shapeMenu');
                    var cameraMenu = document.getElementById('cameraMenu');
                    var listMenu = document.getElementById('submenuMainBar');

                    if (shapeMenu.classList.contains('show')) {
                       shapeMenu.classList.remove('show');
                    }
                    if (cameraMenu && cameraMenu.classList.contains('show')) {
                       cameraMenu.classList.remove('show');
                    }
                });
            });


      


            </script>
            <div class="toolbar-group">
                <button class="tool-button" id="addLight">
                    <i class="fas fa-lightbulb"></i> Light
                </button>
                <button class="tool-button" id="addCameraInit">
                    <i class="fas fa-video"></i> Camera
                </button>
            </div>
            <div id="toolbar-group-camera" class="toolbar-group">
                <button class="tool-button" id="cameraTools">
                    <i class="fas fa-info-circle"></i> Camera
                </button>
                <div id="cameraMenu" class="menu">
                    <button class="tool-button" id="addPointBtn">
                        <i class="fa-solid fa-bezier-curve"></i> Add Point
                    </button>
                    <button class="tool-button" id="startCameraBtn">
                        <i class="fa-solid fa-person-walking-arrow-loop-left"></i> Start Camera
                    </button>
                    <button class="tool-button" id="toggleLookAtBtn">
                        <i class="fas fa-eye"></i> Toggle Look At
                    </button>
                    <button  class="tool-button" id="toggleEditBtn">Enable Edit
                    </button>
                    <button class="tool-button" id="startRecordingBtn">
                        <i class='bx bxs-video-recording'></i> Start Recording
                    </button>
                    <button class="tool-button" id="stopRecordingBtn">
                        <i class='bx bx-stop-circle'></i> Stop Recording
                    </button>
                </div>
            </div>
            <div class="toolbar-group">
                <div  class="tool-button-status" id="statusBar">
                    <span id="recordingStatus">
                        Reco: Stop
                    </span>
                    <span id="recordingTimer">00:00</span>
                </div>
            </div>
            <div class="toolbar-group">
                <button class="tool-button"  id="node-editor-toggle">Node</button>
            </div>

            <div class="toolbar-group" id="node-editor-button-grp">
                
            </div>

            <div class="toolbar-group">
                <button class="tool-button"  id="toggleAnimator">Animator</button>
            </div>
            <div class="toolbar-group">
                <button id="siteModalBtn" class="tool-button">Stor</button>
            </div>
        </div>

        <script>
          document.addEventListener("DOMContentLoaded", function () {
    const siteModal = document.getElementById("siteModal");
    const siteModalBtn = document.getElementById("siteModalBtn");
    const closeSiteModal = document.getElementById("closeSiteModal");
    const siteIframe = document.getElementById("siteIframe");

    // Check if elements exist
    if (!siteModal || !siteModalBtn || !closeSiteModal || !siteIframe) {
        console.error("One or more modal elements not found!");
        return;
    }

    // URL of the site to display in the iframe
    const siteURL = "https://medelbou3.github.io/SM-studio-stor/";

    // Open modal when clicking the "Stor" button
    siteModalBtn.addEventListener("click", function () {
        siteIframe.src = siteURL; // Load the site in the iframe
        siteModal.style.display = "flex"; // Show the modal
    });

    // Close modal when clicking the close button
    closeSiteModal.addEventListener("click", function () {
        siteModal.style.display = "none"; // Hide the modal
        siteIframe.src = ""; // Clear iframe
    });

    // Close modal when clicking outside the content
    siteModal.addEventListener("click", function (event) {
        if (event.target === siteModal) {
            siteModal.style.display = "none";
            siteIframe.src = "";
        }
    });

    // Close modal with Escape key
    document.addEventListener("keydown", function (event) {
        if (event.key === "Escape" && siteModal.style.display === "flex") {
            siteModal.style.display = "none";
            siteIframe.src = "";
        }
    });
});
        </script>

        <!-- Left Panel - Hierarchy -->
        <div id="hierarchy-panel"  class="hierarchy-panel">
            <div class="panel-header" style="cursor: pointer;">
                <i class="fas fa-sitemap" ></i> Hierarchy 
                <select id="hierarchyViewMode" style="margin-top: 5px; margin-left: 9px; width: 45%;">
                    <option value="tree">📁 Tree View</option>
                    <option value="flat">📋 Flat View</option>
                    <option value="type">🧠 Type View</option>
                </select>
                <span class="expand-button"  style="margin-left: 9px; margin-right: 20px;">▼</span>
            </div>
            <div class="hierarchy-search">
                <input type="text" id="hierarchy-search-input" placeholder="Search objects...">
                <button id="hierarchy-search-clear">×</button>
            </div>
            <div class="hierarchy-content" id="hierarchy-content">
                <!-- Hierarchy items will be added here dynamically -->
            </div>
            <div class="panel-header">
                <i class="fa-solid fa-paint-brush"></i> Brush Model Settings
                <span class="expand-button"  style="margin-left: 30px;">▼</span>
            </div>
            <div id="brush-panel" >
                <div class="brush-controls" >
                    <label>Brush Size</label>
                    <input type="range" id="brush-size" min="0.5" max="10" step="0.1" value="2">
                        
                    <label>Density</label>
                    <input type="range" id="brush-density" min="1" max="20" value="5">
                        
                    <label>Upload Model</label>
                    <input type="file" id="model-upload" accept=".glb,.gltf">
                    
                    <div class="brush-actions" style="margin: 10px auto;  display: flex;">
                        <button class="brush-button" onclick="brushSystem.undo()">Undo</button>
                        <button class="brush-button" onclick="brushSystem.redo()">Redo</button>
                    </div>
                </div>
            </div>
            <div class="resize-handle-hierarchy"></div>
        </div>

        <!-- Main Viewport -->
        <div class="viewport" id="viewportRenderer">
            <div id="renderer-container">
                <div id="render-container">
                    <div id="axis-controls" class="axis-controls">
                        <div class="axis-button" id="axis-x" onclick="setCameraView('x')">X</div>
                        <div class="axis-button" id="axis-y" onclick="setCameraView('y')">Y</div>
                        <div class="axis-button" id="axis-z" onclick="setCameraView('z')">Z</div>
                        <div class="axis-button" id="top" onclick="setCameraView('top')"><i class="fa-solid fa-arrow-up-long"></i></div>
                        <div class="axis-button" id="bottom" onclick="setCameraView('bottom')"><i class="fa-solid fa-arrow-down"></i></div>
                        <div class="axis-button" id="diagonal" onclick="setCameraView('diagonal')"><i class="fa-solid fa-square-arrow-up-right"></i></div>
                    </div> 
                    
                </div>
            </div>
        </div>
        <canvas id="selectionCanvas" style="
            position: absolute;
            top: 0;
            left: 0;
            z-index: 10;
            pointer-events: none;
        "></canvas>

        <!-- Right Panel - Inspector -->
        <div id="inspector-panel" class="inspector-panel">
            
            <div class="panel-header">
                <i class="fas fa-info-circle"></i> Inspector
            </div>

            <div class="search-group">
                <input type="text" id="search-input" class="search-input" placeholder="Search..." />
            </div>
        
            <div class="property-group1" id="GuiContainer" style="display: none;">
                <div id="gui-container">
                   <!--Gui Interface-->
                </div>
            </div>
            <div class="property-group">
                <h3>Transform</h3>
                <div class="property-row">
                    <span class="property-label">Pos</span>
                    <div class="vector-inputs">
                        <input type="number" class="property-input" id="posX" step="0.1">
                        <input type="number" class="property-input" id="posY" step="0.1">
                        <input type="number" class="property-input" id="posZ" step="0.1">
                    </div>
                </div>
                <div class="property-row">
                    <span class="property-label">Rot</span>
                    <div class="vector-inputs">
                        <input type="number" class="property-input" id="rotX" step="0.1">
                        <input type="number" class="property-input" id="rotY" step="0.1">
                        <input type="number" class="property-input" id="rotZ" step="0.1">
                    </div>
                </div>
                <div class="property-row">
                    <span class="property-label">Scl</span>
                    <div class="vector-inputs">
                        <input type="number" class="property-input" id="scaleX" step="0.1">
                        <input type="number" class="property-input" id="scaleY" step="0.1">
                        <input type="number" class="property-input" id="scaleZ" step="0.1">
                    </div>
                </div>
                <div class="precision-controls">
                    <!--The content will be add automaticly -->
                </div>
            </div>

          
          
            <div class="physics-controls" id="physics-controls" style="display: none;">
                <h3>Physics Forces</h3>
                <button class="panel-button" id="apply-physics">Apply Physics</button>
            
                <div class="control-group">
                    <div class="slider-container">
                        <label>Gravity:</label>
                        <input type="range" id="gravity-strength" min="-20" max="20" value="-9.81" step="0.1">
                        <span id="gravity-value">-9.81</span>
                    </div>
                </div>
            
                <!-- إضافة خصائص الفيزياء للكائنات -->
                <div class="control-group">
                    <h4>Object Physics Properties</h4>
                    <div class="slider-container">
                        <label>Mass:</label>
                        <input type="range" id="mass" min="0" max="20" value="5" step="0.1">
                        <span id="mass-value">5</span>
                    </div>
                    <div class="slider-container">
                        <label>Friction:</label>
                        <input type="range" id="friction" min="0" max="1" value="0.9" step="0.01">
                        <span id="friction-value">0.9</span>
                    </div>
                    <div class="slider-container">
                        <label>Restitution (Bounciness):</label>
                        <input type="range" id="restitution" min="0" max="1" value="0.7" step="0.01">
                        <span id="restitution-value">0.7</span>
                    </div>
                </div>
            
                <!-- إضافة إعدادات التصادم -->
                <div class="control-group">
                    <h4>Collision Settings</h4>
                    <label>Collision Group:</label>
                    <select id="collision-group">
                        <option value="1">Default (1)</option>
                        <option value="4" selected>Dynamic Objects (4)</option>
                        <option value="8">Kinematic (8)</option>
                        <option value="16">Wind Affected (16)</option>
                    </select>
            
                    <label>Collision Mask:</label>
                    <div>
                        <input type="checkbox" id="mask-default" value="1" checked> Default (1)<br>
                        <input type="checkbox" id="mask-terrain" value="2" checked> Terrain (2)<br>
                        <input type="checkbox" id="mask-dynamic" value="4" checked> Dynamic Objects (4)<br>
                        <input type="checkbox" id="mask-kinematic" value="8"> Kinematic (8)<br>
                        <input type="checkbox" id="mask-wind" value="16"> Wind Affected (16)
                    </div>
                </div>
            
                <div class="control-group">
                    <h4>Wind Zone</h4>
                    <div class="slider-container">
                        <label>Strength:</label>
                        <input type="range" id="wind-strength" min="0" max="50" value="10" step="0.1">
                        <span id="wind-value">10</span>
                    </div>
                    <div class="slider-container">
                        <label>Radius:</label>
                        <input type="range" id="wind-radius" min="1" max="50" value="10" step="0.5">
                        <span id="radius-value">10</span>
                    </div>
                </div>
                <div class="force-buttons">
                    <button class="force-button" id="add-wind">Add Wind Zone</button>
                    <button class="force-button" id="add-vortex">Add Vortex</button>
                </div>
            
                <div class="card">
                    <h2>Cloth Physics Controls</h2>
                    <div id="controls">
                        <button class="panel-button" id="addCloth">Add cloth</button>
                        <button class="panel-button" id="toggleWind">Change Wind</button>
                        <button class="panel-button" id="removeCloth">Remove cloth</button>
                    </div>
                </div>
            </div> 
            <style>
                .card { width: 100%; padding: 5px;  }
                .slider-container { margin-bottom: 15px; }
                .label { display: flex; justify-content: space-between; }
                .separator { border-top: 1px solid #ddd; margin: 15px 0; }
                .switch { cursor: pointer; }
            </style>
           


            <script>
                document.getElementById('apply-physics').addEventListener('click', () => {
    // قراءة القيم من المدخلات
    const mass = parseFloat(document.getElementById('mass').value);
    const friction = parseFloat(document.getElementById('friction').value);
    const restitution = parseFloat(document.getElementById('restitution').value);
    const collisionGroup = parseInt(document.getElementById('collision-group').value);

    // حساب Collision Mask باستخدام الـ checkboxes
    let collisionMask = 0;
    if (document.getElementById('mask-default').checked) collisionMask |= physicsManager.collisionGroups.DEFAULT;
    if (document.getElementById('mask-terrain').checked) collisionMask |= physicsManager.collisionGroups.TERRAIN;
    if (document.getElementById('mask-dynamic').checked) collisionMask |= physicsManager.collisionGroups.DYNAMIC_OBJECTS;
    if (document.getElementById('mask-kinematic').checked) collisionMask |= physicsManager.collisionGroups.KINEMATIC;
    if (document.getElementById('mask-wind').checked) collisionMask |= physicsManager.collisionGroups.WIND_AFFECTED;

    // تطبيق الفيزياء على الكائن المختار
    if (selectedObject && !selectedObject.userData.physicsBody) {
        physicsManager.addPhysicsToObject(selectedObject, {
            mass: mass,
            friction: friction,
            restitution: restitution,
            group: collisionGroup,
            mask: collisionMask
        });
        console.log("Physics applied to", selectedObject.name, "with values:", {
            mass, friction, restitution, collisionGroup, collisionMask
        });
    } else if (selectedObject && selectedObject.userData.physicsBody) {
        console.warn("Physics already applied to", selectedObject.name);
    } else {
        console.warn("No object selected.");
    }

    // تطبيق أو تحديث الفيزياء للتضاريس
    if (terrain) {
        applyPhysicsToTerrain();
        console.log("Physics applied/updated for terrain");
    } else {
        console.warn("No terrain found in the scene.");
    }
});

function applyPhysicsToTerrain() {
    const width = 50;
    const height = 50;
    const widthSegments = 100;
    const heightSegments = 100;

    if (terrain.userData.physicsBody) {
        world.removeBody(terrain.userData.physicsBody);
    }

    const vertices = terrain.geometry.attributes.position.array;
    const matrix = [];

    for (let z = 0; z <= heightSegments; z++) {
        const row = [];
        for (let x = 0; x <= widthSegments; x++) {
            const index = (z * (widthSegments + 1) + x) * 3 + 1;
            row.push(vertices[index]);
        }
        matrix.push(row);
    }

    const heightfieldShape = new CANNON.Heightfield(matrix, {
        elementSize: width / widthSegments
    });

    const heightfieldBody = new CANNON.Body({
        mass: 0, // ثابت (static)
        shape: heightfieldShape,
        material: physicsManager.materials.default,
        collisionFilterGroup: physicsManager.collisionGroups.TERRAIN,
        collisionFilterMask: physicsManager.collisionGroups.DEFAULT | physicsManager.collisionGroups.DYNAMIC_OBJECTS
    });

    heightfieldBody.position.set(-width / 2, 0, height / 2);
    heightfieldBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);

    world.addBody(heightfieldBody);
    terrain.userData.physicsBody = heightfieldBody;
}

                document.addEventListener('DOMContentLoaded', () => {
                    // تحديث قيم العرض لـ Mass
                    const massInput = document.getElementById('mass');
                    const massValue = document.getElementById('mass-value');
                    massInput.addEventListener('input', () => {
                      massValue.textContent = massInput.value;
                    });

                    // تحديث قيم العرض لـ Friction
                    const frictionInput = document.getElementById('friction');
                    const frictionValue = document.getElementById('friction-value');
                    frictionInput.addEventListener('input', () => {
                        frictionValue.textContent = frictionInput.value;
                    });
       
                    // تحديث قيم العرض لـ Restitution
                    const restitutionInput = document.getElementById('restitution');
                    const restitutionValue = document.getElementById('restitution-value');
                    restitutionInput.addEventListener('input', () => {
                        restitutionValue.textContent = restitutionInput.value;
                    });

                    // Gravity listener (موجود بالفعل، لكن نضمن تحديث العرض)
                    const gravityInput = document.getElementById('gravity-strength');
                    const gravityValue = document.getElementById('gravity-value');
                    gravityInput.addEventListener('input', (e) => {
                        const value = parseFloat(e.target.value);
                        world.gravity.set(0, value, 0);
                        gravityValue.textContent = value.toFixed(2);
                    });
                });

                
                function applyPhysicsToSelectedObject(object) {
                    const shape = getCannonShapeFromObject(object);
                    if (!shape) {
                        console.error("Unable to determine physics shape for object.");
                        return;
                    }

                    const body = new CANNON.Body({
                        mass: 5, // Set mass to make it fall
                        shape: shape,
                        position: new CANNON.Vec3(object.position.x, object.position.y, object.position.z),
                        quaternion: new CANNON.Quaternion(object.quaternion.x, object.quaternion.y, object.quaternion.z, object.quaternion.w),
                    });
               
                    world.addBody(body);
                    object.userData.physicsBody = body;
                }

                // Function to determine the appropriate CANNON.js shape
                function getCannonShapeFromObject(object) {
                    if (object.geometry instanceof THREE.BoxGeometry) {
                        const size = new THREE.Vector3();
                        object.geometry.computeBoundingBox();
                        object.geometry.boundingBox.getSize(size);
                        return new CANNON.Box(new CANNON.Vec3(size.x / 2, size.y / 2, size.z / 2));
                    }
                    if (object.geometry instanceof THREE.SphereGeometry) {
                      return new CANNON.Sphere(object.geometry.parameters.radius);
                    }
                    return null;
                }

            </script>
            <div class="viewport-container" style="display: none;">                
                <div class="model-preview-container">
                <canvas id="preview-canvas"></canvas>
                <div class="model-info">
                <span class="model-name"></span>
                <div class="model-stats"></div>
            </div>

            </div>
           </div>

           <div class="sound-controls-meter" id="sound-controls-meter" style="display: none;">
            <div class="meter-section">
                <div class="meter-group">
                    <h3 class="meter-title">Input Meters</h3>
                    <div class="meter-container">
                        <div class="meter-fill" id="leftMeter"></div>
                    </div>
                    <div class="meter-container">
                        <div class="meter-fill" id="rightMeter"></div>
                    </div>
                </div>
            
                <div class="meter-group">
                    <h3 class="meter-title">Master Output</h3>
                    <div class="meter-container">
                        <div class="meter-fill" id="masterMeter"></div>
                    </div>
                </div>
            </div>
            
        </div>

        <div class="sound-controls-header-vis"  id="sound-controls-vis"  style="display: none;">
            <main class="main-content-sound">
                <div class="visualization-container">
                    <div class="viz-panel">
                        <div class="viz-header">Spectrum Analyzer</div>
                        <canvas id="spectrumCanvas"></canvas>
                    </div>
                    <div class="viz-panel">
                        <div class="viz-header">Waveform & Vectorscope</div>
                        <canvas id="waveformCanvas"></canvas>
                    </div>
                    <div class="viz-panel">
                        <div class="viz-header">Phase Correlation</div>
                        <canvas id="phaseCanvas"></canvas>
                    </div>
                </div>
    
                <div class="effect-rack">
                    <div class="effect-module">
                        <div class="effect-header">
                            <span class="effect-title">Parametric EQ</span>
                            <button class="btn" id="eqToggle">On</button>
                        </div>
                        <canvas id="eqCanvas" height=" 180"></canvas>
                        <div class="eq-controls" style="display: flex; flex-wrap: wrap; gap: 15px;"></div>
                    </div>
    
                    <div class="effect-module">
                        <div class="effect-header">
                            <span class="effect-title">Dynamics Processor</span>
                            <button class="btn" id="dynToggle">On</button>
                        </div>
                        <canvas id="dynamicsCanvas" height=" 180"></canvas>
                        <div class="dynamics-controls"></div>
                    </div>
    
                    <div class="effect-module">
                        <div class="effect-header">
                            <span class="effect-title">Reverb</span>
                            <button class="btn" id="reverbToggle">On</button>
                        </div>
                        <div class="reverb-controls"></div>
                    </div>
                </div>
            </main>
           </div>

           

            
        <div class="modeling-tools" id="modelingTools" style="display: none;">
            <div class="panel-header">
                <span>Mesh Manipulation Tools</span>
                <span class="expand-button">▼</span>
            </div>
            <div class="panel-content">
               
                
                <div class="selection-controls">
                    <button id="toggle-modeling" class="panel-button">Modeling Mode</button>
                    <div class="button-container">
                        <button id="select-vertex" class="panel-button-tool" disabled>
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <path d="M4 6L12 4L20 6L20 14L12 16L4 14L4 6Z" fill="none" stroke="currentColor" stroke-width="2"/>
                                <path d="M4 6L12 8L20 6" fill="none" stroke="currentColor" stroke-width="2"/>
                                <path d="M12 8L12 16" fill="none" stroke="currentColor" stroke-width="2"/>
                                <circle cx="12" cy="8" r="1" fill="red"/>
                            </svg>
                        </button>
                    
                        <button id="select-edge" class="panel-button-tool" disabled>
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <path d="M4 6L12 4L20 6L20 14L12 16L4 14L4 6Z" fill="none" stroke="currentColor" stroke-width="2"/>
                                <path d="M4 6L12 8L20 6" fill="none" stroke="currentColor" stroke-width="2"/>
                                <path d="M12 8L12 16" fill="none" stroke="currentColor" stroke-width="2"/>
                                <line x1="4" y1="6" x2="12" y2="8" stroke="blue" stroke-width="2"/>
                                <line x1="12" y1="8" x2="20" y2="6" stroke="blue" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <button id="select-face" class="panel-button-tool" disabled>
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <path d="M4 6L12 4L20 6L20 14L12 16L4 14L4 6Z" fill="none" stroke="currentColor" stroke-width="2"/>
                                <path d="M4 6L12 8L20 6" fill="none" stroke="currentColor" stroke-width="2"/>
                                <path d="M12 8L12 16" fill="none" stroke="currentColor" stroke-width="2"/>
                                <rect x="8" y="10" width="6" height="6" fill="green"/>
                            </svg>
                        </button>
                    </div>
                    <div id="controls">
                        <h3>Building</h3>
                        <label class="control-label">Width : <input type="number" id="building-width" value="5"></label>
                        <label class="control-label"> Height : <input type="number" id="building-height" value="10"></label>
                        <label class="control-label">Depth : <input type="number" id="building-depth" value="5"></label>
                    </div>
                </div>

                <div>
                    <label>Vertex Size:</label>
                    <input type="range" id="vertexSizeSlider" min="0.1" max="2" step="0.1" value="0.5">
                </div>
                <div>
                    <label>Edge Thickness:</label>
                    <input type="range" id="edgeThicknessSlider" min="1" max="5" step="1" value="2">
                </div>
                <div>
                    <label>Subdivision Levels:</label>
                    <input type="range" id="subdivisionLevelsSlider" min="0" max="4" step="1" value="1">
                </div>
                <div>
                    <label>Face Opacity:</label>
                    <input type="range" id="faceOpacitySlider" min="0" max="1" step="0.1" value="0.5">
                </div>

                <div class="tool-separator"></div>

                <div class="tool-section">
                    <h4>Operations</h4>
                    <div class="button-container">
                         <button id="tool-extrude" class="panel-button-tool" title="Extrude Selection (E)" disabled>
                              <svg> <!-- Placeholder SVG for Extrude -->
                                  <rect x="4" y="4" width="16" height="8" stroke="currentColor" fill="none"/>
                                  <rect x="6" y="14" width="12" height="6" stroke="currentColor" fill="lightblue"/>
                                   <line x1="4" y1="12" x2="6" y2="14" stroke="currentColor"/>
                                   <line x1="20" y1="12" x2="18" y2="14" stroke="currentColor"/>
                              </svg>
                              
                          </button>
                
                           <button id="tool-bevel" class="panel-button-tool" title="Bevel Edges/Vertices (Ctrl+B)" disabled>
                               <svg> <!-- Placeholder SVG for Bevel -->
                                  <polygon points="4,4 20,4 20,20 4,20" stroke="currentColor" fill="none"/>
                                  <polygon points="6,6 18,6 18,18 6,18" stroke="lightblue" fill="none" stroke-width="2"/>
                               </svg>
                           </button>
                
                            <button id="tool-loopcut" class="panel-button-tool" title="Insert Edge Loop (Ctrl+R)" disabled>
                                <svg> <!-- Placeholder SVG for Loop Cut -->
                                   <rect x="4" y="4" width="16" height="16" stroke="currentColor" fill="none"/>
                                   <line x1="4" y1="12" x2="20" y2="12" stroke="lightblue" stroke-width="2"/>
                                   <line x1="12" y1="4" x2="12" y2="20" stroke="lightgray" stroke-dasharray="4"/>
                                </svg>
                            </button>
                            <button id="tool-inset" class="panel-button-tool poly-tool" title="Inset Faces (I)" disabled>
                                <svg viewBox="0 0 24 24" width="24" height="24"><path fill="none" stroke="currentColor" stroke-width="1.5" d="M4 4h16v16H4z M8 8h8v8H8z"/></svg>
                            
                            </button>
                            <!-- Add Bridge button (placeholder) -->
                            <button id="tool-bridge" class="panel-button-tool poly-tool" title="Bridge Edge Loops" disabled>
                                <svg viewBox="0 0 24 24" width="24" height="24"><path fill="none" stroke="currentColor" stroke-width="1.5" d="M5 5h3v14H5z M16 5h3v14h-3z M8 6h8 M8 18h8"/></svg>
            
                            </button>
                             <!-- Add more tool buttons here -->
                    </div>
                </div>

                <div class="tool-separator"></div>

                <!-- 3. PRECISION / SNAPPING -->
                <div class="tool-section">
                    <h4>Snapping</h4>
                    <div class="snapping-controls button-container">
                         <button id="toggle-snapping" class="panel-button" title="Toggle Snapping (Shift+Tab)" style="min-width:80px;">Snap OFF</button>
                         <select id="snap-type-select" class="panel-select" disabled>
                             <option value="grid">Grid</option>
                             <option value="vertex">Vertex</option>
                             <option value="edge">Edge</option>
                             <option value="face">Face</option>
                         </select>
                         <label style="margin-left: 5px;">Grid: <input type="number" id="grid-snap-size" value="0.5" step="0.1" style="width: 45px;" disabled></label>
                    </div>
               </div>
        
               <div class="tool-separator"></div>
        
              <!-- 4. ARCHITECTURE TOOLS (Can keep or merge if desired) -->
              <div class="tool-section">
                  <h4>Architecture</h4>
                   <div class="button-container">
                       <button id="tool-wall" class="panel-button-tool arch-tool" ...>
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                 <rect x="4" y="4" width="16" height="16" stroke="currentColor" fill="none"/>
                                 <line x1="4" y1="12" x2="20" y2="12" stroke="lightblue"/>
                                 <line x1="12" y1="4" x2="12" y2="20" stroke="lightgray"/>
                            </svg>
                       </button>
                       <button id="tool-place-door" class="panel-button-tool arch-tool" ...>
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                 <rect x="4" y="4" width="16" height="16" stroke="currentColor" fill="none"/>
                                 <line x1="4" y1="12" x2="20" y2="12" stroke="lightblue"/>
                                 <line x1="12" y1="4" x2="12" y2="20" stroke="lightgray"/>
                                 <rect x="10" y="4" width="4" height="8" fill="#ccc"/>
                            </svg>
                       </button>
                       <button id="tool-place-window" class="panel-button-tool arch-tool" ...>
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                 <rect x="4" y="4" width="16" height="16" stroke="currentColor" fill="none"/>
                                 <line x1="4" y1="12" x2="20" y2="12" stroke="lightblue"/>
                                 <line x1="12" y1="4" x2="12" y2="20" stroke="lightgray"/>
                                 <rect x="10" y="4" width="4" height="8" fill="#ccc"/>
                            </svg>
                       </button>
                       <button id="tool-stairs" class="panel-button-tool arch-tool" ...>
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                 <rect x="4" y="4" width="16" height="16" stroke="currentColor" fill="none"/>
                                 <line x1="4" y1="12" x2="20" y2="12" stroke="lightblue"/>
                                 <line x1="12" y1="4" x2="12" y2="20" stroke="lightgray"/>
                                 <path d="M10 14 L10 20 L14 20 L14 14 Z" fill="#ccc"/>
                            </svg>
                       </button>
                       <button id="tool-measure" class="panel-button-tool arch-tool" ...>
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                 <line x1="4" y1="12" x2="20" y2="12" stroke="currentColor"/>
                                 <line x1="12" y1="4" x2="12" y2="20" stroke="currentColor"/>
                                 <text x="10" y="10" fill="#000">M</text>
                            </svg>
                       </button>
                  </div>
                    <div id="arch-selection-tools" class="panel">
                        <h4>Architecture Selection</h4>
                        <button class="panel-button" id="select-all-walls">Select All Walls</button>
                        <button class="panel-button" id="select-all-doors">Select All Doors</button>
                        <button class="panel-button" id="select-all-windows">Select All Windows</button>
                        <button class="panel-button" id="select-all-arch">Select All Arch</button>
                        <button class="panel-button" id="delete-selected-arch" disabled>Delete Selected Arch</button>
                    </div>
                    <div class="tool-options" id="wall-options" style="display: none;">
                        <h4>Wall Options</h4>
                        <label for="wallHeightInput">Height:</label>
                        <input type="number" id="wallHeightInput" class="panel-input" value="2.5" step="0.1"><br>
                        <label for="wallThicknessInput">Thickness:</label>
                        <input type="number" id="wallThicknessInput" class="panel-input" value="0.2" step="0.05">
                    </div>
                 
                   <div class="tool-options" id="door-options" style="display: none;">
                        <h4>Door Options</h4>
                        <label for="doorWidthInput">Width:</label>
                        <input type="number" id="doorWidthInput" class="panel-input" value="0.9" step="0.1"><br>
                        <label for="doorHeightInput">Height:</label>
                        <input type="number" id="doorHeightInput" class="panel-input" value="2.1" step="0.1"><br>
                        <label for="doorDepthInput">Depth (Thickness):</label>
                        <input type="number" id="doorDepthInput" class="panel-input" value="0.1" step="0.05">
                   </div>
                   <div class="tool-options" id="window-options" style="display: none;">
                        <h4>Window Options</h4>
                        <label for="windowWidthInput">Width:</label>
                        <input type="number" id="windowWidthInput" class="panel-input" value="1.2" step="0.1"><br>
                        <label for="windowHeightInput">Height:</label>
                        <input type="number" id="windowHeightInput" class="panel-input" value="1.0" step="0.1"><br>
                        <label for="windowDepthInput">Depth (Thickness):</label>
                        <input type="number" id="windowDepthInput" class="panel-input" value="0.1" step="0.05">
                    </div>
                    <div class="tool-options" id="stairs-options" style="display: none;">
                        <h4>Stair Options</h4>
                        <label for="stairWidthInput">Width:</label>
                        <input type="number" id="stairWidthInput" class="panel-input" value="1.0" step="0.1"><br>
                        <label for="stairTotalHeightInput">Total Height:</label>
                        <input type="number" id="stairTotalHeightInput" class="panel-input" value="2.5" step="0.1"><br>
                        <label for="stairStepHeightInput">Step Height:</label>
                        <input type="number" id="stairStepHeightInput" class="panel-input" value="0.18" step="0.01"><br>
                        <label for="stairStepDepthInput">Step Depth:</label>
                        <input type="number" id="stairStepDepthInput" class="panel-input" value="0.25" step="0.01">
                    </div>
              </div>
        
        
               <div class="tool-separator"></div>
        
               <!-- 5. SPLINE TOOLS -->
               <div class="tool-section">
                    <h4>Splines</h4>
                    <div class="spline-controls button-container">
                        <button id="spline-draw-profile" class="panel-button spline-tool" title="Draw 2D Profile Shape" disabled>Draw Profile</button>
                        <button id="spline-draw-path" class="panel-button spline-tool" title="Draw 3D Path Curve" disabled>Draw Path</button>
                        <!-- TODO: Need UI to SELECT active profile/path -->
                        <select id="active-profile-select" class="panel-select" disabled><option value="">--Select Profile--</option></select>
                        <select id="active-path-select" class="panel-select" disabled><option value="">--Select Path--</option></select>
                         <button id="spline-extrude" class="panel-button spline-tool" title="Extrude Profile along Path" disabled>Extrude</button>
                         <!-- Add Loft, Revolve etc. buttons -->
                     </div>
                </div>
        
                <div class="tool-separator"></div>
        
              <!-- 6. MODIFIER STACK -->
               <div class="tool-section" id="modifiers-panel" style="display: none;"> <!-- Hide initially, show when an object is selected -->
                   <h4>Modifiers</h4>
                   <div id="modifier-list-container">
                       <!-- Modifiers will be added here dynamically -->
                       <!-- Example Modifier Entry Structure (generated by JS): -->
                       
                       <div class="modifier-entry" data-modifier-index="0">
                            <input type="checkbox" class="mod-active" checked>
                            <span class="mod-name">Solidify</span>
                            <span class="mod-expand">▼</span>
                            <button class="mod-remove">X</button>
                            <div class="mod-settings" style="display: none;">
                                 <label>Thickness: <input type="number" class="mod-param" data-param="thickness" value="0.1"></label>
                                 ... other params
                            </div>
                       </div>
                       
                    </div>
                   <div class="add-modifier-controls">
                       <select id="add-modifier-select" class="panel-select">
                           <option value="">-- Add Modifier --</option>
                           <option value="solidify">Solidify</option>
                           <option value="array">Array</option>
                            <option value="bevel">Bevel</option>
                           <option value="subdivision">Subdivision</option>
                           <!-- <option value="mirror">Mirror</option> -->
                            <!-- <option value="boolean">Boolean</option> -->
                           <!-- Add more when implemented -->
                       </select>
                       <button id="add-modifier-button" class="panel-button">+</button>
                   </div>
                   <div>
                        <button id="apply-modifiers-button" class="panel-button" title="Bake modifiers into base mesh">Apply All</button>
                    </div>
               </div>
        
        
               <div class="tool-separator"></div>
        
                <!-- Your original 'Building' section if needed -->
                <div id="building-controls-placeholder" style="display: none;"> <!-- Example placeholder -->
                    <h3>Building</h3>
                     <label>Width : <input type="number" id="building-width" value="5"></label>
                    <label>Height : <input type="number" id="building-height" value="10"></label>
                    <label>Depth : <input type="number" id="building-depth" value="5"></label>
                </div>
         
            </div>
        </div>

            <style>
                .modeling-tools .tool-section { margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #555;}
                .modeling-tools .button-container { display: flex; flex-wrap: wrap; gap: 5px; margin-top: 5px;}
                .panel-button-tool svg { display: block; margin-bottom: 2px; } /* Adjust icon layout */
                .tool-separator { height: 1px; background-color: #444; margin: 10px 0; }
                .active-tool { background-color: #57a !important; color: white; } /* Highlight active tool */
                .tool-options { background-color: #404040; padding: 8px; margin-top: 8px; border-radius: 4px; }
                .panel-select { background-color: #555; color: white; border: 1px solid #777; padding: 3px; border-radius: 3px;}
                /* Modifier List Styling */
                #modifier-list-container { max-height: 200px; overflow-y: auto; margin-bottom: 10px; background: #3a3a3a; padding: 5px; border-radius: 3px;}
                .modifier-entry { display: flex; align-items: center; background: #484848; padding: 4px; margin-bottom: 3px; border-radius: 3px; flex-wrap: wrap; }
                .modifier-entry > span { margin: 0 5px; cursor: default; }
                .modifier-entry .mod-name { font-weight: bold; flex-grow: 1; }
                .modifier-entry .mod-expand, .modifier-entry .mod-remove { cursor: pointer; padding: 0 5px; background: #555; border: none; color: white; border-radius: 3px; margin-left: 5px;}
                .modifier-entry .mod-remove { background: #a55; }
                .mod-settings { width: 100%; background: #404040; padding: 8px; margin-top: 5px; border-radius: 3px; border-top: 1px solid #555;}
                .mod-settings label { display: block; margin-bottom: 4px; }
                .mod-settings input[type=number] { width: 60px; }
            </style>


            <div class="panel" id="lights" style="display: none;">
                <div class="panel-header">
                    <span>Lights</span>
                    <span class="expand-button">▼</span>
                </div>
                <div class="panel-content">
                    <button id="addPointLight" class="panel-button">
                        <img src="piontlight.png" alt="">
                    </button>
                    <button id="addSunLight" class="panel-button">
                        <img src="sun.png" alt="">
                    </button>
                    <button id="addSpotLight" class="panel-button">
                        <img src="headlight.png">
                    </button>
                    <button id="addAreaLight" class="panel-button">
                        <img src="arealight.png" alt="">
                    </button>
                    <button id="addDirectionalLight" class="panel-button">
                        <img src="directional-light.png" alt="">
                    </button>
                    <button id="addHemisphereLight" class="panel-button">
                        <img src="HemisphereLight.png" alt="">
                    </button>
                    <button id="addLensflareLight" class="panel-button">
                        <img src="Lensflare.png" alt="">
                    </button>
                    <button id="addVolumetricLight" class="panel-button">
                        <img src="volumitriclight.png" alt="">
                    </button>
                    
                    <!-- Light Controls -->
                    <div class="light-controls">
                        <div class="control-group">
                            <label class="control-label">Light Intensity</label>
                            <input type="range" id="lightIntensity" min="0" max="2" step="0.1" value="1">
                        </div>
                        <div class="control-group">
                            <label class="control-label">Light Color</label>
                            <input type="color" id="lightColor" value="#ffffff">
                        </div>
                    </div>
                </div>
            </div>

            <div class="panel" id="Cameras" style="display: none;">
                <div class="panel-header">
                    <span>Camera</span>
                    <span class="expand-button">▼</span>
                </div>
                <div class="panel-content">
                    
                    
                    <div class="button-container">
                        <!-- Add Camera (Standard Camera) -->
                        <button id="addCamera" class="panel-button-tool title="Add Camera">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Camera body -->
                                <rect x="4" y="6" width="16" height="12" rx="2" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Lens -->
                                <circle cx="12" cy="12" r="3" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Top trapezoid (viewfinder) -->
                                <path d="M8 6L10 4L14 4L16 6" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Plus sign -->
                                <path d="M20 12H22M21 11V13" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Add Camera Orto (Orthographic Camera) -->
                        <button id="addCameraOrto" class="panel-button-tool" title="Add Ortho Camera">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Camera body -->
                                <rect x="4" y="6" width="16" height="12" rx="2" fill="none" stroke="#1db34d" stroke-width="2"/>
                                <!-- Orthographic lines (indicating projection) -->
                                <line x1="10" y1="9" x2="10" y2="15" stroke="#1db34d" stroke-width="2"/>
                                <line x1="14" y1="9" x2="14" y2="15" stroke="#1db34d" stroke-width="2"/>
                                <!-- Top trapezoid -->
                                <path d="M8 6L10 4L14 4L16 6" fill="none" stroke="#1db34d" stroke-width="2"/>
                                <!-- Plus sign -->
                                <path d="M20 12H22M21 11V13" fill="none" stroke="#1db34d" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Add Cube Camera (Cubic/Panoramic Camera) -->
                        <button id="addCubeCamera" class="panel-button-tool" title="Add Cube Camera">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Cube shape -->
                                <path d="M6 6L12 4L18 6L18 14L12 16L6 14L6 6Z" fill="none" stroke="#1db34d" stroke-width="2"/>
                                <path d="M6 6L12 8L18 6" fill="none" stroke="#1db34d" stroke-width="2"/>
                                <path d="M12 8L12 16" fill="none" stroke="#1db34d" stroke-width="2"/>
                                <!-- Lens on front face -->
                                <circle cx="12" cy="11" r="2" fill="none" stroke="#1db34d" stroke-width="2"/>
                                <!-- Plus sign -->
                                <path d="M20 12H22M21 11V13" fill="none" stroke="#1db34d" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Add Stereo Camera (Dual Lens) -->
                        <button id="addStereoCamera" class="panel-button-tool" title="Add Stereo Camera">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Camera body -->
                                <rect x="4" y="6" width="16" height="12" rx="2" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Two lenses (stereo) -->
                                <circle cx="9" cy="12" r="2" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <circle cx="15" cy="12" r="2" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Top trapezoid -->
                                <path d="M8 6L10 4L14 4L16 6" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Plus sign -->
                                <path d="M20 12H22M21 11V13" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    </div>
                    <div class="input-group">
                        <label id="cameraFOV">FOV</label>
                        <input type="number" value="60">
                    </div>
                    
                    <!-- Camera list will be inserted here -->
                </div>
            </div>

            <div class="panel" id="drawingMode" style="display: none;">
                <div class="panel-header">
                    <span>Drawing</span>
                    <span class="expand-button">▼</span>
                </div>
                <div class="panel-content">
                    <div class="button-container">
                        <!-- Draw Mode (F) -->
                        <button class="panel-button-tool" id="toggle-draw" title="Draw Mode (F)">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Pencil/Brush -->
                                <path d="M6 18L18 6" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Tip -->
                                <path d="M16 8L18 6L20 8" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Subtle 'F' hint (optional) -->
                                <path d="M8 16H10M8 14H9" fill="none" stroke="#ffffff" stroke-width="1"/>
                            </svg>
                        </button>
                    
                        <!-- Extrude Mode (E) -->
                        <button class="panel-button-tool" id="toggle-extrude" title="Extrude Mode (E)">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Base shape -->
                                <rect x="8" y="14" width="8" height="4" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Extruded top -->
                                <rect x="8" y="6" width="8" height="4" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Connecting lines -->
                                <path d="M8 14L8 10M16 14L16 10" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Up arrow -->
                                <path d="M12 10L12 6L14 8" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Clear (L) -->
                        <button class="panel-button-tool" id="clear" title="Clear (L)">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Eraser -->
                                <rect x="6" y="12" width="12" height="6" rx="2" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Clearing lines -->
                                <path d="M8 14L16 14M8 16L16 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Subtle 'L' hint (optional) -->
                                <path d="M18 12V16" fill="none" stroke="#ffffff" stroke-width="1"/>
                            </svg>
                        </button>
                    </div>
                    <div class="slider-container">
                        <input type="range" id="brush-" min="0.1" max="2" step="0.1" value="0.5">
                        <span>Brush Size: 0.5</span>
                    </div>
                    <div class="slider-container">
                        <input type="range" id="snapping" min="0" max="1" step="0.1" value="0.3">
                        <span>Snapping: 0.3</span>
                    </div>
                    <div class="slider-container">
                        <input type="range" id="extrude-height" min="0.1" max="5" step="0.1" value="1">
                        <span>Extrude: 1.0</span>
                    </div>
                </div>
                <div style="background-color: #e74c3c; padding: 4px;  margin: 10px auto; margin-right: 10px; margin-left: 10px;" class="status" id="status">Ready</div>
            </div>
        

            <!-- Material Editor Panel -->
            <div class="material-editor" id="material-editor"  style="display: none;">
                <div class="panel-header">Material Editor</div>
                <div class="property-group">
                    <div class="property-row">
                        <span class="property-label">Color</span>
                        <input type="color" class="property-input" id="materialColor">
                    </div>
                    <div class="property-row">
                        <span class="property-label">Metalness</span>
                        <input type="range" class="property-input" id="materialMetalness" min="0" max="1" step="0.1">
                    </div>
                    <div class="property-row">
                        <span class="property-label">Roughness</span>
                        <input type="range" class="property-input" id="materialRoughness" min="0" max="1" step="0.1">
                    </div>
                    <div class="property-row">
                        <label for="materialOpacity">Opacity:</label>
                        <input type="range" id="materialOpacity" min="0" max="1" step="0.01" value="1">

                        <label for="materialTexture">Texture:</label>
                        <input type="file" id="materialTexture" accept="image/*">
                    </div>
                    <div class="property-row">
                        <h3>MTXT</h3>
                        <div id="materialTextures" style=" margin: 10px auto; width: 100%; height: auto;">

                        </div>
                    </div>
                </div>
            </div>
                <div class="controls" id="snow-sittings" style="display: none;">
                    <div class="panel-header">Advanced Snow System</div>
                    <div class="property-group">
                        <button class="panel-button" id="toggleSnow">Toggle Snow</button>

                        <!-- Snow Mode Selection -->
                        <div class="control-group">
                            <label>Snow Mode:</label>
                            <select id="snowMode">
                                <option value="normal">Normal Falling</option>
                                <option value="vortex">Vortex</option>
                            </select>
                        </div>


                        <div class="control-group">
                            <label>Density: <span id="densityValue">1000</span></label>
                            <input type="range" id="density" min="100" max="5000" value="1000">
                        </div>
                        <div class="control-group">
                            <label>Size: <span id="sizeValue">0.1</span></label>
                            <input type="range" id="size" min="0.01" max="0.5" value="0.1" step="0.01">
                        </div>
                        <div class="control-group">
                            <label>Speed: <span id="speedValue">1</span></label>
                            <input type="range" id="speed" min="0.1" max="5" value="1" step="0.1">
                        </div>
                        <div class="control-group">
                            <label>Wind: <span id="windValue">0</span></label>
                            <input type="range" id="wind" min="-5" max="5" value="0" step="0.1">
                        </div>
                        <div class="control-group">
                            <label>Turbulence: <span id="turbulenceValue">0.5</span></label>
                            <input type="range" id="turbulence" min="0" max="2" value="0.5" step="0.1">
                        </div>

                        <div class="weather-effects">
                            <div class="button-container">
                                <!-- Storm -->
                                <button class="panel-button-tool" id="storm" title="Storm">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                        <!-- Swirling wind -->
                                        <path d="M6 12C8 10 10 10 12 12C14 14 16 14 18 12" fill="none" stroke="#ffffff" stroke-width="2"/>
                                        <!-- Lightning bolt -->
                                        <path d="M12 8L14 12L12 16L14 20" fill="none" stroke="#ffffff" stroke-width="2"/>
                                    </svg>
                                </button>
                            
                                <!-- Blizzard -->
                                <button class="panel-button-tool" id="blizzard" title="Blizzard">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                        <!-- Wind lines -->
                                        <path d="M6 12H10M14 12H18" fill="none" stroke="#ffffff" stroke-width="2"/>
                                        <!-- Snowflake -->
                                        <path d="M12 8V16M10 10L14 14M10 14L14 10" fill="none" stroke="#ffffff" stroke-width="2"/>
                                    </svg>
                                </button>
                            
                                <!-- Gentle -->
                                <button class="panel-button-tool" id="gentle" title="Gentle">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                        <!-- Soft flowing curves -->
                                        <path d="M6 14C8 12 10 12 12 14C14 16 16 16 18 14" fill="none" stroke="#ffffff" stroke-width="2"/>
                                        <path d="M6 16C8 14 10 14 12 16C14 18 16 18 18 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                                    </svg>
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="property-group">
                        <div id="controls">
                             <!-- Toggle Particles -->
                             <button class="panel-button" id="toggleParticles" title="Toggle Particles">
                                Toggle Particls
                             </button>
                            <div class="button-container">
                                <!-- Increase Particles -->
                                <button class="panel-button-tool" id="increaseParticles" title="Increase Particles">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                        <!-- Particle dots -->
                                        <circle cx="8" cy="14" r="1" fill="#ffffff" stroke="#ffffff" stroke-width="2"/>
                                        <circle cx="12" cy="16" r="1" fill="#ffffff" stroke="#ffffff" stroke-width="2"/>
                                        <circle cx="16" cy="14" r="1" fill="#ffffff" stroke="#ffffff" stroke-width="2"/>
                                        <!-- Up arrow -->
                                        <path d="M12 12L12 6M10 8L12 6L14 8" fill="none" stroke="#ffffff" stroke-width="2"/>
                                    </svg>
                                </button>
                            
                                <!-- Decrease Particles -->
                                <button class="panel-button-tool" id="decreaseParticles" title="Decrease Particles">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                        <!-- Particle dots -->
                                        <circle cx="8" cy="10" r="1" fill="#ffffff" stroke="#ffffff" stroke-width="2"/>
                                        <circle cx="12" cy="8" r="1" fill="#ffffff" stroke="#ffffff" stroke-width="2"/>
                                        <circle cx="16" cy="10" r="1" fill="#ffffff" stroke="#ffffff" stroke-width="2"/>
                                        <!-- Down arrow -->
                                        <path d="M12 12L12 18M10 16L12 18L14 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                                    </svg>
                                </button>
                            
                                <!-- Particle Color (Color Picker) -->
                                <button class="panel-button-tool" title="Particle Color">
                                    <input type="color" id="particleColor" value="#ffcc88" />
                                </button>
                            </div>
                        </div>
                        
                    </div>
                </div>
            
        
            <div class="sculpting-tools" id="sculpting-tools"  style="display: none;">
                <div class="panel-header">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" d="m15.47 13.79l-2.58-1.03L6 15.05l-4-1.54v2.1l4 1.34zm-4.9-2.37L8 8H2v3.61l4 1.34zM6 19.05l-4-1.33V22h20l-4.97-6.62zM17 6V1l-5-1l-3 2v4l3 2zm1.5 1L16 9v3l2.5 2l4.5-2V8z"/></svg>
                    Sculpting Tools
                </div>
                <div class="property-group">
                    <!-- Basic Tools -->
                    <div class="button-container">
                        <!-- Raise/Lower -->
                        <button class="panel-button-tool" id="raiseLower" title="Raise/Lower">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Up arrow -->
                                <path d="M12 6L12 18" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <path d="M8 10L12 6L16 10" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Down arrow -->
                                <path d="M8 14L12 18L16 14" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Smooth (Reused) -->
                        <button class="panel-button-tool" id="smooth" title="Smooth">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Smooth flowing curve -->
                                <path d="M6 16C8 12 10 10 12 12C14 14 16 12 18 8" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Subtle wave -->
                                <path d="M6 14C8 13 10 13 12 14C14 15 16 15 18 14" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Flatten -->
                        <button class="panel-button-tool" id="flatten" title="Flatten">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Flat surface -->
                                <line x1="6" y1="12" x2="18" y2="12" stroke="#ffffff" stroke-width="2"/>
                                <!-- Downward pressure arrows -->
                                <path d="M8 8L8 12L10 10" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <path d="M16 8L16 12L14 10" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Noise -->
                        <button class="panel-button-tool" id="noise" title="Noise">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Jagged noise line -->
                                <path d="M6 12L8 14L10 10L12 14L14 10L16 14L18 12" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Subtle secondary noise -->
                                <path d="M6 14L8 12L10 16L12 12L14 16L16 12L18 14" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    </div>

                    <!-- Advanced Tools -->
                    <div class="button-container">
                        <!-- Pinch (Reused) -->
                        <button class="panel-button-tool" id="pinch" title="Pinch">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Converging arrows -->
                                <path d="M6 8L12 12L6 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <path d="M18 8L12 12L18 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Center pinch point -->
                                <circle cx="12" cy="12" r="1" fill="#ffffff" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Clay -->
                        <button class="panel-button-tool" id="clay" title="Clay">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Clay lump -->
                                <path d="M8 10C6 12 6 16 8 18C10 20 14 20 16 18C18 16 18 12 16 10C14 8 10 8 8 10Z" 
                                      fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Shaping hint -->
                                <path d="M10 12C11 11 13 11 14 12" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Scrape -->
                        <button class="panel-button-tool" id="scrape" title="Scrape">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Scraping edge -->
                                <path d="M6 16L18 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Tool angle -->
                                <path d="M18 16L14 12L10 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Scraped material -->
                                <path d="M8 18L10 18M14 18L16 18" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Fill -->
                        <button class="panel-button-tool" id="fill" title="Fill">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Fill shape -->
                                <rect x="8" y="8" width="8" height="8" rx="2" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Inward flow arrows -->
                                <path d="M12 6V8M12 18V16M6 12H8M18 12H16" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Texture Paint -->
                        <button class="panel-button-tool" id="texturePaint" title="Texture Paint">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Paintbrush handle -->
                                <path d="M6 18L12 6" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Brush tip -->
                                <path d="M10 10C11 9 13 9 14 10" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Texture dots -->
                                <circle cx="12" cy="12" r="1" fill="#ffffff" stroke="#ffffff" stroke-width="2"/>
                                <circle cx="14" cy="14" r="1" fill="#ffffff" stroke="#ffffff" stroke-width="2"/>
                                <circle cx="10" cy="14" r="1" fill="#ffffff" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    </div>
            
                    <!-- Brush Controls -->
                    <div class="brush-controls">
                        <label>Brush Size:
                            <input type="range" id="brushSize" min="0.5" max="5" step="0.1" value="1.5">
                        </label>
                        <label>Brush Strength:
                            <input type="range" id="brushStrength" min="0.01" max="0.5" step="0.01" value="0.1">
                        </label>
                    </div>
            
                    <!-- Symmetry Controls -->
                    <div class="tool-options">
                        <label>
                            <input type="checkbox" id="symmetryToggle"> Enable Symmetry
                        </label>
                        <select id="symmetryAxis">
                            <option value="x">X Axis</option>
                            <option value="z">Z Axis</option>
                        </select>
                    </div>
            
                    <!-- History Controls -->
                    <div class="history-controls">
                        <button class="panel-button" id="undo"><i class="fas fa-undo"></i></button>
                        <button class="panel-button" id="redo"><i class="fas fa-redo"></i></button>
                    </div>
            
                    <!-- Texture Upload -->
                    <input type="file" id="uploadTexture" accept="image/*" style="display: none;">
                    <button class="panel-button" id="selectTexture">Upload Texture</button>

                    <canvas id="texturePreview" width="64" height="64" style="display: block;"></canvas>
                </div>

                <div class="advanced-tools">
                    <div class="button-container">
                        <!-- Terrace -->
                        <button class="panel-button-tool" id="terrace" title="Terrace">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Stepped levels -->
                                <path d="M6 18H18M6 14H18M6 10H18" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Connecting lines -->
                                <path d="M6 18V10M18 18V10" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Erosion -->
                        <button class="panel-button-tool" id="erosion" title="Erosion">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Wavy, worn lines -->
                                <path d="M6 16C8 14 10 14 12 16C14 18 16 18 18 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <path d="M6 14C8 12 10 12 12 14C14 16 16 16 18 14" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Ridge -->
                        <button class="panel-button-tool" id="ridge" title="Ridge">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Sharp peak -->
                                <path d="M6 18L12 6L18 18" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Base line -->
                                <path d="M6 18H18" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Canyon -->
                        <button class="panel-button-tool" id="canyon" title="Canyon">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Deep valley -->
                                <path d="M6 6L8 18L16 18L18 6" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Center dip -->
                                <path d="M8 18L12 14L16 18" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Plateau -->
                        <button class="panel-button-tool" id="plateau" title="Plateau">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Flat elevated surface -->
                                <path d="M6 14H18" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Slopes to base -->
                                <path d="M6 14L4 18H20L18 14" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Slope -->
                        <button class="panel-button-tool" id="slope" title="Slope">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Angled incline -->
                                <path d="M6 18L18 6" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Base and top lines -->
                                <path d="M6 18H4M18 6H20" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Blur Heights -->
                        <button class="panel-button-tool" id="blur" title="Blur Heights">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Soft wavy lines -->
                                <path d="M6 12C8 10 10 10 12 12C14 14 16 14 18 12" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <path d="M6 14C8 12 10 12 12 14C14 16 16 16 18 14" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Sharpen -->
                        <button class="panel-button-tool" id="sharpen" title="Sharpen">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Crisp peak -->
                                <path d="M6 16L12 8L18 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Base line -->
                                <path d="M6 16H18" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    </div>
                    
                    <div class="tool-settings">
                        <label>Steps:
                            <input type="range" id="terraceSteps" min="2" max="10" value="4">
                        </label>
                        <label>Erosion Strength:
                            <input type="range" id="erosionStrength" min="0.1" max="1.0" value="0.5">
                        </label>
                        <label>Ridge Height:
                            <input type="range" id="ridgeHeight" min="0.1" max="2.0" value="1.0">
                        </label>
                    </div>
                </div>

                <div class="material-tools" style="padding: 5px;">
                    <button class="panel-button-tool" id="materialPaint" title="Material Paint">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                            <path d="M6 18L12 6" fill="none" stroke="#ffffff" stroke-width="2"/>
                            <rect x="10" y="10" width="4" height="4" fill="none" stroke="#ffffff" stroke-width="2"/>
                            <circle cx="12" cy="12" r="2" fill="#ffffff"/>
                        </svg>
                    </button>

                    <div class="property-group" >
                        <input type="file" id="uploadMaterial" accept="image/*" style="display: none;">
                        <button class="panel-button" id="selectMaterial">Upload Material</button>
                        <canvas id="materialPreview" width="64" height="64" style="display: block;"></canvas>
                        
                        <label>Brush Size:
                            <input type="range" id="materialBrushSize" min="0.5" max="5" step="0.1" value="1.5">
                        </label>
                        <label>Strength:
                            <input type="range" id="materialStrength" min="0.1" max="1" step="0.01" value="0.5">
                        </label>
                        <label>Falloff:
                            <input type="range" id="materialFalloff" min="0.1" max="1" step="0.01" value="0.7">
                        </label>
                        <label>Rotation:
                            <input type="range" id="materialRotation" min="0" max="360" step="1" value="0">
                        </label>
                        <label>Scale:
                            <input type="range" id="materialScale" min="0.1" max="2" step="0.01" value="1">
                        </label>
                        <label>Opacity:
                            <input type="range" id="materialOpacity" min="0.1" max="1" step="0.01" value="1">
                        </label>
                        <label>Pattern:
                            <select id="materialPattern">
                                <option value="uniform">Uniform</option>
                                <option value="noise">Noise</option>
                                <option value="radial">Radial</option>
                                <option value="custom">Custom</option>
                            </select>
                        </label>
                        <label>Blend Mode:
                            <select id="materialBlendMode">
                                <option value="normal">Normal</option>
                                <option value="multiply">Multiply</option>
                                <option value="overlay">Overlay</option>
                                <option value="add">Add</option>
                            </select>
                        </label>
                    </div>
                </div>
            </div>

            <div id="sculpting-character-tools" class="character-sclupting" style="display: none;">
                <div class="panel-header">Character Sculpting</div>
                <div class="property-group">
                    <div class="group-header">Brush Settings</div>
                    <div class="brush-controls">
                        <label>Sculpting: <input type="checkbox" id="sculptingToggle" checked></label>
                        <label>Brush Size: <input type="range" id="brushSizeSc" min="0.05" max="1.0" step="0.05" value="0.2"></label>
                        <span id="brushSizeValue">0.2</span>
                        <label>Brush Strength: <input type="range" id="brushStrength" min="0.01" max="0.5" step="0.01" value="0.1"></label>
                        <span id="brushStrengthValue">0.1</span>
                        <label>Brush Falloff: <input type="range" id="brushFalloff" min="0.1" max="2.0" step="0.1" value="0.5"></label>
                        <span id="brushFalloffValue">0.5</span>
                    </div>
                </div>
                <div class="property-group">
                    <div class="group-header">Basic Shape Tools</div>
                    <div class="button-container">
                        <!-- Face Shape -->
                        <button class="panel-button-tool" id="faceShape" title="Face Shape">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Full face outline -->
                                <path d="M12 4C8 4 6 8 6 12C6 16 8 20 12 20C16 20 18 16 18 12C18 8 16 4 12 4Z" 
                                      fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Jawline curve -->
                                <path d="M8 16C9 18 11 19 12 19C13 19 15 18 16 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Nose Sculpt -->
                        <button class="panel-button-tool" id="noseSculpt" title="Nose Sculpt">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Nose profile -->
                                <path d="M12 6V10C12 12 13 14 14 15C13 16 12 17 12 18" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Nostril hint -->
                                <path d="M12 18C11.5 17.5 11 17 11 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Cheek Definition -->
                        <button class="panel-button-tool" id="cheekDefinition" title="Cheek Definition">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Face outline (simplified) -->
                                <path d="M8 6C6 8 6 16 8 18C10 20 14 20 16 18C18 16 18 8 16 6" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Cheekbone highlight -->
                                <path d="M9 12C10 13 11 13 12 12" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <path d="M12 12C13 13 14 13 15 12" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Jaw Sculpt -->
                        <button class="panel-button-tool" id="jawSculpt" title="Jaw Sculpt">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Jawline -->
                                <path d="M8 12C8 16 9 18 12 20C15 18 16 16 16 12" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Chin point -->
                                <path d="M12 20V22" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Forehead Shape -->
                        <button class="panel-button-tool" id="foreheadShape" title="Forehead Shape">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Forehead contour -->
                                <path d="M8 6C8 4 10 4 12 4C14 4 16 4 16 6C16 8 14 10 12 10C10 10 8 8 8 6Z" 
                                      fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Hairline hint -->
                                <path d="M8 6H16" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    </div>
                </div>
        
                <div class="property-group">
                    <div class="group-header">Advanced Shape Tools</div>
                    <div class="button-container">
                        <!-- Chin Sculpt -->
                        <button class="panel-button-tool" id="chinSculpt" title="Chin Sculpt">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Chin outline -->
                                <path d="M10 12C9 14 9 16 12 18C15 16 15 14 14 12" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Chin point -->
                                <path d="M12 18V20" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Temple Sculpt -->
                        <button class="panel-button-tool" id="templeSculpt" title="Temple Sculpt">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Temple area (side of forehead) -->
                                <path d="M8 6C8 4 10 4 12 6C14 4 16 4 16 6" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Side curve -->
                                <path d="M8 6C6 8 6 12 8 14" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <path d="M16 6C18 8 18 12 16 14" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Brow Ridge -->
                        <button class="panel-button-tool" id="browRidge" title="Brow Ridge">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Brow ridge arc -->
                                <path d="M8 8C9 6 11 6 12 8C13 6 15 6 16 8" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Eyebrow hint -->
                                <path d="M8 8C9 9 11 10 12 10C13 10 15 9 16 8" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Eye Socket -->
                        <button class="panel-button-tool" id="eyeSocket" title="Eye Socket">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Eye socket shape -->
                                <path d="M8 10C9 8 11 8 12 10C13 8 15 8 16 10C16 12 14 14 12 14C10 14 8 12 8 10Z" 
                                      fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Pupil hint -->
                                <circle cx="12" cy="12" r="1" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Lip Shape -->
                        <button class="panel-button-tool" id="lipShape" title="Lip Shape">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Upper lip -->
                                <path d="M8 12C9 11 11 10 12 11C13 10 15 11 16 12" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Lower lip -->
                                <path d="M8 12C9 13 11 14 12 14C13 14 15 13 16 12" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    </div>
                </div>
        
                <div class="property-group">
                    <div class="group-header">Advanced Tools</div>
                    <button class="panel-button-tool" id="snakeHook" title="Snake Hook">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                            <!-- Hook with snake-like curve -->
                            <path d="M6 18C8 14 10 12 12 14C14 16 16 14 18 10" fill="none" stroke="#ffffff" stroke-width="2"/>
                            <!-- Hook tip -->
                            <path d="M18 10L20 12L22 10" fill="none" stroke="#ffffff" stroke-width="2"/>
                        </svg>
                    </button>
                    <div class="group-header">Hair Brush Settings</div>
                    <button class="panel-button-tool" id="hairBrush" title="Hair Brush">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                            <!-- Brush handle -->
                            <rect x="10" y="4" width="4" height="8" fill="none" stroke="#ffffff" stroke-width="2"/>
                            <!-- Brush bristles (hair strands) -->
                            <path d="M8 12C8 14 10 16 12 16C14 16 16 14 16 12" fill="none" stroke="#ffffff" stroke-width="2"/>
                            <line x1="10" y1="12" x2="10" y2="18" stroke="#ffffff" stroke-width="2"/>
                            <line x1="12" y1="12" x2="12" y2="18" stroke="#ffffff" stroke-width="2"/>
                            <line x1="14" y1="12" x2="14" y2="18" stroke="#ffffff" stroke-width="2"/>
                        </svg>
                    </button>
                    <div class="hair-controls">
                        <h3>Hair Physics Settings</h3>
                        
                        <div class="control-group">
                          <label for="guideHairDensity">Guide Hair Density</label>
                          <input type="range" id="guideHairDensity" min="0.05" max="0.5" step="0.05" value="0.1">
                          <span class="value-display">0.1</span>
                        </div>
                        
                        <div class="control-group">
                          <label for="simulationQuality">Simulation Quality</label>
                          <select id="simulationQuality">
                            <option value="low">Low (Fast)</option>
                            <option value="medium" selected>Medium</option>
                            <option value="high">High (Slower)</option>
                          </select>
                        </div>
                        
                        <div class="control-group">
                          <button id="optimizePerformance">Optimize Hair</button>
                          <button id="togglePhysics">Toggle Physics</button>
                        </div>
                        
                        <div class="stats">
                          <div>Hair Strands: <span id="strandCount">0</span></div>
                          <div>Guide Hairs: <span id="guideCount">0</span></div>
                          <div>Performance: <span id="physicsTime">0</span> ms</div>
                        </div>
                      </div>
                    <div class="brush-controls">
                        <label title="Adjust the number of hair segments.">Segments: <input type="range" id="hairSegments" min="4" max="16" value="8" step="1"></label>
                        <label>Length: <input type="range" id="hairLength" min="0.02" max="0.2" value="0.05" step="0.01"></label>
                        <label>Density: <input type="range" id="hairDensity" min="3" max="12" value="5" step="1"></label>
                        <label>Curl: <input type="range" id="hairCurl" min="0" max="1" value="0.2" step="0.1"></label>
                        <label>Stiffness: <input type="range" id="hairStiffness" min="0.1" max="1" value="0.8" step="0.1"></label>
                    </div>

                    <div class="property-group">
                        <div class="group-header">Advanced Hair Settings</div>
                        <div class="brush-controls">
                            <label>Wave: <input type="range" id="hairWave" min="0" max="1" value="0.2" step="0.05"></label>
                            <label>Frizz: <input type="range" id="hairFrizz" min="0" max="0.5" value="0.1" step="0.05"></label>
                            <label>Clump Size: <input type="range" id="hairClumpSize" min="1" max="10" value="3" step="1"></label>
                            <label>Noise: <input type="range" id="hairNoise" min="0" max="0.2" value="0.05" step="0.01"></label>
                            <label>Color: <input type="color" id="hairColor" value="#3a1a00"></label>
                            <label>Highlight Color: <input type="color" id="hairSpecular" value="#8B4513"></label>
                            <!-- Rename the second togglePhysics to avoid conflict -->
                            <button class="panel-button" id="enablePhysics">Enable Physics</button>
                        </div>
                    </div>
                </div>

                <div class="property-group">
                    <div class="group-header">Detail Tools</div>
                    <div class="button-container">
                        <!-- Smooth -->
                        <button class="panel-button-tool" id="smooth" title="Smooth">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Smooth flowing curve -->
                                <path d="M6 16C8 12 10 10 12 12C14 14 16 12 18 8" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Subtle wave -->
                                <path d="M6 14C8 13 10 13 12 14C14 15 16 15 18 14" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Pinch -->
                        <button class="panel-button-tool" id="pinch" title="Pinch">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Converging arrows -->
                                <path d="M6 8L12 12L6 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <path d="M18 8L12 12L18 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Center pinch point -->
                                <circle cx="12" cy="12" r="1" fill="#ffffff" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Inflate -->
                        <button class="panel-button-tool" id="inflate" title="Inflate">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Expanding circle -->
                                <circle cx="12" cy="12" r="6" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Arrows outward -->
                                <path d="M12 6V4M12 20V18M6 12H4M20 12H18" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Crease -->
                        <button class="panel-button-tool" id="crease" title="Crease">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Sharp crease line -->
                                <path d="M6 18L12 12L18 18" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Fold hint -->
                                <path d="M6 16L12 10L18 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    </div>
                </div>
                
                <div class="property-group">
                    <div class="group-header">Symmetry</div>
                    <div class="symmetry-controls">
                        <label>
                            <input type="checkbox" id="symmetryToggle" checked>
                            Enable Symmetry
                        </label>
                        <select id="symmetryAxis">
                            <option value="x">X Axis</option>
                            <option value="y">Y Axis</option>
                            <option value="z">Z Axis</option>
                        </select>
                    </div>
                </div>
                
            </div>
            <div class="historySysteme">
                <div class="panel-header">
                    <i class="fas fa-history"></i>
                     Histroy & Controls
                </div>
                <div class="history-panel" id="history-panel">
                    <div class="panel-header">
                        <i class="fas fa-history"></i>
                        History panel
                    </div>
                    <div class="property-row">
                        <div id="history-items"></div>
                    </div>
                </div>
                <!-- Advanced Tools Panel -->
                <div class="advanced-tools" id="advanced-tools">
                    <div class="button-container">
                        <!-- Mirror -->
                        <button class="panel-button-tool" id="mirror" title="Mirror">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Shape (left half) -->
                                <path d="M6 8C8 6 10 8 10 12C10 16 8 18 6 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Symmetry line -->
                                <line x1="12" y1="6" x2="12" y2="18" stroke="#ffffff" stroke-width="2" stroke-dasharray="2"/>
                                <!-- Shape (right half, mirrored) -->
                                <path d="M18 8C16 6 14 8 14 12C14 16 16 18 18 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Array -->
                        <button class="panel-button-tool" id="array" title="Array">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Repeated rectangles -->
                                <rect x="6" y="8" width="4" height="4" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <rect x="12" y="8" width="4" height="4" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <rect x="6" y="14" width="4" height="4" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <rect x="12" y="14" width="4" height="4" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Plus hint -->
                                <path d="M18 12H20M19 11V13" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    
                        <!-- Boolean -->
                        <button class="panel-button-tool" id="boolean" title="Boolean">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <!-- Overlapping shapes -->
                                <circle cx="10" cy="12" r="4" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <rect x="10" y="8" width="8" height="8" fill="none" stroke="#ffffff" stroke-width="2"/>
                                <!-- Cutout hint -->
                                <path d="M14 12H16" fill="none" stroke="#ffffff" stroke-width="2"/>
                            </svg>
                        </button>
                    </div>
                </div>
            
            </div>
            <!-- Export Options -->
            <div class="export-panel" id="export-panel">
                <div class="panel-header">
                    Export Options
                </div>
                <div class="export-meth">
                    <select class="property-input" id="exportFormat">
                        <option value="gltf">GLTF/GLB</option>
                        <option value="obj">OBJ</option>
                        <option value="fbx">FBX</option>
                    </select>
                    <button class="tool-button" id="exportButton">Export</button>
                    <button class="tool-button" id="importScene">Export</button>
                </div>
            </div>
        </div>
        
        <div class="animator-container">
            <div class="layers-panel">
                <div class="panel-header">Layers</div>
                <div class="layer-item selected">
                    <span class="layer-icon">▶</span>
                    Base Layer
                </div>
                <div class="layer-item">
                    <span class="layer-icon">▶</span>
                    Left Hand Layer
                </div>
                <div class="layer-item">
                    <span class="layer-icon">▶</span>
                    Right Hand Layer
                </div>
            </div>
    
            <div class="graph-panel">
                <div class="grid"></div>
                <div class="controls1">
                    <button class="control-btn1" id="addState">Add State</button>
                    <button class="control-btn1" id="addTransition">Add Transition</button>
                </div>
            </div>
    
            <div class="parameters-panel">
                <div class="parameter-group">
                    <label class="parameter-label">State Name</label>
                    <input type="text" class="parameter-input" id="stateName">
                </div>
                <div class="parameter-group">
                    <label class="parameter-label">Speed</label>
                    <input type="range" class="parameter-input" min="0" max="2" step="0.1" value="1">
                </div>
                <div class="parameter-group">
                    <label class="parameter-label">Transition Duration</label>
                    <input type="number" class="parameter-input" value="0.25" step="0.05">
                </div>
            </div>
        </div>

         <!-- Add this new modal container right before the existing model-viewer-container -->
         <div class="site-modal-container" id="siteModal">
            <button class="close-site-modal" id="closeSiteModal"><i class="fas fa-times"></i></button>
            <div class="site-modal-content" id="siteModalContent">
                <iframe id="siteIframe" frameborder="0"></iframe>
            </div>
        </div>

        <div class="sound-controls-header"  id="sound-controls-header" style="display: none;">
            <header class="header-bar">
                <div class="transport-controls">
                    <button class="btn" id="playBtn"><i class="fas fa-play"></i></button>
                    <button class="btn" id="stopBtn"><i class="fa-solid fa-stop"></i></button>
                    <button class="btn" id="loopBtn"><i class="fa-solid fa-repeat"></i></button>
                    <div class="time-display">
                        <span id="currentTime">00:00</span>
                    </div>
                </div>
                <div class="master-controls">
                    <input type="file" id="fileInput" accept="audio/*" style="display: none">
                    <label for="fileInput" class="btn"><i class="fa-solid fa-spinner"></i></label>
                </div>
            </header>
        </div>

    <style>
   .animator-container {
        display: none;
       position: absolute;
       top: 41%;
       left: 40%;
       bottom: 31vh;
       transform: translate(-50%, -48.5%);
       width: 57%;
       height: 70vh; /* Adjust height dynamically */
       max-height: 70vh; 
       background: #2a2a2a;
       border: 1px solid #444;
       z-index: 1000;
       overflow: auto;
       transition: width 0.3s ease, left 0.3s ease, transform 0.3s ease;
    }

    .animator-container.visible {
        display: flex;
        width: 80%; 
        left: 20%; 
        transform: translate(0, -50%);
    }

    /* Layers Panel */
    .layers-panel {
        width: 180px;
        background-color: #383838;
        border-right: 1px solid #222;
        overflow-y: auto;
    }

    .layer-icon {
        width: 16px;
        height: 16px;
        margin-right: 8px;
    }

    /* Graph Panel */
    .graph-panel {
        flex: 1;
        background-color: #2D2D2D;
        position: relative;
        overflow-x: auto;
        overflow-y: auto;
    }

    .grid {
        position: absolute;
        width: 100%;
        height: 100%;
        background-size: 20px 20px;
        background-image: 
        linear-gradient(to right, #333 1px, transparent 1px),
        linear-gradient(to bottom, #333 1px, transparent 1px);
    }

    

    .node.entry {
        background-color: #2C632C;
    }

    .node.exit {
        background-color: #633434;
    }

    .node-header {
        padding-bottom: 5px;
        border-bottom: 1px solid #555;
        margin-bottom: 5px;
    }

    .connection {
        position: absolute;
        pointer-events: none;
        z-index: 1;
    }

    .controls1 {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            gap: 5px;
}

        .control-btn1 {
            background-color: #4A4A4A;
            border: none;
            color: white;
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 3px;
        }

        .control-btn1:hover {
            background-color: #555;
        }


        /* Parameters Panel */
        .parameters-panel {
            width: 200px;
            background-color: #383838;
            border-left: 1px solid #222;
            padding: 10px;
        }

        .parameter-group {
            margin-bottom: 15px;
        }

        .parameter-label {
            display: block;
            margin-bottom: 5px;
            color: #ccc;
        }

        .parameter-input {
            width: 100%;
            padding: 5px;
            background-color: #2D2D2D;
            border: 1px solid #444;
            color: white;
            border-radius: 3px;
        }
        </style>
        <script>
           document.getElementById("toggleAnimator").addEventListener("click", function() {
                document.querySelector(".animator-container").classList.toggle("visible");
             });
             class AnimationState {
    constructor(name, animation, transitions = []) {
        this.name = name;
        this.animation = animation;
        this.transitions = transitions;
        this.blendTime = 0.2; // Default blend duration
    }
}

class AnimationController {
    constructor(model) {
        this.model = model;
        this.mixer = new THREE.AnimationMixer(model);
        this.states = new Map();
        this.currentState = null;
    }

    addState(name, animation) {
        const state = new AnimationState(name, animation);
        this.states.set(name, state);
        return state;
    }

    transition(fromState, toState, duration) {
        const currentAction = this.mixer.clipAction(fromState.animation);
        const nextAction = this.mixer.clipAction(toState.animation);
        
        // Crossfade between animations
        currentAction.fadeOut(duration);
        nextAction.reset().fadeIn(duration).play();
        
        this.currentState = toState;
    }
}

class AnimatorInterface {
    constructor() {
        this.controllers = new Map();
        this.connections = new Map();
        this.parameters = new Map();
    }

    createController(model) {
        const controller = new AnimationController(model);
        this.controllers.set(model.uuid, controller);
        return controller;
    }

    addTransition(fromState, toState, conditions) {
        fromState.transitions.push({
            targetState: toState,
            conditions: conditions
        });
    }
}
              class AnimatorGraph {
            constructor() {
                this.nodes = new Map();
                this.connections = new Map();
                this.graphPanel = document.querySelector('.graph-panel');
                this.isDragging = false;
                this.selectedNode = null;
                this.offset = { x: 0, y: 0 };

                this.initializeEventListeners();
                this.createDefaultStates();
            }

            createDefaultStates() {
                // Create Entry state
                this.createNode('Entry', 100, 100, true);
                
                // Create default states
                this.createNode('Idle', 300, 100);
                this.createNode('Walking', 500, 100);
                this.createNode('Running', 700, 100);
                
                // Create connections
                this.createConnection('Entry', 'Idle');
                this.createConnection('Idle', 'Walking');
                this.createConnection('Walking', 'Running');
            }

            createNode(name, x, y, isEntry = false) {
                const node = document.createElement('div');
                node.className = `node ${isEntry ? 'entry' : ''}`;
                node.innerHTML = `
                    <div class="node-header">${name}</div>
                    <div class="node-content">
                        Speed: 1.0
                    </div>
                `;
                node.style.left = `${x}px`;
                node.style.top = `${y}px`;
                
                this.nodes.set(name, node);
                this.graphPanel.appendChild(node);
                
                return node;
            }

            createConnection(fromName, toName) {
                const connection = document.createElement('svg');
                connection.classList.add('connection');
                connection.setAttribute('width', '100%');
                connection.setAttribute('height', '100%');
                
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                line.setAttribute('stroke', '#666');
                line.setAttribute('stroke-width', '2');
                line.setAttribute('fill', 'none');
                
                connection.appendChild(line);
                this.graphPanel.appendChild(connection);
                
                this.connections.set(`${fromName}-${toName}`, {
                    element: connection,
                    line: line,
                    from: fromName,
                    to: toName
                });
                
                this.updateConnection(fromName, toName);
            }

            updateConnection(fromName, toName) {
                const connection = this.connections.get(`${fromName}-${toName}`);
                if (!connection) return;

                const fromNode = this.nodes.get(fromName);
                const toNode = this.nodes.get(toName);
                
                const fromRect = fromNode.getBoundingClientRect();
                const toRect = toNode.getBoundingClientRect();
                
                const x1 = fromRect.left + fromRect.width;
                const y1 = fromRect.top + fromRect.height / 2;
                const x2 = toRect.left;
                const y2 = toRect.top + toRect.height / 2;
                
                const path = `M ${x1} ${y1} C ${x1 + 50} ${y1}, ${x2 - 50} ${y2}, ${x2} ${y2}`;
                connection.line.setAttribute('d', path);
            }

            initializeEventListeners() {
                this.graphPanel.addEventListener('mousedown', (e) => {
                    if (e.target.classList.contains('node')) {
                        this.isDragging = true;
                        this.selectedNode = e.target;
                        const rect = this.selectedNode.getBoundingClientRect();
                        this.offset = {
                            x: e.clientX - rect.left,
                            y: e.clientY - rect.top
                        };
                    }
                });

                document.addEventListener('mousemove', (e) => {
                    if (this.isDragging && this.selectedNode) {
                        const x = e.clientX - this.offset.x;
                        const y = e.clientY - this.offset.y;
                        
                        this.selectedNode.style.left = `${x}px`;
                        this.selectedNode.style.top = `${y}px`;
                        
                        // Update connections
                        this.connections.forEach((connection, key) => {
                            if (key.includes(this.selectedNode.querySelector('.node-header').textContent)) {
                                this.updateConnection(connection.from, connection.to);
                            }
                        });
                    }
                });

                document.addEventListener('mouseup', () => {
                    this.isDragging = false;
                    this.selectedNode = null;
                });

                // Add State button
                document.getElementById('addState').addEventListener('click', () => {
                    const stateName = prompt('Enter state name:');
                    if (stateName) {
                        const x = Math.random() * 500 + 200;
                        const y = Math.random() * 300 + 100;
                        this.createNode(stateName, x, y);
                    }
                });
            }
        }

        // Initialize the animator
        const animator = new AnimatorGraph();
        </script>
         <!-- Timeline -->
         <div class="timeline">
            <div class="resize-handle-timeline"></div>
            <div class="status-bar"> 
                <span id="fps">FPS: 60</span>                 
                <span id="objects">Objects: 0</span>                 
                <span id="triangles">Triangles: 0</span>              
            </div>             
            <div class="timeline-controls">
                <button class="tool-button" id="play">                     
                    <i class="fas fa-play"></i>                 
                </button>                 
                <button class="tool-button" id="pause">                     
                    <i class="fas fa-pause"></i>                 
                </button>                 
                <button class="tool-button" id="stop">                     
                    <i class="fas fa-stop"></i>                 
                </button>
                <button class="tool-button" id="add-keyframe" title="Add Keyframe">
                    <i class="fas fa-diamond"></i>
                </button>
                <button class="tool-button" id="delete-keyframe" title="Delete Keyframe">
                    <i class="fas fa-trash"></i>
                </button>
                <span id="time-display">00:00:00</span>                 
                <div class="zoom-controls">                     
                    <button class="tool-button" id="zoom-out">-</button>                     
                    <button class="tool-button" id="zoom-in">+</button>                 
                </div>             
            </div>

            <div class="timeline-body">
                <div class="timeline-layers">
                    <div class="layers-list" id="layers-list"></div>
                </div>
                <div class="timeline-track">
                    <div class="timeline-scale"></div>
                    <div class="timeline-content" id="timeline-content">
                        <div class="playhead" id="playhead"></div>
                        <div class="keyframes-container" id="keyframes-container"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const resizeHandle = document.querySelector('.resize-handle-timeline');
        const timelineRes = document.querySelector('.timeline');
        const rendererContainer = document.getElementById('renderer-container');
        const viewport = document.querySelector('.viewport');
        // Variables to track the resizing
        let isResizing = false;
        let initialHeight = 0;
        let initialMouseY = 0;

        // Define min and max heights for timeline (in pixels)
        const MIN_HEIGHT = window.innerHeight * 0.15; // 29% of viewport height
        const MAX_HEIGHT = 400; // Maximum height in pixels

        resizeHandle.addEventListener('mousedown', (event) => {
            isResizing = true;
            initialHeight = timelineRes.offsetHeight;
            initialMouseY = event.clientY;
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
        });

        function handleMouseMove(event) {
            if (isResizing) {
                // Calculate the height change (inverted since we're resizing from top)
                const deltaY = initialMouseY - event.clientY;
                let newTimelineHeight = initialHeight + deltaY;

                // Apply height constraints to timeline
                newTimelineHeight = Math.max(MIN_HEIGHT, Math.min(MAX_HEIGHT, newTimelineHeight));

               // Update the timeline height
               timelineRes.style.height = `${newTimelineHeight}px`;

                // Calculate and update renderer container height
                const viewportHeight = viewport.offsetHeight;
                const newRendererHeight = viewportHeight - newTimelineHeight;
                rendererContainer.style.height = `${newRendererHeight}px`;
            }
        }

        function handleMouseUp() {
            isResizing = false;
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
        }
    </script>

    <div class="node-editor">
        <div class="node-editor-header">
            <span>Node Editor</span>
            <button id="node-editor-close">×</button>
        </div>
        <div class="node-toolbar">
            <button class="toolbar-button" title="Add Object" data-type="object">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                    <!-- Cube -->
                    <path d="M6 6L12 4L18 6L18 14L12 16L6 14L6 6Z" fill="none" stroke="#ffffff" stroke-width="2"/>
                    <path d="M6 6L12 8L18 6" fill="none" stroke="#ffffff" stroke-width="2"/>
                    <!-- Plus sign -->
                    <path d="M20 12H22M21 11V13" fill="none" stroke="#ffffff" stroke-width="2"/>
                </svg>
            </button>
            <button class="toolbar-button" title="Add Physics" data-type="physics">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                    <!-- Falling ball -->
                    <circle cx="12" cy="12" r="2" fill="none" stroke="#ffffff" stroke-width="2"/>
                    <!-- Motion lines -->
                    <path d="M12 8V10M10 6L11 9M14 6L13 9" fill="none" stroke="#ffffff" stroke-width="2"/>
                    <!-- Plus sign -->
                    <path d="M20 12H22M21 11V13" fill="none" stroke="#ffffff" stroke-width="2"/>
                </svg>
            </button>
            <button class="toolbar-button" title="Add Effect" data-type="effect">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                    <!-- Sparkle/wave -->
                    <path d="M12 8C14 10 16 10 18 12C16 14 14 14 12 16C10 14 8 14 6 12C8 10 10 10 12 8Z" 
                          fill="none" stroke="#ffffff" stroke-width="2"/>
                    <!-- Plus sign -->
                    <path d="M20 12H22M21 11V13" fill="none" stroke="#ffffff" stroke-width="2"/>
                </svg>
            </button>
            <button class="toolbar-button" title="Add Material" data-type="material">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                    <!-- Textured square -->
                    <rect x="6" y="6" width="12" height="12" fill="none" stroke="#ffffff" stroke-width="2"/>
                    <path d="M8 8L10 10M14 14L16 16" fill="none" stroke="#ffffff" stroke-width="2"/>
                    <!-- Plus sign -->
                    <path d="M20 12H22M21 11V13" fill="none" stroke="#ffffff" stroke-width="2"/>
                </svg>
            </button>
            <button class="toolbar-button" title="Add Transform" data-type="transform">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                    <!-- Transform arrows -->
                    <path d="M12 6V8M12 16V18M6 12H8M16 12H18" fill="none" stroke="#ffffff" stroke-width="2"/>
                    <path d="M10 8L12 6L14 8M10 16L12 18L14 16M8 10L6 12L8 14M16 10L18 12L16 14" 
                          fill="none" stroke="#ffffff" stroke-width="2"/>
                    <!-- Plus sign -->
                    <path d="M20 12H22M21 11V13" fill="none" stroke="#ffffff" stroke-width="2"/>
                </svg>
            </button>
            <button class="toolbar-button" title="Add Animation" data-type="animation">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                    <!-- Play button -->
                    <path d="M8 6L16 12L8 18Z" fill="none" stroke="#ffffff" stroke-width="2"/>
                    <!-- Plus sign -->
                    <path d="M20 12H22M21 11V13" fill="none" stroke="#ffffff" stroke-width="2"/>
                </svg>
            </button>
            <button class="toolbar-button" title="Add light" data-type="light">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                    <!-- Light bulb -->
                    <path d="M12 6C10 6 8 8 8 10C8 12 10 14 12 14C14 14 16 12 16 10C16 8 14 6 12 6Z" 
                          fill="none" stroke="#ffffff" stroke-width="2"/>
                    <path d="M10 14H14V16H10V14Z" fill="none" stroke="#ffffff" stroke-width="2"/>
                    <!-- Plus sign -->
                    <path d="M20 12H22M21 11V13" fill="none" stroke="#ffffff" stroke-width="2"/>
                </svg>
            </button>
        </div>
        <div class="node-canvas" id="node-canvas"></div>
    </div>

    <div class="camera-preview hidden" id="cameraPreview">
        <div class="preview-controls">
           <button class="minimizePreview" id="minimizePreview"><i class="fas fa-window-minimize"></i></button>
           <button class="expandPreview" id="expandPreview"><i class="fas fa-expand-arrows-alt"></i></button>
        </div>
    </div>

    <!-- Context Menu -->
    <div class="context-menu" id="context-menu"> 
        <div class="context-menu-item" >Copy (Ctrl+C)</div>
        <div class="context-menu-item" >Paste (Ctrl+V)</div>
        <div class="context-menu-item">Delete (Del)</div>
        <div class="context-menu-item" >Duplicate (Ctrl+D)</div>
    </div>
   
    <div id="code-editor-panel">
        <div class="resize-handle"></div>
        <div class="editor-header">
            <h3>Code Editor</h3>
            <button class="editor-btn" id="close-editor">&times;</button>
        </div>
        <div class="editor-tabs">
            <button class="editor-tab active" data-tab="js">JavaScript</button>
            <button class="editor-tab" data-tab="html">HTML</button>
            <button class="editor-tab" data-tab="css">CSS</button>
        </div>
        <div class="split-container">
            <div class="main-editor">
                <textarea id="js-editor"></textarea>
                <textarea id="html-editor" style="display: none;"></textarea>
                <textarea id="css-editor" style="display: none;"></textarea>
            </div>
            <div class="console-container" id="console-container">
                <div class="console-header">Console</div>
                <div class="console-content" id="console-content"></div>
            </div>
        </div>
        <div class="editor-footer">
            <input type="text" id="filename-input" placeholder="Enter object name">
            <button class="editor-btn" id="run-code">Run (Ctrl+Enter)</button>
            <button class="editor-btn" id="clear-console">Clear Console</button>
        </div>
        <div class="status-bar-code">Ready</div>
    </div>

    <div id="preview-container">
        <button id="close-preview">✖</button>
    </div>

    <div class="context-menu1" id="context-menu1">
        <div class="context-menu-item1" data-action="delete">Delete Node</div>
        <div class="context-menu-item1" data-action="duplicate">Duplicate Node</div>
    </div>
  
    <script>
        const toggleButton = document.getElementById('toggle-inspector');
        const inspectorPanel = document.getElementById('inspector-panel');
        const timeline1 = document.querySelector('.timeline');
        const nodeEditorExpend = document.querySelector('.node-editor');
        const animatorEditor = document.querySelector('.animator-container');
        const axisControls = document.querySelector('.axis-controls');
        const soundHeader = document.querySelector('.sound-controls-header');
        const storModal = document.querySelector('.site-modal-container');
        toggleButton.addEventListener('click', () => {
            const isInspectorOpen = !inspectorPanel.classList.contains('closed');
            
            inspectorPanel.classList.toggle('closed');
            
            if (isInspectorOpen) {
                // Expand timeline when inspector is closed
                timeline1.classList.add('expanded');
                nodeEditorExpend.classList.add('expanded');
                axisControls.classList.add('expanded');
                animatorEditor.classList.add('expanded');
                storModal.classList.add('expanded');
                soundHeader.classList.add('expanded');
            } else {
                // Restore timeline size when inspector is open
                timeline1.classList.remove('expanded');
                nodeEditorExpend.classList.remove('expanded');
                axisControls.classList.remove('expanded');
                animatorEditor.classList.remove('expanded');
                storModal.classList.remove('expanded');
                soundHeader.classList.remove('expanded');
            }
        });
        
    </script>

    <script>
    class PhysicsManager {
    constructor(scene, world) {
        this.scene = scene;
        this.world = world;
        this.physicsBodies = new Map();
        this.forces = new Set();
        this.collisionGroups = {
            DEFAULT: 1,
            TERRAIN: 2,
            DYNAMIC_OBJECTS: 4,
            KINEMATIC: 8,
            WIND_AFFECTED: 16
        };
        
        this.materials = {
            default: new CANNON.Material({
                friction: 0.5,
                restitution: 0.3
            }),
            bouncy: new CANNON.Material({
                friction: 0.3,
                restitution: 0.8
            }),
            rough: new CANNON.Material({
                friction: 0.8,
                restitution: 0.1
            })
        };

        // Debug visualization settings
        this.debugMode = false;
        this.debugBodies = new Map();
    }

    initPhysicsWorld() {
        this.world.gravity.set(0, -9.81, 0);
        this.world.broadphase = new CANNON.SAPBroadphase(this.world);
        this.world.solver.iterations = 20;
        this.world.allowSleep = true;

        // Contact material behaviors
        Object.values(this.materials).forEach((mat1) => {
            Object.values(this.materials).forEach((mat2) => {
                const contact = new CANNON.ContactMaterial(mat1, mat2, {
                    friction: Math.min(mat1.friction, mat2.friction),
                    restitution: Math.max(mat1.restitution, mat2.restitution),
                    contactEquationStiffness: 1e7,
                    contactEquationRelaxation: 3
                });
                this.world.addContactMaterial(contact);
            });
        });

        // Ground plane setup
        const groundShape = new CANNON.Plane();
        const groundBody = new CANNON.Body({
            mass: 0,
            material: this.materials.default,
            shape: groundShape,
            collisionFilterGroup: this.collisionGroups.TERRAIN,
            collisionFilterMask: this.collisionGroups.DEFAULT | this.collisionGroups.DYNAMIC_OBJECTS
        });
        groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI/2);
        this.world.addBody(groundBody);

        return this;
    }

    addPhysicsToObject(object, options = {}) {
    const box = new THREE.Box3().setFromObject(object);
    const size = new THREE.Vector3();
    box.getSize(size);

    let shape;
    if (object.geometry instanceof THREE.BoxGeometry) {
        shape = new CANNON.Box(new CANNON.Vec3(size.x/2, size.y/2, size.z/2));
    } else if (object.geometry instanceof THREE.SphereGeometry) {
        shape = new CANNON.Sphere(object.geometry.parameters.radius);
    } else if (object.geometry instanceof THREE.CylinderGeometry) {
        shape = new CANNON.Cylinder(
            object.geometry.parameters.radiusTop,
            object.geometry.parameters.radiusBottom,
            object.geometry.parameters.height,
            object.geometry.parameters.radialSegments
        );
    } else {
        shape = new CANNON.Box(new CANNON.Vec3(size.x/2, size.y/2, size.z/2));
    }

    // إنشاء مادة مخصصة بناءً على friction و restitution من الخيارات
    const customMaterial = new CANNON.Material({
        friction: options.friction !== undefined ? options.friction : 0.5,
        restitution: options.restitution !== undefined ? options.restitution : 0.3
    });

    const bodyOptions = {
        mass: options.mass || 1,
        position: new CANNON.Vec3(object.position.x, object.position.y, object.position.z),
        shape: shape,
        material: customMaterial, // استخدام المادة المخصصة
        linearDamping: options.linearDamping || 0.1,
        angularDamping: options.angularDamping || 0.1,
        collisionFilterGroup: options.group || this.collisionGroups.DYNAMIC_OBJECTS,
        collisionFilterMask: options.mask || 
            (this.collisionGroups.DEFAULT | this.collisionGroups.TERRAIN | this.collisionGroups.DYNAMIC_OBJECTS)
    };

    const body = new CANNON.Body(bodyOptions);

    if (options.velocity) {
        body.velocity.copy(options.velocity);
    }

    if (options.angularVelocity) {
        body.angularVelocity.copy(options.angularVelocity);
    }

    this.world.addBody(body);
    this.physicsBodies.set(object, body);

    body.addEventListener("collide", (event) => {
        if (options.onCollide) {
            options.onCollide(event);
        }
        this.handleCollision(event, object);
    });

    object.userData.physics = {
        enabled: true,
        body: body
    };

    return body;
}

    handleCollision(event, object) {
        const impact = event.contact.getImpactVelocityAlongNormal();
        
        // Visual feedback for collision
        if (Math.abs(impact) > 5) {
            this.createCollisionEffect(event.contact.bi.position);
        }

        // Sound feedback could be added here
        if (Math.abs(impact) > 3) {
            // Play collision sound based on impact force
        }
    }

    createCollisionEffect(position) {
        const particles = new THREE.Points(
            new THREE.BufferGeometry(),
            new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.1,
                transparent: true,
                opacity: 0.8
            })
        );

        const particleCount = 20;
        const positions = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount * 3; i += 3) {
            const offset = new THREE.Vector3(
                (Math.random() - 0.5) * 0.5,
                (Math.random() - 0.5) * 0.5,
                (Math.random() - 0.5) * 0.5
            );
            positions[i] = position.x + offset.x;
            positions[i + 1] = position.y + offset.y;
            positions[i + 2] = position.z + offset.z;
        }

        particles.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        this.scene.add(particles);

        // Animate and remove particles
        const startTime = Date.now();
        const animate = () => {
            const elapsed = Date.now() - startTime;
            if (elapsed > 1000) {
                this.scene.remove(particles);
                return;
            }

            const positions = particles.geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                positions[i + 1] += 0.01; // Move particles upward
            }
            particles.geometry.attributes.position.needsUpdate = true;
            particles.material.opacity = 1 - (elapsed / 1000);

            requestAnimationFrame(animate);
        };
        animate();
    }

    createWindZone(position, direction, strength, radius) {
        const windForce = {
            type: 'wind',
            position: position.clone(),
            direction: direction.normalize(),
            strength: strength,
            radius: radius,
            apply: (body) => {
                // Calculate distance to body
                const distance = position.distanceTo(body.position);
                
                if (distance <= radius) {
                    // Scale force based on distance from center
                    const forceMagnitude = strength * (1 - distance / radius);
                    const force = direction.clone().multiplyScalar(forceMagnitude);
                    
                    // Apply force to physics body
                    body.applyForce(
                        new CANNON.Vec3(force.x, force.y, force.z),
                        body.position
                    );
                }
            }
        };
        this.forces.push(windForce);
        return windForce;
    }

    createVortexZone(position, axis, strength, radius) {
        const vortexForce = {
            type: 'vortex',
            position: position.clone(),
            axis: axis.normalize(),
            strength: strength,
            radius: radius,
            apply: (body) => {
                const bodyPos = new THREE.Vector3(
                    body.position.x,
                    body.position.y,
                    body.position.z
                );
                
                const distance = position.distanceTo(bodyPos);
                
                if (distance <= radius) {
                    // Calculate tangential direction for vortex
                    const toCenter = bodyPos.clone().sub(position);
                    const tangent = toCenter.cross(axis).normalize();
                    
                    // Scale force based on distance
                    const forceMagnitude = strength * (distance / radius);
                    const force = tangent.multiplyScalar(forceMagnitude);
                    
                    body.applyForce(
                        new CANNON.Vec3(force.x, force.y, force.z),
                        body.position
                    );
                }
            }
        };
        this.forces.push(vortexForce);
        return vortexForce;
    }

    applyForces(bodies) {
        this.forces.forEach(force => {
            bodies.forEach(body => force.apply(body));
        });
    }

  
    updatePhysics() {
        // Apply forces before stepping the world
        for (const force of this.forces) {
            for (const body of this.world.bodies) {
                if (body.mass > 0) { // Only apply to non-static bodies
                    force.apply(body);
                }
            }
        }
        this.physicsBodies.forEach((body) => {
            this.forces.forEach(force => {
                if (force.active && body.mass > 0) {
                    force.apply(body);
                }
            });
        });

        this.world.step(1/60);

        // Update object positions
        this.physicsBodies.forEach((body, object) => {
            object.position.copy(body.position);
            object.quaternion.copy(body.quaternion);
        });
    }
  
}




function createWindZoneVisual(position, radius, strength) {
    const group = new THREE.Group();
    
    // Main cylinder with improved visibility
    const cylinderGeometry = new THREE.CylinderGeometry(radius, radius, radius * 2, 32, 1, true);
    const cylinderMaterial = new THREE.MeshBasicMaterial({
        color: 0x00ff88,
        transparent: true,
        opacity: 0.2,
        wireframe: true,
        side: THREE.DoubleSide
    });
    const cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
    
    // Direction arrows
    const arrowCount = 8;
    const arrowGroup = new THREE.Group();
    for (let i = 0; i < arrowCount; i++) {
        const arrowHelper = new THREE.ArrowHelper(
            new THREE.Vector3(1, 0, 0),
            new THREE.Vector3(0, 0, 0),
            radius * 0.8,
            0x00ff88,
            radius * 0.2,
            radius * 0.1
        );
        arrowHelper.position.y = (Math.random() - 0.5) * radius;
        arrowHelper.position.z = (Math.random() - 0.5) * radius;
        arrowGroup.add(arrowHelper);
    }

    // Particle system for wind visualization
    const particleCount = 100;
    const particleGeometry = new THREE.BufferGeometry();
    const particlePositions = new Float32Array(particleCount * 3);
    const particleSizes = new Float32Array(particleCount);
    
    for (let i = 0; i < particleCount; i++) {
        const x = (Math.random() - 0.5) * radius * 2;
        const y = (Math.random() - 0.5) * radius * 2;
        const z = (Math.random() - 0.5) * radius * 2;
        
        particlePositions[i * 3] = x;
        particlePositions[i * 3 + 1] = y;
        particlePositions[i * 3 + 2] = z;
        particleSizes[i] = Math.random() * 0.2 + 0.1;
    }
    
    particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
    particleGeometry.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));
    
    const particleMaterial = new THREE.PointsMaterial({
        color: 0x00ff88,
        size: 0.1,
        transparent: true,
        opacity: 0.6,
        sizeAttenuation: true
    });
    
    const particles = new THREE.Points(particleGeometry, particleMaterial);
    
    group.add(cylinder);
    group.add(arrowGroup);
    group.add(particles);
    group.position.copy(position);
    addObjectToScene(group, 'Wind Zone');
    // Animation
    let time = 0;
    group.animate = () => {
        time += 0.016 * strength;
        
        // Animate particles
        const positions = particles.geometry.attributes.position.array;
        for (let i = 0; i < particleCount; i++) {
            positions[i * 3] += 0.1 * strength;
            if (positions[i * 3] > radius) {
                positions[i * 3] = -radius;
            }
        }
        particles.geometry.attributes.position.needsUpdate = true;
        
        // Rotate arrows
        arrowGroup.children.forEach((arrow, i) => {
            arrow.position.x = Math.sin(time + i) * radius * 0.2;
        });
        
        // Pulse cylinder
        cylinder.scale.x = 1 + Math.sin(time) * 0.1;
        cylinder.scale.z = 1 + Math.sin(time) * 0.1;
    };

    return group;
}

function createVortexVisual(position, radius, strength) {
    const group = new THREE.Group();

    // Main torus
    const torusGeometry = new THREE.TorusGeometry(radius * 0.7, radius * 0.05, 16, 100);
    const torusMaterial = new THREE.MeshBasicMaterial({
        color: 0x3F51B5,
        transparent: true,
        opacity: 0.5,
        wireframe: true
    });
    const torus = new THREE.Mesh(torusGeometry, torusMaterial);

    // Spiral lines
    const spiralCount = 3;
    const pointsPerSpiral = 100;
    const spiralGroup = new THREE.Group();
    
    for (let s = 0; s < spiralCount; s++) {
        const spiralPoints = [];
        const angleOffset = (s * Math.PI * 2) / spiralCount;
        
        for (let i = 0; i < pointsPerSpiral; i++) {
            const t = i / (pointsPerSpiral - 1);
            const angle = t * Math.PI * 4 + angleOffset;
            const radiusAt = radius * (0.2 + t * 0.8);
            
            spiralPoints.push(new THREE.Vector3(
                radiusAt * Math.cos(angle),
                t * radius * 2 - radius,
                radiusAt * Math.sin(angle)
            ));
        }
        
        const spiralGeometry = new THREE.BufferGeometry().setFromPoints(spiralPoints);
        const spiralMaterial = new THREE.LineBasicMaterial({
            color: 0x5C6BC0,
            transparent: true,
            opacity: 0.7
        });
        const spiralLine = new THREE.Line(spiralGeometry, spiralMaterial);
        spiralGroup.add(spiralLine);
    }

    // Particle system
    const particleCount = 300;
    const particleGeometry = new THREE.BufferGeometry();
    const particlePositions = new Float32Array(particleCount * 3);
    const particleData = [];
    
    for (let i = 0; i < particleCount; i++) {
        const angle = Math.random() * Math.PI * 2;
        const radiusAt = radius * (0.2 + Math.random() * 0.8);
        const height = (Math.random() - 0.5) * radius * 2;
        
        particlePositions[i * 3] = Math.cos(angle) * radiusAt;
        particlePositions[i * 3 + 1] = height;
        particlePositions[i * 3 + 2] = Math.sin(angle) * radiusAt;
        
        particleData.push({
            angle,
            radius: radiusAt,
            height,
            speed: (0.5 + Math.random() * 0.5) * strength
        });
    }
    
    particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
    
    const particleMaterial = new THREE.PointsMaterial({
        color: 0x5C6BC0,
        size: 0.1,
        transparent: true,
        opacity: 0.8
    });
    
    const particles = new THREE.Points(particleGeometry, particleMaterial);

    group.add(torus);
    group.add(spiralGroup);
    group.add(particles);
    group.position.copy(position);
    addObjectToScene(group, 'Vortex Wind');
    // Animation
    let time = 0;
    group.animate = () => {
        time += 0.016 * strength;
        
        // Rotate torus
        torus.rotation.y += 0.02 * strength;
        
        // Rotate spiral lines
        spiralGroup.rotation.y += 0.01 * strength;
        
        // Animate particles
        const positions = particles.geometry.attributes.position.array;
        for (let i = 0; i < particleCount; i++) {
            const data = particleData[i];
            data.angle += data.speed * 0.02;
            
            positions[i * 3] = Math.cos(data.angle) * data.radius;
            positions[i * 3 + 1] = data.height + Math.sin(time + i) * 0.1;
            positions[i * 3 + 2] = Math.sin(data.angle) * data.radius;
        }
        particles.geometry.attributes.position.needsUpdate = true;
    };

    return group;
}
        
        function addDemonstrationObjects() {
            // Add some boxes and spheres with different materials
            for (let i = 0; i < 5; i++) {
                const size = 1 + Math.random() * 0.5;
                const geometry = Math.random() > 0.5 ? 
                    new THREE.BoxGeometry(size, size, size) :
                    new THREE.SphereGeometry(size/2, 16, 16);
                
                const material = new THREE.MeshStandardMaterial({
                    color: new THREE.Color().setHSL(Math.random(), 0.7, 0.5),
                    roughness: 0.7,
                    metalness: 0.3
                });

                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(
                    (Math.random() - 0.5) * 10,
                    5 + i * 2,
                    (Math.random() - 0.5) * 10
                );
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                addObjectToScene(mesh, 'Physic demostration shapes')

                scene.add(mesh);
                physicsManager.addPhysicsToObject(mesh, {
                    mass: 1,
                    friction: 0.9,
                    restitution: 0.7
                });
            }
        }

      
        function initPhysics() {
           world = new CANNON.World();
           world.gravity.set(0, -9.81, 0); // Apply gravity

           physicsManager = new PhysicsManager(scene, world).initPhysicsWorld();
          
            // Create a static floor for physics
            const floorShape = new CANNON.Plane();
            const floorBody = new CANNON.Body({
               mass: 0, // Static object (does not move)
               shape: floorShape,
               position: new CANNON.Vec3(0, 0, 0),
               quaternion: new CANNON.Quaternion().setFromEuler(-Math.PI / 2, 0, 0),
            });

            world.addBody(floorBody);

            // visual plane for the floor
            const floorGeometry = new THREE.PlaneGeometry(1000, 1000);
            const floorMaterial = new THREE.MeshStandardMaterial({
               color: 0xffffff,
               transparent: true,
               opacity: 0,
               side: THREE.DoubleSide,
            });
            const floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
            floorMesh.rotation.x = -Math.PI / 2;
            floorMesh.receiveShadow = true;

            scene.add(floorMesh);

// Add to PhysicsManager class
PhysicsManager.prototype.initClothSystem = function() {
    this.clothSystem = new ClothSystem(this);
    return this.clothSystem;
};



// Update physics loop
const originalUpdatePhysics = PhysicsManager.prototype.updatePhysics;
PhysicsManager.prototype.updatePhysics = function() {
    originalUpdatePhysics.call(this);
    if (this.clothSystem) {
        this.clothSystem.updateCloth();
    }
};

            //Listeners
            document.getElementById('gravity-strength').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                world.gravity.set(0, value, 0); // ✅ Update gravity dynamically
                document.getElementById('gravity-value').textContent = value.toFixed(2);
            });

             // Apply Wind
             document.getElementById('add-wind').addEventListener('click', () => {
               const strength = parseFloat(document.getElementById('wind-strength').value);
               const radius = parseFloat(document.getElementById('wind-radius').value);
               const position = controls.target.clone();
               const direction = new THREE.Vector3(1, 0, 0);
    
               const windVisual = createWindZoneVisual(position, radius, strength);
               scene.add(windVisual);
    
               const windForce = physicsManager.createWindZone(position, direction, strength, radius);
               windForce.visual = windVisual;
            });

            // Apply Vortex
            document.getElementById('add-vortex').addEventListener('click', () => {
                const strength = parseFloat(document.getElementById('wind-strength').value);
                const radius = parseFloat(document.getElementById('wind-radius').value);
                const position = controls.target.clone();
                const axis = new THREE.Vector3(0, 1, 0);
    
                const vortexVisual = createVortexVisual(position, radius, strength);
                scene.add(vortexVisual);
    
                const vortexForce = physicsManager.createVortexZone(position, axis, strength, radius);
                vortexForce.visual = vortexVisual;
            });



    }

        
    </script>

  
<script>
// Character Sculpting Constants and State
const CHARACTER_TOOLS = {
    FACE_SHAPE: 'faceShape',
    NOSE_SCULPT: 'noseSculpt',
    CHEEK_DEFINITION: 'cheekDefinition',
    JAW_SCULPT: 'jawSculpt',
    FOREHEAD_SHAPE: 'foreheadShape',
    CHIN_SCULPT: 'chinSculpt',
    TEMPLE_SCULPT: 'templeSculpt',
    BROW_RIDGE: 'browRidge',
    EYE_SOCKET: 'eyeSocket',
    LIP_SHAPE: 'lipShape',
    SMOOTH: 'smooth',
    PINCH: 'pinch',
    INFLATE: 'inflate',
    CREASE: 'crease',
    SNAKE_HOOK: 'snakeHook',
    HAIR_BRUSH: 'hairBrush'
};

// Hair system state
let physicsEnabled = false;
let physicsAnimationId = null;
let hairBrushActive = false;
let maxHairStrandsPerOperation = 10; // Limit strands added per brush stroke

const hairBrushSettings = {
    numSegments: 5,
    segmentLength: 0.05,
    stiffness: 0.8,
    gravity: 0.5, // Reduced from 0.9
    windStrength: 0.3, // Reduced from 0.6
    turbulence: 0.1, // Reduced from 0.2
    springStiffness: 0.8,
    damping: 0.4, // Increased from 0.3
    airResistance: 0.05, // Increased from 0.02
    thickness: 0.004, // Reduced from 0.005
    density: 50, // Reduced from 100
    maxStrands: 1000, // Reduced from 5000
    curl: 0.2,
    randomness: 0.1,
    clumpSize: 3,
    frizz: 0.1,
    wave: 0.2,
    hairStrands: [],
    guides: [],
    materialType: 'standard',
    hairColor: 0x3a1a00,
    specularColor: 0x8B4513,
    useInstancing: true, // Option to toggle between instanced and merged geometry
    lastUpdateTime: 0,
    updateInterval: 100, // ms between updates
    batchSize: 50 // Process this many strands per frame
};



// Optimized hair strand class
class HairStrand {
    constructor(rootPosition, normal) {
        this.segments = [];
        this.initialDirection = normal.clone();
        this.springConstant = hairBrushSettings.stiffness;
        this.damping = hairBrushSettings.damping;
        this.airResistance = hairBrushSettings.airResistance;
        this.rootPosition = rootPosition.clone();
        this.normal = normal.clone();
        this.needsUpdate = true;
        this.lastUpdateTime = 0;
        
        this.initializeSegments();
    }
    
    initializeSegments() {
        let currentPos = this.rootPosition.clone();
        
        for (let i = 0; i < hairBrushSettings.numSegments; i++) {
            const t = i / hairBrushSettings.numSegments;
            
            // Create natural curved shape with controlled randomness
            const wave = Math.sin(i * hairBrushSettings.wave * Math.PI) * hairBrushSettings.curl;
            const spiral = new THREE.Vector3(
                Math.cos(t * 2 * Math.PI * hairBrushSettings.curl),
                Math.sin(t * 2 * Math.PI * hairBrushSettings.curl),
                0
            ).multiplyScalar(hairBrushSettings.curl * 0.1);

            const offset = new THREE.Vector3(
                Math.sin(i + wave) * hairBrushSettings.randomness,
                Math.cos(i + wave) * hairBrushSettings.randomness,
                Math.sin((i + wave) * 0.5) * hairBrushSettings.randomness
            ).add(spiral);

            // Add more frizz toward the tips
            const frizzScale = Math.pow(t, 0.5);
            const frizz = new THREE.Vector3(
                (Math.random() - 0.5) * hairBrushSettings.frizz * frizzScale,
                (Math.random() - 0.5) * hairBrushSettings.frizz * frizzScale,
                (Math.random() - 0.5) * hairBrushSettings.frizz * frizzScale
            );

            this.segments.push({
                position: currentPos.clone(),
                prevPosition: currentPos.clone(),
                velocity: new THREE.Vector3(),
                force: new THREE.Vector3(),
                mass: 1 - (t * 0.5), // Tips are lighter
                locked: i === 0, // Root is locked
                normal: this.normal.clone()
            });

            // Calculate next segment position
            const direction = this.normal.clone()
                .add(offset)
                .add(frizz)
                .normalize()
                .multiplyScalar(hairBrushSettings.segmentLength * (1 - t * 0.2));

            currentPos.add(direction);
        }
    }

    update(deltaTime) {
        if (!physicsEnabled) return false;
        
        const now = performance.now();
        if (now - this.lastUpdateTime < 16) return false;
        this.lastUpdateTime = now;
        
        const gravity = new THREE.Vector3(0, -hairBrushSettings.gravity * 9.81, 0);
        const windTime = Date.now() * 0.0005;
        const wind = new THREE.Vector3(
            Math.sin(windTime) * hairBrushSettings.windStrength,
            0,
            Math.cos(windTime * 1.3) * hairBrushSettings.windStrength
        );
        
        let hasChanged = false;
        
        for (let i = 1; i < this.segments.length; i++) {
            const segment = this.segments[i];
            if (segment.locked) continue;
            
            segment.force.set(0, 0, 0);
            
            const massFactor = 1 - (i / this.segments.length) * 0.7;
            segment.force.add(gravity.clone().multiplyScalar(segment.mass * massFactor));
            
            const windFactor = 1 - (i / this.segments.length) * 0.5;
            segment.force.add(wind.clone().multiplyScalar(windFactor * hairBrushSettings.airResistance));
            
            const targetPos = this.segments[i - 1].position.clone()
                .add(this.initialDirection.clone()
                    .multiplyScalar(hairBrushSettings.segmentLength)
                    .applyAxisAngle(new THREE.Vector3(0, 0, 1), hairBrushSettings.curl * Math.PI * i / this.segments.length));
            const springForce = targetPos.sub(segment.position).multiplyScalar(hairBrushSettings.stiffness);
            segment.force.add(springForce);
            
            if (Math.random() > 0.8) {
                const frizzForce = new THREE.Vector3(
                    (Math.random() - 0.5) * hairBrushSettings.frizz,
                    (Math.random() - 0.5) * hairBrushSettings.frizz,
                    (Math.random() - 0.5) * hairBrushSettings.frizz
                ).multiplyScalar(1 - i / this.segments.length);
                segment.force.add(frizzForce);
            }

            const distToRoot = segment.position.distanceTo(this.rootPosition);
            if (distToRoot < 1.02 && i === 1) {
                segment.position.copy(this.rootPosition.clone().add(this.initialDirection.clone().multiplyScalar(0.02)));
                segment.velocity.set(0, 0, 0);
            } else if (distToRoot < 1.02) {
                const normal = segment.position.clone().normalize();
                segment.position.copy(normal.multiplyScalar(1.02));
                segment.velocity.projectOnPlane(normal).multiplyScalar(0.5);
                hasChanged = true;
            }

            const acceleration = segment.force.clone().divideScalar(segment.mass);
            segment.velocity.add(acceleration.multiplyScalar(deltaTime));
            segment.velocity.multiplyScalar(1 - this.damping);
            
            const oldPos = segment.position.clone();
            segment.position.add(segment.velocity.clone().multiplyScalar(deltaTime));
            
            if (oldPos.distanceToSquared(segment.position) > 0.00001) {
                hasChanged = true;
            }
        }
        
        if (hasChanged) {
            this.applyConstraints();
        }
        
        return hasChanged;
    }


    applyConstraints() {
        // Maintain segment lengths
        for (let i = 0; i < this.segments.length - 1; i++) {
            const segA = this.segments[i];
            const segB = this.segments[i + 1];
            
            const diff = segB.position.clone().sub(segA.position);
            const currentLength = diff.length();
            
            if (Math.abs(currentLength - hairBrushSettings.segmentLength) < 0.001) {
                continue; // Skip if length is already correct (optimization)
            }
            
            const correction = diff.normalize().multiplyScalar(
                hairBrushSettings.segmentLength - currentLength
            ).multiplyScalar(this.springConstant);

            // Apply correction based on locked state
            if (!segA.locked) segA.position.sub(correction.clone().multiplyScalar(0.5));
            if (!segB.locked) segB.position.add(correction.clone().multiplyScalar(0.5));
        }
        
        // Optional: Add shape memory - try to maintain original angles
        this.applyShapeMemory();
    }
    
    applyShapeMemory() {
        // Simple version: pull segments toward initial direction
        const memoryStrength = 0.03; // Subtle effect
        
        for (let i = 1; i < this.segments.length; i++) {
            const segment = this.segments[i];
            if (segment.locked) continue;
            
            // Calculate ideal position based on root and initial direction
            const t = i / hairBrushSettings.numSegments;
            const idealOffset = this.initialDirection.clone()
                .multiplyScalar(hairBrushSettings.segmentLength * i);
            const idealPos = this.rootPosition.clone().add(idealOffset);
            
            // Pull slightly toward ideal position (stronger at root, weaker at tip)
            const pullStrength = memoryStrength * (1 - t * 0.8);
            segment.position.lerp(idealPos, pullStrength);
        }
    }

    getMatrix() {
        const points = this.segments.map(seg => seg.position);
        const curve = new THREE.CatmullRomCurve3(points);
        const matrix = new THREE.Matrix4().setPosition(this.rootPosition);
        const quaternion = new THREE.Quaternion().setFromUnitVectors(
            new THREE.Vector3(0, 1, 0),
            this.normal
        );
        matrix.makeRotationFromQuaternion(quaternion);
        return { matrix, curve, points };
    }
}

// Hair mesh management
let hairInstanceMesh = null;
let mergedHairGeometry = null;
let hairMesh = null;

// Create hair mesh using instancing (more efficient)
function createInstancedHairMesh() {
    if (hairInstanceMesh) {
        hairInstanceMesh.geometry.dispose();
        hairInstanceMesh.material.dispose();
        sculptingSphere.remove(hairInstanceMesh);
        hairInstanceMesh = null;
    }
    
    const strandCurve = new THREE.CatmullRomCurve3([
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(0, hairBrushSettings.segmentLength * hairBrushSettings.numSegments * 0.25, 0),
        new THREE.Vector3(0, hairBrushSettings.segmentLength * hairBrushSettings.numSegments * 0.5, 0),
        new THREE.Vector3(0, hairBrushSettings.segmentLength * hairBrushSettings.numSegments * 0.75, 0),
        new THREE.Vector3(0, hairBrushSettings.segmentLength * hairBrushSettings.numSegments, 0)
    ]);
    
    const strandGeometry = new THREE.TubeGeometry(
        strandCurve,
        hairBrushSettings.numSegments,
        hairBrushSettings.thickness * (0.8 + Math.random() * hairBrushSettings.clumpSize * 0.1),
        8, // More radial segments for detail
        false
    );

    const material = new THREE.MeshPhysicalMaterial({
        color: hairBrushSettings.hairColor,
        roughness: 0.3,
        metalness: 0.2,
        clearcoat: 0.4,
        clearcoatRoughness: 0.25,
        sheen: 1.0,
        sheenRoughness: 0.3,
        sheenColor: hairBrushSettings.specularColor,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.95
    });

    hairInstanceMesh = new THREE.InstancedMesh(strandGeometry, material, hairBrushSettings.maxStrands);
    hairInstanceMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    hairInstanceMesh.castShadow = true;
    hairInstanceMesh.receiveShadow = false;
    hairInstanceMesh.frustumCulled = false;

    const dummyMatrix = new THREE.Matrix4();
    for (let i = 0; i < hairBrushSettings.maxStrands; i++) {
        hairInstanceMesh.setMatrixAt(i, dummyMatrix);
    }
    
    hairInstanceMesh.instanceMatrix.needsUpdate = true;
    if (sculptingSphere) sculptingSphere.add(hairInstanceMesh);
    console.log("Instanced hair mesh created with capacity:", hairBrushSettings.maxStrands);
    return hairInstanceMesh;
}

// Alternative: Create merged hair geometry (better for fewer strands)
function createMergedHairGeometry() {
    console.log("Creating merged hair geometry...");
    
    // Clean up previous mesh
    if (hairMesh) {
        hairMesh.geometry.dispose();
        hairMesh.material.dispose();
        sculptingSphere.remove(hairMesh);
        hairMesh = null;
    }
    
    // Create material with hair appearance
    const material = new THREE.MeshPhysicalMaterial({
        color: hairBrushSettings.hairColor,
        roughness: 0.3,
        metalness: 0.2,
        clearcoat: 0.4,
        clearcoatRoughness: 0.25,
        sheen: 1.0,
        sheenRoughness: 0.3,
        sheenColor: hairBrushSettings.specularColor,
        side: THREE.DoubleSide
    });
    
    // Initialize empty geometry
    mergedHairGeometry = new THREE.BufferGeometry();
    hairMesh = new THREE.Mesh(mergedHairGeometry, material);
    hairMesh.castShadow = true;
    hairMesh.receiveShadow = false;
    sculptingSphere.add(hairMesh);
    
    return hairMesh;
}

// Efficiently update hair visualization
function updateHairMesh() {
    const now = performance.now();
    
    // Throttle updates for performance
    if (now - hairBrushSettings.lastUpdateTime < hairBrushSettings.updateInterval && 
        !hairBrushActive) {
        return;
    }
    
    hairBrushSettings.lastUpdateTime = now;
    
    if (hairBrushSettings.useInstancing) {
        updateInstancedHair();
    } else {
        updateMergedHair();
    }
}

// Update instanced hair representation
function updateInstancedHair() {
    if (!hairInstanceMesh) {
        console.warn("hairInstanceMesh is not initialized!");
        return;
    }

    const strands = hairBrushSettings.hairStrands;
    const strandCount = Math.min(strands.length, hairBrushSettings.maxStrands);
    
    // Process in batches
    const batchStart = Math.floor(Date.now() / 100) % Math.max(1, Math.floor(strandCount / hairBrushSettings.batchSize)) * hairBrushSettings.batchSize;
    const batchEnd = Math.min(batchStart + hairBrushSettings.batchSize, strandCount);
    
    // Only update a subset of strands per frame
    for (let i = batchStart; i < batchEnd; i++) {
        if (i < strandCount) {
            const strand = strands[i];
            const { matrix } = strand.getMatrix();
            hairInstanceMesh.setMatrixAt(i, matrix);
        }
    }
    
    hairInstanceMesh.instanceMatrix.needsUpdate = true;
}

// Update merged geometry hair representation
function updateMergedHair() {
    if (!hairMesh || !mergedHairGeometry) {
        console.warn("hairMesh or mergedHairGeometry not initialized!");
        return;
    }
    
    // Only rebuild complete geometry occasionally
    const now = Date.now();
    if (now - hairBrushSettings.lastRebuild < 500 && !hairBrushActive) {
        return;
    }
    hairBrushSettings.lastRebuild = now;
    
    const strands = hairBrushSettings.hairStrands;
    const strandCount = Math.min(strands.length, hairBrushSettings.maxStrands);
    
    // For small strand counts, using merged geometry can be faster
    const geometries = [];
    for (let i = 0; i < strandCount; i++) {
        const strand = strands[i];
        const { points } = strand.getMatrix();
        
        // Create curve from points
        const curve = new THREE.CatmullRomCurve3(points);
        
        // Create tube geometry
        const tubeGeometry = new THREE.TubeGeometry(
            curve,
            hairBrushSettings.numSegments,
            hairBrushSettings.thickness * (0.8 + Math.random() * 0.4), // Slight variation
            4,
            false
        );
        
        geometries.push(tubeGeometry);
    }
    
    // Merge all geometries
    mergedHairGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries(geometries);
    hairMesh.geometry = mergedHairGeometry;
}

// Apply hair brush with efficient strand creation
function applyHairBrush(event, vertices, position, normal) {
    if (!hairBrushActive || event.buttons !== 1 || !position || !normal || !sculptingEnabled) return;
    
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(new THREE.Vector2(
        (event.clientX / window.innerWidth) * 2 - 1,
        -(event.clientY / window.innerHeight) * 2 + 1
    ), camera);
    
    const intersects = raycaster.intersectObject(sculptingSphere);
    if (intersects.length > 0 && sculptingSphere) {
        const intersect = intersects[0];
        const hitPosition = intersect.point.clone();
        const hitNormal = intersect.face.normal.clone().normalize();

        const brushRadius = characterBrushSize * 0.5; // Scale for visibility
        const density = hairBrushSettings.density / 100;
        const area = Math.PI * brushRadius * brushRadius;
        const strandsToAdd = Math.min(
            Math.floor(area * density),
            maxHairStrandsPerOperation,
            hairBrushSettings.maxStrands - hairBrushSettings.hairStrands.length
        );

        let strandsAdded = 0;
        for (let i = 0; i < strandsToAdd; i++) {
            const theta = Math.random() * 2 * Math.PI;
            const r = brushRadius * Math.sqrt(Math.random());
            
            const tangent = new THREE.Vector3(1, 0, 0).cross(hitNormal).normalize();
            if (tangent.lengthSq() < 0.01) tangent.set(0, 0, 1).cross(hitNormal).normalize();
            const bitangent = new THREE.Vector3().crossVectors(hitNormal, tangent).normalize();
            
            const offsetPosition = hitPosition.clone().add(
                tangent.clone().multiplyScalar(Math.cos(theta) * r)
            ).add(
                bitangent.clone().multiplyScalar(Math.sin(theta) * r)
            );
            
            const normalVariation = new THREE.Vector3(
                (Math.random() - 0.5) * 0.1,
                (Math.random() - 0.5) * 0.1,
                (Math.random() - 0.5) * 0.1
            );
            const strandNormal = hitNormal.clone().add(normalVariation).normalize();
            
            const strand = new HairStrand(offsetPosition, strandNormal);
            strand.initialDirection.copy(hitNormal);
            
            if (!hairBrushSettings.hairStrands.some(s => s.rootPosition.distanceTo(offsetPosition) < 0.01)) {
                hairBrushSettings.hairStrands.push(strand);
                strandsAdded++;
            }
        }

        if (!hairInstanceMesh) {
            createInstancedHairMesh();
        }
        if (!sculptingSphere.children.includes(hairInstanceMesh)) {
            sculptingSphere.add(hairInstanceMesh);
        }
        updateHairMesh(); // Force update
        console.log(`Added ${strandsAdded} strands at ${hitPosition.x}, ${hitPosition.y}, ${hitPosition.z}, Total strands: ${hairBrushSettings.hairStrands.length}`);

        // Update UI stats
        document.getElementById('strandCount').textContent = hairBrushSettings.hairStrands.length;
    }

    setTimeout(() => {
        hairBrushActive = false;
    }, 100);
}

// Efficiently update hair physics with animation frame management
function updateHairPhysics(deltaTime = 1/60) {
    if (!physicsEnabled) {
        if (physicsAnimationId) {
            cancelAnimationFrame(physicsAnimationId);
            physicsAnimationId = null;
        }
        return;
    }
    
    const batchSize = hairBrushSettings.batchSize;
    const startIndex = Math.floor(Date.now() / 32) % Math.max(1, Math.ceil(hairBrushSettings.hairStrands.length / batchSize)) * batchSize;
    const endIndex = Math.min(startIndex + batchSize, hairBrushSettings.hairStrands.length);
    
    let needsUpdate = false;
    
    for (let i = startIndex; i < endIndex; i++) {
        if (i < hairBrushSettings.hairStrands.length) {
            const changed = hairBrushSettings.hairStrands[i].update(deltaTime);
            needsUpdate = needsUpdate || changed;
        }
    }
    
    if (needsUpdate || hairBrushActive) {
        updateHairMesh();
    }
    
    physicsAnimationId = requestAnimationFrame(() => updateHairPhysics(deltaTime));
}

// Add initial gravity setting if not present in hairBrushSettings
if (!hairBrushSettings.gravity) {
    hairBrushSettings.gravity = 0.1; // Adjustable gravity strength
}
if (!hairBrushSettings.damping) {
    hairBrushSettings.damping = 0.1; // Default damping
}
if (!hairBrushSettings.windStrength) {
    hairBrushSettings.windStrength = 0.05; // Default wind strength
}
if (!hairBrushSettings.turbulence) {
    hairBrushSettings.turbulence = 0.02; // Default turbulence
}



// Character modeling variables
let selectedCharacterTool = null;
let isCharacterSculpting = false;
let characterBrushSize = 0.2;
let characterBrushStrength = 0.1;
let characterBrushFalloff = 0.5;
let sculptingSphere = null;
let characterUndoStack = [];
let characterRedoStack = [];

function setupLighting() {
    // Clear existing lights if any (optional, depends on your scene setup)
    scene.children = scene.children.filter(child => !(child instanceof THREE.Light));

    // 1. Ambient Light (soft base illumination)
    const ambientLight = new THREE.AmbientLight(0x404040, 0.5); // Soft gray light, moderate intensity
    scene.add(ambientLight);

    // 2. Key Light (main directional light)
    const keyLight = new THREE.DirectionalLight(0xffffff, 0.8);
    keyLight.position.set(5, 5, 5); // Positioned above and to the front-right
    keyLight.castShadow = true;
    keyLight.shadow.mapSize.width = 2048; // Higher resolution shadows
    keyLight.shadow.mapSize.height = 2048;
    keyLight.shadow.camera.near = 0.5;
    keyLight.shadow.camera.far = 50;
    keyLight.shadow.camera.left = -10;
    keyLight.shadow.camera.right = 10;
    keyLight.shadow.camera.top = 10;
    keyLight.shadow.camera.bottom = -10;
    keyLight.shadow.bias = -0.0001; // Reduce shadow acne
    scene.add(keyLight);

    // 3. Fill Light (softer light to reduce shadow harshness)
    const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
    fillLight.position.set(-5, 3, -5); // Positioned to the front-left
    fillLight.castShadow = false; // No shadows from fill light
    scene.add(fillLight);

    // 4. Rim Light (backlight for edge definition)
    const rimLight = new THREE.DirectionalLight(0xffffff, 0.6);
    rimLight.position.set(0, 5, -7); // Positioned behind and above
    rimLight.castShadow = false; // No shadows from rim light
    scene.add(rimLight);

    // Optional: Add a helper to visualize light positions (remove in production)
    // scene.add(new THREE.DirectionalLightHelper(keyLight, 1));
    // scene.add(new THREE.DirectionalLightHelper(fillLight, 1));
    // scene.add(new THREE.DirectionalLightHelper(rimLight, 1));
}

// Add main sculpting sphere
function addSculptingSphere() {
    console.log("Adding sculpting sphere...");
    const geometry = new THREE.SphereGeometry(1, 256, 256);
    const material = new THREE.MeshStandardMaterial({
        color: 0xF5DEB3,
        roughness: 0.6,
        metalness: 0.05,
        flatShading: false,
        emissive: 0x331A00,
        emissiveIntensity: 0.02,
        transmission: 0.1,
        thickness: 0.5,
        envMapIntensity: 0.5
    });

    sculptingSphere = new THREE.Mesh(geometry, material);
    sculptingSphere.name = 'SculptingSphere';
    sculptingSphere.castShadow = true;
    sculptingSphere.receiveShadow = true;
    sculptingSphere.userData.isSculptable = true;

    scene.add(sculptingSphere); // Ensure added to scene
    createCharacterBrushPreview();
    setupCharacterSculptingEvents();
    addObjectToScene(sculptingSphere, 'Sculpting_Sphere');

    if (hairBrushSettings.useInstancing) {
        createInstancedHairMesh();
    } else {
        createMergedHairGeometry();
    }

    setupLighting();
    return sculptingSphere;
}

// Create brush preview for better user feedback
function createCharacterBrushPreview() {
    if (window.characterBrushPreview) {
        scene.remove(window.characterBrushPreview);
    }

    // Create brush preview group
    const brushPreview = new THREE.Group();
    
    // Inner sphere for brush center
    const innerSphereGeometry = new THREE.SphereGeometry(characterBrushSize * 0.25, 16, 16);
    const innerSphereMaterial = new THREE.MeshBasicMaterial({
        color: 0x00FFFF,
        transparent: true,
        opacity: 0.5,
        depthTest: false
    });
    const innerSphere = new THREE.Mesh(innerSphereGeometry, innerSphereMaterial);

    // Falloff ring to show brush falloff area
    const falloffRingGeometry = new THREE.RingGeometry(
        characterBrushSize * 0.5, 
        characterBrushSize * 0.7, 
        32
    );
    const falloffRingMaterial = new THREE.MeshBasicMaterial({
        color: 0x00FF00,
        transparent: true,
        opacity: 0.3,
        side: THREE.DoubleSide,
        depthTest: false
    });
    const falloffRing = new THREE.Mesh(falloffRingGeometry, falloffRingMaterial);

    // Main ring for brush boundary
    const mainRingGeometry = new THREE.RingGeometry(
        characterBrushSize * 0.7, 
        characterBrushSize * 1, 
        32
    );
    const mainRingMaterial = new THREE.MeshBasicMaterial({
        color: 0xFF4500,
        transparent: true,
        opacity: 0.6,
        side: THREE.DoubleSide,
        depthTest: false
    });
    const mainRing = new THREE.Mesh(mainRingGeometry, mainRingMaterial);

    // Animated glow ring for better visibility
    const glowRingGeometry = new THREE.RingGeometry(
        characterBrushSize * 0.9, 
        characterBrushSize * 1.3, 
        32
    );
    const glowRingMaterial = new THREE.ShaderMaterial({
        uniforms: { 
            time: { value: 0 }, 
            color: { value: new THREE.Color(0xFFD700) } 
        },
        vertexShader: `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            uniform float time;
            uniform vec3 color;
            varying vec2 vUv;
            void main() {
                float glow = 0.5 + 0.5 * sin(time + vUv.x * 3.1416);
                gl_FragColor = vec4(color * glow, 0.4);
            }
        `,
        transparent: true,
        depthTest: false
    });
    const glowRing = new THREE.Mesh(glowRingGeometry, glowRingMaterial);

    // Add all elements to the brush preview
    brushPreview.add(innerSphere);
    brushPreview.add(falloffRing);
    brushPreview.add(mainRing);
    brushPreview.add(glowRing);
    brushPreview.visible = false;

    // Store reference to brush preview
    window.characterBrushPreview = brushPreview;
    scene.add(brushPreview);

    // Start animation for glow effect
    animateBrushGlow(glowRingMaterial);
}

// Animate brush glow for better visibility
function animateBrushGlow(material) {
    let lastTime = 0;
    
    function animate(time) {
        // Skip animation if not visible
        if (!window.characterBrushPreview || !window.characterBrushPreview.visible) {
            requestAnimationFrame(animate);
            return;
        }
        
        // Update shader time uniform
        material.uniforms.time.value += 0.05;
        requestAnimationFrame(animate);
    }
    
    animate(0);
}

// Update brush preview position and visibility
function updateCharacterBrushPreview(event) {
    if (!sculptingSphere || !window.characterBrushPreview) return;

    // Get mouse position in normalized device coordinates
    const mouse = new THREE.Vector2(
        (event.clientX / window.innerWidth) * 2 - 1,
        -(event.clientY / window.innerHeight) * 2 + 1
    );

    // Cast ray from camera through mouse position
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(sculptingSphere);

    if (intersects.length > 0) {
        // Position brush preview at intersection point
        const intersect = intersects[0];
        const point = intersect.point;
        const normal = intersect.face.normal;

           // Orient brush preview to follow surface normal
           window.characterBrushPreview.position.copy(point);
        
        // Create orientation matrix based on surface normal
        const orientMatrix = new THREE.Matrix4();
        const lookAt = new THREE.Vector3().addVectors(point, normal);
        orientMatrix.lookAt(point, lookAt, new THREE.Vector3(0, 1, 0));
        
        // Apply orientation to brush preview
        window.characterBrushPreview.quaternion.setFromRotationMatrix(orientMatrix);
        
        // Scale brush preview based on distance to camera for consistent visual size
        const distanceToCamera = camera.position.distanceTo(point);
        const scaleFactor = distanceToCamera * 0.05;
        window.characterBrushPreview.scale.set(scaleFactor, scaleFactor, scaleFactor);
        
        // Make brush preview visible when over sculpting surface
        window.characterBrushPreview.visible = true;
        
        // Store intersection data for potential sculpting operations
        window.lastIntersect = {
            point: point.clone(),
            normal: normal.clone(),
            face: intersect.face,
            object: intersect.object
        };
    } else {
        // Hide brush preview when not over sculpting surface
        window.characterBrushPreview.visible = false;
        window.lastIntersect = null;
    }
}

let sculptingEnabled = true;

// Setup sculpting event listeners
function setupCharacterSculptingEvents() {
    const canvas = renderer.domElement;
    
    // Existing tool selection code
    document.querySelectorAll('.panel-button-tool').forEach(button => {
        button.addEventListener('click', () => {
            selectedCharacterTool = button.id;
            updateToolUI();
            if (selectedCharacterTool === CHARACTER_TOOLS.HAIR_BRUSH) {
                hairBrushActive = true;
            }
        });
    });

    // Mouse events
    canvas.addEventListener('mousedown', onCharacterSculptStart);
    canvas.addEventListener('mousemove', onCharacterSculptMove);
    canvas.addEventListener('mouseup', onCharacterSculptEnd);
    
    // Physics toggle
    document.getElementById('togglePhysics').addEventListener('click', () => {
        physicsEnabled = !physicsEnabled;
        if (physicsEnabled) {
            updateHairPhysics();
        }
        updateToolUI();
    });


    document.getElementById('sculptingToggle').addEventListener('change', (e) => {
        sculptingEnabled = e.target.checked;
    });

    // Existing brush controls
    document.getElementById('brushSizeSc').addEventListener('input', (e) => {
        characterBrushSize = parseFloat(e.target.value);
        document.getElementById('brushSizeValue').textContent = e.target.value;
        updateBrushPreviewSize();
    });

    document.getElementById('brushStrength').addEventListener('input', (e) => {
        characterBrushStrength = parseFloat(e.target.value);
        document.getElementById('brushStrengthValue').textContent = e.target.value;
    });

    document.getElementById('brushFalloff').addEventListener('input', (e) => {
        characterBrushFalloff = parseFloat(e.target.value);
        document.getElementById('brushFalloffValue').textContent = e.target.value;
    });

    setupHairControls();
}

function updateBrushPreviewSize() {
    if (window.characterBrushPreview) {
        const innerSphere = window.characterBrushPreview.children[0];
        const falloffRing = window.characterBrushPreview.children[1];
        const mainRing = window.characterBrushPreview.children[2];
        const glowRing = window.characterBrushPreview.children[3];

        innerSphere.geometry = new THREE.SphereGeometry(characterBrushSize * 0.25, 16, 16);
        falloffRing.geometry = new THREE.RingGeometry(characterBrushSize * 0.5, characterBrushSize * 0.7, 32);
        mainRing.geometry = new THREE.RingGeometry(characterBrushSize * 0.7, characterBrushSize * 1, 32);
        glowRing.geometry = new THREE.RingGeometry(characterBrushSize * 0.9, characterBrushSize * 1.3, 32);
    }
}

// Update UI based on selected tool
function updateToolUI() {
    document.querySelectorAll('.panel-button').forEach(button => {
        button.classList.toggle('active', button.id === selectedCharacterTool);
    });
    document.getElementById('togglePhysics').textContent = 
        physicsEnabled ? 'Disable Physics' : 'Enable Physics';
}

// Setup hair control listeners
function setupHairControls() {
    const controls = [
        'guideHairDensity', 'hairSegments', 'hairLength', 'hairDensity',
        'hairCurl', 'hairStiffness', 'hairWave', 'hairFrizz', 
        'hairClumpSize', 'hairNoise', 'hairColor', 'hairSpecular'
    ];

    controls.forEach(controlId => {
        const element = document.getElementById(controlId);
        element.addEventListener('input', (e) => {
            updateHairSettings(controlId, e.target.value);
            if (controlId.includes('hairColor') || controlId.includes('hairSpecular')) {
                updateHairMaterial();
            }
        });
    });

    document.getElementById('simulationQuality').addEventListener('change', (e) => {
        updateSimulationQuality(e.target.value);
    });
}

// Update hair settings based on UI input
function updateHairSettings(controlId, value) {
    switch(controlId) {
        case 'guideHairDensity': hairBrushSettings.density = parseFloat(value) * 100; break; // Scale to match density
        case 'hairSegments': 
            hairBrushSettings.numSegments = parseInt(value);
            hairBrushSettings.hairStrands.forEach(strand => strand.initializeSegments());
            break;
        case 'hairLength': 
            hairBrushSettings.segmentLength = parseFloat(value);
            hairBrushSettings.hairStrands.forEach(strand => strand.initializeSegments());
            break;
        case 'hairDensity': hairBrushSettings.density = parseInt(value) * 10; break; // Scale density
        case 'hairCurl': hairBrushSettings.curl = parseFloat(value); break;
        case 'hairStiffness': hairBrushSettings.stiffness = parseFloat(value); break;
        case 'hairWave': hairBrushSettings.wave = parseFloat(value); break;
        case 'hairFrizz': hairBrushSettings.frizz = parseFloat(value); break;
        case 'hairClumpSize': hairBrushSettings.clumpSize = parseInt(value); break;
        case 'hairNoise': hairBrushSettings.randomness = parseFloat(value); break;
        case 'hairColor': hairBrushSettings.hairColor = parseInt(value.replace('#', '0x')); break;
        case 'hairSpecular': hairBrushSettings.specularColor = parseInt(value.replace('#', '0x')); break;
    }
    updateHairMaterial();
    updateHairMesh();
    updateHairStrands();
}

function updateHairMaterial() {
    if (hairInstanceMesh) {
        hairInstanceMesh.material.color.setHex(hairBrushSettings.hairColor);
        hairInstanceMesh.material.sheenColor.setHex(hairBrushSettings.specularColor);
    }
    if (hairMesh) {
        hairMesh.material.color.setHex(hairBrushSettings.hairColor);
        hairMesh.material.sheenColor.setHex(hairBrushSettings.specularColor);
    }
}


function updateHairStrands() {
    hairBrushSettings.hairStrands.forEach(strand => {
        strand.initializeSegments(); // Reapply settings to existing strands
    });
    updateHairMesh();
}



// Update simulation quality settings
function updateSimulationQuality(value) {
    switch(value) {
        case 'low':
            hairBrushSettings.batchSize = 25;
            hairBrushSettings.updateInterval = 200;
            break;
        case 'medium':
            hairBrushSettings.batchSize = 50;
            hairBrushSettings.updateInterval = 100;
            break;
        case 'high':
            hairBrushSettings.batchSize = 100;
            hairBrushSettings.updateInterval = 50;
            break;
    }
}

// Sculpting event handlers
function onCharacterSculptStart(event) {
    if (!selectedCharacterTool || !sculptingSphere) return;
    
    isCharacterSculpting = true;
    saveUndoState();
    
    const vertices = sculptingSphere.geometry.attributes.position.array;
    const position = getMousePosition(event);
    const normal = getMouseNormal(event);
    
    applySculptingTool(event, vertices, position, normal);
}

function onCharacterSculptMove(event) {
    updateCharacterBrushPreview(event);
    
    if (!isCharacterSculpting || !selectedCharacterTool) return;
    
    const vertices = sculptingSphere.geometry.attributes.position.array;
    const position = getMousePosition(event);
    const normal = getMouseNormal(event);
    
    applySculptingTool(event, vertices, position, normal);
    prevMouseEvent = event; // Always update prevMouseEvent during sculpting
}

function onCharacterSculptEnd(event) {
    isCharacterSculpting = false;
    if (selectedCharacterTool === CHARACTER_TOOLS.HAIR_BRUSH) {
        hairBrushActive = false;
    }
    sculptingSphere.geometry.attributes.position.needsUpdate = true;
}

// Get mouse position on surface
function getMousePosition(event) {
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(getMouseCoords(event), camera);
    const intersects = raycaster.intersectObject(sculptingSphere);
    return intersects.length > 0 ? intersects[0].point : null;
}

// Get surface normal at mouse position
function getMouseNormal(event) {
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(getMouseCoords(event), camera);
    const intersects = raycaster.intersectObject(sculptingSphere);
    return intersects.length > 0 ? intersects[0].face.normal : null;
}

// Convert screen coords to NDC
function getMouseCoords(event) {
    return new THREE.Vector2(
        (event.clientX / window.innerWidth) * 2 - 1,
        -(event.clientY / window.innerHeight) * 2 + 1
    );
}

// Apply selected sculpting tool
function applySculptingTool(event, vertices, position, normal) {
    if (!position || !normal) return;

    switch(selectedCharacterTool) {
        case CHARACTER_TOOLS.FACE_SHAPE:
        case CHARACTER_TOOLS.NOSE_SCULPT:
        case CHARACTER_TOOLS.CHEEK_DEFINITION:
        case CHARACTER_TOOLS.JAW_SCULPT:
        case CHARACTER_TOOLS.FOREHEAD_SHAPE:
        case CHARACTER_TOOLS.CHIN_SCULPT:
        case CHARACTER_TOOLS.TEMPLE_SCULPT:
        case CHARACTER_TOOLS.BROW_RIDGE:
        case CHARACTER_TOOLS.EYE_SOCKET:
        case CHARACTER_TOOLS.LIP_SHAPE:
            sculptVertices(vertices, position, normal);
            break;
        case CHARACTER_TOOLS.SMOOTH:
            smoothVertices(vertices, position);
            break;
        case CHARACTER_TOOLS.PINCH:
            pinchVertices(vertices, position);
            break;
        case CHARACTER_TOOLS.INFLATE:
            inflateVertices(vertices, position);
            break;
        case CHARACTER_TOOLS.CREASE:
            creaseVertices(vertices, position);
            break;
        case CHARACTER_TOOLS.SNAKE_HOOK:
            snakeHookVertices(vertices, position);
            break;
        case CHARACTER_TOOLS.HAIR_BRUSH:
            applyHairBrush(event, vertices, position, normal);
            break;
    }
}

// Core sculpting functions
function sculptVertices(vertices, position, normal) {
    const symmetry = document.getElementById('symmetryToggle').checked;
    const axis = document.getElementById('symmetryAxis').value;
    
    for (let i = 0; i < vertices.length; i += 3) {
        const vertex = new THREE.Vector3(vertices[i], vertices[i + 1], vertices[i + 2]);
        const distance = vertex.distanceTo(position);
        
        if (distance < characterBrushSize) {
            const falloff = 1 - Math.pow(distance / characterBrushSize, characterBrushFalloff);
            const displacement = normal.clone().multiplyScalar(characterBrushStrength * falloff);
            
            vertices[i] += displacement.x;
            vertices[i + 1] += displacement.y;
            vertices[i + 2] += displacement.z;
            
            if (symmetry) {
                applySymmetry(vertices, i, axis);
            }
        }
    }
    sculptingSphere.geometry.attributes.position.needsUpdate = true;
    sculptingSphere.geometry.computeVertexNormals(); // Update normals for proper lighting
}

function smoothVertices(vertices, position) {
    const tempVertices = new Float32Array(vertices);
    for (let i = 0; i < vertices.length; i += 3) {
        const vertex = new THREE.Vector3(vertices[i], vertices[i + 1], vertices[i + 2]);
        if (vertex.distanceTo(position) < characterBrushSize) {
            let avg = new THREE.Vector3();
            let count = 0;
            
            for (let j = 0; j < vertices.length; j += 3) {
                if (i !== j) {
                    const neighbor = new THREE.Vector3(vertices[j], vertices[j + 1], vertices[j + 2]);
                    if (neighbor.distanceTo(vertex) < characterBrushSize * 0.5) {
                        avg.add(neighbor);
                        count++;
                    }
                }
            }
            
            if (count > 0) {
                avg.divideScalar(count);
                const falloff = 1 - (vertex.distanceTo(position) / characterBrushSize);
                tempVertices[i] = THREE.MathUtils.lerp(vertices[i], avg.x, falloff * 0.5);
                tempVertices[i + 1] = THREE.MathUtils.lerp(vertices[i + 1], avg.y, falloff * 0.5);
                tempVertices[i + 2] = THREE.MathUtils.lerp(vertices[i + 2], avg.z, falloff * 0.5);
            }
        }
    }
    vertices.set(tempVertices);
    sculptingSphere.geometry.attributes.position.needsUpdate = true;
}

function pinchVertices(vertices, position) {
    for (let i = 0; i < vertices.length; i += 3) {
        const vertex = new THREE.Vector3(vertices[i], vertices[i + 1], vertices[i + 2]);
        const distance = vertex.distanceTo(position);
        
        if (distance < characterBrushSize) {
            const falloff = 1 - (distance / characterBrushSize);
            const direction = position.clone().sub(vertex).normalize();
            const displacement = direction.multiplyScalar(characterBrushStrength * falloff * 0.5);
            
            vertices[i] += displacement.x;
            vertices[i + 1] += displacement.y;
            vertices[i + 2] += displacement.z;
        }
    }
    sculptingSphere.geometry.attributes.position.needsUpdate = true;
}

function inflateVertices(vertices, position) {
    for (let i = 0; i < vertices.length; i += 3) {
        const vertex = new THREE.Vector3(vertices[i], vertices[i + 1], vertices[i + 2]);
        const distance = vertex.distanceTo(position);
        
        if (distance < characterBrushSize) {
            const falloff = 1 - (distance / characterBrushSize);
            const direction = vertex.clone().normalize();
            const displacement = direction.multiplyScalar(characterBrushStrength * falloff);
            
            vertices[i] += displacement.x;
            vertices[i + 1] += displacement.y;
            vertices[i + 2] += displacement.z;
        }
    }
    sculptingSphere.geometry.attributes.position.needsUpdate = true;
}

function creaseVertices(vertices, position) {
    for (let i = 0; i < vertices.length; i += 3) {
        const vertex = new THREE.Vector3(vertices[i], vertices[i + 1], vertices[i + 2]);
        const distance = vertex.distanceTo(position);
        
        if (distance < characterBrushSize) {
            const falloff = 1 - Math.pow(distance / characterBrushSize, 2);
            const direction = vertex.clone().sub(position).normalize();
            const displacement = direction.multiplyScalar(-characterBrushStrength * falloff);
            
            vertices[i] += displacement.x;
            vertices[i + 1] += displacement.y;
            vertices[i + 2] += displacement.z;
        }
    }
    sculptingSphere.geometry.attributes.position.needsUpdate = true;
}

let prevMouseEvent = null;

function snakeHookVertices(vertices, position) {
    if (!prevMouseEvent) return; // Skip if no previous position

    const mousePos = getMouseCoords(event);
    const prevMousePos = getMouseCoords(prevMouseEvent);
    const movement = new THREE.Vector2().subVectors(mousePos, prevMousePos);

    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mousePos, camera);
    const intersects = raycaster.intersectObject(sculptingSphere);
    if (!intersects.length) return;

    const newPosition = intersects[0].point;

    for (let i = 0; i < vertices.length; i += 3) {
        const vertex = new THREE.Vector3(vertices[i], vertices[i + 1], vertices[i + 2]);
        const distance = vertex.distanceTo(position);
        
        if (distance < characterBrushSize) {
            const falloff = 1 - (distance / characterBrushSize);
            const direction = newPosition.clone().sub(position).normalize();
            const displacement = direction.multiplyScalar(characterBrushStrength * falloff * movement.length() * 5);
            
            vertices[i] += displacement.x;
            vertices[i + 1] += displacement.y;
            vertices[i + 2] += displacement.z;
        }
    }
    sculptingSphere.geometry.attributes.position.needsUpdate = true;
    sculptingSphere.geometry.computeVertexNormals(); // Update normals
    prevMouseEvent = event; // Update previous event
}

// Symmetry handling
function applySymmetry(vertices, index, axis) {
    const vertex = new THREE.Vector3(vertices[index], vertices[index + 1], vertices[index + 2]);
    const symmetricVertex = vertex.clone();
    
    switch(axis) {
        case 'x': symmetricVertex.x = -symmetricVertex.x; break;
        case 'y': symmetricVertex.y = -symmetricVertex.y; break;
        case 'z': symmetricVertex.z = -symmetricVertex.z; break;
    }
    
    let closestIndex = -1;
    let minDistance = Infinity;
    
    for (let i = 0; i < vertices.length; i += 3) {
        const v = new THREE.Vector3(vertices[i], vertices[i + 1], vertices[i + 2]);
        const distance = v.distanceTo(symmetricVertex);
        if (distance < minDistance) {
            minDistance = distance;
            closestIndex = i;
        }
    }
    
    if (closestIndex >= 0) {
        vertices[closestIndex] = symmetricVertex.x;
        vertices[closestIndex + 1] = symmetricVertex.y;
        vertices[closestIndex + 2] = symmetricVertex.z;
    }
}

// Undo/Redo system
function saveUndoState() {
    const vertices = sculptingSphere.geometry.attributes.position.array.slice();
    characterUndoStack.push({
        vertices: vertices,
        hairStrands: hairBrushSettings.hairStrands.map(strand => ({
            rootPosition: strand.rootPosition.clone(),
            normal: strand.normal.clone(),
            segments: strand.segments.map(seg => ({
                position: seg.position.clone(),
                velocity: seg.velocity.clone()
            }))
        }))
    });
    if (characterUndoStack.length > 50) characterUndoStack.shift();
    characterRedoStack = [];
}

function undo() {
    if (characterUndoStack.length === 0) return;
    
    const currentState = {
        vertices: sculptingSphere.geometry.attributes.position.array.slice(),
        hairStrands: hairBrushSettings.hairStrands.map(strand => ({
            rootPosition: strand.rootPosition.clone(),
            normal: strand.normal.clone(),
            segments: strand.segments.map(seg => ({
                position: seg.position.clone(),
                velocity: seg.velocity.clone()
            }))
        }))
    };
    
    characterRedoStack.push(currentState);
    const state = characterUndoStack.pop();
    
    sculptingSphere.geometry.attributes.position.array.set(state.vertices);
    sculptingSphere.geometry.attributes.position.needsUpdate = true;
    
    hairBrushSettings.hairStrands = state.hairStrands.map(data => {
        const strand = new HairStrand(data.rootPosition, data.normal);
        strand.segments = data.segments.map(seg => ({
            position: seg.position.clone(),
            velocity: seg.velocity.clone(),
            prevPosition: seg.position.clone(),
            force: new THREE.Vector3(),
            mass: 1,
            locked: false,
            normal: data.normal.clone()
        }));
        return strand;
    });
    updateHairMesh();
}

function redo() {
    if (characterRedoStack.length === 0) return;
    
    const currentState = {
        vertices: sculptingSphere.geometry.attributes.position.array.slice(),
        hairStrands: hairBrushSettings.hairStrands.map(strand => ({
            rootPosition: strand.rootPosition.clone(),
            normal: strand.normal.clone(),
            segments: strand.segments.map(seg => ({
                position: seg.position.clone(),
                velocity: seg.velocity.clone()
            }))
        }))
    };
    
    characterUndoStack.push(currentState);
    const state = characterRedoStack.pop();
    
    sculptingSphere.geometry.attributes.position.array.set(state.vertices);
    sculptingSphere.geometry.attributes.position.needsUpdate = true;
    
    hairBrushSettings.hairStrands = state.hairStrands.map(data => {
        const strand = new HairStrand(data.rootPosition, data.normal);
        strand.segments = data.segments.map(seg => ({
            position: seg.position.clone(),
            velocity: seg.velocity.clone(),
            prevPosition: seg.position.clone(),
            force: new THREE.Vector3(),
            mass: 1,
            locked: false,
            normal: data.normal.clone()
        }));
        return strand;
    });
    updateHairMesh();
}



function initRenderer() {
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Soft shadows like Blender
    renderer.toneMapping = THREE.ACESFilmicToneMapping; // Better color response
    renderer.toneMappingExposure = 1.0;
}

// Initialize the sculpting system
function initCharacterSculpting() {
    initRenderer(); // Ensure renderer is properly configured
    addSculptingSphere();
    animate();
}

// Start the system
initCharacterSculpting();

// Add keyboard shortcuts
document.addEventListener('keydown', (event) => {
    if (event.ctrlKey && event.key === 'z') undo();
    if (event.ctrlKey && event.key === 'y') redo();
});
</script>

   
    <script>
        class TerrainBrushSystem {
            constructor(scene, camera, renderer, terrain) {
                this.scene = scene;
                this.camera = camera;
                this.renderer = renderer;
                this.terrain = terrain;
                
                // Brush states
                this.isActive = false;
                this.isPainting = false;
                this.lastPaintPosition = new THREE.Vector3();
                
                // Brush settings
                this.settings = {
                    radius: 2,
                    density: 5,
                    spacing: 0.5,
                    scaleMin: 0.8,
                    scaleMax: 1.2,
                    rotationMin: 0,
                    rotationMax: 360,
                    heightOffset: 0,
                    paintDelay: 50, // ms between paint operations
                };
        
                // Storage for models
                this.models = new Map();
                this.activeModel = null;
                
                // Initialize systems
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.brushPreview = this.createBrushPreview2();
                this.scene.add(this.brushPreview);
                
                // Initialize event listeners
                this.initializeEventListeners();
                this.lastPaintTime = 0;
                
                // Undo/Redo system
                this.undoStack = [];
                this.redoStack = [];
                this.currentPaintOperation = [];
            }
        
            createBrushPreview2() {
                const group = new THREE.Group();
        
                // Main circle
                const circleGeometry = new THREE.CircleGeometry(1, 32);
                const circleMaterial = new THREE.MeshBasicMaterial({
                    color: 0xFF7F7F,
                    transparent: true,
                    opacity: 0.6,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });
                const circle = new THREE.Mesh(circleGeometry, circleMaterial);
                circle.rotation.x = -Math.PI / 2;
                circle.renderOrder = 1;
        
                // Outer ring
                const ringGeometry = new THREE.RingGeometry(0.95, 1, 32);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: 0xFFFFFF,
                    transparent: true,
                    opacity: 0.7,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = -Math.PI / 2;
                ring.renderOrder = 2;
        
                // Center dot
                const dotGeometry = new THREE.CircleGeometry(0.05, 16);
                const dotMaterial = new THREE.MeshBasicMaterial({
                    color: 0xFFFFFF,
                    transparent: true,
                    opacity: 0.9,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });
                const dot = new THREE.Mesh(dotGeometry, dotMaterial);
                dot.rotation.x = -Math.PI / 2;
                dot.position.y = 0.01;
                dot.renderOrder = 3;
        
                group.add(circle);
                group.add(ring);
                group.add(dot);
                group.visible = false;
        
                return group;
            }
        
            initializeEventListeners() {
                // Mouse events
                this.renderer.domElement.addEventListener('mousemove', this.onMouseMove.bind(this));
                this.renderer.domElement.addEventListener('mousedown', this.onMouseDown.bind(this));
                this.renderer.domElement.addEventListener('mouseup', this.onMouseUp.bind(this));
                
                // Keyboard shortcuts
                window.addEventListener('keydown', (e) => {
                    if (e.key === 'b' || e.key === 'B') {
                        this.toggleBrush();
                    }
                    if (e.key === 'z' && e.ctrlKey) {
                        this.undo();
                    }
                    if (e.key === 'y' && e.ctrlKey) {
                        this.redo();
                    }
                });
        
                // UI Controls
                this.setupUIControls();
            }
        
            setupUIControls() {
                // Brush size control
                const sizeSlider = document.getElementById('brush-size');
                if (sizeSlider) {
                    sizeSlider.addEventListener('input', (e) => {
                        this.settings.radius = parseFloat(e.target.value);
                        this.updateBrushPreview();
                    });
                }
        
                // Density control
                const densitySlider = document.getElementById('brush-density');
                if (densitySlider) {
                    densitySlider.addEventListener('input', (e) => {
                        this.settings.density = parseInt(e.target.value);
                    });
                }
        
                // Model upload
                const modelUpload = document.getElementById('model-upload');
                if (modelUpload) {
                    modelUpload.addEventListener('change', this.handleModelUpload.bind(this));
                }
            }
        
            handleModelUpload(event) {
                const file = event.target.files[0];
                if (!file) return;
        
                const loader = new THREE.GLTFLoader();
                const reader = new FileReader();
        
                reader.onload = (e) => {
                    loader.load(e.target.result, (gltf) => {
                        const model = gltf.scene;
                        const modelName = file.name.split('.')[0];
                        
                        // Center and normalize model
                        const box = new THREE.Box3().setFromObject(model);
                        const center = box.getCenter(new THREE.Vector3());
                        const size = box.getSize(new THREE.Vector3());
                        const maxDim = Math.max(size.x, size.y, size.z);
                        
                        model.position.sub(center);
                        model.scale.multiplyScalar(1 / maxDim);
                        
                        this.models.set(modelName, model);
                        this.activeModel = model;
                        
                        console.log(`Model ${modelName} loaded successfully`);
                    });
                };
        
                reader.readAsDataURL(file);
            }
        
            onMouseMove(event) {
                if (!this.isActive) return;
        
                this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        
                this.updateBrushPosition();
                
                if (this.isPainting) {
                    this.paint();
                }
            }
        
            onMouseDown(event) {
                if (event.button !== 0 || !this.isActive || !this.activeModel) return;
                this.isPainting = true;
                this.currentPaintOperation = [];
                this.paint();
            }
        
            onMouseUp() {
                if (this.isPainting && this.currentPaintOperation.length > 0) {
                    this.undoStack.push(this.currentPaintOperation);
                    this.redoStack = [];
                }
                this.isPainting = false;
            }
        
            updateBrushPosition() {
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObject(this.terrain);
        
                if (intersects.length > 0) {
                    const point = intersects[0].point;
                    this.brushPreview.position.copy(point);
                    this.brushPreview.scale.setScalar(this.settings.radius);
                    this.brushPreview.visible = true;
                } else {
                    this.brushPreview.visible = false;
                }
            }
        
            paint() {
                if (!this.activeModel || !this.isPainting) return;
        
                const now = Date.now();
                if (now - this.lastPaintTime < this.settings.paintDelay) return;
                this.lastPaintTime = now;
        
                const intersects = this.raycaster.intersectObject(this.terrain);
                if (intersects.length === 0) return;
        
                const center = intersects[0].point;
                const instanceCount = Math.floor(this.settings.density * (this.settings.radius * this.settings.radius));
        
                for (let i = 0; i < instanceCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * this.settings.radius;
                    
                    const position = new THREE.Vector3(
                        center.x + Math.cos(angle) * radius,
                        center.y + this.settings.heightOffset,
                        center.z + Math.sin(angle) * radius
                    );
        
                    // Check minimum distance from last placement
                    if (position.distanceTo(this.lastPaintPosition) < this.settings.spacing) {
                        continue;
                    }
        
                    const instance = this.activeModel.clone();
                    instance.position.copy(position);
        
                    // Random rotation
                    const rotation = THREE.MathUtils.degToRad(
                        this.settings.rotationMin + 
                        Math.random() * (this.settings.rotationMax - this.settings.rotationMin)
                    );
                    instance.rotation.y = rotation;
        
                    // Random scale
                    const scale = this.settings.scaleMin + 
                        Math.random() * (this.settings.scaleMax - this.settings.scaleMin);
                    instance.scale.setScalar(scale);
        
                    this.scene.add(instance);
                    this.currentPaintOperation.push(instance);
                    this.lastPaintPosition.copy(position);
                }
            }
        
            undo() {
                if (this.undoStack.length === 0) return;
                
                const objects = this.undoStack.pop();
                this.redoStack.push(objects);
                
                objects.forEach(obj => {
                    this.scene.remove(obj);
                });
            }
        
            redo() {
                if (this.redoStack.length === 0) return;
                
                const objects = this.redoStack.pop();
                this.undoStack.push(objects);
                
                objects.forEach(obj => {
                    this.scene.add(obj);
                });
            }
        
            toggleBrush() {
                this.isActive = !this.isActive;
                this.brushPreview.visible = this.isActive;
            }
        
            updateBrushPreview() {
                this.brushPreview.scale.setScalar(this.settings.radius);
            }
        }
    </script>
   
    <script src="index.js"></script>
    <script src="cloth.js"></script>
    <script src="nodes/node-editor-ex.js"></script>
    <script src="physics/lighting-stystem.js"></script>
    <script src="processing/transform-controls.js"></script>
    <script src="js/code-editor.js"></script>
    <script src="js/export.js"></script>
    <script src="hilpers/canvas-selection.js"></script>
    <script src="animations/animation-path.js"></script>
    <script src="js/timeline.js"></script>
    <script src="processing/nanite-ex.js"></script>
    <script src="soundes/sound-editor.js"></script>
    <script src="physics/material-brush-system.js"></script>
    <script src="nodes/vfx.js"></script>
    <script src="hilpers/grid-hilpers.js"></script>
    <script src="hilpers/Keyboard-Shortcuts.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://threejs.org/examples/jsm/controls/OrbitControls.js"></script>
    <script src="https://threejs.org/examples/jsm/controls/TransformControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/TransformControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/geometries/TextGeometry.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@latest/build/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/RGBELoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.17"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.139.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.139.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.139.0/examples/js/controls/TransformControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.139.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.139.0/examples/js/loaders/RGBELoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.139.0/examples/js/pmrem/PMREMGenerator.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.139.0/examples/js/pmrem/PMREMCubeUVPacker.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FBXLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/examples/js/controls/TransformControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r146/three.min.js"></script>
  
    <!-- Physics -->
    <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.7/build/dat.gui.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"></script>

    <!--Gui-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.139.0/examples/js/objects/Sky.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.17.0/dist/lil-gui.min.js"></script>
    <!-- Particle effects -->
    <script src="https://cdn.jsdelivr.net/npm/three-spritetext@1.6.5/dist/three-spritetext.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script  src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon-es/0.17.0/cannon-es.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/postprocessing/OutlinePass.js"></script>
   <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/loaders/FBXLoader.js"></script>
   <script src="https://cdn.jsdelivr.net/npm/three@0.166.1/build/three.min.js"></script>

   <script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/GLTFLoader.js"></script>
   <script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/OBJLoader.js"></script>
   <script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/FBXLoader.js"></script>

   <!-- Required for FBX -->
   <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/helpers/SkeletonHelper.js"></script>
   <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/loaders/FBXLoader.min.js"></script>
   <script src="https://cdn.jsdelivr.net/npm/fflate@0.7.4/umd/index.min.js"></script>
   <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/inflate.min.js"></script>


  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/postprocessing/UnrealBloomPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/postprocessing/SSAOPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/shaders/CopyShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/postprocessing/ShaderPass.js"></script>
    
  <!--Exporters-->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
  
  <!-- Exporters & Loaders -->
  <script src="https://cdn.jsdelivr.net/npm/three/examples/js/exporters/GLTFExporter.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three/examples/js/exporters/OBJExporter.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three/examples/js/exporters/FBXExporter.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/GLTFLoader.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/OBJLoader.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/FBXLoader.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.161.0/examples/js/loaders/RGBELoader.js"></script>

  <!--Proccesing-->
  <script src="https://cdn.jsdelivr.net/npm/three-subdivide"></script>

<script>




// First, add these global variables at the top of your 

const vertexShader = `
    uniform float size;
    attribute float lifetime;
    varying float vLifetime;
    void main() {
        vLifetime = lifetime;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        gl_PointSize = size;
    }
`;

const fragmentShader = `
    uniform sampler2D map;
    varying float vLifetime;
    void main() {
        vec4 texColor = texture2D(map, gl_PointCoord);
        gl_FragColor = texColor * vec4(1.0, 1.0, 1.0, vLifetime * 0.8);
    }
`;

let objects = [];
let snowParticles = [];
let groundLevel = 0;
let snowDensity = 1500;
let snowSize = 0.2;
let snowSpeed = 0.5;
let windForce = 0.5;
let turbulence = 0.5;
let stormMode = false;
let isSnowing = true;
let snowMaterial;

let params = {
    density: 1000,
    size: 0.1,
    speed: 1,
    wind: 0,
    turbulence: 0.5,
    groundLevel: -10,
    mode: 'normal',  // Default mode
    vortexStrength: 1.0,  // For vortex mode
    vortexRadius: 5.0    // For vortex mode
};

const textureLoader = new THREE.TextureLoader();
const snowflakeTexture = textureLoader.load('https://threejs.org/examples/textures/sprites/snowflake2.png');

let snowAccumulation = new Map(); // Store accumulated snow particles
const maxAccumulatedParticles = 1000; // Maximum particles that can accumulate at one spot
const meltingRate = 0.01; // Rate at which snow melts
const gridY = params.groundLevel; // Y position of the grid

function setupSnowControls() {
    // Toggle snow
    document.getElementById('toggleSnow').addEventListener('click', () => {
        isSnowing = !isSnowing;
        if (isSnowing) {
            createSnow();
        } else {
            snowParticles.forEach(particle => scene.remove(particle));
            snowParticles = [];
        }
    });

    // Mode selection
    document.getElementById('snowMode').addEventListener('change', (e) => {
        params.mode = e.target.value;
        recreateSnow();
    });

    // Parameter controls
    ['density', 'size', 'speed', 'wind', 'turbulence'].forEach(param => {
        const slider = document.getElementById(param);
        const valueDisplay = document.getElementById(`${param}Value`);
        
        slider.addEventListener('input', (e) => {
            params[param] = parseFloat(e.target.value);
            valueDisplay.textContent = e.target.value;
            if (param === 'density') recreateSnow();
            if (param === 'size') updateSnowSize();
        });
    });

    // Weather presets
    setupWeatherEffects();
}

function createSnow() {
    const snowGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(params.density * 3);
    const velocities = new Float32Array(params.density * 3);
    const randomFactors = new Float32Array(params.density);

    for (let i = 0; i < params.density; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 50;
        positions[i * 3 + 1] = Math.random() * 50;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 50;

        velocities[i * 3] = (Math.random() - 0.5) * 0.05;
        velocities[i * 3 + 1] = -Math.random() * params.speed;
        velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.05;

        randomFactors[i] = Math.random();
    }

    snowGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    snowGeometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
    snowGeometry.setAttribute('random', new THREE.BufferAttribute(randomFactors, 1));

    const snowMaterial = new THREE.PointsMaterial({
        size: params.size,
        color: 0xffffff,
        transparent: true,
        opacity: 0.8,
        depthWrite: false,
        alphaTest: 0.1,
        map: snowflakeTexture,
        blending: THREE.AdditiveBlending
    });

    const snow = new THREE.Points(snowGeometry, snowMaterial);
    snowParticles.push(snow);
    scene.add(snow);
}

function createSnowflakeTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 32;
    canvas.height = 32;
    const ctx = canvas.getContext('2d');

    ctx.beginPath();
    ctx.arc(16, 16, 14, 0, Math.PI * 2);
    ctx.fillStyle = 'white';
    ctx.fill();

    return new THREE.CanvasTexture(canvas);
}

function updateSnow() {
    const time = Date.now() * 0.001;
    
    snowParticles.forEach(particle => {
        const positions = particle.geometry.attributes.position.array;
        const velocities = particle.geometry.attributes.velocity.array;
        const randomFactors = particle.geometry.attributes.random.array;

        for (let i = 0; i < positions.length; i += 3) {
            if (params.mode === 'normal') {
                // Normal falling snow
                positions[i] += velocities[i] + params.wind * 0.1;
                positions[i + 1] += velocities[i + 1];
                positions[i + 2] += velocities[i + 2];

                // Add some gentle turbulence
                positions[i] += Math.sin(time + randomFactors[i / 3]) * params.turbulence * 0.1;
                positions[i + 2] += Math.cos(time + randomFactors[i / 3]) * params.turbulence * 0.1;
            } else if (params.mode === 'vortex') {
                // Vortex snow
                const x = positions[i];
                const z = positions[i + 2];
                const distance = Math.sqrt(x * x + z * z);
                
                // Calculate vortex motion
                const angle = Math.atan2(z, x) + time * params.vortexStrength;
                const radius = Math.min(distance, params.vortexRadius);
                
                positions[i] = Math.cos(angle) * radius;
                positions[i + 2] = Math.sin(angle) * radius;
                positions[i + 1] += velocities[i + 1] - params.speed * 0.5;

                // Add turbulence to vortex
                positions[i] += Math.sin(time + randomFactors[i / 3]) * params.turbulence * 0.2;
                positions[i + 2] += Math.cos(time + randomFactors[i / 3]) * params.turbulence * 0.2;
            }

            // Ground collision and reset
            if (positions[i + 1] < params.groundLevel) {
                positions[i + 1] = 50 + Math.random() * 10;
                positions[i] = (Math.random() - 0.5) * 50;
                positions[i + 2] = (Math.random() - 0.5) * 50;
                
                velocities[i] = (Math.random() - 0.5) * 0.05;
                velocities[i + 1] = -Math.random() * params.speed;
                velocities[i + 2] = (Math.random() - 0.5) * 0.05;
            }
        }

        particle.geometry.attributes.position.needsUpdate = true;
    });
}

function updateSnowSize() {
    snowParticles.forEach(particle => {
        particle.material.size = params.size;
    });
}

function recreateSnow() {
    snowParticles.forEach(particle => scene.remove(particle));
    snowParticles = [];
    if (isSnowing) createSnow();
}

function setupWeatherEffects() {
    const effects = {
        storm: { speed: 3, wind: 3, turbulence: 2, mode: 'vortex', vortexStrength: 2.0 },
        blizzard: { speed: 4, wind: 4, turbulence: 2.5, mode: 'normal' },
        gentle: { speed: 0.5, wind: 0.2, turbulence: 0.3, mode: 'normal' }
    };

    Object.keys(effects).forEach(effect => {
        document.getElementById(effect).addEventListener('click', () => {
            const settings = effects[effect];
            Object.keys(settings).forEach(param => {
                params[param] = settings[param];
                const slider = document.getElementById(param);
                const valueDisplay = document.getElementById(`${param}Value`);
                if (slider && valueDisplay) {
                    slider.value = settings[param];
                    valueDisplay.textContent = settings[param];
                }
            });
            document.getElementById('snowMode').value = settings.mode;
            recreateSnow();
        });
    });
}

</script>

<script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
    import { RGBELoader} from 'three/examples/jsm/loaders/RGBELoader.js';
</script>

<script>
// Global variables
let scene, camera, renderer, controls, transformControls, raycaster, mouse;
let selectedObject = null;
let clock = new THREE.Clock();
let isPlaying = false;
let isDragging = false;
let timelineDuration = 300; // 5 minutes in seconds
let currentTime = 0;
const keyframes = new Map();

let  particles;
let particlesGeometry,  particlesMaterial;
const particlesCount = 10000;
let particleColor = 0xffcc88; 
let isParticlesVisible = true;
let isLocked = false;

let textureLoaded = null; 

function toggleParticles() {
    if (!particles) {
        // Create particles for the first time
        createParticles();
        console.log("Particles initialized and enabled");
    } else {
        // Toggle visibility if already created
        isParticlesVisible = !isParticlesVisible;
        particles.visible = isParticlesVisible;
        console.log(`Particles ${isParticlesVisible ? "enabled" : "disabled"}`);
    }
}


function createParticles() {
    if (!textureLoaded) {
        textureLoaded = new THREE.TextureLoader().load(
            'https://threejs.org/examples/textures/sprites/spark1.png'
        );
    }

    particlesGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particlesCount * 3);
    const sizes = new Float32Array(particlesCount);

    for (let i = 0; i < particlesCount; i++) {
        // Gaussian distribution for natural spread
        positions[i * 3] = (Math.random() - 0.5) * 100 + gaussianRandom() * 20;
        positions[i * 3 + 1] = (Math.random() - 0.5) * 100 + gaussianRandom() * 20;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 100 + gaussianRandom() * 20;

        // Randomized size variation
        sizes[i] = Math.random() * 0.5 + 0.1;
    }

    particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    particlesGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

    if (!particlesMaterial) {
        particlesMaterial = new THREE.PointsMaterial({
            color: particleColor,
            size: 0.3,
            sizeAttenuation: true,
            transparent: true,
            opacity: 0.8, // Slight fade-in effect
            map: textureLoaded,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
        });
    }

    particles = new THREE.Points(particlesGeometry, particlesMaterial);
    scene.add(particles);
    isParticlesVisible = true;
}

/**
 * Generates a Gaussian (normal) distribution random number.
 * Creates more naturally clustered particles.
 */
function gaussianRandom(mean = 0, stdev = 1) {
    let u = 1 - Math.random(); // Uniform(0,1] random number
    let v = 1 - Math.random();
    let z = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    return mean + z * stdev;
}


function changeParticlesCount(amount) {
    particlesCount = Math.max(1000, particlesCount + amount);  // Minimum particlesCount is 1000
    updateParticles();
}

function changeParticleColor(color) {
    particleColor = new THREE.Color(color);
    particles.material.color.set(particleColor);  // Update particle color
}




let isDrawing = false;
let drawMode = false;
let extrudeMode = false;
let points = [];
let previewMesh = null;
let previewLine = null;
let quadMeshes = [];
let snapThreshold = 0.3;
let extrudeHeight = 1.0;
cameraOrbitSpeed = 0.005;
let currentCameraPosition = new THREE.Vector3();
let targetCameraPosition = new THREE.Vector3();
let cameraVelocity = new THREE.Vector3();

let mouseDown = false;
let selectedFace = null;
let orbitControls = true;
let transformControlsActive = false;


let isModelingMode = false;
let selectionMode = 'vertex';
let activeObject = null;
let selectedElements = [];
let isOrthographicViewActive = false;

let vertexHelpers = new THREE.Group(); vertexHelpers.name = "VertexHelpers_Global";
let edgeHelpers = new THREE.Group(); edgeHelpers.name = "EdgeHelpers_Global";
let faceHelpers = new THREE.Group(); faceHelpers.name = "FaceHelpers_Global";


function init() {
    // Scene setup
    //scene.background = new THREE.Color(0x333333); // Default to a neutral gray color
    scene = new THREE.Scene();
    scene.backgroundBlurriness = 0.5;
    scene.backgroundIntensity = 1.2;

    if (scene.background && scene.background.dispose) {
        scene.background.dispose();
    }
    if (scene.environment && scene.environment.dispose) {
        scene.environment.dispose();
    }
    updateRenderOrder();
    // Camera setup
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    updateCameraPosition();
    // Renderer setup
    renderer = new THREE.WebGLRenderer({
        antialias: true,
        toneMapping: THREE.ACESFilmicToneMapping,
        toneMappingExposure: 1.0,
        powerPreference: "high-performance",
        stencil: true,
        depth: true,
        logarithmicDepthBuffer: true,
        alpha: true
    });

    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('renderer-container').appendChild(renderer.domElement);
    renderer.setPixelRatio(window.devicePixelRatio); // دقة أفضل
    renderer.sortObjects = true; 
    renderer.setClearColor(0x000000, 0);
    renderer.autoClear = true;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.antialias = true; // تنعيم الحواف
    renderer.physicallyCorrectLights = true;

    // Remove OrbitControls (if you prefer full manual control)
    if (controls) {
        controls.dispose();
        controls = null;
    }

    // Axes helper
    const axesHelper = new THREE.AxesHelper(5);
    scene.add(axesHelper);

    // Raycaster and mouse setup
    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();

    // Controls
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    transformControls = new THREE.TransformControls(camera, renderer.domElement);
    scene.add(transformControls);
    controls.enableDamping = true;
    controls.dampingFactor = 0.25;
    controls.screenSpacePanning = false;
    controls.enabled = true;

    // 3. Set up the interaction between the two
    transformControls.addEventListener('mouseDown', function() {
        transformControlsActive = true;
        if (controls && !isLocked) {
            controls.enabled = false;
        }

        selectedObject = transformControls.object;
        updateLayersUI();

        console.log("Transform started, orbit controls disabled");
    });

    transformControls.addEventListener('mouseUp', function() {
        transformControlsActive = false;
        if (controls && !isLocked) {
            controls.enabled = true;
        }
        console.log("Transform ended, orbit controls restored");
    });

    // This is still helpful as a backup
    transformControls.addEventListener('dragging-changed', function(event) {
        if (controls && !isLocked) {
            controls.enabled = !event.value;
        }
    });

    const nodeEditor = new NodeEditor(scene, camera, raycaster);
    // Pass nodeEditor to global scope if needed
    window.nodeEditor = nodeEditor;

    document.addEventListener('keydown', (e) => {
        if (e.ctrlKey && e.key === 'z') nodeEditor.undo();
        if (e.ctrlKey && e.key === 'y') nodeEditor.redo();
    });
    //modeling helpers
    scene.add(vertexHelpers);
    scene.add(edgeHelpers);
    scene.add(faceHelpers);
    vertexHelpers.name = "VertexHelpers"; scene.add(vertexHelpers);
    edgeHelpers.name = "EdgeHelpers"; scene.add(edgeHelpers);
    faceHelpers.name = "FaceHelpers"; scene.add(faceHelpers);
    // World-Class Lighting Setup
    // 1. Ambient Light (soft global illumination)
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.15); // Just a gentle fill
    scene.add(ambientLight);

    // 2. Hemisphere Light (sky + ground simulation)
    const hemiLight = new THREE.HemisphereLight(0xb1e1ff, 0x444444, 0.6);
    hemiLight.position.set(0, 100, 0);
    scene.add(hemiLight);

    const sunLight = new THREE.DirectionalLight(0xfff2cc, 3.5);
    sunLight.position.set(40, 60, 20);
    sunLight.castShadow = true;

    sunLight.shadow.mapSize.width = 4096;
    sunLight.shadow.mapSize.height = 4096;

    sunLight.shadow.camera.left = -100;
    sunLight.shadow.camera.right = 100;
    sunLight.shadow.camera.top = 100;
    sunLight.shadow.camera.bottom = -100;
    sunLight.shadow.camera.far = 350;
    sunLight.shadow.camera.near = 0.5;

    sunLight.shadow.bias = -0.0001;
    sunLight.shadow.normalBias = 0.05;

    scene.add(sunLight);
    // Helper (optional for debugging)
    const sunHelper = new THREE.DirectionalLightHelper(sunLight, 10);

    // 4. RectArea Light (softbox-like fill)
    const rectLight1 = new THREE.RectAreaLight(0xffddbb, 2.5, 20, 20);
    rectLight1.position.set(-15, 20, 15);
    rectLight1.lookAt(0, 0, 0);
    scene.add(rectLight1);

    // 5. Extra Area Light (cooler bounce)
    const rectLight2 = new THREE.RectAreaLight(0x99ccff, 2.0, 30, 15);
    rectLight2.position.set(15, 10, -15);
    rectLight2.lookAt(0, 0, 0);
    scene.add(rectLight2);

    // Optional Light Probes (if you use light baking)
    const lightProbe = new THREE.LightProbe();
    scene.add(lightProbe);

    // 6. Spotlight with angle and penumbra (editor-style light beam)
    const spotLight = new THREE.SpotLight(0xffffff, 1.5, 100, Math.PI / 5, 0.3, 2);
    spotLight.position.set(25, 40, 10);
    spotLight.target.position.set(0, 0, 0);
    spotLight.castShadow = true;

    spotLight.shadow.mapSize.width = 2048;
    spotLight.shadow.mapSize.height = 2048;
    spotLight.shadow.bias = -0.0001;
    spotLight.shadow.normalBias = 0.02;

    scene.add(spotLight);
    scene.add(spotLight.target);

    // 3. Directional Light (Sun-like main light)
    const directionalLight = new THREE.DirectionalLight(0xfff8e1, 2.0); // Warm sunlight
    directionalLight.position.set(20, 30, 10);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 4096;
    directionalLight.shadow.mapSize.height = 4096;
    directionalLight.shadow.camera.near = 0.5;
    directionalLight.shadow.camera.far = 100;
    directionalLight.shadow.camera.left = -50;
    directionalLight.shadow.camera.right = 50;
    directionalLight.shadow.camera.top = 50;
    directionalLight.shadow.camera.bottom = -50;
    directionalLight.shadow.bias = -0.00005;
    directionalLight.shadow.normalBias = 0.02;
    scene.add(directionalLight);

    // Add helper for directional light (optional for debugging)
    const dirLightHelper = new THREE.DirectionalLightHelper(directionalLight, 5);
    // scene.add(dirLightHelper); // Uncomment to visualize

    // 4. Fill Light (Soft secondary light)
    const fillLight = new THREE.SpotLight(0xe6e6fa, 1.5, 50, Math.PI / 4, 0.5);
    fillLight.position.set(-10, 15, 20);
    fillLight.castShadow = true;
    fillLight.shadow.mapSize.width = 2048;
    fillLight.shadow.mapSize.height = 2048;
    scene.add(fillLight);

    // 5. Rect Area Light (Environment bounce)
    const rectLight = new THREE.RectAreaLight(0xadd8e6, 3, 20, 20);
    rectLight.position.set(0, 10, -15);
    rectLight.lookAt(0, 0, 0);
    scene.add(rectLight);

  

    // Grid helper
    const advancedGrid = createAdvancedGridHelper(1000, 1000);
    advancedGrid.name = 'advancedGrid';
    advancedGrid.renderOrder = -2; 
    scene.add(advancedGrid);

    if (axesHelper) {
        axesHelper.renderOrder = -1;
    }
    const lineMaterial = new THREE.LineBasicMaterial({
        color: 0xffff00,
        linewidth: 2
    });

    previewLine = new THREE.Line(
        new THREE.BufferGeometry(),
        lineMaterial
    );
    scene.add(previewLine);


    // Enhanced fog
    scene.fog = new THREE.FogExp2(0x2a2a2a, 0.01);
    // GUI setup
    const settings = addGUI(scene, renderer, camera);
    if (settings.useHDR) {
        scene.background = new THREE.Color(settings.background);
        scene.environment = null;
        scene.fog = new THREE.FogExp2(settings.background, settings.density);
    } else {
        // Start with color background if HDRI is disabled
        const hdriPath = `https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/${hdriFiles[settings.selectedHDRI]}`;
        updateEnvironmentAndBackground(hdriPath);
    }

    // Event listeners and initialization
    window.addEventListener('DOMContentLoaded', () => {
        const lockButton = document.getElementById('toggle-lock');
        if (lockButton) {
            lockButton.addEventListener('click', toggleLock);
            console.log("Lock button listener attached");
        } else {
            console.error("Lock button not found!");
        }
    });

    document.addEventListener('DOMContentLoaded', () => {
        // Wait a short time to ensure THREE.js is initialized
        setTimeout(() => {
            initPathAnimationSystem();
            addPathAnimationStyles();
        }, 1000);
    });

    // Override scene.add to auto-add objects to timeline
    const originalSceneAdd = scene.add;
    scene.add = function(object) {
        originalSceneAdd.apply(scene, arguments); // Call original add
            if (object.isObject3D) { // Ensure it’s a 3D object
                addObjectToTimeline(object);
        }
        return object;
    };
 
    initializeTimeline();
    setupTimelineEventListeners();
    initCanvasSelection();
    setupMultiSelectionHandling();
    initializeShortcutsSystem();

    initShortcutsPanel();
    setupSceneElements();
    initModeling();
    setupSnowControls();
    createSnow();
    bindInspectorInputs(); 

    setupEventListeners();
    activatePanelButtonTool();
    initPhysics();
    addDemonstrationObjects();
    //createParticles();
    toggleParticles();
    animate();
    optimizeScene();
    initBrush();
    initCharacterSculpting();
}

function updateEnvironmentAndBackground(hdriUrl) {
    const loader = new THREE.RGBELoader();
    const pmremGenerator = new THREE.PMREMGenerator(renderer);
    pmremGenerator.compileEquirectangularShader();

    loader.load(hdriUrl, function (texture) {
        const envMap = pmremGenerator.fromEquirectangular(texture).texture;

        // Dispose previous environment/background if needed
        if (scene.environment && scene.environment.dispose) {
            scene.environment.dispose();
        }
        if (scene.background && scene.background.dispose) {
            scene.background.dispose();
        }

        scene.environment = envMap;
        scene.background = envMap; // Set this if you want the HDR to be visible as the background

        texture.dispose();
        pmremGenerator.dispose();

        console.log("HDR environment and background applied.");
    }, undefined, function (err) {
        console.error("Failed to load HDRI:", err);
    });
}

function createAdvancedGridHelper(size = 100, divisions = 100) { // Adjusted default size for typical scenes
    const gridGroup = new THREE.Group();
    gridGroup.name = 'advancedGrid'; // Set name here for consistency

    gridGroup.renderOrder = -1;
    // Horizontal XZ grid
    const horizontalGrid = new THREE.GridHelper(size, divisions);
    horizontalGrid.material = new THREE.LineBasicMaterial({
        color: 0x666666,
        opacity: 0.5,
        transparent: true,
        depthWrite: false 
    });
    horizontalGrid.renderOrder = -1; 
    horizontalGrid.name = 'horizontalGrid';
    gridGroup.add(horizontalGrid);

    // Vertical grid (XY or YZ)
    const verticalGrid = new THREE.GridHelper(size, divisions * 2); // Can have more divisions if needed
    verticalGrid.material = new THREE.LineBasicMaterial({
        color: 0x888888, // Slightly lighter
        opacity: 0.7,
        transparent: true,
        depthWrite: false
    });
    verticalGrid.renderOrder = -1; 
    verticalGrid.name = 'verticalGrid';
    verticalGrid.visible = false; // Hidden by default
    gridGroup.add(verticalGrid);

    // Major axes (Placeholder, implement if needed)
    const axesGroup = createMajorAxes(size); // Assuming this returns a Group
    gridGroup.add(axesGroup);

    // Measurement labels (Placeholder, implement if needed)
    const labelsGroup = createMeasurementLabels(size); // Assuming this returns a Group
    gridGroup.add(labelsGroup);

    // Current active plane tracker
    gridGroup.currentPlane = 'xz'; // Default to horizontal XZ plane

    // Method to update grid visibility and orientation
    gridGroup.updateGrid = function(plane) {
        console.log(`[updateGrid] Called with plane: ${plane}`);
        
        // Set current plane
        this.currentPlane = plane || 'xz';
        
        // Update grid visibility based on plane
        horizontalGrid.visible = (plane === 'xz' || plane === null);
        verticalGrid.visible = (plane === 'xy' || plane === 'yz');
        
        console.log(`  [updateGrid] horizontalGrid.visible: ${horizontalGrid.visible}, verticalGrid.visible: ${verticalGrid.visible}`);

        // Always reset rotation before applying a new one to avoid cumulative rotations
        verticalGrid.rotation.set(0, 0, 0);

        if (plane === 'xy') {
            // For XY plane (looking along Z axis), rotate 90 degrees around X
            verticalGrid.rotation.x = Math.PI / 2;
        } else if (plane === 'yz') {
            // For YZ plane (looking along X axis)
            // For proper orientation facing the camera, we need specific rotations
            verticalGrid.rotation.x = Math.PI / 2;
            verticalGrid.rotation.z = Math.PI / 2;
        }
    };

    // Store original camera position and orientation for detecting view changes
    let lastCameraPosition = new THREE.Vector3();
    let lastCameraDirection = new THREE.Vector3();
    
    // Dynamic visibility based on camera distance and view change
    gridGroup.onBeforeRender = function(renderer, scene, camera) {
        if (!camera || typeof camera.position.length !== 'function') return;

        const distance = camera.position.length();
        const maxVisibleDistance = size * 1.5;

        // Fade out based on distance
        const fade = THREE.MathUtils.smoothstep(distance, maxVisibleDistance * 0.5, maxVisibleDistance);

        const baseHorizontalOpacity = 0.5;
        const baseVerticalOpacity = 0.7;

        if (horizontalGrid.material && typeof horizontalGrid.material.opacity !== 'undefined') {
            horizontalGrid.material.opacity = baseHorizontalOpacity * (1 - fade);
        }
        if (verticalGrid.material && typeof verticalGrid.material.opacity !== 'undefined') {
            verticalGrid.material.opacity = baseVerticalOpacity * (1 - fade);
        }

        // Visibility of labels based on distance
        if (labelsGroup) {
            labelsGroup.visible = (distance < size * 0.75);
        }
        
        // Get current camera position and direction
        const currentCameraPosition = new THREE.Vector3().copy(camera.position);
        // Get the direction the camera is pointing (normalized)
        const currentCameraDirection = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion).normalize();
        
        // Check if the camera has moved significantly
        const positionChanged = !lastCameraPosition.equals(currentCameraPosition);
        const directionChanged = lastCameraDirection.dot(currentCameraDirection) < 0.999; // Slight change in direction
        
        // If we moved or rotated and vertical grid is visible, check if we need to revert to horizontal
        if ((positionChanged || directionChanged) && verticalGrid.visible) {
            // Calculate normalized direction vector from origin to camera
            const cameraDir = new THREE.Vector3().copy(camera.position).normalize();
            
            // Define axis direction vectors for the three standard views
            const xAxisDir = new THREE.Vector3(1, 0, 0);   // X axis (YZ plane)
            const yAxisDir = new THREE.Vector3(0, 1, 0);   // Y axis (XZ plane)
            const zAxisDir = new THREE.Vector3(0, 0, 1);   // Z axis (XY plane)
            
            // Calculate dot products to see alignment with axes
            const xDot = Math.abs(cameraDir.dot(xAxisDir));
            const yDot = Math.abs(cameraDir.dot(yAxisDir));
            const zDot = Math.abs(cameraDir.dot(zAxisDir));
            
            // Threshold for deciding when view is "aligned" with an axis
            const alignmentThreshold = 0.97; // Higher value = stricter alignment required
            
            // Check if we're aligned with the current plane's axis
            let isAligned = false;
            if (this.currentPlane === 'xy' && zDot > alignmentThreshold) {
                isAligned = true;
            } else if (this.currentPlane === 'yz' && xDot > alignmentThreshold) {
                isAligned = true;
            } else if (this.currentPlane === 'xz' && yDot > alignmentThreshold) {
                isAligned = true;
            }
            
            // If we're not aligned with the current plane's axis, revert to horizontal grid
            if (!isAligned) {
                horizontalGrid.visible = true;
                verticalGrid.visible = false;
                this.currentPlane = 'xz'; // Reset to horizontal XZ plane
                console.log("[Grid] View changed, reverting to horizontal grid only");
            }
            
            // Update last position and direction for next frame
            lastCameraPosition.copy(currentCameraPosition);
            lastCameraDirection.copy(currentCameraDirection);
        }
    };

    return gridGroup;
}


let axisToggleState = {
    x: true,
    y: true,
    z: true
};

function setCameraView(direction) {
    console.log(`--- setCameraView CALLED with direction: ${direction} ---`);

    let targetPosition = new THREE.Vector3();
    let lookAtPosition = new THREE.Vector3(0, 0, 0); // Always look at origin
    let gridPlane = null;
    let initialIsOrthographicActive = isOrthographicViewActive;

    switch (direction) {
        case 'x':
            if (axisToggleState.x) {
                targetPosition.set(4, 0, 0); // +X
                document.getElementById("axis-x").innerText = "X";
            } else {
                targetPosition.set(-4, 0, 0); // -X
                document.getElementById("axis-x").innerText = "-X";
            }
            axisToggleState.x = !axisToggleState.x;
            gridPlane = 'yz';
            isOrthographicViewActive = true;
            break;
        case 'y':
        case 'top':
            if (axisToggleState.y) {
                targetPosition.set(0, 4, 0); // +Y
                document.getElementById("axis-y").innerText = "Y";
            } else {
                targetPosition.set(0, -4, 0); // -Y
                document.getElementById("axis-y").innerText = "-Y";
            }
            axisToggleState.y = !axisToggleState.y;
            gridPlane = 'xz';
            isOrthographicViewActive = true;
            break;
        case 'z':
            if (axisToggleState.z) {
                targetPosition.set(0, 0, 4); // +Z
                document.getElementById("axis-z").innerText = "Z";
            } else {
                targetPosition.set(0, 0, -4); // -Z
                document.getElementById("axis-z").innerText = "-Z";
            }
            axisToggleState.z = !axisToggleState.z;
            gridPlane = 'xy';
            isOrthographicViewActive = true;
            break;
        case 'bottom':
            targetPosition.set(0, -4, 0);
            gridPlane = 'xz';
            isOrthographicViewActive = true;
            break;
        case 'diagonal':
            targetPosition.set(4, 4, 4);
            gridPlane = 'xz';
            isOrthographicViewActive = false;
            break;
        default:
            console.warn('[setCameraView] Unknown camera view:', direction);
            return;
    }
    
    console.log(`[setCameraView] Direction: ${direction}, Initial isOrthographicViewActive: ${initialIsOrthographicActive}, New isOrthographicViewActive: ${isOrthographicViewActive}, Target GridPlane: ${gridPlane}`);

    const advancedGrid = scene.getObjectByName('advancedGrid');
    if (advancedGrid && advancedGrid.updateGrid) {
        advancedGrid.updateGrid(gridPlane);
        
        // Reset the camera tracking variables to prevent immediate reversion of grid
        if (advancedGrid.onBeforeRender && advancedGrid.onBeforeRender.lastCameraPosition) {
            advancedGrid.onBeforeRender.lastCameraPosition = targetPosition.clone();
            const lookDir = new THREE.Vector3().subVectors(lookAtPosition, targetPosition).normalize();
            advancedGrid.onBeforeRender.lastCameraDirection = lookDir;
        }
    } else {
        console.error("[setCameraView] Could not find advancedGrid or its updateGrid method!");
    }

    if (controls) controls.enabled = false; // Disable controls during animation

    gsap.to(camera.position, {
        duration: 0.5,
        x: targetPosition.x,
        y: targetPosition.y,
        z: targetPosition.z,
        ease: "power2.inOut",
        onUpdate: () => {
            camera.lookAt(lookAtPosition);
        },
        onComplete: () => {
            console.log(`[setCameraView GSAP Complete] Final isOrthographicViewActive after animation for '${direction}' view: ${isOrthographicViewActive}`);
            if (controls) {
                controls.target.copy(lookAtPosition);
                controls.update();
                controls.enabled = true;
                
                // After animation completes, store the final camera position and direction
                // to establish a new baseline for grid visibility checks
                if (advancedGrid && advancedGrid.onBeforeRender) {
                    const currentCameraPosition = new THREE.Vector3().copy(camera.position);
                    const currentCameraDirection = new THREE.Vector3(0, 0, -1)
                        .applyQuaternion(camera.quaternion).normalize();
                        
                    // Store these as the new baseline
                    if (!advancedGrid.onBeforeRender.lastCameraPosition) {
                        advancedGrid.onBeforeRender.lastCameraPosition = new THREE.Vector3();
                    }
                    if (!advancedGrid.onBeforeRender.lastCameraDirection) {
                        advancedGrid.onBeforeRender.lastCameraDirection = new THREE.Vector3();
                    }
                    
                    advancedGrid.onBeforeRender.lastCameraPosition.copy(currentCameraPosition);
                    advancedGrid.onBeforeRender.lastCameraDirection.copy(currentCameraDirection);
                }
            }
        }
    });
} 



function initModeling() {
     console.log("Initializing Modeling System...");
     // Ensure transformControls exists
     if (!transformControls) {
         console.error("TransformControls not initialized before initModeling!");
         return;
     }
    // This function now mainly sets up listeners, called from init
    initTransformControls(); // Setup TransformControls listeners specific to modeling
    setupTransformControls(); // Setup general interaction with OrbitControls
    setupModelingEventListeners(); // Setup buttons, mouse interactions for modeling panel/canvas
    console.log("Modeling System Initialized.");
    // Optionally toggle modeling mode ON by default for testing:
    // setTimeout(toggleModelingMode, 500); // Delay slightly to ensure UI is ready
}

// Camera controls
const zoomSpeed = 0.05; // Finer control over zoom sensitivity
const rotationSpeed = 0.005; // Smoother rotation
const moveSpeed = 0.1; // Consistent movement speed
let cameraDistance = 10;
let cameraTheta = Math.PI / 4;
let cameraPhi = Math.PI / 3;
const cameraTarget = new THREE.Vector3(0, 0, 0);
let isDraggingCam = false;
let lastMouseX, lastMouseY;
let velocity = new THREE.Vector3(); // For smooth movement
let targetTheta = cameraTheta;
let targetPhi = cameraPhi;
let targetDistance = cameraDistance;

const dampingFactor = 0.05; // Instead of 0.1 for more easing

function updateCameraPosition() {
   const x = cameraDistance * Math.sin(cameraPhi) * Math.sin(cameraTheta);
   const y = cameraDistance * Math.cos(cameraPhi);
   const z = cameraDistance * Math.sin(cameraPhi) * Math.cos(cameraTheta);
   camera.position.set(x, y, z);
   camera.lookAt(cameraTarget);
}

// Enhanced smooth zoom with better focus
function smoothZoomToTarget(newTargetDistance, newTargetPoint) {
   const steps = 20;
   let stepCount = 0;

   const initialDistance = cameraDistance;
   const initialTarget = cameraTarget.clone();

   const deltaDistance = newTargetDistance - initialDistance;
   const deltaTarget = newTargetPoint.clone().sub(initialTarget);

    function step() {
       stepCount++;
       const t = stepCount / steps;

       cameraDistance = initialDistance + deltaDistance * t;
       cameraTarget.copy(initialTarget.clone().add(deltaTarget.clone().multiplyScalar(t)));

       updateCameraPosition();

        if (stepCount < steps) {
           requestAnimationFrame(step);
        }
    }

    requestAnimationFrame(step);
}

// Improved zoom camera with better intersection detection
function zoomCamera(delta, mouseX, mouseY) {
    const zoomFactor = 1 - delta * zoomSpeed;
    const newDistance = THREE.MathUtils.clamp(targetDistance * zoomFactor, 1, 100);
  

    raycaster.setFromCamera(new THREE.Vector2(mouseX, mouseY), camera);
    const intersects = raycaster.intersectObjects(scene.children, true);

    if (intersects.length > 0) {
       const point = intersects[0].point;
       smoothZoomToTarget(newDistance, point); // Use smooth zoom
    } else {
       smoothZoomToTarget(newDistance, cameraTarget); // Zoom to center if no object
    }

    // Update internal targets
    targetDistance = newDistance;


}



function focusOnObject(object) {
    const box = new THREE.Box3().setFromObject(object);
    const center = box.getCenter(new THREE.Vector3());

    cameraTarget.copy(center);

    const size = box.getSize(new THREE.Vector3()).length();
    targetDistance = size * 1.5;

    updateCameraPosition();

}

// Keyboard Movement Controls
function moveCamera(direction) {
    const forward = new THREE.Vector3();
    camera.getWorldDirection(forward);
    
    // اتجاه اليمين باستخدام cross مع المحور Y
    const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();

    switch (direction) {
        case "forward": // Up Arrow / W
            camera.position.add(forward.multiplyScalar(moveSpeed));
            break;
        case "backward": // Down Arrow / S
            camera.position.add(forward.multiplyScalar(-moveSpeed));
            break;
        case "left": // Left Arrow / A
            camera.position.add(right.multiplyScalar(-moveSpeed));
            break;
        case "right": // Right Arrow / D
            camera.position.add(right.multiplyScalar(moveSpeed));
            break;
    }
}

document.addEventListener("keydown", (event) => {
    switch (event.code) {
        case "ArrowUp":
        case "KeyW":
            moveCamera("forward");
            break;
        case "ArrowDown":
        case "KeyS":
            moveCamera("backward");
            break;
        case "ArrowLeft":
        case "KeyA":
            moveCamera("left");
            break;
        case "ArrowRight":
        case "KeyD":
            moveCamera("right");
            break;
    }
});


// Add model to scene
function addModelToScene(model) {
    // Process model materials and enable shadows
    model.traverse((node) => {
        if (node.isMesh) {
            node.castShadow = true;
            node.receiveShadow = true;
            
            // Ensure materials update correctly
            if (node.material) {
                node.material.needsUpdate = true;
                if (Array.isArray(node.material)) {
                    node.material.forEach(mat => mat.needsUpdate = true);
                }
            }
        }
    });

    // Add model to the scene
    scene.add(model);
    objects.push(model);

    // Setup animations if present
    if (model.animations && model.animations.length > 0) {
        const mixer = new THREE.AnimationMixer(model);
        model.userData.mixer = mixer;
        model.animations.forEach(clip => {
            const action = mixer.clipAction(clip);
            action.play();
        });
    }

    // Update hierarchy (if needed)
    updateHierarchy();
}



function setupSceneElements() {
    scene.fog = new THREE.FogExp2(0x1c1c1c, 0.02);
    
    const axesHelper = new THREE.AxesHelper(5);
    scene.add(axesHelper);

    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();
}

function animateParticles() {
    const positions = particles.geometry.attributes.position.array;
    const time = Date.now() * 0.001;

    for (let i = 0; i < particlesCount * 3; i += 3) {
        positions[i] += Math.sin(time + positions[i + 2] * 0.1) * 0.01;
        positions[i + 1] += Math.cos(time + positions[i] * 0.1) * 0.01;
        positions[i + 2] += Math.sin(time * 0.5 + positions[i] * 0.1) * 0.01;
    }

    particles.geometry.attributes.position.needsUpdate = true;
}

function addGUI(scene, renderer, camera) {
    const gui = new dat.GUI({ autoPlace: false });

    const settings = {
        background: 0x2a2a2a, 
        density: 0.02,
        useHDR: true, 
        selectedHDRI: 'sunset', 
        hdriIntensity: 1.0, 
        hdriRotation: 0,
        fov: camera.fov, nearPlane: camera.near, farPlane: camera.far,
        enableShadows: true, shadowMapSize: 2048, shadowBias: -0.0001,
        lightIntensity: 1,
        ambientLightColor: 0xffffff, ambientLightIntensity: 0.5,
        pointLightColor: 0xffffff, pointLightIntensity: 1, pointLightDistance: 100, pointLightDecay: 2,
        directionalLightColor: 0xffffff, directionalLightIntensity: 1,
        directionalLightPosition: { x: 5, y: 5, z: 5 },
        materialReflectivity: 0.5, roughness: 0.5, metalness: 0.5, envMapIntensity: 1.0,
        enablePostProcessing: true, bloomEnabled: true, bloomIntensity: 1.0,
        bloomThreshold: 0.9, bloomRadius: 0.8,
        dofEnabled: false, focusDistance: 10, focalLength: 24, bokehScale: 2.0,
        enableStats: false, pixelRatio: 1.0
    };

    const hdriFiles = {
        sunset: 'venice_sunset_1k.hdr',
        forest: 'mossy_forest_1k.hdr',
        studio: 'studio_small_07_1k.hdr',
        night: 'dikhololo_night_1k.hdr',
        indoor: 'IndoorEnvironmentHDRI003_1K.hdr',
        Kloppenheim06: 'kloppenheim_06_1k.hdr',
        Syferfontein_1d_Clear : 'syferfontein_1d_clear_1k.hdr',
        Syferfontein_6d_Clear: 'syferfontein_6d_clear_1k.hdr',
        Syferfontein_18d_Clear : 'syferfontein_18d_clear_1k.hdr',
    };

    // Utility: Update material properties
    const updateMaterials = () => {
        scene.traverse(obj => {
            const mat = obj.material;
            if (mat) {
                ['reflectivity', 'roughness', 'metalness', 'envMapIntensity'].forEach(prop => {
                    if (mat[prop] !== undefined) mat[prop] = settings[prop];
                });
                mat.needsUpdate = true;
            }
        });
    };

    // === Scene Folder ===
    const sceneFolder = gui.addFolder('Scene Settings');
    sceneFolder.addColor(settings, 'background').onChange(() => {
        if (!settings.useHDR) {
            scene.background = new THREE.Color(settings.background);
            updateFog();
        }
    });
    sceneFolder.add(settings, 'density', 0.001, 0.1).step(0.001).onChange(updateFog);
    sceneFolder.open();

    // === HDRI Folder ===
    const hdriFolder = gui.addFolder('HDRI Settings');
    hdriFolder.add(settings, 'useHDR').name('Enable HDRI').onChange(updateHDRI);
    hdriFolder.add(settings, 'selectedHDRI', Object.keys(hdriFiles)).name('HDRI Type').onChange(updateHDRI);
    hdriFolder.add(settings, 'hdriIntensity', 0, 5).step(0.1).name('Intensity').onChange(updateHDRISettings);
    hdriFolder.add(settings, 'hdriRotation', 0, Math.PI * 2).step(0.1).name('Rotation').onChange(updateHDRISettings);
    hdriFolder.open();


    function updateFog() {
        scene.fog = new THREE.FogExp2(settings.background, settings.density);
    }

     function updateHDRI() {
        if (!settings.useHDR) {
            // When HDRI is disabled, set background to color and remove environment
            scene.background = new THREE.Color(settings.background);
            scene.environment = null;
            updateFog();
            console.log("HDRI disabled");
            return;
        }

        // When HDRI is enabled, load the selected HDRI
        const hdriPath = `https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/${hdriFiles[settings.selectedHDRI]}`;
        
        const loader = new THREE.RGBELoader();
        loader.setDataType(THREE.FloatType)
              .load(hdriPath, texture => {
            const pmremGen = new THREE.PMREMGenerator(renderer);
            pmremGen.compileEquirectangularShader();
            
            const envMap = pmremGen.fromEquirectangular(texture).texture;
            
            // Apply the HDRI to both background and environment
            scene.background = envMap;
            scene.environment = envMap;
            
            // Apply intensity and rotation
            scene.backgroundIntensity = settings.hdriIntensity;
            // Apply rotation if needed (requires a more complex setup with background material)
            
            texture.dispose();
            pmremGen.dispose();
            
            console.log("HDRI enabled and updated:", settings.selectedHDRI);
        });
    }

    // Function to update HDRI settings without reloading
    function updateHDRISettings() {
        if (settings.useHDR && scene.background) {
            scene.backgroundIntensity = settings.hdriIntensity;
            // For rotation, you might need a more sophisticated approach
            // involving a background mesh or transforming the environment map
            console.log("HDRI settings updated");
        }
    }
    // === Camera Folder ===
    const cameraFolder = gui.addFolder('Camera Settings');
    cameraFolder.add(settings, 'fov', 20, 120).onChange(updateCamera);
    cameraFolder.add(settings, 'nearPlane', 0.1, 10).onChange(updateCamera);
    cameraFolder.add(settings, 'farPlane', 100, 5000).onChange(updateCamera);
    cameraFolder.open();

    function updateCamera() {
        camera.fov = settings.fov;
        camera.near = settings.nearPlane;
        camera.far = settings.farPlane;
        camera.updateProjectionMatrix();
    }

    // === Shadow Folder ===
    const shadowFolder = gui.addFolder('Shadow Settings');
    shadowFolder.add(settings, 'enableShadows').onChange(enable => {
        renderer.shadowMap.enabled = enable;
        scene.traverse(obj => {
            if (obj.castShadow !== undefined) {
                obj.castShadow = enable;
                obj.receiveShadow = enable;
            }
        });
    });
    shadowFolder.add(settings, 'shadowMapSize', [512, 1024, 2048, 4096]).onChange(updateShadowMapSize);
    shadowFolder.add(settings, 'shadowBias', -0.01, 0.01).step(0.0001).onChange(updateShadowBias);
    shadowFolder.open();

    function updateShadowMapSize(val) {
        scene.traverse(obj => {
            if (obj.isLight && obj.shadow) {
                obj.shadow.mapSize.set(val, val);
                obj.shadow.map?.dispose();
            }
        });
    }

    function updateShadowBias(val) {
        scene.traverse(obj => {
            if (obj.isLight && obj.shadow) obj.shadow.bias = val;
        });
    }

    // === Lighting Folder ===
    const lightFolder = gui.addFolder('Lighting Settings');

    const ambient = lightFolder.addFolder('Ambient Light');
    ambient.addColor(settings, 'ambientLightColor').onChange(updateAmbientLight);
    ambient.add(settings, 'ambientLightIntensity', 0, 2).onChange(updateAmbientLight);

    const point = lightFolder.addFolder('Point Light');
    point.addColor(settings, 'pointLightColor').onChange(updatePointLight);
    point.add(settings, 'pointLightIntensity', 0, 5).onChange(updatePointLight);
    point.add(settings, 'pointLightDistance', 0, 1000).onChange(updatePointLight);
    point.add(settings, 'pointLightDecay', 0, 5).onChange(updatePointLight);

    const directional = lightFolder.addFolder('Directional Light');
    directional.addColor(settings, 'directionalLightColor').onChange(updateDirectionalLight);
    directional.add(settings, 'directionalLightIntensity', 0, 5).onChange(updateDirectionalLight);
    ['x', 'y', 'z'].forEach(axis => {
        directional.add(settings.directionalLightPosition, axis, -20, 20).onChange(updateDirectionalLight);
    });

    lightFolder.open();

    function updateAmbientLight() {
        scene.traverse(obj => {
            if (obj instanceof THREE.AmbientLight) {
                obj.color.set(settings.ambientLightColor);
                obj.intensity = settings.ambientLightIntensity;
            }
        });
    }

    function updatePointLight() {
        scene.traverse(obj => {
            if (obj instanceof THREE.PointLight) {
                obj.color.set(settings.pointLightColor);
                obj.intensity = settings.pointLightIntensity;
                obj.distance = settings.pointLightDistance;
                obj.decay = settings.pointLightDecay;
            }
        });
    }

    function updateDirectionalLight() {
        scene.traverse(obj => {
            if (obj instanceof THREE.DirectionalLight) {
                obj.color.set(settings.directionalLightColor);
                obj.intensity = settings.directionalLightIntensity;
                obj.position.set(
                    settings.directionalLightPosition.x,
                    settings.directionalLightPosition.y,
                    settings.directionalLightPosition.z
                );
            }
        });
    }

    // === Material Folder ===
    const matFolder = gui.addFolder('Material Settings');
    matFolder.add(settings, 'materialReflectivity', 0, 1).onChange(updateMaterials);
    matFolder.add(settings, 'roughness', 0, 1).onChange(updateMaterials);
    matFolder.add(settings, 'metalness', 0, 1).onChange(updateMaterials);
    matFolder.add(settings, 'envMapIntensity', 0, 5).onChange(updateMaterials);
    matFolder.open();

    // === Post-Processing ===
    const postFolder = gui.addFolder('Post-Processing');
    postFolder.add(settings, 'enablePostProcessing').onChange(() => {});

    const bloom = postFolder.addFolder('Bloom');
    bloom.add(settings, 'bloomEnabled').onChange(() => {});
    bloom.add(settings, 'bloomIntensity', 0, 5).onChange(() => {});
    bloom.add(settings, 'bloomThreshold', 0, 1).onChange(() => {});
    bloom.add(settings, 'bloomRadius', 0, 1).onChange(() => {});

    const dof = postFolder.addFolder('Depth of Field');
    dof.add(settings, 'dofEnabled').onChange(() => {});
    dof.add(settings, 'focusDistance', 0.1, 50).onChange(() => {});
    dof.add(settings, 'focalLength', 12, 100).onChange(() => {});
    dof.add(settings, 'bokehScale', 0, 10).onChange(() => {});

    postFolder.open();

    // === Performance ===
    const perfFolder = gui.addFolder('Performance');
    perfFolder.add(settings, 'enableStats').onChange(() => {});
    perfFolder.add(settings, 'pixelRatio', 0.5, 2).step(0.25).onChange(() => {
        renderer.setPixelRatio(settings.pixelRatio);
    });
    perfFolder.open();
    // Append GUI to container
    const guiContainer = document.getElementById('gui-container');
    guiContainer.appendChild(gui.domElement);

    // Return settings object for external access
    return settings;

    return gui; // in case user wants to append GUI manually or reuse
}





//Modelign Shapes

let subdivisionLevel = 0;

function createMajorAxes(size = 10) {
    const axesGroup = new THREE.Group();
    const fontSize = size * 0.1;
    const arrowLength = size / 2;
    const arrowHeadLength = size * 0.05;
    const arrowHeadWidth = size * 0.03;

    // Create axis lines
    const xAxis = createAxisLine(size, 0xff0000, new THREE.Vector3(1, 0, 0));
    const yAxis = createAxisLine(size, 0x00ff00, new THREE.Vector3(0, 1, 0));
    const zAxis = createAxisLine(size, 0x0000ff, new THREE.Vector3(0, 0, 1));
    axesGroup.add(xAxis, yAxis, zAxis);

    // Create arrowheads
    const xArrow = new THREE.ArrowHelper(
        new THREE.Vector3(1, 0, 0),
        new THREE.Vector3(arrowLength, 0, 0),
        arrowHeadLength,
        0xff0000,
        arrowHeadLength,
        arrowHeadWidth
    );

    const yArrow = new THREE.ArrowHelper(
        new THREE.Vector3(0, 1, 0),
        new THREE.Vector3(0, arrowLength, 0),
        arrowHeadLength,
        0x00ff00,
        arrowHeadLength,
        arrowHeadWidth
    );

    const zArrow = new THREE.ArrowHelper(
        new THREE.Vector3(0, 0, 1),
        new THREE.Vector3(0, 0, arrowLength),
        arrowHeadLength,
        0x0000ff,
        arrowHeadLength,
        arrowHeadWidth
    );

    axesGroup.add(xArrow, yArrow, zArrow);

    // Create labels using your text sprite method
    const xLabel = createTextSprite('X');
    xLabel.position.set(arrowLength + arrowHeadLength * 1.5, 0, 0);
    axesGroup.add(xLabel);

    const yLabel = createTextSprite('Y');
    yLabel.position.set(0, arrowLength + arrowHeadLength * 1.5, 0);
    axesGroup.add(yLabel);

    const zLabel = createTextSprite('Z');
    zLabel.position.set(0, 0, arrowLength + arrowHeadLength * 1.5);
    axesGroup.add(zLabel);

    return axesGroup;
}


// Create arrow at the positive end
function createAxisLine(size, color, direction) { 
    const geometry = new THREE.BufferGeometry();
    const vertices = new Float32Array([
        -size/2 * direction.x, -size/2 * direction.y, -size/2 * direction.z,
        size/2 * direction.x, size/2 * direction.y, size/2 * direction.z
    ]);
    geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
    
    const material = new THREE.LineBasicMaterial({
        color: color,
        linewidth: 2,
        opacity: 0.8,
        transparent: true
    });

    return new THREE.Line(geometry, material);
}



function createMeasurementLabels(size) {
    const labelsGroup = new THREE.Group();
    const interval = size / 10;
    
    // Create text sprites for measurement labels
    for (let i = -size/2; i <= size/2; i += interval) {
        if (i === 0) continue; // Skip 0
        
        // X-axis labels
        const xLabel = createTextSprite(i.toString());
        xLabel.position.set(i, 0, -20);
        labelsGroup.add(xLabel);
        
        // Z-axis labels
        const zLabel = createTextSprite(i.toString());
        zLabel.position.set(-20, 0, i);
        labelsGroup.add(zLabel);
    }

    return labelsGroup;
}


function createTextSprite(message) {
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.width = 256;
    canvas.height = 256;
    
    context.font = "Bold 36px Arial";
    context.fillStyle = "rgba(255,255,255,0.95)";
    context.fillText(message, 128, 128);
    
    const texture = new THREE.CanvasTexture(canvas);
    const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
    const sprite = new THREE.Sprite(spriteMaterial);
    sprite.scale.set(50, 50, 1);
    
    return sprite;
}


function toggleLock() {
    isLocked = !isLocked;
    
    if (controls) {
        // If locked, disable controls regardless of transform state
        if (isLocked) {
            controls.enabled = false;
        } 
        // If unlocked, enable controls only if not currently transforming
        else if (!transformControlsActive) {
            controls.enabled = true;
        }
    }
    
    // Update UI
    const lockButton = document.getElementById('toggle-lock');
    if (lockButton) {
        lockButton.innerHTML = isLocked 
            ? '<i class="fas fa-lock"></i>' 
            : '<i class="fas fa-unlock"></i>';
        lockButton.style.backgroundColor = isLocked ? '#e74c3c' : '#2ecc71';
    }
    
    console.log("Camera lock toggled:", isLocked, "Controls enabled:", controls.enabled);
}





function toggleExtrudeMode() {
    if (drawMode) toggleDrawMode();
    extrudeMode = !extrudeMode;
    
    if (extrudeMode) {
        controls.enabled = false;
        transformControls.enabled = false;
        transformControls.detach();
        selectedObject = null;
    } else {
        controls.enabled = true;
        transformControls.enabled = true;
        selectedFace = null;
    }
    
    document.getElementById('toggle-extrude').classList.toggle('active', extrudeMode);
    updateStatus();
}


function exitCurrentMode() {
    if (drawMode) toggleDrawMode();
    if (extrudeMode) toggleExtrudeMode();
    
    // Restore normal controls
    controls.enabled = true;
    transformControls.enabled = true;
    
    points = [];
    updatePreviewLine();
    selectedFace = null;
    brushCursor.visible = false;
    updateStatus();
}

function toggleDrawMode() {
    if (extrudeMode) toggleExtrudeMode();
    drawMode = !drawMode;
    
    if (drawMode) {
        controls.enabled = false;
        transformControls.enabled = false;
        transformControls.detach();
        selectedObject = null;
        brushCursor.visible = true;
    } else {
        controls.enabled = true;
        transformControls.enabled = true;
        points = [];
        updatePreviewLine();
        brushCursor.visible = false;
    }
   
    document.getElementById('toggle-draw').classList.toggle('active', drawMode);
    updateStatus();
}


function updateStatus() {
    let statusText = "Ready";
    if (drawMode) {
        statusText = `Drawing: ${points.length} points`;
    } else if (extrudeMode) {
        statusText = "Select a face to extrude";
        if (selectedFace) {
            statusText = "Click to extrude selected face";
        }
    }
    document.getElementById('status').textContent = statusText;
}

function updatePreviewLine() {
    if (points.length > 0) {
        const positions = [];
        points.forEach(point => {
            positions.push(point.x, point.y, point.z);
        });
        
        // Close the shape if we have enough points
        if (points.length >= 3) {
            positions.push(points[0].x, points[0].y, points[0].z);
        }

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        previewLine.geometry.dispose();
        previewLine.geometry = geometry;
    } else {
        previewLine.geometry.dispose();
        previewLine.geometry = new THREE.BufferGeometry();
    }
}

function clearGeometry() {
    quadMeshes.forEach(mesh => {
        mesh.geometry.dispose();
        mesh.material.dispose();
        scene.remove(mesh);
    });
    quadMeshes = [];
    points = [];
    updatePreviewLine();
    selectedFace = null;
    updateStatus();
}


function onMouseDown(event) {
    if (isLocked) return;
    event.preventDefault();
    mouseDown = true;
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    if (drawMode) {
        isDrawing = true;
        addPoint(event);
    } else if (extrudeMode) {
        selectFaceToExtrude();
    } else if (!drawMode && !extrudeMode) {
        orbitControls.enabled = true;
    }

    zoomCamera(e.deltaY > 0 ? 1 : -1);
}

function onMouseMove(event) {
    if (isLocked) return;
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    // Update brush cursor position
    updateBrushPosition(event);

    if (drawMode && isDrawing) {
        addPoint(event);
    }

    // Highlight face when in extrude mode
    if (extrudeMode && !mouseDown) {
        highlightFace();
    }

}

function onMouseUp(event) {
    if (isLocked) return;
    mouseDown = false;
    
    if (drawMode && isDrawing) {
        isDrawing = false;
        if (points.length >= 4) {
            createQuad();
            points = [];
            updatePreviewLine();
            updateStatus();
        }
    } else if (extrudeMode && selectedFace) {
        extrudeFace();
    }
}

function onMouseWheel(event) {
   event.preventDefault();
            
    // Adjust camera zoom
    cameraDistance = THREE.MathUtils.clamp(
        cameraDistance + event.deltaY * 0.01,
        5, 30
    );
    updateCameraPosition();
}


function initQuadBrush() {
    // Preview line for drawing
    const lineMaterial = new THREE.LineBasicMaterial({
        color: 0xffff00,
        linewidth: 2
    });
    
    previewLine = new THREE.Line(
        new THREE.BufferGeometry(),
        lineMaterial
    );
    scene.add(previewLine);
    
    // Reset quad-related variables
    points = [];
    quadMeshes = [];
    drawMode = false;
    extrudeMode = false;
}

    
function addPoint(event) {
    raycaster.setFromCamera(mouse, camera);
    
    // Try to snap to existing points or grid
    let snappedPoint = null;
    
    // First try to snap to existing points
    if (points.length > 0 && snapThreshold > 0) {
        for (const point of points) {
            const screenPoint = point.clone().project(camera);
            const distance = Math.sqrt(
                Math.pow(screenPoint.x - mouse.x, 2) + 
                Math.pow(screenPoint.y - mouse.y, 2)
            );
            
            if (distance < snapThreshold * 0.1) {
                snappedPoint = point.clone();
                break;
            }
        }
    }
    
    // If no point snap, check for mesh or grid intersections
    if (!snappedPoint) {
        // Include all scene objects that should be considered for drawing
        const intersectObjects = [...quadMeshes, ...objects];
        const intersects = raycaster.intersectObjects(intersectObjects, true);
        
        if (intersects.length > 0) {
            snappedPoint = intersects[0].point.clone();
            
            // Add some height offset to avoid z-fighting
            snappedPoint.y += 0.01;
            
            // Grid snapping
            if (snapThreshold > 0) {
                snappedPoint.x = Math.round(snappedPoint.x / snapThreshold) * snapThreshold;
                snappedPoint.z = Math.round(snappedPoint.z / snapThreshold) * snapThreshold;
            }
        }
    }
    
    if (snappedPoint) {
        // Check if this is close to first point (to close the loop)
        if (points.length >= 3) {
            const firstPoint = points[0];
            if (snappedPoint.distanceTo(firstPoint) < 0.5) {
                createQuad();
                points = [];
                updatePreviewLine();
                isDrawing = false;
                updateStatus();
                return;
            }
        }
        
        // Only add point if it's far enough from the last point
        if (points.length === 0 || 
            snappedPoint.distanceTo(points[points.length - 1]) > 0.1) {
            points.push(snappedPoint);
            updatePreviewLine();
            updateStatus();
        }
    }
}



function selectFaceToExtrude() {
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(quadMeshes);
    
    if (intersects.length > 0) {
        const face = intersects[0].face;
        const mesh = intersects[0].object;
        
        selectedFace = {
            mesh: mesh,
            faceIndex: face.a, // Store the first vertex index of the face
            normal: face.normal.clone()
        };
        
        updateStatus();
    }
}


function highlightFace() {
    // Reset any previously selected face
    quadMeshes.forEach(mesh => {
        if (mesh.material.emissive) {
            mesh.material.emissive.setRGB(0, 0, 0);
        }
    });
    
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(quadMeshes);
    
    if (intersects.length > 0) {
        const mesh = intersects[0].object;
        
        // Highlight by setting emissive color
        if (mesh.material.emissive) {
            mesh.material.emissive.setRGB(0.2, 0.2, 0);
        }
    }
}

function extrudeFace() {
    if (!selectedFace) return;
    
    const mesh = selectedFace.mesh;
    const geometry = mesh.geometry;
    const normal = selectedFace.normal;
    
    // Get the indices of the face to extrude (assuming quads)
    const faceIndex = selectedFace.faceIndex;
    const indices = [];
    
    // For a quad, find the indices that make up the face
    if (geometry.index) {
        for (let i = 0; i < geometry.index.count; i += 3) {
            if (geometry.index.array[i] === faceIndex ||
                geometry.index.array[i+1] === faceIndex ||
                geometry.index.array[i+2] === faceIndex) {
                indices.push(
                    geometry.index.array[i],
                    geometry.index.array[i+1],
                    geometry.index.array[i+2]
                );
                // Get next triangle if it's part of the same quad
                if (i+3 < geometry.index.count && 
                    (geometry.index.array[i+3] === geometry.index.array[i] ||
                     geometry.index.array[i+3] === geometry.index.array[i+1] ||
                     geometry.index.array[i+3] === geometry.index.array[i+2])) {
                    indices.push(
                        geometry.index.array[i+3],
                        geometry.index.array[i+4],
                        geometry.index.array[i+5]
                    );
                }
                break;
            }
        }
    }
    
    if (indices.length === 0) return;
    
    // Get unique vertex indices
    const uniqueIndices = [...new Set(indices)];
    
    // Create new geometry
    const newGeometry = new THREE.BufferGeometry();
    
    // Get position attribute
    const positions = geometry.getAttribute('position');
    const newPositions = [];
    
    // Original vertices
    uniqueIndices.forEach(index => {
        newPositions.push(
            positions.getX(index),
            positions.getY(index),
            positions.getZ(index)
        );
    });
    
    // Extruded vertices
    uniqueIndices.forEach(index => {
        newPositions.push(
            positions.getX(index) + normal.x * extrudeHeight,
            positions.getY(index) + normal.y * extrudeHeight,
            positions.getZ(index) + normal.z * extrudeHeight
        );
    });
    
    // Create new index buffer for the sides
    const newIndices = [];
    
    // The front face (original quad)
    newIndices.push(0, 1, 2, 0, 2, 3);
    
    // The back face (extruded quad)
    newIndices.push(4, 6, 5, 4, 7, 6);
    
    // The four side faces
    newIndices.push(0, 4, 1, 1, 4, 5);
    newIndices.push(1, 5, 2, 2, 5, 6);
    newIndices.push(2, 6, 3, 3, 6, 7);
    newIndices.push(3, 7, 0, 0, 7, 4);
    
    newGeometry.setAttribute('position', new THREE.Float32BufferAttribute(newPositions, 3));
    newGeometry.setIndex(newIndices);
    newGeometry.computeVertexNormals();
    
    const material = new THREE.MeshPhongMaterial({
        color: 0x808080,
        side: THREE.DoubleSide,
        flatShading: true
    });
    
    const newMesh = new THREE.Mesh(newGeometry, material);
    scene.add(newMesh);
    quadMeshes.push(newMesh);
    
    // Remove the original face/mesh
    scene.remove(mesh);
    quadMeshes = quadMeshes.filter(m => m !== mesh);
    mesh.geometry.dispose();
    mesh.material.dispose();
    
    selectedFace = null;
    updateStatus();
}

function createQuad() {
    if (points.length < 4) return;

    // Use the first 4 points or simplify if more
    const validPoints = points.length > 4 ? simplifyPoints(points) : points.slice(0, 4);
    
    const geometry = new THREE.BufferGeometry();
    const vertices = [];
    const indices = [];

    // Create vertices
    for (let i = 0; i < validPoints.length; i++) {
        vertices.push(validPoints[i].x, validPoints[i].y, validPoints[i].z);
    }

    // Create faces - first triangle
    indices.push(0, 1, 2);
    
    // If we have 4 points, add second triangle
    if (validPoints.length >= 4) {
        indices.push(0, 2, 3);
    }

    geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
    geometry.setIndex(indices);
    geometry.computeVertexNormals();

    const material = new THREE.MeshPhongMaterial({
        color: 0x808080,
        side: THREE.DoubleSide,
        flatShading: true
    });

    const quad = new THREE.Mesh(geometry, material);
    scene.add(quad);
    addObjectToScene(quad, "Quad geomitry")
    quadMeshes.push(quad);
    
    // Make it selectable in your existing system
    objects.push(quad);
}

function simplifyPoints(inputPoints) {
    if (inputPoints.length <= 4) return inputPoints;
    
    // Simple algorithm to find corners
    const result = [inputPoints[0]];
    
    // Find point furthest from first point
    let maxDist = 0;
    let furthestIdx = 0;
    for (let i = 1; i < inputPoints.length; i++) {
        const dist = inputPoints[0].distanceTo(inputPoints[i]);
        if (dist > maxDist) {
            maxDist = dist;
            furthestIdx = i;
        }
    }
    result.push(inputPoints[furthestIdx]);
    
    // Find point furthest from line between first and second point
    maxDist = 0;
    furthestIdx = 0;
    const line = new THREE.Line3(result[0], result[1]);
    for (let i = 1; i < inputPoints.length; i++) {
        if (i === result[1]) continue;
        const closest = new THREE.Vector3();
        line.closestPointToPoint(inputPoints[i], true, closest);
        const dist = closest.distanceTo(inputPoints[i]);
        if (dist > maxDist) {
            maxDist = dist;
            furthestIdx = i;
        }
    }
    result.push(inputPoints[furthestIdx]);
    
    // Find the fourth point
    maxDist = 0;
    furthestIdx = 0;
    for (let i = 1; i < inputPoints.length; i++) {
        if (result.includes(inputPoints[i])) continue;
        
        // Calculate area of quad with this point
        const area = calculateQuadArea([
            result[0], result[1], result[2], inputPoints[i]
        ]);
        
        if (area > maxDist) {
            maxDist = area;
            furthestIdx = i;
        }
    }
    result.push(inputPoints[furthestIdx]);
    
    return result;
}

function calculateQuadArea(points) {
    if (points.length !== 4) return 0;
    
    // Calculate area using cross product
    const v1 = points[2].clone().sub(points[0]);
    const v2 = points[3].clone().sub(points[1]);
    return v1.cross(v2).length() / 2;
}


 
// Event listeners setup
function setupEventListeners() {
    // Tool buttons
    document.getElementById('translate').addEventListener('click', () => setTransformMode('translate'));
    document.getElementById('rotate').addEventListener('click', () => setTransformMode('rotate'));
    document.getElementById('scale').addEventListener('click', () => setTransformMode('scale'));
   
    // Event delegation for cleaner code
    document.querySelector('.toolbar-group').addEventListener('click', (event) => {
    const mode = event.target.id;
    if (TRANSFORM_MODES.includes(mode)) {
        setTransformMode(mode);
    }
    });  
    
    
    // Add objects buttons
    document.getElementById('addCube').addEventListener('click', addCube);
    document.getElementById('addSphere').addEventListener('click', addSphere);
    document.getElementById('addSculptingSphere').addEventListener('click', addSculptingSphere);

    document.getElementById("addSculptingSphere").addEventListener("click", function() {
       const sculptingTools = document.getElementById("sculpting-character-tools");
      // Toggle visibility
      if (sculptingTools.style.display === "none" || sculptingTools.style.display === "") {
        sculptingTools.style.display = "block";
      } else {
        sculptingTools.style.display = "none";
    }
    });

    document.getElementById("addTerrain").addEventListener("click", function() {
       const sculptingTools = document.getElementById("sculpting-tools");
      // Toggle visibility
      if (sculptingTools.style.display === "none" || sculptingTools.style.display === "") {
        sculptingTools.style.display = "block";
      } else {
        sculptingTools.style.display = "none";
    }
    });

    document.getElementById("materialsEditor").addEventListener("click", function() {
       const materialsEditor = document.getElementById("material-editor");
      // Toggle visibility
      if (materialsEditor.style.display === "none" || materialsEditor.style.display === "") {
        materialsEditor.style.display = "block";
      } else {
        materialsEditor.style.display = "none";
    }
    });

    document.getElementById("guiControls").addEventListener("click", function() {
       const guiControlsEditor = document.getElementById("GuiContainer");
      // Toggle visibility
      if (guiControlsEditor.style.display === "none" || guiControlsEditor.style.display === "") {
        guiControlsEditor.style.display = "block";
      } else {
        guiControlsEditor.style.display = "none";
    }
    });

    document.getElementById("cameraControls").addEventListener("click", function() {
       const cameraControls = document.getElementById("Cameras");
      // Toggle visibility
      if (cameraControls.style.display === "none" || cameraControls.style.display === "") {
        cameraControls.style.display = "block";
      } else {
        cameraControls.style.display = "none";
    }
    });

    document.getElementById("lightControls").addEventListener("click", function() {
       const lightControls = document.getElementById("lights");
      // Toggle visibility
      if (lightControls.style.display === "none" || lightControls.style.display === "") {
        lightControls.style.display = "block";
      } else {
        lightControls.style.display = "none";
    }
    });

    document.getElementById("modelingControls").addEventListener("click", function() {
       const modelingTools = document.getElementById("modelingTools");
      // Toggle visibility
      if (modelingTools.style.display === "none" || modelingTools.style.display === "") {
        modelingTools.style.display = "block";
      } else {
        modelingTools.style.display = "none";
    }
    });

    document.getElementById("soundControls").addEventListener("click", function() {
        const meterSection = document.getElementById("sound-controls-meter");
        const visSection = document.getElementById("sound-controls-vis");
        const headerSection = document.getElementById("sound-controls-header");

        // Toggle all sections
        const isHidden = meterSection.style.display === "none" || meterSection.style.display === "";
    
        meterSection.style.display = isHidden ? "block" : "none";
        visSection.style.display = isHidden ? "block" : "none";
        headerSection.style.display = isHidden ? "block" : "none";
    });

    document.getElementById("drawingControls").addEventListener("click", function() {
       const drawingTools = document.getElementById("drawingMode");
      // Toggle visibility
      if (drawingTools.style.display === "none" || drawingTools.style.display === "") {
         drawingTools.style.display = "block";
      } else {
        drawingTools.style.display = "none";
    }
    });

    document.getElementById("physicsControls").addEventListener("click", function() {
       const physicsControls = document.getElementById("physics-controls");
      // Toggle visibility
      if (physicsControls.style.display === "none" || physicsControls.style.display === "") {
        physicsControls.style.display = "block";
      } else {
        physicsControls.style.display = "none";
    }
    });

    document.getElementById("snow-controls").addEventListener("click", function() {
       const snowTools = document.getElementById("snow-sittings");
      // Toggle visibility
      if (snowTools.style.display === "none" || snowTools.style.display === "") {
        snowTools.style.display = "block";
      } else {
        snowTools.style.display = "none";
    }
    });

    document.getElementById('addPlane').addEventListener('click', addPlane);
    document.getElementById('addCylinder').addEventListener('click', addCylinder);
    document.getElementById('addPyramid').addEventListener('click', addPyramid);
    document.getElementById('addRectangularPrism').addEventListener('click', addRectangularPrism);
    document.getElementById('addTorus').addEventListener('click', addTorus)
    document.getElementById('addLight').addEventListener('click', addLight);
    document.getElementById('addCameraInit').addEventListener('click', addCameraInit);

    //cloths
    document.getElementById('addCloth').addEventListener('click', () => {
        if (!selectedObject) {
           console.warn("No object selected for cloth application");
           return;
        }
    
        if (!physicsManager.clothSystem) {
            physicsManager.initClothSystem();
        }
        physicsManager.clothSystem.createClothForObject(selectedObject);
    });

    document.getElementById('removeCloth').addEventListener('click', () => {
       if (!selectedObject || !physicsManager.clothSystem) return;
       physicsManager.clothSystem.removeClothFromObject(selectedObject);
    });
  
    renderer.domElement.addEventListener('mousemove', onModelingMouseMove);
    renderer.domElement.addEventListener('click', onModelingClick);

    window.addEventListener('resize', onWindowResize, false);
        window.addEventListener('keydown', (e) => {
            if (e.key === 'f' || e.key === 'F') {
                toggleDrawMode();
            }
            if (e.key === 'e' || e.key === 'E') {
                toggleExtrudeMode();
            }
            if (e.key === 'l' || e.key === 'L') {
                clearGeometry();
            }
            if (e.key === 'Escape') {
                exitCurrentMode();
            }
    });
            
    document.getElementById('toggle-draw').addEventListener('click', toggleDrawMode);
    document.getElementById('toggle-extrude').addEventListener('click', toggleExtrudeMode);
    document.getElementById('clear').addEventListener('click', clearGeometry);
            
    document.getElementById('brush-size').addEventListener('input', (e) => {
        brushSize = parseFloat(e.target.value);
        e.target.nextElementSibling.textContent = `Brush Size: ${brushSize.toFixed(1)}`;
    });
            
    document.getElementById('snapping').addEventListener('input', (e) => {
        snapThreshold = parseFloat(e.target.value);
        e.target.nextElementSibling.textContent = `Snapping: ${snapThreshold.toFixed(1)}`;
    });
            
    document.getElementById('extrude-height').addEventListener('input', (e) => {
         extrudeHeight = parseFloat(e.target.value);
        e.target.nextElementSibling.textContent = `Extrude: ${extrudeHeight.toFixed(1)}`;
    });

    const canvas = renderer.domElement;
    canvas.addEventListener('mousedown', onMouseDown);
    canvas.addEventListener('mousemove', onMouseMove);
    canvas.addEventListener('mouseup', onMouseUp);
    canvas.addEventListener('wheel', onMouseWheel);
    canvas.addEventListener('pointerdown', (event) => {
        if (isModelingMode) return;  // Skip selection in modeling mode

        const rect = canvas.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(scene.children, true);

        if (intersects.length > 0) {
            const firstSelectable = intersects.find(i => i.object.userData.selectable);
            if (firstSelectable) {
                const clickedObject = firstSelectable.object;
                setHoverObject(clickedObject);     // visually hover on click
                selectObject(clickedObject);       // also select
            }
        }
    });
    
    //Particls
    document.addEventListener("DOMContentLoaded", () => {
        document.getElementById("toggleParticles").addEventListener("click", toggleParticles);
    });

    document.getElementById('increaseParticles').addEventListener('click', () => changeParticlesCount(1000));  // Increase by 1000
    document.getElementById('decreaseParticles').addEventListener('click', () => changeParticlesCount(-1000));  // Decrease by 1000
    document.getElementById('particleColor').addEventListener('input', (e) => changeParticleColor(e.target.value));  // Color picker

    //Snow 
    document.getElementById('density').addEventListener('input', (e) => {
    params.density = parseInt(e.target.value);
    document.getElementById('densityValue').textContent = params.density;
    recreateSnow();
    });
    

    document.addEventListener('keydown', (event) => {
    if (event.key === 's') {
        stormMode = !stormMode;
    }
    });

    
    document.getElementById('size').addEventListener('input', (e) => {
        params.size = parseFloat(e.target.value);
        document.getElementById('sizeValue').textContent = params.size;
         updateSnowSize();
    });

    document.getElementById('speed').addEventListener('input', (e) => {
        params.speed = parseFloat(e.target.value);
         document.getElementById('speedValue').textContent = params.speed;
    });

    document.getElementById('wind').addEventListener('input', (e) => {
        params.wind = parseFloat(e.target.value);
        document.getElementById('windValue').textContent = params.wind;
    });

    document.getElementById('turbulence').addEventListener('input', (e) => {
        params.turbulence = parseFloat(e.target.value);
        document.getElementById('turbulenceValue').textContent = params.turbulence;
    });



    setupWeatherEffects();

    //hierarchy resizing
    document.addEventListener('DOMContentLoaded', () => {
        setupHierarchyResize();
    });
    
    // add Physics listeners here
    document.querySelectorAll('.preview-item').forEach(item => {
        item.addEventListener('click', (e) => {
            document.querySelectorAll('.preview-item').forEach(i => i.classList.remove('active'));
            e.target.closest('.preview-item').classList.add('active');
            
            const type = e.target.closest('.preview-item').dataset.type;
            if (window.brushSystem) {
                window.brushSystem.setModelType(type);
            }
        });
    });

    // Add model upload handler
    document.getElementById('model-upload').addEventListener('change', (e) => {
        const file = e.target.files[0];
        const loader = new THREE.GLTFLoader();
        
        loader.load(URL.createObjectURL(file), (gltf) => {
            if (window.brushSystem) {
                window.brushSystem.loadedModels.set('current', gltf.scene);
                window.brushSystem.loadedModels.set('custom', gltf.scene);
            }
        });
    });

    //material brush system listeners
    document.getElementById('materialPaint').addEventListener('click', () => {
        selectedTool = TOOLS.MATERIAL_PAINT;
        updateToolUI('materialPaint');
    });

    // Material Upload
    document.getElementById('selectMaterial').addEventListener('click', () => {
        document.getElementById('uploadMaterial').click();
    });

    document.getElementById('uploadMaterial').addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const image = new Image();
                image.onload = () => {
                    uploadedMaterial = image;
                    updateMaterialPreview();
                };
                image.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
    });

    // Material Brush Controls
    document.getElementById('materialBrushSize').addEventListener('input', (e) => {
        materialBrushSettings.size = parseFloat(e.target.value);
        updateBrushPreview();
    });

    document.getElementById('materialStrength').addEventListener('input', (e) => {
        materialBrushSettings.strength = parseFloat(e.target.value);
    });

    document.getElementById('materialFalloff').addEventListener('input', (e) => {
        materialBrushSettings.falloff = parseFloat(e.target.value);
    });

    document.getElementById('materialRotation').addEventListener('input', (e) => {
        materialBrushSettings.rotation = parseFloat(e.target.value);
    });

    document.getElementById('materialScale').addEventListener('input', (e) => {
        materialBrushSettings.scale = parseFloat(e.target.value);
    });

    document.getElementById('materialOpacity').addEventListener('input', (e) => {
        materialBrushSettings.opacity = parseFloat(e.target.value);
    });

    document.getElementById('materialPattern').addEventListener('change', (e) => {
        materialBrushSettings.pattern = e.target.value;
    });

    document.getElementById('materialBlendMode').addEventListener('change', (e) => {
        materialBrushSettings.blendMode = e.target.value;
    });


 
   
    window.addEventListener('resize', onWindowResize);
    // In setupEventListeners()
    document.getElementById('raiseLower').addEventListener('click', () => {
        selectedTool = TOOLS.RAISE_LOWER;
        updateToolUI('raiseLower');
    });
    document.getElementById('smooth').addEventListener('click', () => {
        selectedTool = TOOLS.SMOOTH;
        updateToolUI('smooth');
    });
    document.getElementById('flatten').addEventListener('click', () => {
        selectedTool = TOOLS.FLATTEN;
        updateToolUI('flatten');
    });
    document.getElementById('noise').addEventListener('click', () => {
        selectedTool = TOOLS.NOISE;
        updateToolUI('noise');
    });
    document.getElementById('pinch').addEventListener('click', () => {
        selectedTool = TOOLS.PINCH;
        updateToolUI('pinch');
    });
    document.getElementById('clay').addEventListener('click', () => {
        selectedTool = TOOLS.CLAY;
        updateToolUI('clay');
    });
    document.getElementById('scrape').addEventListener('click', () => {
        selectedTool = TOOLS.SCRAPE;
        updateToolUI('scrape');
    });
    document.getElementById('fill').addEventListener('click', () => {
        selectedTool = TOOLS.FILL;
        updateToolUI('fill');
    });

    //NWE ADVANCED TOOLS
    document.getElementById('terrace').addEventListener('click', () => {
        selectedTool = TOOLS.TERRACE;
        updateToolUI('terrace');
    });
    document.getElementById('erosion').addEventListener('click', () => {
        selectedTool = TOOLS.EROSION;
        updateToolUI('erosion');
    });
    document.getElementById('ridge').addEventListener('click', () => {
        selectedTool = TOOLS.RIDGE;
        updateToolUI('ridge');
    });
    document.getElementById('canyon').addEventListener('click', () => {
        selectedTool = TOOLS.CANYON;
        updateToolUI('canyon');
    });
    document.getElementById('plateau').addEventListener('click', () => {
        selectedTool = TOOLS.PLATEAU;
        updateToolUI('plateau');
    });
    document.getElementById('slope').addEventListener('click', () => {
        selectedTool = TOOLS.SLOPE;
        updateToolUI('slope');
    });
    document.getElementById('blur').addEventListener('click', () => {
        selectedTool = TOOLS.BLUR;
        updateToolUI('blur');
    });
    document.getElementById('sharpen').addEventListener('click', () => {
        selectedTool = TOOLS.SHARPEN;
        updateToolUI('sharpen');
    });

    // Settings of textures
    document.getElementById('selectTexture').addEventListener('click', () => {
        document.getElementById('uploadTexture').click();
    });


    document.getElementById('uploadTexture').addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const image = new Image();
                image.onload = () => {
                    uploadedTextureImage = image; // Store raw image for painting
                    console.log('Texture uploaded for painting');

                    // Optional preview
                    const previewCanvas = document.getElementById('texturePreview');
                    if (previewCanvas) {
                        const ctx = previewCanvas.getContext('2d');
                        ctx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
                        ctx.drawImage(image, 0, 0, previewCanvas.width, previewCanvas.height);
                    }
                };
                image.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
    });

    document.getElementById('texturePaint').addEventListener('click', () => {
        selectedTool = TOOLS.TEXTURE_PAINT;
        updateToolUI('texturePaint');
    });
    
    // Add this new function to update UI
    function updateToolUI(toolId) {
        document.querySelectorAll('.panel-button').forEach(button => {
            button.classList.remove('active');
        });
        document.getElementById(toolId).classList.add('active');
    }
    

    // Terrain creation button
    document.getElementById('addTerrain').addEventListener('click', createTerrain);

    // Brush size controls
    document.getElementById('brushSize').addEventListener('input', (e) => {
        brushSize = parseFloat(e.target.value);
    });

    document.getElementById('brushStrength').addEventListener('input', (e) => {
        brushStrength = parseFloat(e.target.value);
    });

   

    // Mouse move for brush preview
    renderer.domElement.addEventListener('mousemove', updateBrushPreview);

    // Add pointer events for sculpting and painting
    renderer.domElement.addEventListener('pointerdown', (event) => {
        isSculpting = true;
        if (selectedTool === TOOLS.TEXTURE_PAINT) {
            applyTexturePaint(event);
        } else if (selectedTool) {
            applySculpting(event);
        }
    });

    renderer.domElement.addEventListener('pointermove', (event) => {
        updateBrushPreview(event); // Blue brush for feedback
        if (isSculpting) {
            if (selectedTool === TOOLS.TEXTURE_PAINT) {
                applyTexturePaint(event);
            } else if (selectedTool) {
                applySculpting(event);
            }
        }
    });

    renderer.domElement.addEventListener('pointerup', () => {
        isSculpting = false;
    });

    
    // Symmetry controls
    document.getElementById('symmetryToggle').addEventListener('change', (e) => {
        symmetryEnabled = e.target.checked;
    });
    
    document.getElementById('symmetryAxis').addEventListener('change', (e) => {
        symmetryAxis = e.target.value;
    });
    
    // History controls
    document.getElementById('undo').addEventListener('click', () => {
        if (undoStack.length > 0) {
            const currentState = terrain.geometry.attributes.position.array.slice();
            redoStack.push(currentState);
            
            const previousState = undoStack.pop();
            terrain.geometry.attributes.position.array.set(previousState);
            terrain.geometry.attributes.position.needsUpdate = true;
            terrain.geometry.computeVertexNormals();
        }
    });
    
    document.getElementById('redo').addEventListener('click', () => {
        if (redoStack.length > 0) {
            const currentState = terrain.geometry.attributes.position.array.slice();
            undoStack.push(currentState);
            
            const nextState = redoStack.pop();
            terrain.geometry.attributes.position.array.set(nextState);
            terrain.geometry.attributes.position.needsUpdate = true;
            terrain.geometry.computeVertexNormals();
        }
    });


    // Add helper function to find symmetry vertex index
    function findSymmetryVertexIndex(originalIndex, vertices) {
        const original = new THREE.Vector3(
            vertices.getX(originalIndex),
            vertices.getY(originalIndex),
            vertices.getZ(originalIndex)
        );
        
        // Create world position for more accurate symmetry
        const worldPosition = original.clone();
        terrain.localToWorld(worldPosition);
        
        // Create symmetry point
        const symmetryPoint = worldPosition.clone();
        symmetryPoint[symmetryAxis] *= -1;
        
        // Transform back to local space
        terrain.worldToLocal(symmetryPoint);
        
        let closestIndex = -1;
        let minDistance = Infinity;
        
        for (let i = 0; i < vertices.count; i++) {
            if (i === originalIndex) continue;
    
            const vertex = new THREE.Vector3(
                vertices.getX(i),
                vertices.getY(i),
                vertices.getZ(i)
            );
            
            // More precise symmetry detection
            const tolerance = 0.001;
            const isSymmetric = Math.abs(vertex[symmetryAxis] + original[symmetryAxis]) < tolerance;
            
            if (isSymmetric) {
                const otherAxes = ['x', 'y', 'z'].filter(axis => axis !== symmetryAxis);
                const matchesOtherAxes = otherAxes.every(axis => 
                    Math.abs(vertex[axis] - original[axis]) < tolerance
                );
                
                if (matchesOtherAxes) {
                    return i;
                }
                
                const distance = vertex.distanceTo(symmetryPoint);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestIndex = i;
                }
            }
        }
        
        return closestIndex;
    }
    
   
    
    // File operations
    document.getElementById('newScene').addEventListener('click', newScene);
    document.getElementById('saveScene').addEventListener('click', saveScene);
    document.getElementById('loadScene').addEventListener('click', loadScene);
    document.getElementById('exportButton').addEventListener('click', exportScene);
    document.getElementById('importScene').addEventListener('click', importScene);

    
    // Timeline controls
    document.getElementById('play').addEventListener('click', playAnimation);
    document.getElementById('pause').addEventListener('click', pauseAnimation);
    document.getElementById('stop').addEventListener('click', stopAnimation); 
 
     // Transform controls events
     transformControls.addEventListener('dragging-changed', function(event) {
         controls.enabled = !event.value;
     });
 
     transformControls.addEventListener('change', updateInspector);

}


// Object creation functions
function addCube() {
    const geometry = new THREE.BoxGeometry();
    const material = new THREE.MeshStandardMaterial({ color: 0x00ff00 , side: THREE.DoubleSide });
    const cube = new THREE.Mesh(geometry, material);
    cube.castShadow = true;
    cube.receiveShadow = true;
    cube.position.set(0, 0.5, 0); // Start above ground
    cube.renderOrder = 0;  // This will render after (in front of) the grid
    addObjectToScene(cube, 'Cube');
}  



 function addPlane() {
    const geometry = new THREE.PlaneGeometry(10, 10); // Width: 10, Height: 10
    const material = new THREE.MeshStandardMaterial({ color: 0x87CEEB, side: THREE.DoubleSide });
    const plane = new THREE.Mesh(geometry, material);
    plane.rotation.x = -Math.PI / 2; // Rotate to lay flat on the ground
    addObjectToScene(plane, 'Plane');
}



let symmetryEnabled = false;
let symmetryAxis = 'x';
let undoStack = [];
let redoStack = [];
let lastSavedState = null;
let autoSaveInterval = 5000; 


let brushSize = 1.5; // Default brush size
let brushStrength = 0.1; // Default brush strength
let brushPreview; // Brush preview mesh


let terrain; // Reference to the terrain
let selectedTool = null; // Current active tool
let isSculpting = false; // Flag for sculpting state
let uploadedTexture = null; // Stores the uploaded texture for painting

const TOOLS = {
    RAISE_LOWER: 'raiseLower',
    SMOOTH: 'smooth',
    FLATTEN: 'flatten',
    NOISE: 'noise',
    PINCH: 'pinch',
    CLAY: 'clay',
    SCRAPE: 'scrape',
    FILL: 'fill',
    TEXTURE_PAINT: 'texturePaint',
    TERRACE: 'terrace',
    EROSION: 'erosion',
    RIDGE: 'ridge',
    CANYON: 'canyon',
    PLATEAU: 'plateau',
    SLOPE: 'slope',
    BLUR: 'blur',
    SHARPEN: 'sharpen',
    MATERIAL_PAINT: 'materialPaint'
};


function applySymmetry(originalVertex, index, vertices) {
    if (!symmetryEnabled) return;

    const symmetryVertex = originalVertex.clone();
    symmetryVertex[symmetryAxis] *= -1;

    // search symitry point
    const tolerance = 0.0001;
    for (let i = 0; i < vertices.count; i++) {
        if (i === index) continue;
        
        const vertex = new THREE.Vector3(
            vertices.getX(i),
            vertices.getY(i),
            vertices.getZ(i)
        );

        if (Math.abs(vertex[symmetryAxis] + originalVertex[symmetryAxis]) < tolerance &&
            Math.abs(vertex[(symmetryAxis === 'x' ? 'z' : 'x')] - originalVertex[(symmetryAxis === 'x' ? 'z' : 'x')]) < tolerance) {
            vertices.setXYZ(i, symmetryVertex.x, symmetryVertex.y, symmetryVertex.z);
            break;
        }
    }
}

function createTerrain() {
    const width = 50;
    const height = 50;
    const widthSegments = 100;
    const heightSegments = 100;

    const geometry = new THREE.PlaneGeometry(width, height, widthSegments, heightSegments);
    geometry.rotateX(-Math.PI / 2);

    const canvas = document.createElement('canvas');
    canvas.width = 1024;
    canvas.height = 1024;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#87CEEB';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    const texture = new THREE.CanvasTexture(canvas);
    texture.needsUpdate = true;

    const material = new THREE.MeshStandardMaterial({
        color: 0x87CEEB,
        map: texture,
        side: THREE.DoubleSide
    });

    terrain = new THREE.Mesh(geometry, material);
    terrain.userData.textureCanvas = canvas;
    terrain.userData.textureContext = ctx;
    terrain.geometry.attributes.position.needsUpdate = true;
    terrain.receiveShadow = true;
    terrain.castShadow = true;

    scene.add(terrain);
    addObjectToScene(terrain, 'Terrain');

    createBrushPreview();

    if (!window.brushSystem) {
        window.brushSystem = new TerrainBrushSystem(scene, camera, renderer, terrain);
    }
}


// Create advanced brush preview
function createBrushPreview() {
    if (brushPreview) {
        scene.remove(brushPreview);
    }

    // Create inner circle
    const innerGeometry = new THREE.CircleGeometry(1, 32);
    const innerMaterial = new THREE.MeshBasicMaterial({
        color: 0x4A90E2,
        transparent: true,
        opacity: 0.3,
        side: THREE.DoubleSide
    });
    
    // Create outer circle (falloff indicator)
    const outerGeometry = new THREE.RingGeometry(0.8, 1, 32);
    const outerMaterial = new THREE.MeshBasicMaterial({
        color: 0x4A90E2,
        transparent: true,
        opacity: 0.15,
        side: THREE.DoubleSide
    });

    // Create direction indicator for certain tools
    const directionGeometry = new THREE.ConeGeometry(0.2, 0.5, 32);
    const directionMaterial = new THREE.MeshBasicMaterial({
        color: 0xEE82EE,
        transparent: true,
        opacity: 0.5
    });

    const innerCircle = new THREE.Mesh(innerGeometry, innerMaterial);
    const outerCircle = new THREE.Mesh(outerGeometry, outerMaterial);
    const directionIndicator = new THREE.Mesh(directionGeometry, directionMaterial);

    brushPreview = new THREE.Group();
    brushPreview.add(innerCircle);
    brushPreview.add(outerCircle);
    brushPreview.add(directionIndicator);
    
    brushPreview.rotation.x = -Math.PI / 2;
    brushPreview.visible = false;
    scene.add(brushPreview);
}


// Update brush preview with advanced features
function updateBrushPreview(event) {
    if (!terrain || !brushPreview) return;

    const mouse = new THREE.Vector2(
        (event.clientX / window.innerWidth) * 2 - 1,
        -(event.clientY / window.innerHeight) * 2 + 1
    );

    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(terrain);

    if (intersects.length > 0) {
        const intersect = intersects[0];
        brushPreview.position.copy(intersect.point);
        
        if (selectedTool === TOOLS.MATERIAL_PAINT) {
            brushPreview.scale.set(materialBrushSettings.size, materialBrushSettings.size, 1);
            if (materialPreviewTexture) {
                brushPreview.children[0].material.map = materialPreviewTexture;
                brushPreview.children[0].material.opacity = materialBrushSettings.opacity;
                brushPreview.children[0].material.needsUpdate = true;
            }
        } else {
            brushPreview.scale.set(brushSize, brushSize, 1);
            brushPreview.children[0].material.map = null;
            brushPreview.children[0].material.needsUpdate = true;
        }
        brushPreview.visible = Object.values(TOOLS).includes(selectedTool);
    } else {
        brushPreview.visible = false;
    }
}


// Save terrain state for undo/redo
function saveTerrainState() {
    const positions = terrain.geometry.attributes.position.array.slice();
    undoStack.push(positions);
    redoStack.length = 0; // Clear redo stack when new action is performed
    
    // Limit undo stack size
    if (undoStack.length > 20) {
        undoStack.shift();
    }
}

// Advanced sculpting functions
function pinchTerrain(vertex, position, influence) {
    const direction = new THREE.Vector3().subVectors(position, vertex);
    vertex.add(direction.multiplyScalar(influence * brushStrength));
}

function clayTerrain(vertex, position, influence, normal) {
    const offset = normal.multiplyScalar(brushStrength * influence);
    if (vertex.y < position.y) {
        vertex.add(offset);
    }
}

function scrapeTerrain(vertex, position, influence, normal) {
    const offset = normal.multiplyScalar(-brushStrength * influence);
    if (vertex.y > position.y) {
        vertex.add(offset);
    }
}

function fillTerrain(vertex, position, influence) {
    if (vertex.y < position.y) {
        vertex.y += brushStrength * influence;
    }
}

function startSculpting(event) {
    isSculpting = true;
    applySculpting(event);
    applySculpting1(event);
}

function stopSculpting() {
    isSculpting = false;
}




// تحسين دالة معالجة النحت
function applySculpting(event) {
    if (!isSculpting || !selectedTool || !terrain) return;

    const mouse = new THREE.Vector2(
        (event.clientX / window.innerWidth) * 2 - 1,
        -(event.clientY / window.innerHeight) * 2 + 1
    );
    
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(terrain);
    
    if (intersects.length > 0) {
        // Save state for undo/redo
        if (!lastSavedState || Date.now() - lastSavedState > autoSaveInterval) {
            saveTerrainState();
            lastSavedState = Date.now();
        }
        
        const intersect = intersects[0];
        const vertices = terrain.geometry.attributes.position;
        const position = intersect.point.clone();
        const normal = intersect.face.normal.clone().transformDirection(terrain.matrixWorld);
        
        // Transform position to local space
        terrain.worldToLocal(position);
        
        // Handle material painting separately
        if (selectedTool === TOOLS.MATERIAL_PAINT) {
            applyMaterialPaint(event);
            return; // Exit early since material painting doesn't modify vertices
        }

        for (let i = 0; i < vertices.count; i++) {
            const vertex = new THREE.Vector3(
                vertices.getX(i),
                vertices.getY(i),
                vertices.getZ(i)
            );
            
            const distance = vertex.distanceTo(position);
            if (distance < brushSize) {
                const influence = Math.pow(1 - (distance / brushSize), 2); // Smoother falloff
                const originalVertex = vertex.clone();
                
                // Apply tool effect
                switch (selectedTool) {
                    case TOOLS.RAISE_LOWER:
                        vertex.y += brushStrength * influence;
                        break;
                    case TOOLS.SMOOTH:
                        vertex.y += (position.y - vertex.y) * influence * brushStrength;
                        break;
                    case TOOLS.FLATTEN:
                        vertex.y += (position.y - vertex.y) * influence;
                        break;
                    case TOOLS.NOISE:
                        vertex.y += (Math.random() - 0.5) * brushStrength * influence * 2;
                        break;
                    case TOOLS.PINCH:
                        const toCenter = new THREE.Vector3().subVectors(position, vertex);
                        vertex.add(toCenter.multiplyScalar(influence * brushStrength));
                        break;
                    case TOOLS.CLAY:
                        if (vertex.y < position.y) {
                            vertex.add(normal.clone().multiplyScalar(brushStrength * influence));
                        }
                        break;
                    case TOOLS.SCRAPE:
                        if (vertex.y > position.y) {
                            vertex.add(normal.clone().multiplyScalar(-brushStrength * influence));
                        }
                        break;
                    case TOOLS.FILL:
                        if (vertex.y < position.y) {
                            vertex.y += brushStrength * influence;
                        }
                        break;
                    case TOOLS.TERRACE:
                        applyTerrace(vertex, position, influence);
                        break;
                    case TOOLS.EROSION:
                        applyErosion(vertex, position, influence, vertices, i);
                        break;
                    case TOOLS.RIDGE:
                        applyRidge(vertex, position, influence);
                        break;
                    case TOOLS.CANYON:
                        applyCanyon(vertex, position, influence);
                        break;
                    case TOOLS.PLATEAU:
                        applyPlateau(vertex, position, influence);
                        break;
                    case TOOLS.SLOPE:
                        applySlope(vertex, position, influence, normal);
                        break;
                    case TOOLS.BLUR:
                        applyBlur(vertex, position, influence, vertices, i);
                        break;
                    case TOOLS.SHARPEN:
                        applySharpen(vertex, position, influence, vertices, i);
                        break;
                }
                
                vertices.setXYZ(i, vertex.x, vertex.y, vertex.z);
                applySymmetry(originalVertex, i, vertices);
               
            }
        }
        
        vertices.needsUpdate = true;
        terrain.geometry.computeVertexNormals();
    }
}

// Advanced Texture Painting Function
let uploadedTextureImage = null; 

function applyTexturePaint(event) {
    if (!terrain || !terrain.userData.textureCanvas || !uploadedTextureImage) {
        console.error('Terrain, texture canvas, or uploaded texture not ready');
        return;
    }

    const mouse = new THREE.Vector2(
        (event.clientX / window.innerWidth) * 2 - 1,
        -(event.clientY / window.innerHeight) * 2 + 1
    );

    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(terrain);

    if (intersects.length > 0) {
        const intersect = intersects[0];
        const uv = intersect.uv;
        const ctx = terrain.userData.textureContext;
        const canvas = terrain.userData.textureCanvas;

        // Calculate brush position on canvas
        const x = uv.x * canvas.width;
        const y = (1 - uv.y) * canvas.height;
        const brushRadius = brushSize * 50; // Scale to canvas size

        // Save current state for undo
        if (!lastSavedState || Date.now() - lastSavedState > autoSaveInterval) {
            saveTerrainState();
            lastSavedState = Date.now();
        }

        // Create a temporary canvas for the brush
        const brushCanvas = document.createElement('canvas');
        brushCanvas.width = brushRadius * 2;
        brushCanvas.height = brushRadius * 2;
        const brushCtx = brushCanvas.getContext('2d');

        // Draw the uploaded texture portion
        const sx = uv.x * uploadedTextureImage.width - brushRadius;
        const sy = (1 - uv.y) * uploadedTextureImage.height - brushRadius;
        brushCtx.drawImage(
            uploadedTextureImage,
            sx, sy, brushRadius * 2, brushRadius * 2,
            0, 0, brushCanvas.width, brushCanvas.height
        );

        // Apply brush mask with gradient
        const gradient = brushCtx.createRadialGradient(
            brushRadius, brushRadius, 0,
            brushRadius, brushRadius, brushRadius
        );
        gradient.addColorStop(0, `rgba(255, 255, 255, ${brushStrength})`);
        gradient.addColorStop(0.7, `rgba(255, 255, 255, ${brushStrength * 0.3})`);
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        
        brushCtx.globalCompositeOperation = 'destination-in';
        brushCtx.fillStyle = gradient;
        brushCtx.beginPath();
        brushCtx.arc(brushRadius, brushRadius, brushRadius, 0, Math.PI * 2);
        brushCtx.fill();

        // Draw the brush result onto the terrain texture
        ctx.drawImage(
            brushCanvas,
            x - brushRadius,
            y - brushRadius
        );

        // Update the texture
        terrain.material.map.needsUpdate = true;
    }
}

function addSphere() {
    const geometry = new THREE.SphereGeometry(0.5, 32, 32);
    const material = new THREE.MeshStandardMaterial({ color: 0xff0000, side: THREE.DoubleSide });
    const sphere = new THREE.Mesh(geometry, material);
    sphere.castShadow = true;
    sphere.receiveShadow = true;
    sphere.position.set(0, 0.5, 0);
    addObjectToScene(sphere, 'Sphere');
    meshes.push(sphere);
}
 
 function addCylinder() {
     const geometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 32);
     const material = new THREE.MeshStandardMaterial({ color: 0x0000ff, side: THREE.DoubleSide });
     const cylinder = new THREE.Mesh(geometry, material);
     cylinder.castShadow = true;
     cylinder.receiveShadow = true;
     cylinder.position.set(0, 0.5, 0);
     addObjectToScene(cylinder, 'Cylinder');
    meshes.push(cylinder);
 }
 
 // Function to add a Pyramid
function addPyramid() {
    const geometry = new THREE.ConeGeometry(1, 2, 4); // Base radius 1, height 2, 4 sides
    const material = new THREE.MeshStandardMaterial({ color: 0xFFD700, side: THREE.DoubleSide });
    const pyramid = new THREE.Mesh(geometry, material);
    pyramid.castShadow = true;
    pyramid.receiveShadow = true;
    pyramid.position.set(0, 1, 0);
    addObjectToScene(pyramid, 'Pyramid');
    meshes.push(pyramid);
}

// Function to add a Rectangular Prism
function addRectangularPrism() {
    const geometry = new THREE.BoxGeometry(1, 2, 3); // Adjust dimensions for rectangular prism
    const material = new THREE.MeshStandardMaterial({ color: 0x8A2BE2, side: THREE.DoubleSide  });
    const rectangularPrism = new THREE.Mesh(geometry, material);
    rectangularPrism.castShadow = true;
    rectangularPrism.receiveShadow = true;
    rectangularPrism.position.set(0, 1, 0);
    addObjectToScene(rectangularPrism, 'Rectangular Prism');
    meshes.push(rectangularPrism);
}

// Function to add a Torus (Donut Shape)
function addTorus() {
    const geometry = new THREE.TorusGeometry(1, 0.4, 16, 100); // Radius 1, tube radius 0.4
    const material = new THREE.MeshStandardMaterial({ color: 0xFF4500, side: THREE.DoubleSide  });
    const torus = new THREE.Mesh(geometry, material);
    torus.castShadow = true;
    torus.receiveShadow = true;
    torus.position.set(0, 1, 0);
    addObjectToScene(torus, 'Torus');
    meshes.push(torus);
}

 function addLight() {
    const light = new THREE.PointLight(0xffffff, 1);
    light.position.set(0, 2, 0);
    addObjectToScene(light, 'Light');
 }
 
function addCameraInit() {
    const newCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    newCamera.position.set(0, 0, 5);
    addObjectToScene(newCamera, 'Camera');
}




// Advanced tool implementations
function applyTerrace(vertex, position, influence) {
    const steps = parseInt(document.getElementById('terraceSteps').value);
    const heightDiff = position.y - vertex.y;
    const stepHeight = heightDiff / steps;
    
    // Calculate closest step
    const currentStep = Math.round(vertex.y / stepHeight);
    const targetHeight = currentStep * stepHeight;
    
    // Smooth transition between steps
    vertex.y += (targetHeight - vertex.y) * influence * brushStrength;
}

function applyErosion(vertex, position, influence, vertices, index) {
    const erosionStrength = parseFloat(document.getElementById('erosionStrength').value);
    const radius = brushSize * 2;
    let avgHeight = 0;
    let count = 0;
    
    // Sample neighboring vertices
    for (let i = 0; i < vertices.count; i++) {
        const neighborVertex = new THREE.Vector3(
            vertices.getX(i),
            vertices.getY(i),
            vertices.getZ(i)
        );
        
        const distance = vertex.distanceTo(neighborVertex);
        if (distance < radius && distance > 0) {
            avgHeight += neighborVertex.y;
            count++;
        }
    }
    
    if (count > 0) {
        avgHeight /= count;
        const heightDiff = vertex.y - avgHeight;
        vertex.y -= heightDiff * erosionStrength * influence;
    }
}

function applyRidge(vertex, position, influence) {
    const ridgeHeight = parseFloat(document.getElementById('ridgeHeight').value);
    const distance = Math.abs(vertex.x - position.x);
    const falloff = 1 - Math.min(distance / brushSize, 1);
    
    if (falloff > 0) {
        // Create ridge shape using sine function
        const ridge = Math.sin(falloff * Math.PI) * ridgeHeight;
        vertex.y += ridge * influence * brushStrength;
    }
}

function applyCanyon(vertex, position, influence) {
    const depth = brushStrength * 2;
    const distance = Math.abs(vertex.x - position.x);
    const falloff = 1 - Math.min(distance / brushSize, 1);
    
    if (falloff > 0) {
        // Create canyon shape using exponential function
        const canyon = Math.exp(-falloff * 2) * depth;
        vertex.y -= canyon * influence;
    }
}

function applyPlateau(vertex, position, influence) {
    const targetHeight = position.y;
    const threshold = brushSize * 0.3;
    const distance = vertex.distanceTo(position);
    
    if (distance < threshold) {
        // Flat plateau area
        vertex.y += (targetHeight - vertex.y) * influence;
    } else if (distance < brushSize) {
        // Smooth transition to plateau
        const falloff = 1 - ((distance - threshold) / (brushSize - threshold));
        vertex.y += (targetHeight - vertex.y) * falloff * influence;
    }
}

function applySlope(vertex, position, influence, normal) {
    const angle = Math.PI / 4; // 45-degree slope
    const direction = new THREE.Vector3().subVectors(position, vertex);
    const distance = direction.length();
    
    if (distance < brushSize) {
        const targetHeight = position.y - Math.tan(angle) * distance;
        vertex.y += (targetHeight - vertex.y) * influence;
    }
}

function applyBlur(vertex, position, influence, vertices, index) {
    const radius = brushSize * 1.5;
    let avgHeight = 0;
    let totalWeight = 0;
    
    // Gaussian blur
    for (let i = 0; i < vertices.count; i++) {
        const neighborVertex = new THREE.Vector3(
            vertices.getX(i),
            vertices.getY(i),
            vertices.getZ(i)
        );
        
        const distance = vertex.distanceTo(neighborVertex);
        if (distance < radius) {
            const weight = Math.exp(-(distance * distance) / (2 * radius * radius));
            avgHeight += neighborVertex.y * weight;
            totalWeight += weight;
        }
    }
    
    if (totalWeight > 0) {
        avgHeight /= totalWeight;
        vertex.y += (avgHeight - vertex.y) * influence * brushStrength;
    }
}

function applySharpen(vertex, position, influence, vertices, index) {
    const radius = brushSize;
    let avgHeight = 0;
    let count = 0;
    
    // Calculate local average height
    for (let i = 0; i < vertices.count; i++) {
        const neighborVertex = new THREE.Vector3(
            vertices.getX(i),
            vertices.getY(i),
            vertices.getZ(i)
        );
        
        const distance = vertex.distanceTo(neighborVertex);
        if (distance < radius && distance > 0) {
            avgHeight += neighborVertex.y;
            count++;
        }
    }
    
    if (count > 0) {
        avgHeight /= count;
        const heightDiff = vertex.y - avgHeight;
        vertex.y += heightDiff * influence * brushStrength;
    }
}

function addObjectToScene(object, name) {
    object.userData.selectable = true; // Mark object as selectable
    object.name = name + '_' + objects.length;
    objects.push(object); 
    scene.add(object)
    updateHierarchy();
    selectObject(object);

    if (isModelingMode) {
        activeObject = object;
        showMeshStructure(activeObject);
    }
}

/*function addObjectToScene(object, name) {
    object.userData.selectable = true;
    object.name = name + '_' + objects.length;
    
    // Set render order for the object to be higher than grid
    object.renderOrder = 1;
    
    // If the object is a mesh, adjust its material
    if (object.isMesh) {
        if (Array.isArray(object.material)) {
            object.material.forEach(mat => {
                mat.depthWrite = true;
                mat.depthTest = true;
            });
        } else if (object.material) {
            object.material.depthWrite = true;
            object.material.depthTest = true;
        }
    }
    
    objects.push(object);
    scene.add(object);
    updateHierarchy();
    selectObject(object);

    if (isModelingMode) {
        activeObject = object;
        showMeshStructure(activeObject);
    }
}
*/
function updateRenderOrder() {
    scene.traverse((object) => {
        if (object.isGroup && object.name === 'advancedGrid') {
            object.renderOrder = -2;
            object.children.forEach(child => {
                child.renderOrder = -2;
                if (child.material) {
                    child.material.depthWrite = false;
                    child.material.transparent = true;
                }
            });
        } else if (object.isHelper) {
            object.renderOrder = -1;
        } else if (object.isMesh || object.isLine) {
            object.renderOrder = 1;
        }
    });
}

const COLORS = {
    HIGHLIGHT: 0x00e5ff,  // Cyan for hover
    SELECTED: 0xffa500    // Orange for selection
};

const originalEmissive = new WeakMap();

function applySelectionHighlight(object, colorHex, intensity = 0.5) {
    if (!object || !object.material) return;

    if (!originalEmissive.has(object)) {
        originalEmissive.set(object, {
            color: object.material.emissive.clone(),
            intensity: object.material.emissiveIntensity
        });
    }

    object.material.emissive.setHex(colorHex);
    object.material.emissiveIntensity = intensity;
}

function highlightSelectionBlenderStyle(object) {
    if (!object || !object.material || object.isLight) return;

    const mat = object.material;

    if (!originalMaterials.has(object)) {
        originalMaterials.set(object, mat.clone());
    }

    mat.transparent = true;
    mat.depthWrite = true;
    mat.emissive = new THREE.Color(COLORS.SELECTED);
    mat.emissiveIntensity = 0.4;
    mat.needsUpdate = true;
}

function highlightHoverBlenderStyle(object) {
    if (!object || !object.material || object === selectedObject || object.isLight) return;

    const mat = object.material;

    if (!originalMaterials.has(object)) {
        originalMaterials.set(object, mat.clone());
    }

    mat.transparent = true;
    mat.depthWrite = false;
    mat.emissive = new THREE.Color(COLORS.HIGHLIGHT);
    mat.emissiveIntensity = 0.3;
    mat.needsUpdate = true;
}


/*
// Material for highlighted objects (e.g., during operations)
const highlightSettings = {
    color: new THREE.Color(COLORS.HIGHLIGHT),
    emissive: new THREE.Color(COLORS.HIGHLIGHT),
    emissiveIntensity: 0.4,
    opacity: 0.5,
    roughness: 0.1,
    metalness: 0.2
};
// 🔹 Selected Material (Emissive glow with subtle pulse)
const selectedSettings = {
    color: new THREE.Color(COLORS.SELECTED),
    emissive: new THREE.Color(COLORS.SELECTED),
    emissiveIntensity: 0.8,
    opacity: 0.9,
    roughness: 0.05,
    metalness: 0.3
};

// 🔹 Smooth Material Transitions with Animated Glow
function animateMaterialToSettings(object, settings, pulse = false) {
    if (!object || !object.material) return;

    const mat = object.material;

    gsap.to(mat.color, {
        r: settings.color.r,
        g: settings.color.g,
        b: settings.color.b,
        duration: 0.5,
        ease: "power2.out"
    });

    gsap.to(mat.emissive, {
        r: settings.emissive.r,
        g: settings.emissive.g,
        b: settings.emissive.b,
        duration: 0.5,
        ease: "power2.out"
    });

    gsap.to(mat, {
        emissiveIntensity: settings.emissiveIntensity,
        metalness: settings.metalness,
        roughness: settings.roughness,
        opacity: settings.opacity,
        duration: 0.6,
        ease: "power1.out"
    });

    if (pulse) {
        gsap.to(mat, {
            emissiveIntensity: settings.emissiveIntensity + 0.3,
            duration: 0.8,
            yoyo: true,
            repeat: -1,
            ease: "sine.inOut"
        });
    }
}
*/

// State management
let hoveredObject = null;
const originalMaterials = new WeakMap();
const selectionHandlers = new Set();


// Selection management functions
function addSelectionHandler(handler) {
    selectionHandlers.add(handler);
}

function removeSelectionHandler(handler) {
    selectionHandlers.delete(handler);
}

function notifySelectionHandlers(object) {
    selectionHandlers.forEach(handler => handler(object));
}

// Enhanced selectObject function to work with multiple selection
function selectObject(newObject) {
    activeObject = newObject;
    
    try {
        if (newObject) {
            ensureObjectUUID(newObject);
        }
        
        // If selecting the same object, do nothing
        if (selectedObject === newObject) return selectedObject;

        // Clear hover state if the hovered object is being selected
        if (hoveredObject === newObject) {
            hoveredObject = null;
        }

        // If we have box-selected objects, handle them differently
        if (selectedObjectsFromBox && selectedObjectsFromBox.length > 1) {
            // Only restore the previous active object if it's not in the box selection
            if (selectedObject && !selectedObjectsFromBox.includes(selectedObject)) {
                restoreOriginalMaterial(selectedObject);
                
                if (selectedObject.helper) {
                    selectedObject.helper.visible = false;
                }
            }
        } else {
            // Restore previous selection's material (normal case)
            if (selectedObject) {
                restoreOriginalMaterial(selectedObject);
                
                if (selectedObject.helper) {
                    selectedObject.helper.visible = false;
                }
            }
        }

        selectedObject = newObject;

        // Handle new selection
        if (selectedObject) {
            // Store and apply selection material if not already applied
            // (Don't apply again if it's part of a multiple selection)
            if (!selectedObjectsFromBox || selectedObjectsFromBox.length <= 1) {
                applySelectionHighlight(selectedObject, COLORS.SELECTED, 0.6);
            }

            if (selectedObject.helper) {
                selectedObject.helper.visible = true;
            }

            transformControls.attach(selectedObject);

            if (selectedObject.isLight) {
                updateLightUI(selectedObject);
            } else if (selectedObject.isCamera) {
                updateCameraUI(selectedObject);
            }
        } else {
            transformControls.detach();
            
            // Clear box selection if we're selecting nothing
            if (selectedObjectsFromBox && selectedObjectsFromBox.length > 0) {
                selectedObjectsFromBox.forEach(obj => {
                    restoreOriginalMaterial(obj);
                });
                selectedObjectsFromBox = [];
            }
        }

        // Notify handlers of selection change
        notifySelectionHandlers(selectedObject);
        
        // Update UI elements
        updateInspector();
        updateHierarchySelection();
        
        // If in modeling mode, show mesh structure
        if (isModelingMode && selectedObject) {
            showMeshStructure(selectedObject);
        }
        
        return selectedObject;

    } catch (error) {
        console.error('Error in selectObject:', error);
        throw error;
    }
}

// Utility function to restore original material
function restoreOriginalMaterial(object) {
    if (!object) return;
    
    if (object.userData.originalMaterial) {
        if (Array.isArray(object.material)) {
            // Clone the original materials back
            object.material = object.userData.originalMaterial.map(m => m.clone());
        } else {
            // Clone the original material back
            object.material = object.userData.originalMaterial.clone();
        }
        delete object.userData.originalMaterial;
    } else if (object.material) {
        // Reset emissive properties if no original material stored
        if (Array.isArray(object.material)) {
            object.material.forEach(mat => {
                if (mat.emissive) {
                    mat.emissive.set(0x000000);
                    mat.emissiveIntensity = 0;
                }
            });
        } else if (object.material.emissive) {
            object.material.emissive.set(0x000000);
            object.material.emissiveIntensity = 0;
        }
    }
}

/*function restoreOriginalMaterial(object) {
    if (!object || !object.material || !originalEmissive.has(object)) return;

    const original = originalEmissive.get(object);
    object.material.emissive.copy(original.color);
    object.material.emissiveIntensity = original.intensity;
    originalEmissive.delete(object);
}

function selectObject(newObject) {
    activeObject = newObject;
    if (selectedObject && !selectedObject.isLight && !selectedObject.isCamera) {
        applySelectionHighlight(selectedObject, COLORS.SELECTED, 0.6);
    }
    if (isModelingMode) {
         showMeshStructure(newobject);
    }
   
    try {
        if (newObject) {
            ensureObjectUUID(newObject);
        }
        // If selecting the same object, do nothing
        if (selectedObject === newObject) return selectedObject;

        // Clear hover state if the hovered object is being selected
        if (hoveredObject === newObject) {
            hoveredObject = null;
        }

        // Restore previous selection's material
        if (selectedObject) {
            restoreOriginalMaterial(selectedObject);
            
            if (selectedObject.helper) {
                selectedObject.helper.visible = false;
            }
        }

        selectedObject = newObject;

        // Handle new selection
        if (selectedObject) {
            // Store and apply selection material

            if (selectedObject.helper) {
                selectedObject.helper.visible = true;
            }

            transformControls.attach(selectedObject);

            if (selectedObject.isLight) {
                updateLightUI(selectedObject);
            } else if (selectedObject.isCamera) {
                updateCameraUI(selectedObject);
            }
        } else {
            transformControls.detach();
        }

        // Notify handlers of selection change
        notifySelectionHandlers(selectedObject);
        
        updateInspector();
        updateHierarchySelection();
        return selectedObject;

    } catch (error) {
        console.error('Error in selectObject:', error);
        throw error;
    }
}*/

function setHoverObject(object) {
    if (object === selectedObject || !object || !object.material || object.isLight) return;

    // Restore previous hovered object
    if (hoveredObject && originalEmissive.has(hoveredObject)) {
        const original = originalEmissive.get(hoveredObject);
        hoveredObject.material.emissive.copy(original.color);
        hoveredObject.material.emissiveIntensity = original.intensity;
    }

    hoveredObject = object;

    // Store original emissive values
    if (!originalEmissive.has(object)) {
        originalEmissive.set(object, {
            color: object.material.emissive.clone(),
            intensity: object.material.emissiveIntensity
        });
    }

    // Apply hover effect
    object.material.emissive.setHex(COLORS.HIGHLIGHT);
    object.material.emissiveIntensity = 0.3;
}






// Hierarchy view functions
function getObjectIcon(obj) {
    if (obj.isLight) return '💡';
    if (obj.isCamera) return '🎥';
    if (obj.isMesh) return '📦';
    if (obj.isGroup) return '📁';
    if (obj.type === 'Scene') return '🌐';
    if (obj.type === 'Bone') return '🦴';

    // Fallback based on object type string
    const type = obj.type?.toLowerCase() || '';

    if (type.includes('mesh')) return '📦';
    if (type.includes('light')) return '💡';
    if (type.includes('camera')) return '🎥';
    if (type.includes('group')) return '📁';
    if (type.includes('bone')) return '🦴';
    if (type.includes('object3d')) return '🔹';

    return '⚪'; // default unknown type
}

function createHierarchyItem(obj, level = 0, isLastChild = false, siblings = []) {
    const item = document.createElement('div');
    item.className = 'hierarchy-item';
    item.dataset.uuid = obj.uuid || generateUUID();
    item.dataset.level = level;

    // Add hierarchy line
    const line = document.createElement('div');
    line.className = 'hierarchy-line';
    line.style.left = `${level * 20 + 10}px`; // Position line based on level

    if (isLastChild) {
        line.style.height = '50%'; // Only show top half of the line for last child
        line.style.bottom = 'auto'; // Don't extend to bottom
    }
    item.appendChild(line);

    // Add horizontal connector line
    if (level > 0) {
        const connector = document.createElement('div');
        connector.className = 'hierarchy-connector';
        connector.style.left = `${level * 20 + 10}px`;
        connector.style.width = `10px`;
        item.appendChild(connector);
    }

    const content = document.createElement('div');
    content.className = 'hierarchy-item-content';
    content.style.paddingLeft = `${level * 20 + 25}px`;

    // Add expand/collapse toggle
    if (obj.children && obj.children.length > 0) {
        const toggle = document.createElement('span');
        toggle.className = 'hierarchy-toggle';
        toggle.innerHTML = obj.expanded ? '▼' : '▶';
        toggle.onclick = (e) => {
            e.stopPropagation();
            obj.expanded = !obj.expanded;
            updateHierarchy();
        };
        content.appendChild(toggle);
    }

    item.oncontextmenu = (e) => {
        e.preventDefault();
        e.stopPropagation();
        showContextMenu(e.clientX, e.clientY, obj);
        return false;
    };

    // Add icon and name with visual prefix
    const icon = document.createElement('span');
    icon.className = 'hierarchy-icon';
    icon.innerHTML = getObjectIcon(obj);
    content.appendChild(icon);

    const prefix = getTreePrefix(level, isLastChild);
    const name = document.createElement('span');
    name.className = 'hierarchy-name';
    name.style.cssText = 'max-width: 110px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;';
    name.textContent = `${prefix}${obj.name || `${obj.type || 'Object'}_${obj.id}`}`;
    content.appendChild(name);

    // Enable inline renaming on double-click
    name.ondblclick = () => {
  const input = document.createElement('input');
  input.type = 'text';
  input.value = obj.name;
  input.style.width = '100px';
  input.className = 'hierarchy-rename-input';

  input.onblur = () => {
    obj.name = input.value || obj.name;
    updateHierarchy();
  };

  input.onkeydown = (e) => {
    if (e.key === 'Enter' || e.key === 'Escape') {
      input.blur();
    }
  };

  name.replaceWith(input);
  input.focus();
};

    // Visibility toggle
    const visibilityToggle = document.createElement('button');
    visibilityToggle.className = 'hierarchy-visibility';
    visibilityToggle.innerHTML = obj.visible ? '👁️' : '👁️‍🗨️';
    visibilityToggle.onclick = (e) => {
        e.stopPropagation();
        obj.visible = !obj.visible;
        visibilityToggle.innerHTML = obj.visible ? '👁️' : '👁️‍🗨️';
    };
    content.appendChild(visibilityToggle);

    // Geometry/material info
    if (obj.geometry || obj.material) {
        const properties = document.createElement('div');
        properties.className = 'hierarchy-properties';

        if (obj.geometry) {
            const vertCount = document.createElement('span');
            vertCount.className = 'property';
            vertCount.textContent = `Verts: ${obj.geometry.attributes.position.count}`;
            properties.appendChild(vertCount);
        }

        if (obj.material) {
            const matType = document.createElement('span');
            matType.className = 'property';
            matType.textContent = `Mat: ${obj.material.type}`;
            properties.appendChild(matType);
        }

        content.appendChild(properties);
    }

    item.appendChild(content);

    if (selectedObject && selectedObject.uuid === obj.uuid) {
        item.classList.add('selected');
    }

    item.onclick = (e) => {
        e.stopPropagation();
        selectObject(obj);
    };

    item.onmouseenter = () => {
        if (obj !== selectedObject) {
            setHoverObject(obj);
        }
    };

    item.onmouseleave = () => {
        if (obj !== selectedObject) {
            setHoverObject(null);
        }
    };

    setupDragAndDrop(item, obj);

    if (selectedObject === obj) {
        item.classList.add('selected');
    }

    return item;
}

function getTreePrefix(level, isLastChild) {
    return '';
}



function showContextMenu(x, y, obj) {
    const menu = document.createElement('div');
    menu.className = 'hierarchy-context-menu';
    menu.style.left = `${x}px`;
    menu.style.top = `${y}px`;
    
    const options = [
        { label: 'Rename', action: () => renameObject(obj) },
        { label: 'Duplicate', action: () => duplicateObject(obj) },
        { label: 'Delete', action: () => deleteObject(obj) },
        { label: 'Create Child', action: () => createChildObject(obj) }
    ];
    
    options.forEach(option => {
        const item = document.createElement('div');
        item.className = 'context-menu-item';
        item.textContent = option.label;
        item.onclick = () => {
            option.action();
            document.body.removeChild(menu);
        };
        menu.appendChild(item);
    });
    
    document.body.appendChild(menu);
    
    // Close menu when clicking elsewhere
    setTimeout(() => {
        window.addEventListener('click', function closeMenu() {
            if (document.body.contains(menu)) {
                document.body.removeChild(menu);
            }
            window.removeEventListener('click', closeMenu);
        });
    }, 0);
}

function renameObject(obj) {
    const newName = prompt("Enter new name:", obj.name || obj.type || "Object");
    if (newName !== null && newName.trim() !== "") {
        obj.name = newName.trim();
        updateHierarchy();
    }
}


function createChildObject(parentObj) {
    const child = new THREE.Mesh( // or new THREE.Object3D() if you want a generic object
        new THREE.BoxGeometry(1, 1, 1),
        new THREE.MeshBasicMaterial({ color: 0x00ff00 })
    );
    child.name = "NewChild_" + Date.now();
    parentObj.add(child);
    parentObj.expanded = true; // Make sure the parent shows children
    updateHierarchy();
}


function showDropIndicator(targetItem, position) {
    // Remove any existing indicators
    document.querySelectorAll('.drop-indicator').forEach(el => el.remove());
    
    const indicator = document.createElement('div');
    indicator.className = 'drop-indicator';
    
    if (position === 'inside') {
        targetItem.classList.add('drop-target');
    } else {
        // Position indicator above or below target
        indicator.style.top = position === 'before' ? 
            `${targetItem.offsetTop - 2}px` : 
            `${targetItem.offsetTop + targetItem.offsetHeight - 2}px`;
        
        document.getElementById('hierarchy-content').appendChild(indicator);
    }
}

document.getElementById('hierarchy-search-input').addEventListener('input', function() {
    const searchTerm = this.value.toLowerCase();
    highlightMatchingItems(searchTerm);
});

document.getElementById('hierarchy-search-clear').addEventListener('click', function() {
    document.getElementById('hierarchy-search-input').value = '';
    highlightMatchingItems('');
});

function highlightMatchingItems(searchTerm) {
    const items = document.querySelectorAll('.hierarchy-item');
    
    if (!searchTerm) {
        items.forEach(item => {
            item.style.display = '';
            item.classList.remove('search-match');
        });
        return;
    }
    
    items.forEach(item => {
        const name = item.querySelector('.hierarchy-name').textContent.toLowerCase();
        if (name.includes(searchTerm)) {
            item.style.display = '';
            item.classList.add('search-match');
        } else {
            item.style.display = 'none';
        }
    });
}

function setupHierarchyResize() {
    const hierarchyPanel = document.getElementById('hierarchy-panel');
    const resizeHandle = hierarchyPanel.querySelector('.resize-handle-hierarchy');

    let isResizing = false;
    let startX = 0;
    let startWidth = 0;

    resizeHandle.addEventListener('mousedown', (e) => {
        isResizing = true;
        startX = e.clientX;
        startWidth = hierarchyPanel.offsetWidth;
        document.body.style.cursor = 'ew-resize';
    });

    document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;

        const newWidth = startWidth + (e.clientX - startX);
        const minWidth = window.innerWidth * 0.2; // 20% of viewport width
        const maxWidth = window.innerWidth * 0.5; // 50% of viewport width
        const hierarchyWidth = Math.min(Math.max(newWidth, minWidth), maxWidth);

        // Set hierarchy panel width
        hierarchyPanel.style.width = `${hierarchyWidth}px`;

        // Calculate remaining width
        const totalWidth = window.innerWidth;
        const sidebarWidth = totalWidth - hierarchyWidth - timeline.offsetWidth;
        const sidebarThreshold = totalWidth * 0.1; // Hide sidebar if less than 10% width

        // Adjust sidebar
        if (sidebarWidth > sidebarThreshold) {
            sidebar.style.width = `${sidebarWidth}px`;
            sidebar.style.left = `${hierarchyWidth}px`;
            sidebar.classList.remove('hidden');
        } else {
            sidebar.classList.add('hidden');
        }

        // Adjust timeline
        const timelineWidth = totalWidth - hierarchyWidth;
        timeline.style.width = `${timelineWidth}px`;
        timeline.style.left = `${hierarchyWidth}px`;
    });

    document.addEventListener('mouseup', () => {
        if (isResizing) {
            isResizing = false;
            document.body.style.cursor = 'default';
        }
    });
}


function ensureObjectUUID(obj) {
    if (!obj.uuid) {
        obj.uuid = THREE.MathUtils.generateUUID();
    }
    return obj.uuid;
}

// Drag and drop handling
let draggedItem = null;
let dropTarget = null;

function setupDragAndDrop(item, obj) {
    item.draggable = true;

    item.addEventListener('dragstart', (e) => {
        e.dataTransfer.setData('application/json', JSON.stringify({ uuid: obj.uuid }));
        e.stopPropagation();
    });

    item.addEventListener('dragover', (e) => {
        e.preventDefault(); // Allow drop
        item.classList.add('drag-over');
    });

    item.addEventListener('dragleave', () => {
        item.classList.remove('drag-over');
    });

    item.addEventListener('drop', (e) => {
        e.preventDefault();
        e.stopPropagation();
        item.classList.remove('drag-over');

        const data = JSON.parse(e.dataTransfer.getData('application/json'));
        const draggedObj = findObjectByUUID(scene, data.uuid); // Replace 'scene' with your actual root scene object

        if (draggedObj && draggedObj !== obj && !isDescendant(draggedObj, obj)) {
            obj.add(draggedObj); // Reparent the object
            updateHierarchy(); // Refresh the hierarchy
        }
    });
}

function findObjectByUUID(root, uuid) {
    if (root.uuid === uuid) return root;
    for (let child of root.children) {
        const found = findObjectByUUID(child, uuid);
        if (found) return found;
    }
    return null;
}

function isDescendant(parent, child) {
    while (child.parent) {
        if (child.parent === parent) return true;
        child = child.parent;
    }
    return false;
}


function canDrop(draggedObj, targetObj) {
    if (draggedObj === targetObj) return false;
    let parent = targetObj.parent;
    while (parent) {
        if (parent === draggedObj) return false;
        parent = parent.parent;
    }
    return true;
}



function handleDrop(draggedObj, targetObj) {
    const oldParent = draggedObj.parent;
    oldParent.remove(draggedObj);
    targetObj.add(draggedObj);
    updateHierarchy();
}

function clearDropTargets() {
    const dropTargets = document.querySelectorAll('.drop-target');
    dropTargets.forEach(el => el.classList.remove('drop-target'));
    dropTarget = null;
}

function updateHierarchy() {
    const container = document.getElementById('hierarchy-content');
    container.innerHTML = '';

    const viewMode = document.getElementById('hierarchyViewMode')?.value || 'tree';

    if (viewMode === 'flat') {
        renderFlatView(container);
    } else if (viewMode === 'type') {
        renderTypeView(container);
    } else {
        renderTreeView(container); // default
    }

    updateHierarchySelection();
}

function renderTreeView(container) {
    function addChildrenToHierarchy(parent, level, siblings = []) {
        const children = parent.children || [];
        children.forEach((child, index) => {
            const isLastChild = index === children.length - 1;
            const item = createHierarchyItem(child, level, isLastChild, siblings);
            container.appendChild(item);
            if (child.expanded && child.children && child.children.length > 0) {
                addChildrenToHierarchy(child, level + 1, children);
            }
        });
    }

    objects.forEach((obj, index) => {
        const isLastChild = index === objects.length - 1;
        container.appendChild(createHierarchyItem(obj, 0, isLastChild, objects));
        if (obj.expanded && obj.children && obj.children.length > 0) {
            addChildrenToHierarchy(obj, 1, objects);
        }
    });
}

function renderFlatView(container) {
    function addFlatItems(objList) {
        objList.forEach(obj => {
            container.appendChild(createHierarchyItem(obj, 0, false, []));
            if (obj.children) addFlatItems(obj.children);
        });
    }
    addFlatItems(objects);
}

function renderTypeView(container) {
    const typeGroups = {};

    function collectByType(objList) {
        objList.forEach(obj => {
            const type = obj.type || 'Unknown';
            if (!typeGroups[type]) typeGroups[type] = [];
            typeGroups[type].push(obj);
            if (obj.children) collectByType(obj.children);
        });
    }

    collectByType(objects);

    for (const [type, group] of Object.entries(typeGroups)) {
        const header = document.createElement('div');
        header.textContent = `📦 ${type}`;
        header.style.fontWeight = 'bold';
        header.style.marginTop = '10px';
        container.appendChild(header);

        group.forEach(obj => {
            container.appendChild(createHierarchyItem(obj, 1, false, group));
        });
    }
}
document.getElementById('hierarchyViewMode').addEventListener('change', updateHierarchy);

// Material cache for highlighting

function updateInspector() {
    if (!selectedObject) return;
 
    document.getElementById('posX').value = selectedObject.position.x;
    document.getElementById('posY').value = selectedObject.position.y;
    document.getElementById('posZ').value = selectedObject.position.z;
 
    document.getElementById('rotX').value = selectedObject.rotation.x;
    document.getElementById('rotY').value = selectedObject.rotation.y;
    document.getElementById('rotZ').value = selectedObject.rotation.z;
 
    document.getElementById('scaleX').value = selectedObject.scale.x;
    document.getElementById('scaleY').value = selectedObject.scale.y;
    document.getElementById('scaleZ').value = selectedObject.scale.z;
}
 
function bindInspectorInputs() {
    const positionInputs = ['posX', 'posY', 'posZ'];
    const rotationInputs = ['rotX', 'rotY', 'rotZ'];
    const scaleInputs = ['scaleX', 'scaleY', 'scaleZ'];

    positionInputs.forEach(axis => {
        document.getElementById(axis).addEventListener('input', () => {
            if (!selectedObject) return;
            selectedObject.position.x = parseFloat(document.getElementById('posX').value);
            selectedObject.position.y = parseFloat(document.getElementById('posY').value);
            selectedObject.position.z = parseFloat(document.getElementById('posZ').value);
        });
    });

    rotationInputs.forEach(axis => {
        document.getElementById(axis).addEventListener('input', () => {
            if (!selectedObject) return;
            selectedObject.rotation.x = parseFloat(document.getElementById('rotX').value);
            selectedObject.rotation.y = parseFloat(document.getElementById('rotY').value);
            selectedObject.rotation.z = parseFloat(document.getElementById('rotZ').value);
        });
    });

    scaleInputs.forEach(axis => {
        document.getElementById(axis).addEventListener('input', () => {
            if (!selectedObject) return;
            selectedObject.scale.x = parseFloat(document.getElementById('scaleX').value);
            selectedObject.scale.y = parseFloat(document.getElementById('scaleY').value);
            selectedObject.scale.z = parseFloat(document.getElementById('scaleZ').value);
        });
    });
}


 function updateHierarchySelection() {
    const items = document.querySelectorAll('.hierarchy-item');

    items.forEach(item => {
        item.classList.remove('selected');
    });

    if (selectedObject) {
        const selectedItem = document.querySelector(`.hierarchy-item[data-uuid="${selectedObject.uuid}"]`);
        if (selectedItem) {
            selectedItem.classList.add('selected');

            let parent = selectedItem.parentElement;
            while (parent) {
                const parentItem = parent.closest('.hierarchy-item');
                if (parentItem) {
                    const toggle = parentItem.querySelector('.hierarchy-toggle');
                    if (toggle && toggle.innerHTML === '▶') {
                        const parentObj = objects.find(obj => obj.uuid === parentItem.dataset.uuid);
                        if (parentObj) {
                            parentObj.expanded = true;
                            updateHierarchy();
                            return;
                        }
                    }
                }
                parent = parent.parentElement;
            }
        }
    }
}

 
// Available Transform Modes
const TRANSFORM_MODES = ['translate', 'rotate', 'scale', 'mirror', 'snap', 'shear', 'reset'];

// Function to Set Transform Mode
function setTransformMode(mode) {
    if (!TRANSFORM_MODES.includes(mode)) return;

    transformControls.setMode(mode);
    
    document.querySelectorAll('.toolbar-group button').forEach(btn => {
        btn.classList.remove('active');
        gsap.to(btn, { scale: 1, duration: 0.2 });  // Reset size
    });

    const activeBtn = document.getElementById(mode);
    activeBtn.classList.add('active');

    // Smooth animation for button feedback
    gsap.to(activeBtn, { scale: 1.2, duration: 0.3, yoyo: true, repeat: 1 });

    // Apply Special Modes
    applySpecialTransform(mode);
}

// Function to Apply Special Transformations
function applySpecialTransform(mode) {
    const object = transformControls.object;
    if (!object) return;

    switch (mode) {
        case 'mirror': 
            object.scale.x *= -1; // Flip along X-axis
            break;

        case 'snap':
            object.position.x = Math.round(object.position.x / 5) * 5; // Snap to 5 units
            object.position.y = Math.round(object.position.y / 5) * 5;
            object.position.z = Math.round(object.position.z / 5) * 5;
            break;

        case 'shear': 
            object.scale.x += 0.1;  // Skew effect
            object.scale.y -= 0.05;
            break;

        case 'reset': 
            object.position.set(0, 0, 0);
            object.rotation.set(0, 0, 0);
            object.scale.set(1, 1, 1);
            break;
    }
    object.matrixWorldNeedsUpdate = true;
}



 // File operations
 function newScene() {
    objects.forEach(obj => scene.remove(obj));
    objects = [];
    selectedObject = null;
    updateHierarchy();
    updateInspector();
    localStorage.removeItem("savedScene"); // Reset saved scene
}



// ✅ **Auto-save Scene**
function autoSaveScene() {
    const sceneData = serializeScene();
    try {
        localStorage.setItem("savedScene", JSON.stringify(sceneData));
        console.log("✅ Scene auto-saved!");
    } catch (error) {
        console.error("❌ Failed to auto-save scene:", error);
    }
}

// ✅ **Load Scene from Local Storage**
function loadSavedScene() {
    try {
        const savedData = localStorage.getItem("savedScene");
        if (savedData) {
            restoreScene(JSON.parse(savedData));
            console.log("✅ Scene loaded from localStorage!");
        }
    } catch (error) {
        console.error("❌ Failed to load saved scene:", error);
    }
}

// ✅ **Save Scene Manually (Download as JSON)**
function saveScene() {
    const sceneData = serializeScene();
    const blob = new Blob([JSON.stringify(sceneData, null, 2)], { type: 'application/json' });
    saveAs(blob, "scene.json");
}

// ✅ **Load Scene from File**
function loadScene() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    input.onchange = (e) => {
        const file = e.target.files[0];
        const reader = new FileReader();
        reader.onload = (event) => {
            restoreScene(JSON.parse(event.target.result));
            console.log("✅ Scene loaded from JSON!");
        };
        reader.readAsText(file);
    };
    input.click();
}

// ✅ **Serialize Scene**
function serializeScene() {
    return {
        objects: objects.map(obj => ({
            type: obj.type,
            geometry: obj.geometry ? obj.geometry.parameters : null,
            material: obj.material ? {
                color: obj.material.color.getHex(),
                wireframe: obj.material.wireframe
            } : null,
            position: obj.position.toArray(),
            rotation: obj.rotation.toArray(),
            scale: obj.scale.toArray(),
            name: obj.name
        })),
        timestamp: Date.now()
    };
}

// ✅ **Restore Scene**
function restoreScene(sceneData) {
    newScene();
    sceneData.objects.forEach(objData => {
        let obj;
        switch (objData.type) {
            case 'Mesh':
                obj = new THREE.Mesh(
                    new THREE.BoxGeometry(
                        objData.geometry.width,
                        objData.geometry.height,
                        objData.geometry.depth
                    ),
                    new THREE.MeshStandardMaterial({ color: objData.material.color })
                );
                break;
        }
        if (obj) {
            obj.position.fromArray(objData.position);
            obj.rotation.fromArray(objData.rotation);
            obj.scale.fromArray(objData.scale);
            obj.name = objData.name;
            addObjectToScene(obj);
        }
    });
}

// ✅ **Export Scene as GLTF, OBJ, FBX, and ZIP**
function exportScene() {
    const format = document.getElementById('exportFormat').value;
    switch (format) {
        case 'gltf':
            exportGLTF();
            break;
        case 'obj':
            exportOBJ();
            break;
        case 'fbx':
            exportFBX();
            break;
        case 'zip':
            exportAsZip();
            break;
    }
}

// ✅ **Export as GLTF**
function exportGLTF() {
    const exporter = new THREE.GLTFExporter();
    exporter.parse(scene, (result) => {
        const blob = new Blob([JSON.stringify(result)], { type: 'application/json' });
        saveAs(blob, "scene.gltf");
    });
}

// ✅ **Export as OBJ**
function exportOBJ() {
    const exporter = new THREE.OBJExporter();
    const result = exporter.parse(scene);
    const blob = new Blob([result], { type: 'text/plain' });
    saveAs(blob, "scene.obj");
}

// ✅ **Export as FBX**
function exportFBX() {
    const exporter = new THREE.FBXExporter();
    const result = exporter.parse(scene);
    const blob = new Blob([result], { type: 'application/octet-stream' });
    saveAs(blob, "scene.fbx");
}

// ✅ **Export Scene as Compressed ZIP**
function exportAsZip() {
    const zip = new JSZip();
    zip.file("scene.json", JSON.stringify(serializeScene(), null, 2));

    zip.generateAsync({ type: "blob" }).then((content) => {
        saveAs(content, "scene.zip");
    });
}

// ✅ **Import Scene**
function importScene() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json,.gltf,.glb,.obj,.fbx,.zip';
    input.onchange = (e) => {
        const file = e.target.files[0];
        const reader = new FileReader();
        reader.onload = (event) => {
            if (file.name.endsWith('.json')) {
                restoreScene(JSON.parse(event.target.result));
            } else if (file.name.endsWith('.gltf') || file.name.endsWith('.glb')) {
                loadGLTF(event.target.result);
            } else if (file.name.endsWith('.obj')) {
                loadOBJ(event.target.result);
            } else if (file.name.endsWith('.fbx')) {
                loadFBX(event.target.result);
            } else if (file.name.endsWith('.zip')) {
                loadZIP(event.target.result);
            }
        };
        reader.readAsText(file);
    };
    input.click();
}

// ✅ **Warn Before Leaving (If Unsaved Changes)**
window.addEventListener("beforeunload", (event) => {
    if (localStorage.getItem("savedScene")) {
        event.preventDefault();
        event.returnValue = "You have unsaved changes. Do you want to leave?";
    }
});

// ✅ **Auto-save every 2 minutes**
setInterval(autoSaveScene, 2 * 60 * 1000);

// ✅ **Load scene from local storage on startup**
window.addEventListener("load", loadSavedScene);

/*
// Utility functions
function onWindowResize() {
    const aspect = window.innerWidth / window.innerHeight;
    
    // Update perspective camera
    perspectiveCamera.aspect = aspect;
    perspectiveCamera.updateProjectionMatrix();
    
    // Update orthographic camera
    const frustumSize = 10;
    orthographicCamera.left = -frustumSize * aspect / 2;
    orthographicCamera.right = frustumSize * aspect / 2;
    orthographicCamera.top = frustumSize / 2;
    orthographicCamera.bottom = -frustumSize / -2;
    orthographicCamera.updateProjectionMatrix();
    
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
}
*/

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
    if (orientationWidget) {
        orientationWidget.position.set(-window.innerWidth/2 + 70, window.innerHeight/2 - 70, 0);
    }
}
// Store references to elements once
const objectsElem = document.getElementById('objects');
const fpsElem = document.getElementById('fps');
const trianglesElem = document.getElementById('triangles');

let lastTime = performance.now();
let frameCount = 0;
let fps = 0;

function updateStats() {
    // Update object count
    objectsElem.textContent = `Objects: ${objects.length}`;

    // FPS Calculation
    const now = performance.now();
    frameCount++;
    if (now - lastTime >= 1000) {
        fps = frameCount;
        frameCount = 0;
        lastTime = now;
    }
    fpsElem.textContent = `FPS: ${fps}`;

    // Calculate total triangles
    let triangles = 0;
    scene.traverse(object => {
        if (object.geometry?.attributes?.position) {
            triangles += object.geometry.attributes.position.count / 3;
        }
    });
    trianglesElem.textContent = `Triangles: ${triangles}`;
}

 

let zoomLevel = 1;
let timelineOffset = 0;

let dragStart = 0;
let selectedSegment = null;

const timeline = document.querySelector('.timeline-track');
const playhead = document.querySelector('.playhead');
const timelineScale = document.querySelector('.timeline-scale');
const timelineContent = document.querySelector('.timeline-content');


function playAnimation() {
    if (!isPlaying) {
        isPlaying = true;
        clock.start(); // Reset clock to 0
        currentTime = 0; // Sync timeline
        requestAnimationFrame(updatePlayhead);
    }
}

function pauseAnimation() {
    isPlaying = false;
    clock.stop();
}

function stopAnimation() {
    isPlaying = false;
    clock.stop();
    currentTime = 0;
    updatePlayhead();
    updateTimeDisplay();
    updateSceneFromTimeline();
}

function zoomIn() {
    zoomLevel = Math.min(zoomLevel * 1.2, 10); // Smoother zoom, max 10x
    updateTimelineZoom();
}

function zoomOut() {
    zoomLevel = Math.max(zoomLevel / 1.2, 0.1); // Min 0.1x
    updateTimelineZoom();
}

function updateTimelineZoom() {
    const timelineContent = document.getElementById('timeline-content');
    const timelineScale = document.querySelector('.timeline-scale');
    
    // Apply transform to timeline content (keyframes and playhead)
    timelineContent.style.transform = `translateX(${timelineOffset}px) scaleX(${zoomLevel})`;
    
    // Update timeline scale to match zoom
    timelineScale.style.transform = `scaleX(${zoomLevel})`;
    timelineScale.style.transformOrigin = 'left'; // Ensure scale starts from left
    
    // Adjust playhead width to prevent distortion
    const playhead = document.getElementById('playhead');
    playhead.style.transform = `scaleX(${1 / zoomLevel})`; // Counter-scale to maintain width
    playhead.style.transformOrigin = 'left';
    
    // Update keyframes UI if needed
    updateKeyframesUI();
}

function initializeTimelineScale() {
    const timelineScale = document.querySelector('.timeline-scale');
    timelineScale.innerHTML = ''; // Clear existing markers
    const totalSeconds = timelineDuration; // Use global duration
    const majorMarkerInterval = 30; // Major tick every 30 seconds
    const minorMarkerInterval = 5; // Minor tick every 5 seconds

    for (let i = 0; i <= totalSeconds; i += minorMarkerInterval) {
        const marker = document.createElement('div');
        const isMajor = i % majorMarkerInterval === 0;
        marker.className = `timeline-scale-marker ${isMajor ? 'major' : ''}`;
        marker.style.left = `${(i / totalSeconds) * 100}%`;

        if (isMajor) {
            const label = document.createElement('div');
            label.className = 'timeline-scale-label';
            label.textContent = `${Math.floor(i / 60)}:${String(i % 60).padStart(2, '0')}`;
            marker.appendChild(label);
        }

        timelineScale.appendChild(marker);
    }
}

// this whenever timeline duration or zoom changes
function updateTimelineScale() {
    initializeTimelineScale(); // Rebuild scale
    updateTimelineZoom(); // Reapply zoom
}

function updatePlayhead() {
    const playhead = document.getElementById('playhead');
    if (isPlaying) {
        currentTime = clock.getElapsedTime();
        if (currentTime >= timelineDuration) {
            stopAnimation();
            return;
        }
        requestAnimationFrame(updatePlayhead);
    }
    const position = (currentTime / timelineDuration) * 100;
    playhead.style.left = `${position}%`;
    updateTimeDisplay();
    updateSceneFromTimeline();
}




// Timeline dragging
timeline.addEventListener('mousedown', (e) => {
    if (e.target.closest('.keyframe') || e.target.closest('.playhead')) return; // Ignore clicks on keyframes/playhead
    isDragging = true;
    dragStart = e.clientX - timelineOffset;
    timeline.style.cursor = 'grabbing';
});

document.addEventListener('mousemove', (e) => {
    if (isDragging) {
        timelineOffset = e.clientX - dragStart;
        // Limit offset to prevent panning too far
        const maxOffset = 0; // Leftmost position
        const minOffset = -(timelineContent.offsetWidth * zoomLevel - timelineContent.offsetWidth); // Rightmost
        timelineOffset = Math.min(maxOffset, Math.max(minOffset, timelineOffset));
        updateTimelineZoom();
    }
});

document.addEventListener('mouseup', () => {
    isDragging = false;
    timeline.style.cursor = 'grab';
});

// Segment selection
timelineContent.addEventListener('click', (e) => {
    if (e.target.classList.contains('recording-segment')) {
        if (selectedSegment) {
            selectedSegment.classList.remove('selected');
        }
        selectedSegment = e.target;
        selectedSegment.classList.add('selected');
    }
});




function recordSceneData() {
    if (isPlaying && selectedSegment) {
        const time = clock.getElapsedTime();
        const position = (time / 300) * 100; // 5 minutes total
        selectedSegment.style.width = `${position}%`;
    }
}

// Add this to your existing animate function to integrate the node editor
function animate () {
    requestAnimationFrame(animate);
    if (controls && controls.enabled) {
        controls.update();
    }
    transformControls.setTranslationSnap(null);
    animateParticles();
    recordSceneData();
    
    if (isSnowing) {
        updateSnow();
    }
    
    // Update animations
    if (world) world.step(1 / 60); // Physics simulation step
    const delta = clock.getDelta();
    
    scene.traverse((object) => {
        if (object.userData && object.userData.mixer) {
          object.userData.mixer.update(delta);
        }
    });
    
    if (physicsEnabled) updateHairPhysics();
    
    scene.traverse((obj) => {
        if (obj.userData.animate) {
            obj.rotation.y += 0.01;
            obj.position.y += Math.sin(Date.now() * 0.001) * 0.01;
        }
    });
    
    scene.traverse(object => {
        if (object.userData.physicsBody) {
            object.position.copy(object.userData.physicsBody.position);
            object.quaternion.copy(object.userData.physicsBody.quaternion);
        }
    });
    
    if (world && physicsManager) {
        world.step(1/60);
        physicsManager.updatePhysics();
    }
    
    // Update scene objects
    scene.traverse(obj => {
        if (obj.userData.needsUpdate) {
            if (obj.userData.mixer) obj.userData.mixer.update(delta);
            if (obj.userData.physicsBody) {
                obj.position.copy(obj.userData.physicsBody.position);
                obj.quaternion.copy(obj.userData.physicsBody.quaternion);
            }
        }
    });
    
    // Update node editor and apply VFX
    if (window.nodeEditor) {
        window.nodeEditor.update(delta);
        
        // Execute active VFX in the node graph
        if (window.nodeEditor.activeEffects) {
            window.nodeEditor.activeEffects.forEach(effect => {
                if (effect.enabled && effect.execute) {
                    effect.execute(scene, camera, renderer, delta);
                }
            });
        }
    }
    
    if (window.materialSettings && window.materialSettings.enableTextureAnimation) {
        window.materialSettings.updateMaterialAnimation();
    }
    
    scene.traverse((object) => {
        if (object.animate && typeof object.animate === 'function') {
            object.animate();
        }
    });
    
    scene.traverse((obj) => {
        if (obj.userData.mixer) obj.userData.mixer.update(delta);
    });
    
    if (isPlaying) {
        currentTime = clock.getElapsedTime();
        updatePlayhead();
    }

    scene.traverse(object => {
        if (object.userData.mixer) {
            object.userData.mixer.update(delta);
        }
    });
    
    updateStats();
    updateHelpers();
    // First render the scene normally
    renderer.clear();
    renderer.render(scene, camera);
    // Then apply post-processing if node editor has active post effects
    if (window.nodeEditor && window.nodeEditor.hasPostProcessing) {
        window.nodeEditor.renderPostEffects(renderer, scene, camera);
    }
    
    if (activeCamera && previewRenderer) {
        previewRenderer.render(scene, activeCamera);
    }
    updateRenderOrder();
    composer.render();
}

 // Initialize the editor when the page loads
 init();
    </script>
    <script>
        function initializeUI() {
            // Ensure timeline and inspector are visible
            const timeline = document.querySelector('.timeline');
            const inspector = document.querySelector('.inspector-panel');
            if (timeline) timeline.style.display = 'flex';
            if (inspector) inspector.style.display = 'flex';
        }

        // Material Editor with GUI Display
        function setupMaterialEditor() {
            const materialColor = document.getElementById('materialColor');
            const materialMetalness = document.getElementById('materialMetalness');
            const materialRoughness = document.getElementById('materialRoughness');
            const materialOpacity = document.getElementById('materialOpacity');
            const materialTexture = document.getElementById('materialTexture');
            materialColor.addEventListener('input', updateMaterial);
            materialMetalness.addEventListener('input', updateMaterial);
            materialRoughness.addEventListener('input', updateMaterial);
            materialOpacity.addEventListener('input', updateMaterial);
            materialTexture.addEventListener('change', updateTexture);
        
            const gui = new dat.GUI({ autoPlace: false });
            const settings = {
                texture: 'glass'
            };
        
            gui.add(settings, 'texture', ['glass', 'metal', 'water', 'crystal', 'plastic', 'ceramic', 'wood', 'marble', 'gold', 'chrome', 'holographic', 'matte']).onChange((value) => {
                updateTextureMaterials(value);
            });
        
            // Style the GUI container
            gui.domElement.style.position = 'relative';
            gui.domElement.style.marginTop = '10px';
        
            // Get the materialTextures div and append the GUI
            const materialTextures = document.getElementById('materialTextures');
            materialTextures.appendChild(gui.domElement);
        }
        
       

        // Enhanced textures object with more materials
        const textures = {
            glass: new THREE.MeshPhysicalMaterial({
                color: 0xA0D8EF,
                roughness: 0.1,
                metalness: 0.1,
                clearcoat: 1.0,
                clearcoatRoughness: 0.1,
                transmission: 0.95,
                thickness: 0.5,
                reflectivity: 1.0,
                transparent: true,
                opacity: true,
                attenuationColor: 0xA0D8EF, 
                attenuationDistance: 0.75 ,
                envMap: loadEnvironmentMap(),
                refractionRatio: 1.5
            }),
        
            metal: new THREE.MeshPhysicalMaterial({
                color: 0xAAAAAA,
                roughness: 0.05,
                metalness: 1.0,
                clearcoat: 0.7,
                clearcoatRoughness: 0.02,
                anisotropy: 0.8,
                envMap: loadEnvironmentMap()
            }),
        
            water: new THREE.MeshPhysicalMaterial({
                color: 0x1e90ff,
                roughness: 0.01,
                metalness: 0.0,
                transmission: 1,
                thickness: 0.1,
                transparent: true,
                opacity: 0.9,
                envMap: loadEnvironmentMap(),
                reflectivity: 0.9,
                refractionRatio: 1.33,

            }),
        
            crystal: new THREE.MeshPhysicalMaterial({
                color: 0x7F7FFF,
                roughness: 0.01,
                metalness: 0.0,
                transmission: 1.0,
                thickness: 1.0,
                transparent: true,
                opacity: 0.95,
                envMap: loadEnvironmentMap(),
                clearcoat: 1.0,
                clearcoatRoughness: 0.01,
                attenuationColor: 0x7F7FFF,
                attenuationDistance: 1.0,
                iridescence: 0.8,
                iridescenceIOR: 2.0,
                iridescenceThicknessRange: [200, 500]
            }),
        
            
            plastic: new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                roughness: 0.3,
                metalness: 0.0,
                clearcoat: 0.8,
                clearcoatRoughness: 0.2
            }),
        
            ceramic: new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                roughness: 0.1,
                metalness: 0.0,
                clearcoat: 1.0,
                clearcoatRoughness: 0.1,
                sheen: 1.0,
                sheenRoughness: 0.3,
                sheenColor: 0xffffff
            }),
        
            wood: new THREE.MeshStandardMaterial({
                color: 0x885533,
                roughness: 0.8,
                metalness: 0.0,
                map: loadWoodTexture()
            }),
        
            marble: new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                roughness: 0.15,
                metalness: 0.0,
                transmission: 0.5,
                thickness: 0.5,
                clearcoat: 0.8,
                clearcoatRoughness: 0.2
            }),
        
            gold: new THREE.MeshPhysicalMaterial({
                color: 0xffd700,
                roughness: 0.1,
                metalness: 1.0,
                envMap: loadEnvironmentMap(),
                clearcoat: 0.5,
                clearcoatRoughness: 0.1
            }),
        
            chrome: new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                roughness: 0.0,
                metalness: 1.0,
                envMap: loadEnvironmentMap(),
                clearcoat: 1.0,
                clearcoatRoughness: 0.0
            }),
        
            holographic: new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                roughness: 0.2,
                metalness: 0.5,
                transmission: 0.5,
                thickness: 0.5,
                attenuationColor: 0xff00ff,
                attenuationDistance: 0.5,
                iridescence: 1.0,
                iridescenceIOR: 2.0,
                iridescenceThicknessRange: [100, 400]
            }),
        
            matte: new THREE.MeshStandardMaterial({
                color: 0x808080,
                roughness: 1.0,
                metalness: 0.0
            })
            
        };
    
        function loadEnvironmentMap() {
            return new THREE.CubeTextureLoader().load([
                'textures/skybox/px.jpg',
                'textures/skybox/nx.jpg',
                'textures/skybox/py.jpg',
                'textures/skybox/ny.jpg',
                'textures/skybox/pz.jpg',
                'textures/skybox/nz.jpg'
            ]);
        }
        
    
        function loadWoodTexture() {
            return new THREE.TextureLoader().load('textures/wood/woodgrain.jpg');
        }


        function updateMaterial() {
            if (!selectedObject || !selectedObject.material) return;
        
            selectedObject.material.color.setHex(parseInt(materialColor.value.substr(1), 16));
            selectedObject.material.metalness = parseFloat(materialMetalness.value);
            selectedObject.material.roughness = parseFloat(materialRoughness.value);
            selectedObject.material.opacity = parseFloat(materialOpacity.value);
            selectedObject.material.emissive.setHex(parseInt(materialEmissive.value.substr(1), 16));
            selectedObject.material.emissiveIntensity = parseFloat(materialEmissiveIntensity.value);
            selectedObject.material.clearcoat = parseFloat(materialClearcoat.value);
            selectedObject.material.iridescence = parseFloat(materialIridescence.value);
            selectedObject.material.transparent = selectedObject.material.opacity < 1;
            selectedObject.material.needsUpdate = true;
        }
    
     
        function updateTexture(event) {
            if (!selectedObject || !selectedObject.material) return;
        
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const texture = new THREE.TextureLoader().load(e.target.result);
                    texture.encoding = THREE.sRGBEncoding;
                    selectedObject.material.map = texture;
                    selectedObject.material.needsUpdate = true;
                };
                reader.readAsDataURL(file);
            }
        }
    
        function updateTextureMaterials(textureName) {
            if (!selectedObject || !selectedObject.material) return;
            
            const newMaterial = textures[textureName].clone();
            selectedObject.material = newMaterial;
            selectedObject.material.needsUpdate = true;
        }

        // History System
const history = [];
let currentHistoryIndex = -1;

// Utility function to add an action to history and update UI
function recordHistoryAction(type, objectName, undoAction = null, redoAction = null) {
    const action = {
        type: type,
        object: objectName,
        undo: undoAction,
        redo: redoAction
    };
    history.push(action);
    currentHistoryIndex = history.length - 1;
    updateHistoryPanel();
}

function undo() {
    if (currentHistoryIndex >= 0) {
        const action = history[currentHistoryIndex];
        if (action.undo) action.undo();
        currentHistoryIndex--;
        updateHistoryPanel();
    }
}

function redo() {
    if (currentHistoryIndex < history.length - 1) {
        currentHistoryIndex++;
        const action = history[currentHistoryIndex];
        if (action.redo) action.redo();
        updateHistoryPanel();
    }
}

function clearHistory() {
    history.length = 0;
    currentHistoryIndex = -1;
    updateHistoryPanel();
}

function updateHistoryPanel() {
    const historyPanel = document.getElementById('history-items');
    if (!historyPanel) {
        console.error("History panel not found!");
        return;
    }

    historyPanel.innerHTML = ''; // Clear previous history items

    history.forEach((action, index) => {
        const historyItem = document.createElement('div');
        historyItem.classList.add('history-item'); // Uses the styled class
        historyItem.textContent = `${index + 1}. ${action.type || 'Action'}`;

        historyItem.addEventListener('click', () => {
            if (action.undo) action.undo();
            updateHistoryPanel();
        });

        historyPanel.appendChild(historyItem);
    });
}





        // Initialize everything
        function initializeAll() {
            initializeUI();
            setupClipboardOperations();
            const objectPool = optimizeScene();
    
            // Store objectPool for later use
            window.objectPool = objectPool;
        }

// Call initialization when the page loads
window.addEventListener('load', initializeAll);

// Context Menu
function setupContextMenu() {
    const rendererContainer = document.getElementById('renderer-container');

    // Add contextmenu listener only to renderer-container
    rendererContainer.addEventListener('contextmenu', (e) => {
        e.preventDefault(); // Prevent default browser context menu

        // Check if the click is within renderer-container (redundant here since the listener is on the element, but good practice)
        if (rendererContainer.contains(e.target)) {
            const contextMenu = document.getElementById('context-menu');
            contextMenu.style.display = 'block';
            contextMenu.style.left = e.pageX + 'px';
            contextMenu.style.top = e.pageY + 'px';
        }
    });

    // Hide context menu when clicking anywhere on the document
    document.addEventListener('click', () => {
        const contextMenu = document.getElementById('context-menu');
        contextMenu.style.display = 'none';
    });
}



// Initialize new features
function initializeAdvancedFeatures() {
    setupMaterialEditor();
    enableSnapping();
    setupContextMenu();
    initializeTextures();
}

// Call initialization
initializeAdvancedFeatures();
    </script>
    <script>

        // Camera Preview
        let activeCamera = null; 
        const expandButton = document.getElementById('expandPreview');
        const previewRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        const previewContainer = document.getElementById('cameraPreview');
        previewRenderer.setSize(previewContainer.clientWidth, previewContainer.clientHeight);
        previewRenderer.setPixelRatio(window.devicePixelRatio); // High DPI support
        previewContainer.appendChild(previewRenderer.domElement);
    

        function initializePanelControls() {
            const lightIntensityControl = document.getElementById('lightIntensity');
            const lightColorControl = document.getElementById('lightColor');

            // Update light properties when controls change
            function updateLightControls() {
                if (selectedObject && (selectedObject instanceof THREE.Light)) {
                    selectedObject.intensity = parseFloat(lightIntensityControl.value);
                    selectedObject.color.setStyle(lightColorControl.value);
                    if (selectedObject.helper) {
                        selectedObject.helper.update();
                    }
                }
            }

            lightIntensityControl.addEventListener('input', updateLightControls);
            lightColorControl.addEventListener('input', updateLightControls);

            function updatePreviewSize() {
              const rect = previewContainer.getBoundingClientRect();
               previewRenderer.setSize(rect.width, rect.height);
                if (activeCamera) {
                  activeCamera.aspect = rect.width / rect.height;
                  activeCamera.updateProjectionMatrix();
                }
            }

           // Toggle preview size
           document.getElementById('expandPreview').addEventListener('click', () => {
                previewContainer.classList.toggle('expanded');
                updatePreviewSize();
            });

           
            // Resize observer for dynamic adjustments
            new ResizeObserver(updatePreviewSize).observe(previewContainer);
            
       
           
            // Light controls initialization
            document.getElementById('addPointLight').addEventListener('click', () => {
                const light = new THREE.PointLight(0xffffff, 1);
                light.position.set(0, 5, 0);
                light.castShadow = true;
                
                // Create visual representation
                const sphereGeometry = new THREE.SphereGeometry(0.2);
                const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true });
                const visualMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
                light.add(visualMesh);
                
                // Add helper
                const helper = new THREE.PointLightHelper(light, 0.5);
                scene.add(helper);
                light.helper = helper;
                
                // Add to scene
                light.name = `PointLight_${objects.length}`;
                addObjectToScene(light, 'Point Light');
                document.querySelector('.controls-panel').appendChild(controls);
                light.controls = controls;
                updateHierarchy();
            });

            document.getElementById('addSpotLight').addEventListener('click', () => {
                const light = new THREE.SpotLight(0xffffff, 1);
                light.position.set(0, 5, 0);
                light.angle = Math.PI / 4;
                light.castShadow = true;
                
                // Create visual representation
                const coneGeometry = new THREE.ConeGeometry(0.2, 0.5);
                const coneMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true });
                const visualMesh = new THREE.Mesh(coneGeometry, coneMaterial);
                light.add(visualMesh);
                
                // Add helper
                const helper = new THREE.SpotLightHelper(light);
                scene.add(helper);
                light.helper = helper;
                
                // Add to scene
                light.name = `SpotLight_${objects.length}`;
                addObjectToScene(light, 'Spot Light');
                updateHierarchy();
            });

            document.getElementById('addAreaLight').addEventListener('click', () => {
                const light = new THREE.RectAreaLight(0xffffff, 1, 2, 2);
                light.position.set(0, 5, 0);
                
                // Create visual representation
                const planeGeometry = new THREE.PlaneGeometry(0.4, 0.4);
                const planeMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true });
                const visualMesh = new THREE.Mesh(planeGeometry, planeMaterial);
                light.add(visualMesh);
                
                // Add helper
                const helper = new THREE.RectAreaLightHelper(light);
                scene.add(helper);
                light.helper = helper;
                
                // Add to scene
                light.name = `AreaLight_${objects.length}`;
                addObjectToScene(light, 'Area Light');
                updateHierarchy();
            });

             document.getElementById('addSunLight').addEventListener('click', () => {
               const { sunSystem, updateDayNightCycle } = createSimpleSunLight();
               scene.add(sunSystem);

               // تحديث حلقة الأنيميشن
                function animate() {
                   updateDayNightCycle();
                   requestAnimationFrame(animate);
                }
                requestAnimationFrame(animate);

                // Add to scene management
                sunSystem.name = `SunSystem_${objects.length}`;
                addObjectToScene(sunSystem, 'Sun System');
                updateHierarchy();
            });

            document.getElementById('addDirectionalLight').addEventListener('click', () => {
                const light = new THREE.DirectionalLight(0xffffff, 1);
                light.position.set(0, 5, 0);
                light.castShadow = true;
                
                // Create visual representation
                const boxGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
                const boxMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true });
                const visualMesh = new THREE.Mesh(boxGeometry, boxMaterial);
                light.add(visualMesh);
                
                // Add helper
                const helper = new THREE.DirectionalLightHelper(light, 1);
                scene.add(helper);
                light.helper = helper;
                
                // Add to scene
                light.name = `DirectionalLight_${objects.length}`;
                addObjectToScene(light, 'Directional Light');
                updateHierarchy();
            });

            // New Light Types
            document.getElementById('addHemisphereLight').addEventListener('click', () => {
                const light = new THREE.HemisphereLight(0xffffbb, 0x080820, 1);
                light.position.set(0, 5, 0);
                
                // Create visual representation
                const sphereGeometry = new THREE.SphereGeometry(0.3);
                const sphereMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffffbb,
                    wireframe: true,
                    vertexColors: true
                });
                const visualMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
                light.add(visualMesh);
                
                // Add helper
                const helper = new THREE.HemisphereLightHelper(light, 1);
                scene.add(helper);
                light.helper = helper;
                
                light.name = `HemisphereLight_${objects.length}`;
                addObjectToScene(light, 'Hemisphere Light');
                updateHierarchy();
            });
        
            document.getElementById('addLensflareLight').addEventListener('click', () => {
                const light = new THREE.PointLight(0xffffff, 1.5, 2000);
                light.position.set(0, 10, 0);
                
                // Create lensflare effect
                const textureLoader = new THREE.TextureLoader();
                const textureFlare = textureLoader.load('path_to_lensflare_texture.png');
                
                const lensflare = new THREE.Lensflare();
                lensflare.addElement(new THREE.LensflareElement(textureFlare, 512, 0));
                light.add(lensflare);
                
                // Visual representation
                const sphereGeometry = new THREE.SphereGeometry(0.2);
                const sphereMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00,
                    wireframe: true
                });
                const visualMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
                light.add(visualMesh);
                
                light.name = `LensflareLight_${objects.length}`;
                addObjectToScene(light, 'Lensflare Light');
                updateHierarchy();
            });
        
            document.getElementById('addVolumetricLight').addEventListener('click', () => {
                const light = new THREE.SpotLight(0xffffff, 1);
                light.position.set(0, 5, 0);
                light.angle = Math.PI / 6;
                light.penumbra = 0.3;
                light.decay = 2;
                light.distance = 50;
                
                // Create volumetric effect
                const geometry = new THREE.CylinderGeometry(0, 2, 10, 32);
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        lightColor: { value: new THREE.Color(0xffffff) },
                        intensity: { value: 1.0 }
                    },
                    vertexShader: `
                        varying vec3 vNormal;
                        void main() {
                            vNormal = normalize(normalMatrix * normal);
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform vec3 lightColor;
                        uniform float intensity;
                        varying vec3 vNormal;
                        void main() {
                            float opacity = pow(1.0 - abs(dot(vNormal, vec3(0.0, 1.0, 0.0))), 2.0);
                            gl_FragColor = vec4(lightColor, opacity * intensity * 0.2);
                        }
                    `,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    side: THREE.DoubleSide
                });
                
                const volumetricCone = new THREE.Mesh(geometry, material);
                light.add(volumetricCone);
                
                // Add helper
                const helper = new THREE.SpotLightHelper(light);
                scene.add(helper);
                light.helper = helper;
                
                light.name = `VolumetricLight_${objects.length}`;
                addObjectToScene(light, 'Volumetric Light');
                updateHierarchy();
            });

            
            // Camera Management System
            document.getElementById('addCameraOrto').addEventListener('click', () => {
            const aspectRatio = window.innerWidth / window.innerHeight;
    const orthoCamera = new THREE.OrthographicCamera(
        -10 * aspectRatio, 10 * aspectRatio,
        10, -10,
        0.1, 100
    );

    orthoCamera.position.set(15, 10, 15);
    orthoCamera.lookAt(0, 0, 0);

    // Create main group that will contain both camera model and helper
    const mainGroup = new THREE.Group();

    // Camera model group
    const cameraGroup = new THREE.Group();

    const bodyGeometry = new THREE.BoxGeometry(1, 0.6, 0.8);
    const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xffbd54 });
    const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
    cameraGroup.add(bodyMesh);

    const lensGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.4, 16);
    const lensMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
    const lensMesh = new THREE.Mesh(lensGeometry, lensMaterial);
    lensMesh.rotation.z = Math.PI / 2;
    lensMesh.position.x = 0.7;
    cameraGroup.add(lensMesh);

    cameraGroup.scale.set(0.5, 0.5, 0.5);
    mainGroup.add(cameraGroup);

    // Improved pyramid helper
    const pyramidGeometry = new THREE.BufferGeometry();
    
    // Define pyramid dimensions
    const baseWidth = 8;    // Width of the base
    const baseHeight = 8;   // Height of the base
    const pyramidLength = 12; // Length of the pyramid

    const pyramidVertices = new Float32Array([
        // Pyramid tip (at camera position)
        0, 0, 0,

        // Base vertices (forming a rectangle)
        -baseWidth/2, -baseHeight/2, -pyramidLength,  // bottom left
        baseWidth/2, -baseHeight/2, -pyramidLength,   // bottom right
        baseWidth/2, baseHeight/2, -pyramidLength,    // top right
        -baseWidth/2, baseHeight/2, -pyramidLength,   // top left
    ]);

    // Define the indices for drawing lines
    const pyramidIndices = [
        // Lines from tip to base corners
        0, 1,  // tip to bottom left
        0, 2,  // tip to bottom right
        0, 3,  // tip to top right
        0, 4,  // tip to top left

        // Base rectangle
        1, 2,  // bottom edge
        2, 3,  // right edge
        3, 4,  // top edge
        4, 1   // left edge
    ];

    pyramidGeometry.setAttribute('position', new THREE.BufferAttribute(pyramidVertices, 3));
    pyramidGeometry.setIndex(pyramidIndices);

    const pyramidMaterial = new THREE.LineBasicMaterial({ 
        color: 0xffbd54,
        linewidth: 1
    });
    
    const pyramidHelper = new THREE.LineSegments(pyramidGeometry, pyramidMaterial);
    
    // Add guide lines for better visualization
    const guideGeometry = new THREE.BufferGeometry();
    const numGuides = 4;
    const guideVertices = [];
    const guideIndices = [];
    
    // Create vertical guide lines
    for (let i = 1; i < numGuides; i++) {
        const x = -baseWidth/2 + (baseWidth * i/numGuides);
        guideVertices.push(
            0, 0, 0,  // Start at tip
            x, -baseHeight/2, -pyramidLength  // End at base
        );
        guideIndices.push(guideVertices.length/3 - 2, guideVertices.length/3 - 1);
        
        guideVertices.push(
            0, 0, 0,  // Start at tip
            x, baseHeight/2, -pyramidLength  // End at base
        );
        guideIndices.push(guideVertices.length/3 - 2, guideVertices.length/3 - 1);
    }

    guideGeometry.setAttribute('position', new THREE.Float32BufferAttribute(guideVertices, 3));
    guideGeometry.setIndex(guideIndices);

    const guideMaterial = new THREE.LineBasicMaterial({ 
        color: 0xffbd54,
        opacity: 0.3,
        transparent: true
    });
    
    const guideLines = new THREE.LineSegments(guideGeometry, guideMaterial);
    pyramidHelper.add(guideLines);

    mainGroup.add(pyramidHelper);

    // Position and orient main group
    mainGroup.position.copy(orthoCamera.position);
    scene.add(mainGroup);

    function syncWithCamera() {
        mainGroup.position.copy(orthoCamera.position);
        
        const target = new THREE.Vector3(0, 0, 0);
        mainGroup.lookAt(target);
        mainGroup.rotateOnAxis(new THREE.Vector3(0, 1, 0), Math.PI);
    }

    const handleResize = () => {
        const newAspectRatio = window.innerWidth / window.innerHeight;
        orthoCamera.left = -10 * newAspectRatio;
        orthoCamera.right = 10 * newAspectRatio;
        orthoCamera.updateProjectionMatrix();
    };

    window.addEventListener('resize', handleResize);

    const gridHelper = new THREE.GridHelper(20, 20);
    scene.add(gridHelper);
    
    const axesHelper = new THREE.AxesHelper(10);
    scene.add(axesHelper);

    addObjectToScene(orthoCamera, 'Ortho_camera');
    updateHierarchy();
    setupCameraControls(orthoCamera);

    if (activeCamera) {
        transitionToCamera(orthoCamera);
    }

    activeCamera = orthoCamera;

    function animate() {
        requestAnimationFrame(animate);
        syncWithCamera();
    }
    animate();
});


// CubeCamera Implementation
document.getElementById('addCubeCamera').addEventListener('click', () => {
    //cube camera with 256x256 resolution for each face
    const cubeCamera = new THREE.PerspectiveCamera(90, window.innerWidth/window.innerHeight, 0.1, 100);
    cubeCamera.position.set(5, 2, 5);

    // Create main group
    const mainGroup = new THREE.Group();

    // Camera model
    const cameraGroup = new THREE.Group();

    // Create central cube for camera body
    const bodyGeometry = new THREE.BoxGeometry(1, 1, 1);
    const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x4287f5 });
    const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
    cameraGroup.add(bodyMesh);

    // Add small lenses on each face
    const lensPositions = [
        [0.5, 0, 0],  // right
        [-0.5, 0, 0], // left
        [0, 0.5, 0],  // top
        [0, -0.5, 0], // bottom
        [0, 0, 0.5],  // front
        [0, 0, -0.5]  // back
    ];

    lensPositions.forEach(pos => {
        const lensGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.2, 16);
        const lensMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
        const lensMesh = new THREE.Mesh(lensGeometry, lensMaterial);
        
        lensMesh.position.set(...pos);
        
        // Rotate lens based on position
        if (pos[0] !== 0) {
            lensMesh.rotation.z = Math.PI / 2;
        } else if (pos[1] !== 0) {
            lensMesh.rotation.x = Math.PI / 2;
        }
        
        cameraGroup.add(lensMesh);
    });

    cameraGroup.scale.set(0.5, 0.5, 0.5);
    mainGroup.add(cameraGroup);

    // Add helper box to show capture area
    const helperGeometry = new THREE.BoxGeometry(8, 8, 8);
    const helperMaterial = new THREE.LineBasicMaterial({ color: 0x4287f5 });
    const helperWireframe = new THREE.LineSegments(
        new THREE.WireframeGeometry(helperGeometry),
        helperMaterial
    );
    mainGroup.add(helperWireframe);

    mainGroup.position.copy(cubeCamera.position);
    scene.add(mainGroup);

    // Sync function
    function syncWithCamera() {
        mainGroup.position.copy(cubeCamera.position);
    }

    addObjectToScene(cubeCamera, 'Cube_camera');
    updateHierarchy();
    setupCameraControls(cubeCamera);

    if (activeCamera) {
        transitionToCamera(cubeCamera);
    }

    activeCamera = cubeCamera;
    // Animation loop
    function animate() {
        requestAnimationFrame(animate);
        syncWithCamera();
    }
    animate();
});

// StereoCamera Implementation
  document.getElementById('addStereoCamera').addEventListener('click', () => {
    //StereoCamera
    const stereoCamera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100);
     stereoCamera.position.set(5, 2, 5);
    
    // Position the camera
    stereoCamera.position = new THREE.Vector3(5, 2, 5);

    // Create main group
    const mainGroup = new THREE.Group();

    // Camera model group
    const cameraGroup = new THREE.Group();

    // Create base for stereo camera
    const baseGeometry = new THREE.BoxGeometry(2, 0.3, 0.5);
    const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
    const baseMesh = new THREE.Mesh(baseGeometry, baseMaterial);
    cameraGroup.add(baseMesh);

    // Add two camera lenses
    const lensGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.3, 16);
    const lensMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });

    // Left lens
    const leftLens = new THREE.Mesh(lensGeometry, lensMaterial);
    leftLens.position.set(-0.5, 0, 0.25);
    leftLens.rotation.x = Math.PI / 2;
    cameraGroup.add(leftLens);

    // Right lens
    const rightLens = new THREE.Mesh(lensGeometry, lensMaterial);
    rightLens.position.set(0.5, 0, 0.25);
    rightLens.rotation.x = Math.PI / 2;
    cameraGroup.add(rightLens);

    cameraGroup.scale.set(0.5, 0.5, 0.5);
    mainGroup.add(cameraGroup);

    // Add frustum helpers for both eyes
    const frustumSize = 4;
    
    // Helper for left eye
    const leftFrustum = createFrustumHelper(frustumSize, 0xff0000);
    leftFrustum.position.x = -stereoCamera.eyeSep / 2;
    mainGroup.add(leftFrustum);

    // Helper for right eye
    const rightFrustum = createFrustumHelper(frustumSize, 0x00ff00);
    rightFrustum.position.x = stereoCamera.eyeSep / 2;
    mainGroup.add(rightFrustum);

    mainGroup.position.set(5, 2, 5);
    mainGroup.lookAt(0, 0, 0);
    scene.add(mainGroup);

    function createFrustumHelper(size, color) {
        const geometry = new THREE.BufferGeometry();
        const vertices = new Float32Array([
            0, 0, 0,  // tip
            -size/2, -size/2, -size,  // base bottom-left
            size/2, -size/2, -size,   // base bottom-right
            size/2, size/2, -size,    // base top-right
            -size/2, size/2, -size    // base top-left
        ]);

        const indices = [
            0, 1, 0, 2, 0, 3, 0, 4,  // lines from tip to base
            1, 2, 2, 3, 3, 4, 4, 1   // base square
        ];

        geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
        geometry.setIndex(indices);

        return new THREE.LineSegments(
            geometry,
            new THREE.LineBasicMaterial({ color: color })
        );
    }

    function syncWithCamera() {
        mainGroup.position.copy(stereoCamera.position);
        mainGroup.lookAt(0, 0, 0);
    }


    addObjectToScene(stereoCamera, 'Stereo_camera');
    updateHierarchy();

    setupCameraControls(stereoCamera);

    if (activeCamera) {
        transitionToCamera(stereoCamera);
    }

    activeCamera = stereoCamera;
    // Animation loop
    function animate() {
        requestAnimationFrame(animate);
        syncWithCamera();
    }
    animate();
});

            document.getElementById('addCamera').addEventListener('click', () => {
            const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 5);
            camera.lookAt(0, 0, 0);
            
            const cameraGroup = new THREE.Group();
            
            // Main Camera Body
            const bodyGeometry = new THREE.BoxGeometry(0.6, 0.3, 0.5);
            const bodyMaterial = new THREE.MeshPhysicalMaterial({ 
                color: 0x2c3e50,
                metalness: 0.8,
                roughness: 0.2,
                clearcoat: 1,
                clearcoatRoughness: 0.1
            });
            const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
            cameraGroup.add(bodyMesh);
            
            // Camera Grip
            const gripGeometry = new THREE.CylinderGeometry(0.08, 0.06, 0.4, 8);
            const gripMaterial = new THREE.MeshPhysicalMaterial({ 
                color: 0x34495e,
                metalness: 0.6,
                roughness: 0.8,
                clearcoat: 0.5
            });
            const gripMesh = new THREE.Mesh(gripGeometry, gripMaterial);
            gripMesh.position.y = -0.2;
            cameraGroup.add(gripMesh);
            
            function animateLensFocus() {
            const maxExtension = 0.2;
            lensGroup.userData.focusing = true;
            
            const animate = () => {
                const time = performance.now() * 0.001;
                const extension = Math.sin(time) * maxExtension;
                
                lensElements.forEach((lens, index) => {
                    lens.position.z = lensPositions[index] + extension;
                });
                
                if (lensGroup.userData.focusing) {
                    requestAnimationFrame(animate);
                }
            };
            animate();
            }
            
            // Add focus trigger on right-click
            cameraGroup.userData.onRightClick = () => {
            if (!lensGroup.userData.focusing) {
            animateLensFocus();
            } else {
            lensGroup.userData.focusing = false;
            }
            };
            
            // Lens System
            const lensGroup = new THREE.Group();
            
            // Main Lens
            const lensElements = [];
            const lensPositions = [0.3, 0.4, 0.5];
            
            lensPositions.forEach((pos, index) => {
                const element = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.12 - (index * 0.01), 0.13 - (index * 0.01), 0.05, 32),
                    new THREE.MeshPhysicalMaterial({
                        color: 0x88ccff,
                        metalness: 0.1,
                        roughness: 0.1,
                        transmission: 0.9,
                        thickness: 0.02,
                        clearcoat: 1
                    })
                );
                element.rotation.x = Math.PI / 2;
                element.position.z = pos;
                lensElements.push(element);
                lensGroup.add(element);
            });
            
            // Lens Glass
            const lensGlassGeometry = new THREE.CircleGeometry(0.15, 32);
            const glassMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x88ccff,
                metalness: 0.9,
                roughness: 0.1,
                transmission: 0.9,
                thickness: 0.1,
                clearcoat: 1
            });
            
            
            
            // Lens Ring
            const ringGeometry = new THREE.TorusGeometry(0.15, 0.02, 16, 60);
            const ringMaterial = new THREE.MeshPhysicalMaterial({ 
                color: 0x444444,
                metalness: 0.8,
                roughness: 0.4,
                clearcoat: 1
            });
            const ringMesh = new THREE.Mesh(ringGeometry, ringMaterial);
            ringMesh.position.z = 0.45;
            lensGroup.add(ringMesh);
            
            cameraGroup.add(lensGroup);
            
            // Viewfinder
            const viewfinderGeometry = new THREE.BoxGeometry(0.3, 0.2, 0.2);
            const viewfinderMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x2c3e50,
                metalness: 0.8,
                roughness: 0.2,
                clearcoat: 1
            });
            const viewfinderMesh = new THREE.Mesh(viewfinderGeometry, viewfinderMaterial);
            viewfinderMesh.position.y = 0.25;
            cameraGroup.add(viewfinderMesh);
            
            // OLED Screen
            // Replace the existing screenMaterial definition with this
            const createLCDContent = () => {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 192;
            const ctx = canvas.getContext('2d');
            
            
            const updateLCD = () => {
                ctx.fillStyle = '#001122';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#00ff00';
                ctx.font = '24px monospace';
                ctx.fillText(`ISO: 100`, 10, 30);
                ctx.fillText(`f/2.8`, 10, 60);
                ctx.fillText(`1/125`, 10, 90);
                
                ctx.strokeStyle = '#00ff00';
                ctx.strokeRect(200, 10, 40, 20);
                ctx.fillRect(202, 12, 36 * 0.8, 16);
            };
            
            updateLCD();
            return new THREE.CanvasTexture(canvas);
            };
            
            const screenMaterial = new THREE.MeshBasicMaterial({
            map: createLCDContent(),
            emissive: 0x222222,
            emissiveIntensity: 0.5
            });
            
             // Control Dials
             const dialGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.02, 32, 1, false, 0, Math.PI * 2);
            const dialMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x95a5a6,
                metalness: 0.9,
                roughness: 0.3,
                clearcoat: 1
            });
            
            // Mode Dial
            const modeDial = new THREE.Mesh(dialGeometry, dialMaterial);
            modeDial.rotation.x = Math.PI / 2;
            modeDial.position.set(0.2, 0.15, 0);
            cameraGroup.add(modeDial);
            
            // Command Dial
            const commandDial = new THREE.Mesh(dialGeometry, dialMaterial);
            commandDial.rotation.x = Math.PI / 2;
            commandDial.position.set(-0.2, 0.15, 0);
            cameraGroup.add(commandDial);
            
            cameraGroup.scale.set(0.5, 0.5, 0.5);
            cameraGroup.position.set(0, 0, 0);
            camera.add(cameraGroup);
            
            
            // Hot Shoe
            const hotShoeGeometry = new THREE.BoxGeometry(0.2, 0.05, 0.2);
            const hotShoeMesh = new THREE.Mesh(hotShoeGeometry, gripMaterial);
            hotShoeMesh.position.y = 0.35;
            cameraGroup.add(hotShoeMesh);
            
            cameraGroup.scale.set(0.5, 0.5, 0.5);
            cameraGroup.position.set(0, 0, 0);
            camera.add(cameraGroup);
            
            // Enhanced Camera Helper with thicker lines
            const helper = new THREE.CameraHelper(camera);
            helper.material.linewidth = 3; // Increased line width
            helper.material.color.setHex(0xff6600); // Brighter orange color
            helper.visible = true;
            scene.add(helper);
            camera.helper = helper;
            
            
            // Add camera to the scene
            camera.name = `Camera_${objects.length}`;
            addObjectToScene(camera, 'camera');
            updateHierarchy();
            
            setupCameraControls(camera);
            
            if (activeCamera) {
                transitionToCamera(camera);
            }
            
            activeCamera = camera;
            
            
            // Add pop-up flash
            const flashGroup = new THREE.Group();
            const flashBase = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, 0.05, 0.1),
            new THREE.MeshPhysicalMaterial({ color: 0x2c3e50, metalness: 0.8 })
            );
            
            const flashHead = new THREE.Mesh(
            new THREE.BoxGeometry(0.2, 0.1, 0.05),
            new THREE.MeshPhysicalMaterial({ color: 0x2c3e50, metalness: 0.8 })
            );
            flashHead.position.y = 0.05;
            
            const flashBulb = new THREE.Mesh(
            new THREE.CylinderGeometry(0.03, 0.03, 0.02, 16),
            new THREE.MeshPhysicalMaterial({
            color: 0xffffff,
            emissive: 0xffffff,
            emissiveIntensity: 0
            })
            );
            flashBulb.rotation.x = Math.PI / 2;
            flashHead.add(flashBulb);
            
            flashGroup.add(flashBase, flashHead);
            flashGroup.position.set(0, 0.4, -0.1);
            cameraGroup.add(flashGroup);
            
            // Add strap lugs
            const strapLugGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.1, 8);
            const strapLugMaterial = new THREE.MeshPhysicalMaterial({
            color: 0x95a5a6,
            metalness: 0.9
            });
            
            [-0.3, 0.3].forEach(x => {
            const lug = new THREE.Mesh(strapLugGeometry, strapLugMaterial);
            lug.rotation.z = Math.PI / 2;
            lug.position.set(x, 0.1, 0);
            cameraGroup.add(lug);
            });
            
            // Add dial animations
            function animateDials() {
            modeDial.rotation.z += 0.02;
            commandDial.rotation.z -= 0.015;
            }
            
            cameraGroup.userData.controlsActive = false;
            cameraGroup.userData.onControlClick = () => {
            cameraGroup.userData.controlsActive = !cameraGroup.userData.controlsActive;
            };
            
            // Create DOF helper
            const createDOFVisualization = () => {
            const dofGroup = new THREE.Group();
            
            
            const focalPlane = new THREE.Mesh(
                new THREE.PlaneGeometry(2, 2),
                new THREE.MeshBasicMaterial({ 
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.2
                })
            );
            focalPlane.position.z = -5;
            
            dofGroup.add(focalPlane);
            scene.add(dofGroup);
            
            return dofGroup;
            };
            
            const dofHelper = createDOFVisualization();
            
            function animate() {
            requestAnimationFrame(animate);
            if (cameraGroup.userData.controlsActive) {
            animateDials();
            }
            }
            // Start animation
            animate();
            });
            
            
            
            function setupCameraControls(camera) {
                const fovInput = document.querySelector('#cameraFOV input');
                if (fovInput) {
                  fovInput.value = camera.fov;
                  fovInput.addEventListener('input', () => {
                  camera.fov = parseFloat(fovInput.value);
                  camera.updateProjectionMatrix();
                  if (camera.helper) camera.helper.update();
                });
            }
            
            
            const nearInput = document.querySelector('#cameraNear input');
            const farInput = document.querySelector('#cameraFar input');
            
            if (nearInput) {
                nearInput.value = camera.near;
                nearInput.addEventListener('input', () => {
                    camera.near = parseFloat(nearInput.value);
                    camera.updateProjectionMatrix();
                    if (camera.helper) camera.helper.update();
                });
            }
            
            if (farInput) {
                farInput.value = camera.far;
                farInput.addEventListener('input', () => {
                    camera.far = parseFloat(farInput.value);
                    camera.updateProjectionMatrix();
                    if (camera.helper) camera.helper.update();
                });
            }
            }

            function transitionToCamera(targetCamera) {
const duration = 1.5;
const startPosition = activeCamera.position.clone();
const startRotation = activeCamera.rotation.clone();
const startQuaternion = activeCamera.quaternion.clone();

const endPosition = targetCamera.position.clone();
const endRotation = targetCamera.rotation.clone();
const endQuaternion = targetCamera.quaternion.clone();

let time = 0;
const easing = t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;

function animateTransition() {
    time += 0.016;
    const alpha = easing(Math.min(time / duration, 1));

    activeCamera.position.lerpVectors(startPosition, endPosition, alpha);
    THREE.Quaternion.slerp(startQuaternion, endQuaternion, activeCamera.quaternion, alpha);

    if (time < duration) {
        requestAnimationFrame(animateTransition);
    } else {
        activeCamera.position.copy(endPosition);
        activeCamera.rotation.copy(endRotation);
        if (activeCamera.helper) activeCamera.helper.update();
        if (activeCamera.projectionLine) {
            const positions = new Float32Array([
                activeCamera.position.x, activeCamera.position.y, activeCamera.position.z,
                0, 0, 0
            ]);
            activeCamera.projectionLine.geometry.setAttribute('position', 
                new THREE.BufferAttribute(positions, 3));
            activeCamera.projectionLine.geometry.attributes.position.needsUpdate = true;
        }
    }
}

animateTransition();
}
        }


       
        // Add this to your init() function or call it when the page loads
        window.addEventListener('load', initializePanelControls);
         document.querySelectorAll('.panel-header').forEach(header => {
            header.addEventListener('click', () => {
                const content = header.nextElementSibling;
                const button = header.querySelector('.expand-button');
                if (content.style.display === 'none') {
                    content.style.display = 'block';
                    button.textContent = '▼';
                } else {
                    content.style.display = 'none';
                    button.textContent = '▶';
                }
            });
        });

        // Toggle assets panel
       

        // Switch tabs
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
        });
    });



        // functions to update the UI
        function updateLightUI(light) {
            // Update light-specific controls in the UI
            const fovInput = document.querySelector('#cameraFOV input');
            if (fovInput) {
                fovInput.disabled = true;
            }

           
        }
        
        function updateCameraUI(camera) {
            // Update camera-specific controls in the UI
            const fovInput = document.querySelector('#cameraFOV input');
            if (fovInput) {
                fovInput.disabled = false;
                fovInput.value = camera.fov;
            }

           
        }
        
        // Call this in your init function
        function initializeLightAndCameraSystem() {
            setupLightControls();
    
            
            // Make renderer support shadows
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        }
        
        // Add this to your animation loop
        function updateHelpers() {
            objects.forEach(obj => {
                if (obj.helper) {
                    obj.helper.update();
                }
            });
        }

    </script>

<script src="processing/assets.js"></script>
<script src="animations/camera-path.js"></script>

</body>
</html>
