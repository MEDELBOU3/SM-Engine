<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Advanced 3D Editor</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/remixicon/fonts/remixicon.css">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Outlined" rel="stylesheet">
    

    <link href='https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css' rel='stylesheet'>
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/preview.css">
    <link rel="stylesheet" href="css/tools.css">
    <link rel="stylesheet" href="css/search.css">
    <link rel="stylesheet" href="css/gui.css">
    
</head>
<body>
    
    <div class="editor-container">
        <!-- Top Toolbar -->
        <div class="sidebar"> 
                <button class="tool-btn" id="toggle-lock">
                   <i class="fas fa-unlock"></i>
                </button>
                <button class="tool-btn" id="guiControls">
                    Gui
                </button>
      
                <button class="tool-btn" id="translate">
                    <i class="fas fa-arrows-alt"></i>
                </button>
                <button class="tool-btn" id="rotate">
                    <i class="fas fa-sync"></i>
                </button>
                <button class="tool-btn" id="scale">
                    <i class="fas fa-expand-arrows-alt"></i>
                </button>
                <button class="tool-btn" id="materialsEditor">
                    <i class="fas fa-fill-drip"></i> 
                </button>
                <button class="tool-btn" id="addSculptingSphere">
                    <i class="fas fa-paint-brush icon"></i>
                </button>
                <button class="tool-btn" id="snow-controls">
                    <i class="fas fa-snowflake"></i>
                </button>
                <button class="tool-btn" id="lightControls">
                    <i class="fas fa-sun"></i> 
                </button>
                <button class="tool-btn" id="cameraControls">
                   <i class="fas fa-video"></i> 
                </button>
                <button class="tool-btn" id="physicsControls">
                    <i class="fas fa-atom"></i>
                </button>
                <button class="tool-btn" id="modelingControls">
                    <i class='bx bx-buildings'></i>
                </button>
                <button class="tool-btn" id="drawingControls">
                    <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24"><path fill="currentColor" d="M1.999 15V2h13v5h-2V4h-9v9h3v2zm6 5V8h12v5.5h-2V10h-8v8h3.5v2zm8.778 3.684L13.41 13.378l10.258 3.407l-4.656 2.227z"/></svg>
                </button>
        </div>
    
        
        <div class="toolbar">
            <div class="toolbar-group">
                <button class="tool-button" id="newScene">
                    <i class="fas fa-file"></i> New
                </button>
                <button class="tool-button" id="saveScene">
                    <i class="fas fa-save"></i> Save
                </button>
                <button class="tool-button" id="loadScene">
                    <i class="fas fa-folder-open"></i> Load
                </button>
                <button class="tool-button" onclick="toggleAssetsPanel()">
                    Assets
                </button>
                <button class="tool-button">Export</button>
                <button class="tool-button" id="toggle-inspector">Inspector</button>
            </div>
            
            <div class="toolbar-group">
                <button class="tool-button"   id="addCube">
                    <i class='bx bx-cube-alt'></i>
                </button>
                <button class="tool-button" id="addPlane">
                    <i class="fas fa-square"></i> <!-- Icon for Plane -->
                </button>

                <button class="tool-button" id="addTerrain">
                    <i class="fas fa-border-all"></i> <!-- Icon for Plane -->
                </button>

                
                <button class="tool-button" id="addSphere">
                   <i class="fas fa-circle"></i>
                </button>
                <button class="tool-button" id="addCylinder">
                    <i class='bx bx-cylinder' style='color:#ffffff' ></i>
                </button>
                <button class="tool-button" id="addRectangularPrism">
                    <i class='bx bx-cuboid'></i>
                </button>
                <button class="tool-button" id="addPyramid">
                    <i class='bx bxs-pyramid'></i>
                </button>
                <button class="tool-button" id="addTorus">
                    <i class="fas fa-ring"></i>
                </button>
            </div>
            <div class="toolbar-group">
                <button class="tool-button" id="addLight">
                    <i class="fas fa-lightbulb"></i> Light
                </button>
                <button class="tool-button" id="addCameraInit">
                    <i class="fas fa-video"></i> Camera
                </button>
            </div>
            <div class="toolbar-group">
                <button class="tool-button"  id="node-editor-toggle">Node</button>
            </div>
            <div class="toolbar-group">
                <button class="tool-button"  id="toggleAnimator">Animator</button>
            </div>
        </div>

        <!-- Left Panel - Hierarchy -->
        <div id="hierarchy-panel"  class="hierarchy-panel">
            <div class="panel-header" style="cursor: pointer;">
                <i class="fas fa-sitemap" ></i> Hierarchy 
                <span class="expand-button"  style="margin-left: 30px;">▼</span>
            </div>
            <div class="hierarchy-content" id="hierarchy-content">
                <!-- Hierarchy items will be added here dynamically -->
            </div>
            <div class="panel-header">
                <i class="fa-solid fa-paint-brush"></i> Brush Model Settings
                <span class="expand-button"  style="margin-left: 30px;">▼</span>
            </div>
            <div id="brush-panel" >
                <div class="brush-controls" >
                    <label>Brush Size</label>
                    <input type="range" id="brush-size" min="0.5" max="10" step="0.1" value="2">
                        
                    <label>Density</label>
                    <input type="range" id="brush-density" min="1" max="20" value="5">
                        
                    <label>Upload Model</label>
                    <input type="file" id="model-upload" accept=".glb,.gltf">
                    
                    <div class="brush-actions" style="margin: 10px auto;  display: flex;">
                        <button class="brush-button" onclick="brushSystem.undo()">Undo</button>
                        <button class="brush-button" onclick="brushSystem.redo()">Redo</button>
                    </div>
                </div>
            </div>
            <div class="resize-handle"></div> 
        </div>

        <!-- Main Viewport -->
        <div class="viewport" id="viewportRenderer">
            <div id="renderer-container">
                <div id="render-container">
                    <div id="axis-controls" class="axis-controls">
                        <div class="axis-button" id="axis-x" onclick="setCameraView('x')">X</div>
                        <div class="axis-button" id="axis-y" onclick="setCameraView('y')">Y</div>
                        <div class="axis-button" id="axis-z" onclick="setCameraView('z')">Z</div>
                        <div class="axis-button" id="top" onclick="setCameraView('top')"><i class="fa-solid fa-arrow-up-long"></i></div>
                        <div class="axis-button" id="bottom" onclick="setCameraView('bottom')"><i class="fa-solid fa-arrow-down"></i></div>
                        <div class="axis-button" id="diagonal" onclick="setCameraView('diagonal')"><i class="fa-solid fa-square-arrow-up-right"></i></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right Panel - Inspector -->
        <div id="inspector-panel" class="inspector-panel">
            
            <div class="panel-header">
                <i class="fas fa-info-circle"></i> Inspector
            </div>

            <div class="search-group">
                <input type="text" id="search-input" class="search-input" placeholder="Search..." />
            </div>
        
            <div class="property-group1" id="GuiContainer" style="display: none;">
                <div id="gui-container">
                   <!--Gui Interface-->
                </div>
            </div>
            <div class="property-group">
                <h3>Transform</h3>
                <div class="property-row">
                    <span class="property-label">Pos</span>
                    <div class="vector-inputs">
                        <input type="number" class="property-input" id="posX" step="0.1">
                        <input type="number" class="property-input" id="posY" step="0.1">
                        <input type="number" class="property-input" id="posZ" step="0.1">
                    </div>
                </div>
                <div class="property-row">
                    <span class="property-label">Rot</span>
                    <div class="vector-inputs">
                        <input type="number" class="property-input" id="rotX" step="0.1">
                        <input type="number" class="property-input" id="rotY" step="0.1">
                        <input type="number" class="property-input" id="rotZ" step="0.1">
                    </div>
                </div>
                <div class="property-row">
                    <span class="property-label">Scl</span>
                    <div class="vector-inputs">
                        <input type="number" class="property-input" id="scaleX" step="0.1">
                        <input type="number" class="property-input" id="scaleY" step="0.1">
                        <input type="number" class="property-input" id="scaleZ" step="0.1">
                    </div>
                </div>
            </div>

          
          
            <div class="physics-controls"  id="physics-controls" style="display: none;">
                <h3>Physics Forces</h3>
                <button class="panel-button" id="apply-physics">Apply Physics</button>

                <div class="control-group">
                    <div class="slider-container">
                        <label>Gravity:</label>
                        <input type="range" id="gravity-strength" min="-20" max="20" value="-9.81" step="0.1">
                        <span id="gravity-value">-9.81</span>
                    </div>
                </div>
                <div class="control-group">
                    <h4>Wind Zone</h4>
                    <div class="slider-container">
                        <label>Strength:</label>
                        <input type="range" id="wind-strength" min="0" max="50" value="10" step="0.1">
                        <span id="wind-value">10</span>
                    </div>
                    <div class="slider-container">
                        <label>Radius:</label>
                        <input type="range" id="wind-radius" min="1" max="50" value="10" step="0.5">
                        <span id="radius-value">10</span>
                    </div>
                </div>
                <div class="force-buttons">
                    <button class="force-button" id="add-wind">Add Wind Zone</button>
                    <button class="force-button" id="add-vortex">Add Vortex</button>
                </div>
            </div>

            <script>
                 document.getElementById('apply-physics').addEventListener('click', () => {
               if (!selectedObject) {
                console.warn("No object selected.");
                return;
              }

            physicsManager.addPhysicsToObject(selectedObject, {
                mass: 5,
                friction: 0.9,
                restitution: 0.7
            });

           console.log("Physics applied to", selectedObject.name);
           });


  function applyPhysicsToSelectedObject(object) {
    const shape = getCannonShapeFromObject(object);
    if (!shape) {
        console.error("Unable to determine physics shape for object.");
        return;
    }

    const body = new CANNON.Body({
        mass: 5, // Set mass to make it fall
        shape: shape,
        position: new CANNON.Vec3(object.position.x, object.position.y, object.position.z),
        quaternion: new CANNON.Quaternion(object.quaternion.x, object.quaternion.y, object.quaternion.z, object.quaternion.w),
    });

    world.addBody(body);
    object.userData.physicsBody = body;
}

// Function to determine the appropriate CANNON.js shape
function getCannonShapeFromObject(object) {
    if (object.geometry instanceof THREE.BoxGeometry) {
        const size = new THREE.Vector3();
        object.geometry.computeBoundingBox();
        object.geometry.boundingBox.getSize(size);
        return new CANNON.Box(new CANNON.Vec3(size.x / 2, size.y / 2, size.z / 2));
    }
    if (object.geometry instanceof THREE.SphereGeometry) {
        return new CANNON.Sphere(object.geometry.parameters.radius);
    }
    return null;
}

</script>

            <div class="viewport-container" style="display: none;">                
                <div class="model-preview-container">
                    <canvas id="preview-canvas"></canvas>
                    <div class="model-info">
                        <span class="model-name"></span>
                        <div class="model-stats"></div>
                    </div>
                </div>
            </div>
         
            
            <div class="modeling-tools" id="modelingTools" style="display: none;">
                <div class="panel-header">
                    <span>Mesh Manipulation Tools</span>
                    <span class="expand-button">▼</span>
                </div>
                <div class="panel-content">
                   
                    
                    <div class="selection-controls">
                        <button id="toggle-modeling" class="panel-button">Modeling Mode</button>
                        <button id="select-vertex" class="panel-button" disabled>
                             Select Vertex
                        </button>
                        <button id="select-edge" class="panel-button" disabled>Select Edge</button>
                        <button id="select-face" class="panel-button" disabled>Select Face</button>
                        <div id="controls">
                            <h3>Building</h3>
                            <label class="control-label">Width : <input type="number" id="building-width" value="5"></label>
                            <label class="control-label"> Height : <input type="number" id="building-height" value="10"></label>
                            <label class="control-label">Depth : <input type="number" id="building-depth" value="5"></label>
                            <button class="panel-button" id="create-building">Add building</button>
                        
                            <h3>Decoration</h3>
                            <button class="panel-button" id="add-decoration">Add Decoration</button>

                        </div>
                    </div>

                    <div>
                        <label>Vertex Size:</label>
                        <input type="range" id="vertexSizeSlider" min="0.1" max="2" step="0.1" value="0.5">
                    </div>
                    <div>
                        <label>Edge Thickness:</label>
                        <input type="range" id="edgeThicknessSlider" min="1" max="5" step="1" value="2">
                    </div>
                    <div>
                        <label>Subdivision Levels:</label>
                        <input type="range" id="subdivisionLevelsSlider" min="0" max="4" step="1" value="1">
                    </div>
                    <div>
                        <label>Face Opacity:</label>
                        <input type="range" id="faceOpacitySlider" min="0" max="1" step="0.1" value="0.5">
                    </div>
                </div>
            </div>

            


            <div class="panel" id="lights" style="display: none;">
                <div class="panel-header">
                    <span>Lights</span>
                    <span class="expand-button">▼</span>
                </div>
                <div class="panel-content">
                    <button id="addPointLight" class="panel-button">Point Light</button>
                    <button id="addSpotLight" class="panel-button">Spot Light</button>
                    <button id="addAreaLight" class="panel-button">Area Light</button>
                    <button id="addDirectionalLight" class="panel-button">Directional Light</button>
                    <button id="addHemisphereLight" class="panel-button">Hemisphere Light</button>
                    <button id="addLensflareLight" class="panel-button">Lensflare Light</button>
                    <button id="addVolumetricLight" class="panel-button">Volumetric Light</button>
                    
                    <!-- Light Controls -->
                    <div class="light-controls">
                        <div class="control-group">
                            <label class="control-label">Light Intensity</label>
                            <input type="range" id="lightIntensity" min="0" max="2" step="0.1" value="1">
                        </div>
                        <div class="control-group">
                            <label class="control-label">Light Color</label>
                            <input type="color" id="lightColor" value="#ffffff">
                        </div>
                    </div>
                </div>
            </div>

            <div class="panel" id="Cameras" style="display: none;">
                <div class="panel-header">
                    <span>Camera</span>
                    <span class="expand-button">▼</span>
                </div>
                <div class="panel-content">
                    <button id="addCamera" class="panel-button">Add 
                        <i class='bx bx-camera-movie' style="color:#ffffff; font-size: 20px;"></i>
                    </button>
                    <button id="addCameraOrto" class="panel-button">Add 
                        <i class='bx bx-camera-movie' style="color:#1db34d; font-size: 20px;"></i>
                    </button>
                    
                    <div class="input-group">
                        <label id="cameraFOV">FOV</label>
                        <input type="number" value="60">
                    </div>
                    
                    <!-- Camera list will be inserted here -->
                </div>
            </div>

            <div class="panel" id="drawingMode" style="display: none;">
                <div class="panel-header">
                    <span>Drawing</span>
                    <span class="expand-button">▼</span>
                </div>
                <div class="panel-content">
                    <button class="panel-button" id="toggle-draw">Draw Mode (F)</button>
                    <button class="panel-button" id="toggle-extrude">Extrude Mode (E)</button>
                    <button class="panel-button" id="clear">Clear (L)</button>
                    <div class="slider-container">
                        <input type="range" id="brush-" min="0.1" max="2" step="0.1" value="0.5">
                        <span>Brush Size: 0.5</span>
                    </div>
                    <div class="slider-container">
                        <input type="range" id="snapping" min="0" max="1" step="0.1" value="0.3">
                        <span>Snapping: 0.3</span>
                    </div>
                    <div class="slider-container">
                        <input type="range" id="extrude-height" min="0.1" max="5" step="0.1" value="1">
                        <span>Extrude: 1.0</span>
                    </div>
                </div>
                <div style="background-color: #e74c3c; padding: 4px;  margin: 10px auto; margin-right: 10px; margin-left: 10px;" class="status" id="status">Ready</div>
            </div>
        

            <!-- Material Editor Panel -->
            <div class="material-editor" id="material-editor"  style="display: none;">
                <div class="panel-header">Material Editor</div>
                <div class="property-group">
                    <div class="property-row">
                        <span class="property-label">Color</span>
                        <input type="color" class="property-input" id="materialColor">
                    </div>
                    <div class="property-row">
                        <span class="property-label">Metalness</span>
                        <input type="range" class="property-input" id="materialMetalness" min="0" max="1" step="0.1">
                    </div>
                    <div class="property-row">
                        <span class="property-label">Roughness</span>
                        <input type="range" class="property-input" id="materialRoughness" min="0" max="1" step="0.1">
                    </div>
                    <div class="property-row">
                        <label for="materialOpacity">Opacity:</label>
                        <input type="range" id="materialOpacity" min="0" max="1" step="0.01" value="1">

                        <label for="materialTexture">Texture:</label>
                        <input type="file" id="materialTexture" accept="image/*">
                    </div>
                    <div class="property-row">
                        <h3>MTXT</h3>
                        <div id="materialTextures" style=" margin: 10px auto; width: 100%; height: auto;">

                        </div>
                    </div>
                </div>
            </div>
                <div class="controls" id="snow-sittings" style="display: none;">
                    <div class="panel-header">Advanced Snow System</div>
                    <div class="property-group">
                        <button class="panel-button" id="toggleSnow">Toggle Snow</button>
                        <div class="control-group">
                            <label>Density: <span id="densityValue">1000</span></label>
                            <input type="range" id="density" min="100" max="5000" value="1000">
                        </div>
                        <div class="control-group">
                            <label>Size: <span id="sizeValue">0.1</span></label>
                            <input type="range" id="size" min="0.01" max="0.5" value="0.1" step="0.01">
                        </div>
                        <div class="control-group">
                            <label>Speed: <span id="speedValue">1</span></label>
                            <input type="range" id="speed" min="0.1" max="5" value="1" step="0.1">
                        </div>
                        <div class="control-group">
                            <label>Wind: <span id="windValue">0</span></label>
                            <input type="range" id="wind" min="-5" max="5" value="0" step="0.1">
                        </div>
                        <div class="control-group">
                            <label>Turbulence: <span id="turbulenceValue">0.5</span></label>
                            <input type="range" id="turbulence" min="0" max="2" value="0.5" step="0.1">
                        </div>

                        <div class="weather-effects">
                            <button class="effect-button" id="storm">Storm</button>
                            <button class="effect-button" id="blizzard">Blizzard</button>
                            <button class="effect-button" id="gentle">Gentle</button>
                        </div>
                    </div>

                    <div class="property-group">
                        <div id="controls">
                            <button class="panel-button" id="toggleParticles">Toggle Particles</button>

                            <button class="panel-button"  id="increaseParticles">Increase Particles</button>
                            <button class="panel-button"  id="decreaseParticles">Decrease Particles</button>
                            <input class="panel-button" type="color" id="particleColor" value="#ffcc88" />
                        </div>
                        
                    </div>
                </div>
            
        
            <div class="sculpting-tools" id="sculpting-tools"  style="display: none;">
                <div class="panel-header">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" d="m15.47 13.79l-2.58-1.03L6 15.05l-4-1.54v2.1l4 1.34zm-4.9-2.37L8 8H2v3.61l4 1.34zM6 19.05l-4-1.33V22h20l-4.97-6.62zM17 6V1l-5-1l-3 2v4l3 2zm1.5 1L16 9v3l2.5 2l4.5-2V8z"/></svg>
                    Sculpting Tools
                </div>
                <div class="property-group">
                    <!-- Basic Tools -->
                    <button class="panel-button" id="raiseLower">Raise/Lower</button>
                    <button class="panel-button" id="smooth">Smooth</button>
                    <button class="panel-button" id="flatten">Flatten</button>
                    <button class="panel-button" id="noise">Noise</button>
                    
                    <!-- Advanced Tools -->
                    <button class="panel-button" id="pinch">Pinch</button>
                    <button class="panel-button" id="clay">Clay</button>
                    <button class="panel-button" id="scrape">Scrape</button>
                    <button class="panel-button" id="fill">Fill</button>
                    <button class="panel-button" id="texturePaint">Texture Paint</button>
            
                    <!-- Brush Controls -->
                    <div class="brush-controls">
                        <label>Brush Size:
                            <input type="range" id="brushSize" min="0.5" max="5" step="0.1" value="1.5">
                        </label>
                        <label>Brush Strength:
                            <input type="range" id="brushStrength" min="0.01" max="0.5" step="0.01" value="0.1">
                        </label>
                    </div>
            
                    <!-- Symmetry Controls -->
                    <div class="tool-options">
                        <label>
                            <input type="checkbox" id="symmetryToggle"> Enable Symmetry
                        </label>
                        <select id="symmetryAxis">
                            <option value="x">X Axis</option>
                            <option value="z">Z Axis</option>
                        </select>
                    </div>
            
                    <!-- History Controls -->
                    <div class="history-controls">
                        <button class="panel-button" id="undo">Undo</button>
                        <button class="panel-button" id="redo">Redo</button>
                    </div>
            
                    <!-- Texture Upload -->
                    <input type="file" id="uploadTexture" accept="image/*" style="display: none;">
                    <button class="panel-button" id="selectTexture">Upload Texture</button>
                </div>

                <div class="advanced-tools">
                    <button class="panel-button" id="terrace">Terrace</button>
                    <button class="panel-button" id="erosion">Erosion</button>
                    <button class="panel-button" id="ridge">Ridge</button>
                    <button class="panel-button" id="canyon">Canyon</button>
                    <button class="panel-button" id="plateau">Plateau</button>
                    <button class="panel-button" id="slope">Slope</button>
                    <button class="panel-button" id="blur">Blur Heights</button>
                    <button class="panel-button" id="sharpen">Sharpen</button>
                    
                    <div class="tool-settings">
                        <label>Steps:
                            <input type="range" id="terraceSteps" min="2" max="10" value="4">
                        </label>
                        <label>Erosion Strength:
                            <input type="range" id="erosionStrength" min="0.1" max="1.0" value="0.5">
                        </label>
                        <label>Ridge Height:
                            <input type="range" id="ridgeHeight" min="0.1" max="2.0" value="1.0">
                        </label>
                    </div>
                </div>
            </div>

            <div id="sculpting-character-tools" class="character-sclupting" style="display: none;">
                <div class="panel-header">Character Sculpting</div>
                <div class="property-group">
                    <div class="group-header">Basic Shape Tools</div>
                    <button class="panel-button" id="faceShape">Face Shape</button>
                    <button class="panel-button" id="noseSculpt">Nose Sculpt</button>
                    <button class="panel-button" id="cheekDefinition">Cheek Definition</button>
                    <button class="panel-button" id="jawSculpt">Jaw Sculpt</button>
                    <button class="panel-button" id="foreheadShape">Forehead Shape</button>
                </div>
        
                <div class="property-group">
                    <div class="group-header">Advanced Shape Tools</div>
                    <button class="panel-button" id="chinSculpt">Chin Sculpt</button>
                    <button class="panel-button" id="templeSculpt">Temple Sculpt</button>
                    <button class="panel-button" id="browRidge">Brow Ridge</button>
                    <button class="panel-button" id="eyeSocket">Eye Socket</button>
                    <button class="panel-button" id="lipShape">Lip Shape</button>
                </div>
        
                <div class="property-group">
                    <div class="group-header">Advanced Tools</div>
                    <button class="panel-button" id="snakeHook">Snake Hook</button>
                    <button class="panel-button" id="hairBrush">Hair Brush</button>

                    <div class="group-header">Hair Brush Settings</div>
                    <button class="panel-button" id="hairBrush">Hair Brush</button>
                    <div class="brush-controls">
                        <label title="Adjust the number of hair segments.">Segments: <input type="range" id="hairSegments" min="4" max="16" value="8" step="1"></label>

                       <label>Length: <input type="range" id="hairLength" min="0.02" max="0.2" value="0.05" step="0.01"></label>
                       <label>Density: <input type="range" id="hairDensity" min="3" max="12" value="5" step="1"></label>
                       <label>Curl: <input type="range" id="hairCurl" min="0" max="1" value="0.2" step="0.1"></label>
                        <label>Stiffness: <input type="range" id="hairStiffness" min="0.1" max="1" value="0.8" step="0.1"></label>
                    </div>

                    <div class="property-group">
                        <div class="group-header">Advanced Hair Settings</div>
                        <div class="brush-controls">
                            <label>Wave: <input type="range" id="hairWave" min="0" max="1" value="0.2" step="0.05"></label>
                            <label>Frizz: <input type="range" id="hairFrizz" min="0" max="0.5" value="0.1" step="0.05"></label>
                            <label>Clump Size: <input type="range" id="hairClumpSize" min="1" max="10" value="3" step="1"></label>
                            <label>Noise: <input type="range" id="hairNoise" min="0" max="0.2" value="0.05" step="0.01"></label>
                            <label>Color:
                                <input type="color" id="hairColor" value="#3a1a00">
                            </label>
                            <label>Highlight Color:
                                <input type="color" id="hairSpecular" value="#8B4513">
                            </label>
                        </div>
                    </div>
                </div>

                <div class="property-group">
                    <div class="group-header">Detail Tools</div>
                    <button class="panel-button" id="smooth">Smooth</button>
                    <button class="panel-button" id="pinch">Pinch</button>
                    <button class="panel-button" id="inflate">Inflate</button>
                    <button class="panel-button" id="crease">Crease</button>
                </div>
                
                <div class="property-group">
                    <div class="group-header">Symmetry</div>
                    <div class="symmetry-controls">
                        <label>
                            <input type="checkbox" id="symmetryToggle" checked>
                            Enable Symmetry
                        </label>
                        <select id="symmetryAxis">
                            <option value="x">X Axis</option>
                            <option value="y">Y Axis</option>
                            <option value="z">Z Axis</option>
                        </select>
                    </div>
                </div>
                
            </div>
            <div class="historySysteme">
                <div class="panel-header">
                    <i class="fas fa-history"></i>
                     Histroy & Controls
                </div>
                <div class="history-panel" id="history-panel">
                    <div class="panel-header">
                        <i class="fas fa-history"></i>
                        History panel
                    </div>
                    <div class="property-row">
                        <div id="history-items"></div>
                    </div>
                </div>
                <!-- Advanced Tools Panel -->
                <div class="advanced-tools" id="advanced-tools">
                    <button class="tool-button" id="mirror">Mirror</button>
                    <button class="tool-button" id="array">Array</button>
                    <button class="tool-button" id="boolean">Boolean</button>
                </div>
            
            </div>
            <!-- Export Options -->
            <div class="export-panel" id="export-panel">
                <div class="panel-header">
                    Export Options
                </div>
                <div class="export-meth">
                    <select class="property-input" id="exportFormat">
                        <option value="gltf">GLTF/GLB</option>
                        <option value="obj">OBJ</option>
                        <option value="fbx">FBX</option>
                    </select>
                    <button class="tool-button" id="exportButton">Export</button>
                </div>
            </div>
        </div>
        
        <div class="animator-container">
            <div class="layers-panel">
                <div class="panel-header">Layers</div>
                <div class="layer-item selected">
                    <span class="layer-icon">▶</span>
                    Base Layer
                </div>
                <div class="layer-item">
                    <span class="layer-icon">▶</span>
                    Left Hand Layer
                </div>
                <div class="layer-item">
                    <span class="layer-icon">▶</span>
                    Right Hand Layer
                </div>
            </div>
    
            <div class="graph-panel">
                <div class="grid"></div>
                <div class="controls1">
                    <button class="control-btn1" id="addState">Add State</button>
                    <button class="control-btn1" id="addTransition">Add Transition</button>
                </div>
            </div>
    
            <div class="parameters-panel">
                <div class="parameter-group">
                    <label class="parameter-label">State Name</label>
                    <input type="text" class="parameter-input" id="stateName">
                </div>
                <div class="parameter-group">
                    <label class="parameter-label">Speed</label>
                    <input type="range" class="parameter-input" min="0" max="2" step="0.1" value="1">
                </div>
                <div class="parameter-group">
                    <label class="parameter-label">Transition Duration</label>
                    <input type="number" class="parameter-input" value="0.25" step="0.05">
                </div>
            </div>
        </div>

    <style>
     .animator-container {
        display: none;
       position: absolute;
       top: 41%;
       left: 50%;
       bottom: 31vh;
       transform: translate(-50%, -50%);
       width: 54%;
       height: 70vh; /* Adjust height dynamically */
       max-height: 70vh; 
       background: #2a2a2a;
       border: 1px solid #444;
       z-index: 1000;
       overflow: auto;
       transition: width 0.3s ease, left 0.3s ease, transform 0.3s ease;
    }

    .animator-container.visible {
        display: flex;
        width: 77%; 
        left: 23%; 
        transform: translate(0, -50%);
    }

    /* Layers Panel */
    .layers-panel {
        width: 180px;
        background-color: #383838;
        border-right: 1px solid #222;
        overflow-y: auto;
    }


    .layer-item {
        padding: 8px 12px;
        display: flex;
        align-items: center;
         cursor: pointer;
        user-select: none;
    }

    .layer-item:hover {
        background-color: #454545;
    }

    .layer-item.selected {
         background-color: #2C5D87;
    }

    .layer-icon {
        width: 16px;
        height: 16px;
        margin-right: 8px;
    }

    /* Graph Panel */
    .graph-panel {
        flex: 1;
        background-color: #2D2D2D;
        position: relative;
        overflow-x: auto;
        overflow-y: auto;
    }

    .grid {
        position: absolute;
        width: 100%;
        height: 100%;
        background-size: 20px 20px;
        background-image: 
        linear-gradient(to right, #333 1px, transparent 1px),
        linear-gradient(to bottom, #333 1px, transparent 1px);
    }

    .node {
        position: absolute;
        background-color: #4A4A4A;
        border: 1px solid #666;
        border-radius: 4px;
        padding: 10px;
        min-width: 120px;
         cursor: move;
         user-select: none;
    }

        .node.entry {
            background-color: #2C632C;
        }

        .node.exit {
            background-color: #633434;
        }

        .node-header {
            padding-bottom: 5px;
            border-bottom: 1px solid #555;
            margin-bottom: 5px;
        }

        .connection {
            position: absolute;
            pointer-events: none;
            z-index: 1;
        }

        .controls1 {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            gap: 5px;
        }

        .control-btn1 {
            background-color: #4A4A4A;
            border: none;
            color: white;
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 3px;
        }

        .control-btn1:hover {
            background-color: #555;
        }


        /* Parameters Panel */
        .parameters-panel {
            width: 200px;
            background-color: #383838;
            border-left: 1px solid #222;
            padding: 10px;
        }

        .parameter-group {
            margin-bottom: 15px;
        }

        .parameter-label {
            display: block;
            margin-bottom: 5px;
            color: #ccc;
        }

        .parameter-input {
            width: 100%;
            padding: 5px;
            background-color: #2D2D2D;
            border: 1px solid #444;
            color: white;
            border-radius: 3px;
        }
        </style>
        <script>
              document.getElementById("toggleAnimator").addEventListener("click", function() {
                document.querySelector(".animator-container").classList.toggle("visible");
             });
             class AnimationState {
    constructor(name, animation, transitions = []) {
        this.name = name;
        this.animation = animation;
        this.transitions = transitions;
        this.blendTime = 0.2; // Default blend duration
    }
}

class AnimationController {
    constructor(model) {
        this.model = model;
        this.mixer = new THREE.AnimationMixer(model);
        this.states = new Map();
        this.currentState = null;
    }

    addState(name, animation) {
        const state = new AnimationState(name, animation);
        this.states.set(name, state);
        return state;
    }

    transition(fromState, toState, duration) {
        const currentAction = this.mixer.clipAction(fromState.animation);
        const nextAction = this.mixer.clipAction(toState.animation);
        
        // Crossfade between animations
        currentAction.fadeOut(duration);
        nextAction.reset().fadeIn(duration).play();
        
        this.currentState = toState;
    }
}

class AnimatorInterface {
    constructor() {
        this.controllers = new Map();
        this.connections = new Map();
        this.parameters = new Map();
    }

    createController(model) {
        const controller = new AnimationController(model);
        this.controllers.set(model.uuid, controller);
        return controller;
    }

    addTransition(fromState, toState, conditions) {
        fromState.transitions.push({
            targetState: toState,
            conditions: conditions
        });
    }
}
              class AnimatorGraph {
            constructor() {
                this.nodes = new Map();
                this.connections = new Map();
                this.graphPanel = document.querySelector('.graph-panel');
                this.isDragging = false;
                this.selectedNode = null;
                this.offset = { x: 0, y: 0 };

                this.initializeEventListeners();
                this.createDefaultStates();
            }

            createDefaultStates() {
                // Create Entry state
                this.createNode('Entry', 100, 100, true);
                
                // Create default states
                this.createNode('Idle', 300, 100);
                this.createNode('Walking', 500, 100);
                this.createNode('Running', 700, 100);
                
                // Create connections
                this.createConnection('Entry', 'Idle');
                this.createConnection('Idle', 'Walking');
                this.createConnection('Walking', 'Running');
            }

            createNode(name, x, y, isEntry = false) {
                const node = document.createElement('div');
                node.className = `node ${isEntry ? 'entry' : ''}`;
                node.innerHTML = `
                    <div class="node-header">${name}</div>
                    <div class="node-content">
                        Speed: 1.0
                    </div>
                `;
                node.style.left = `${x}px`;
                node.style.top = `${y}px`;
                
                this.nodes.set(name, node);
                this.graphPanel.appendChild(node);
                
                return node;
            }

            createConnection(fromName, toName) {
                const connection = document.createElement('svg');
                connection.classList.add('connection');
                connection.setAttribute('width', '100%');
                connection.setAttribute('height', '100%');
                
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                line.setAttribute('stroke', '#666');
                line.setAttribute('stroke-width', '2');
                line.setAttribute('fill', 'none');
                
                connection.appendChild(line);
                this.graphPanel.appendChild(connection);
                
                this.connections.set(`${fromName}-${toName}`, {
                    element: connection,
                    line: line,
                    from: fromName,
                    to: toName
                });
                
                this.updateConnection(fromName, toName);
            }

            updateConnection(fromName, toName) {
                const connection = this.connections.get(`${fromName}-${toName}`);
                if (!connection) return;

                const fromNode = this.nodes.get(fromName);
                const toNode = this.nodes.get(toName);
                
                const fromRect = fromNode.getBoundingClientRect();
                const toRect = toNode.getBoundingClientRect();
                
                const x1 = fromRect.left + fromRect.width;
                const y1 = fromRect.top + fromRect.height / 2;
                const x2 = toRect.left;
                const y2 = toRect.top + toRect.height / 2;
                
                const path = `M ${x1} ${y1} C ${x1 + 50} ${y1}, ${x2 - 50} ${y2}, ${x2} ${y2}`;
                connection.line.setAttribute('d', path);
            }

            initializeEventListeners() {
                this.graphPanel.addEventListener('mousedown', (e) => {
                    if (e.target.classList.contains('node')) {
                        this.isDragging = true;
                        this.selectedNode = e.target;
                        const rect = this.selectedNode.getBoundingClientRect();
                        this.offset = {
                            x: e.clientX - rect.left,
                            y: e.clientY - rect.top
                        };
                    }
                });

                document.addEventListener('mousemove', (e) => {
                    if (this.isDragging && this.selectedNode) {
                        const x = e.clientX - this.offset.x;
                        const y = e.clientY - this.offset.y;
                        
                        this.selectedNode.style.left = `${x}px`;
                        this.selectedNode.style.top = `${y}px`;
                        
                        // Update connections
                        this.connections.forEach((connection, key) => {
                            if (key.includes(this.selectedNode.querySelector('.node-header').textContent)) {
                                this.updateConnection(connection.from, connection.to);
                            }
                        });
                    }
                });

                document.addEventListener('mouseup', () => {
                    this.isDragging = false;
                    this.selectedNode = null;
                });

                // Add State button
                document.getElementById('addState').addEventListener('click', () => {
                    const stateName = prompt('Enter state name:');
                    if (stateName) {
                        const x = Math.random() * 500 + 200;
                        const y = Math.random() * 300 + 100;
                        this.createNode(stateName, x, y);
                    }
                });
            }
        }

        // Initialize the animator
        const animator = new AnimatorGraph();
        </script>
         <!-- Timeline -->
         <div class="timeline">
            <div class="status-bar">
                <span id="fps">FPS: 60</span>
                <span id="objects">Objects: 0</span>
                <span id="triangles">Triangles: 0</span>

            </div>
            <div class="timeline-controls">
                <button class="tool-button" id="play">
                    <i class="fas fa-play"></i>
                </button>
                <button class="tool-button" id="pause">
                    <i class="fas fa-pause"></i>
                </button>
                <button class="tool-button" id="stop">
                    <i class="fas fa-stop"></i>
                </button>
                <span id="time-display">00:00:00</span>
                <div class="zoom-controls">
                    <button class="tool-button" id="zoom-out">-</button>
                    <button class="tool-button" id="zoom-in">+</button>
                </div>
            </div>
            <div class="timeline-track">
                <div class="timeline-scale"></div>
                <div class="timeline-content">
                    <div class="playhead"></div>
                </div>
            </div>
        </div>

    </div>

    <div class="node-editor">
        <div class="node-editor-header">
            <span>Node Editor</span>
            <button id="node-editor-close">×</button>
        </div>
        <div class="node-toolbar">
            <button class="toolbar-button" title="Add Object" data-type="object">O</button>
            <button class="toolbar-button" title="Add Physics" data-type="physics">P</button>
            <button class="toolbar-button" title="Add Effect" data-type="effect">E</button>
            <button class="toolbar-button" title="Add Material" data-type="material">M</button>
            <button class="toolbar-button" title="Add Transform" data-type="transform">T</button>
        </div>
        <div class="node-canvas" id="node-canvas"></div>
    </div>

    <div class="camera-preview" id="cameraPreview">
        <div class="preview-controls">
            <button id="minimizePreview"><i class="fas fa-window-minimize"></i></button>
            <button id="expandPreview"><i class="fas fa-expand-arrows-alt"></i></button>
        </div>
    </div>
    

    <!-- Context Menu -->
    <div class="context-menu" id="context-menu"> 
        <div class="context-menu-item" >Copy (Ctrl+C)</div>
        <div class="context-menu-item" >Paste (Ctrl+V)</div>
        <div class="context-menu-item">Delete (Del)</div>
        <div class="context-menu-item" >Duplicate (Ctrl+D)</div>
    </div>
   


    <div class="context-menu1" id="context-menu1">
        <div class="context-menu-item" data-action="delete">Delete Node</div>
        <div class="context-menu-item" data-action="duplicate">Duplicate Node</div>
    </div>

    <script>
        const toggleButton = document.getElementById('toggle-inspector');
        const inspectorPanel = document.getElementById('inspector-panel');
        const timeline1 = document.querySelector('.timeline');
        const nodeEditorExpend = document.querySelector('.node-editor');
        const animatorEditor = document.querySelector('.animator-container');
        const axisControls = document.querySelector('.axis-controls');
        const assetspanel = document.querySelector(".assets-panel");
        toggleButton.addEventListener('click', () => {
            const isInspectorOpen = !inspectorPanel.classList.contains('closed');
            
            inspectorPanel.classList.toggle('closed');
            
            if (isInspectorOpen) {
                // Expand timeline when inspector is closed
                timeline1.classList.add('expanded');
                nodeEditorExpend.classList.add('expanded');
                axisControls.classList.add('expanded');
                assetspanel.classList.add('expanded');
                animatorEditor.classList.add('expanded');
            } else {
                // Restore timeline size when inspector is open
                timeline1.classList.remove('expanded');
                nodeEditorExpend.classList.remove('expanded');
                axisControls.classList.remove('expanded');
                assetspanel.classList.remove('expanded');
                animatorEditor.classList.remove('expanded');
            }
        });
        
    </script>

    <script>
    class PhysicsManager {
    constructor(scene, world) {
        this.scene = scene;
        this.world = world;
        this.physicsBodies = new Map();
        this.forces = new Set();
        this.collisionGroups = {
            DEFAULT: 1,
            TERRAIN: 2,
            DYNAMIC_OBJECTS: 4,
            KINEMATIC: 8,
            WIND_AFFECTED: 16
        };
        
        this.materials = {
            default: new CANNON.Material({
                friction: 0.5,
                restitution: 0.3
            }),
            bouncy: new CANNON.Material({
                friction: 0.3,
                restitution: 0.8
            }),
            rough: new CANNON.Material({
                friction: 0.8,
                restitution: 0.1
            })
        };

        // Debug visualization settings
        this.debugMode = false;
        this.debugBodies = new Map();
    }

    initPhysicsWorld() {
        this.world.gravity.set(0, -9.81, 0);
        this.world.broadphase = new CANNON.SAPBroadphase(this.world);
        this.world.solver.iterations = 20;
        this.world.allowSleep = true;

        // Contact material behaviors
        Object.values(this.materials).forEach((mat1) => {
            Object.values(this.materials).forEach((mat2) => {
                const contact = new CANNON.ContactMaterial(mat1, mat2, {
                    friction: Math.min(mat1.friction, mat2.friction),
                    restitution: Math.max(mat1.restitution, mat2.restitution),
                    contactEquationStiffness: 1e7,
                    contactEquationRelaxation: 3
                });
                this.world.addContactMaterial(contact);
            });
        });

        // Ground plane setup
        const groundShape = new CANNON.Plane();
        const groundBody = new CANNON.Body({
            mass: 0,
            material: this.materials.default,
            shape: groundShape,
            collisionFilterGroup: this.collisionGroups.TERRAIN,
            collisionFilterMask: this.collisionGroups.DEFAULT | this.collisionGroups.DYNAMIC_OBJECTS
        });
        groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI/2);
        this.world.addBody(groundBody);

        return this;
    }

    addPhysicsToObject(object, options = {}) {
        const box = new THREE.Box3().setFromObject(object);
        const size = new THREE.Vector3();
        box.getSize(size);

        let shape;
        if (object.geometry instanceof THREE.BoxGeometry) {
            shape = new CANNON.Box(new CANNON.Vec3(size.x/2, size.y/2, size.z/2));
        } else if (object.geometry instanceof THREE.SphereGeometry) {
            shape = new CANNON.Sphere(object.geometry.parameters.radius);
        } else if (object.geometry instanceof THREE.CylinderGeometry) {
            shape = new CANNON.Cylinder(
                object.geometry.parameters.radiusTop,
                object.geometry.parameters.radiusBottom,
                object.geometry.parameters.height,
                object.geometry.parameters.radialSegments
            );
        } else {
            // Default to box if geometry type is unknown
            shape = new CANNON.Box(new CANNON.Vec3(size.x/2, size.y/2, size.z/2));
        }

        const bodyOptions = {
            mass: options.mass || 1,
            position: new CANNON.Vec3(object.position.x, object.position.y, object.position.z),
            shape: shape,
            material: this.materials[options.material] || this.materials.default,
            linearDamping: options.linearDamping || 0.1,
            angularDamping: options.angularDamping || 0.1,
            collisionFilterGroup: options.group || this.collisionGroups.DYNAMIC_OBJECTS,
            collisionFilterMask: options.mask || 
                (this.collisionGroups.DEFAULT | this.collisionGroups.TERRAIN | this.collisionGroups.DYNAMIC_OBJECTS)
        };

        const body = new CANNON.Body(bodyOptions);

        if (options.velocity) {
            body.velocity.copy(options.velocity);
        }

        if (options.angularVelocity) {
            body.angularVelocity.copy(options.angularVelocity);
        }

        this.world.addBody(body);
        this.physicsBodies.set(object, body);

        // Set up collision event listeners
        body.addEventListener("collide", (event) => {
            if (options.onCollide) {
                options.onCollide(event);
            }
            this.handleCollision(event, object);
        });

        object.userData.physics = {
            enabled: true,
            body: body
        };

        return body;
    }

    handleCollision(event, object) {
        const impact = event.contact.getImpactVelocityAlongNormal();
        
        // Visual feedback for collision
        if (Math.abs(impact) > 5) {
            this.createCollisionEffect(event.contact.bi.position);
        }

        // Sound feedback could be added here
        if (Math.abs(impact) > 3) {
            // Play collision sound based on impact force
        }
    }

    createCollisionEffect(position) {
        const particles = new THREE.Points(
            new THREE.BufferGeometry(),
            new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.1,
                transparent: true,
                opacity: 0.8
            })
        );

        const particleCount = 20;
        const positions = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount * 3; i += 3) {
            const offset = new THREE.Vector3(
                (Math.random() - 0.5) * 0.5,
                (Math.random() - 0.5) * 0.5,
                (Math.random() - 0.5) * 0.5
            );
            positions[i] = position.x + offset.x;
            positions[i + 1] = position.y + offset.y;
            positions[i + 2] = position.z + offset.z;
        }

        particles.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        this.scene.add(particles);

        // Animate and remove particles
        const startTime = Date.now();
        const animate = () => {
            const elapsed = Date.now() - startTime;
            if (elapsed > 1000) {
                this.scene.remove(particles);
                return;
            }

            const positions = particles.geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                positions[i + 1] += 0.01; // Move particles upward
            }
            particles.geometry.attributes.position.needsUpdate = true;
            particles.material.opacity = 1 - (elapsed / 1000);

            requestAnimationFrame(animate);
        };
        animate();
    }

    createWindZone(position, direction, strength, radius) {
        const windForce = {
            type: 'wind',
            position: position.clone(),
            direction: direction.normalize(),
            strength: strength,
            radius: radius,
            apply: (body) => {
                // Calculate distance to body
                const distance = position.distanceTo(body.position);
                
                if (distance <= radius) {
                    // Scale force based on distance from center
                    const forceMagnitude = strength * (1 - distance / radius);
                    const force = direction.clone().multiplyScalar(forceMagnitude);
                    
                    // Apply force to physics body
                    body.applyForce(
                        new CANNON.Vec3(force.x, force.y, force.z),
                        body.position
                    );
                }
            }
        };
        this.forces.push(windForce);
        return windForce;
    }

    createVortexZone(position, axis, strength, radius) {
        const vortexForce = {
            type: 'vortex',
            position: position.clone(),
            axis: axis.normalize(),
            strength: strength,
            radius: radius,
            apply: (body) => {
                const bodyPos = new THREE.Vector3(
                    body.position.x,
                    body.position.y,
                    body.position.z
                );
                
                const distance = position.distanceTo(bodyPos);
                
                if (distance <= radius) {
                    // Calculate tangential direction for vortex
                    const toCenter = bodyPos.clone().sub(position);
                    const tangent = toCenter.cross(axis).normalize();
                    
                    // Scale force based on distance
                    const forceMagnitude = strength * (distance / radius);
                    const force = tangent.multiplyScalar(forceMagnitude);
                    
                    body.applyForce(
                        new CANNON.Vec3(force.x, force.y, force.z),
                        body.position
                    );
                }
            }
        };
        this.forces.push(vortexForce);
        return vortexForce;
    }

    applyForces(bodies) {
        this.forces.forEach(force => {
            bodies.forEach(body => force.apply(body));
        });
    }

  
    updatePhysics() {
        // Apply forces before stepping the world
        for (const force of this.forces) {
            for (const body of this.world.bodies) {
                if (body.mass > 0) { // Only apply to non-static bodies
                    force.apply(body);
                }
            }
        }
        this.physicsBodies.forEach((body) => {
            this.forces.forEach(force => {
                if (force.active && body.mass > 0) {
                    force.apply(body);
                }
            });
        });

        this.world.step(1/60);

        // Update object positions
        this.physicsBodies.forEach((body, object) => {
            object.position.copy(body.position);
            object.quaternion.copy(body.quaternion);
        });
    }
  
}




function createWindZoneVisual(position, radius, strength) {
    const group = new THREE.Group();
    
    // Main cylinder with improved visibility
    const cylinderGeometry = new THREE.CylinderGeometry(radius, radius, radius * 2, 32, 1, true);
    const cylinderMaterial = new THREE.MeshBasicMaterial({
        color: 0x00ff88,
        transparent: true,
        opacity: 0.2,
        wireframe: true,
        side: THREE.DoubleSide
    });
    const cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
    
    // Direction arrows
    const arrowCount = 8;
    const arrowGroup = new THREE.Group();
    for (let i = 0; i < arrowCount; i++) {
        const arrowHelper = new THREE.ArrowHelper(
            new THREE.Vector3(1, 0, 0),
            new THREE.Vector3(0, 0, 0),
            radius * 0.8,
            0x00ff88,
            radius * 0.2,
            radius * 0.1
        );
        arrowHelper.position.y = (Math.random() - 0.5) * radius;
        arrowHelper.position.z = (Math.random() - 0.5) * radius;
        arrowGroup.add(arrowHelper);
    }

    // Particle system for wind visualization
    const particleCount = 100;
    const particleGeometry = new THREE.BufferGeometry();
    const particlePositions = new Float32Array(particleCount * 3);
    const particleSizes = new Float32Array(particleCount);
    
    for (let i = 0; i < particleCount; i++) {
        const x = (Math.random() - 0.5) * radius * 2;
        const y = (Math.random() - 0.5) * radius * 2;
        const z = (Math.random() - 0.5) * radius * 2;
        
        particlePositions[i * 3] = x;
        particlePositions[i * 3 + 1] = y;
        particlePositions[i * 3 + 2] = z;
        particleSizes[i] = Math.random() * 0.2 + 0.1;
    }
    
    particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
    particleGeometry.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));
    
    const particleMaterial = new THREE.PointsMaterial({
        color: 0x00ff88,
        size: 0.1,
        transparent: true,
        opacity: 0.6,
        sizeAttenuation: true
    });
    
    const particles = new THREE.Points(particleGeometry, particleMaterial);
    
    group.add(cylinder);
    group.add(arrowGroup);
    group.add(particles);
    group.position.copy(position);
    addObjectToScene(group, 'Wind Zone');
    // Animation
    let time = 0;
    group.animate = () => {
        time += 0.016 * strength;
        
        // Animate particles
        const positions = particles.geometry.attributes.position.array;
        for (let i = 0; i < particleCount; i++) {
            positions[i * 3] += 0.1 * strength;
            if (positions[i * 3] > radius) {
                positions[i * 3] = -radius;
            }
        }
        particles.geometry.attributes.position.needsUpdate = true;
        
        // Rotate arrows
        arrowGroup.children.forEach((arrow, i) => {
            arrow.position.x = Math.sin(time + i) * radius * 0.2;
        });
        
        // Pulse cylinder
        cylinder.scale.x = 1 + Math.sin(time) * 0.1;
        cylinder.scale.z = 1 + Math.sin(time) * 0.1;
    };

    return group;
}

function createVortexVisual(position, radius, strength) {
    const group = new THREE.Group();

    // Main torus
    const torusGeometry = new THREE.TorusGeometry(radius * 0.7, radius * 0.05, 16, 100);
    const torusMaterial = new THREE.MeshBasicMaterial({
        color: 0x3F51B5,
        transparent: true,
        opacity: 0.5,
        wireframe: true
    });
    const torus = new THREE.Mesh(torusGeometry, torusMaterial);

    // Spiral lines
    const spiralCount = 3;
    const pointsPerSpiral = 100;
    const spiralGroup = new THREE.Group();
    
    for (let s = 0; s < spiralCount; s++) {
        const spiralPoints = [];
        const angleOffset = (s * Math.PI * 2) / spiralCount;
        
        for (let i = 0; i < pointsPerSpiral; i++) {
            const t = i / (pointsPerSpiral - 1);
            const angle = t * Math.PI * 4 + angleOffset;
            const radiusAt = radius * (0.2 + t * 0.8);
            
            spiralPoints.push(new THREE.Vector3(
                radiusAt * Math.cos(angle),
                t * radius * 2 - radius,
                radiusAt * Math.sin(angle)
            ));
        }
        
        const spiralGeometry = new THREE.BufferGeometry().setFromPoints(spiralPoints);
        const spiralMaterial = new THREE.LineBasicMaterial({
            color: 0x5C6BC0,
            transparent: true,
            opacity: 0.7
        });
        const spiralLine = new THREE.Line(spiralGeometry, spiralMaterial);
        spiralGroup.add(spiralLine);
    }

    // Particle system
    const particleCount = 300;
    const particleGeometry = new THREE.BufferGeometry();
    const particlePositions = new Float32Array(particleCount * 3);
    const particleData = [];
    
    for (let i = 0; i < particleCount; i++) {
        const angle = Math.random() * Math.PI * 2;
        const radiusAt = radius * (0.2 + Math.random() * 0.8);
        const height = (Math.random() - 0.5) * radius * 2;
        
        particlePositions[i * 3] = Math.cos(angle) * radiusAt;
        particlePositions[i * 3 + 1] = height;
        particlePositions[i * 3 + 2] = Math.sin(angle) * radiusAt;
        
        particleData.push({
            angle,
            radius: radiusAt,
            height,
            speed: (0.5 + Math.random() * 0.5) * strength
        });
    }
    
    particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
    
    const particleMaterial = new THREE.PointsMaterial({
        color: 0x5C6BC0,
        size: 0.1,
        transparent: true,
        opacity: 0.8
    });
    
    const particles = new THREE.Points(particleGeometry, particleMaterial);

    group.add(torus);
    group.add(spiralGroup);
    group.add(particles);
    group.position.copy(position);
    addObjectToScene(group, 'Vortex Wind');
    // Animation
    let time = 0;
    group.animate = () => {
        time += 0.016 * strength;
        
        // Rotate torus
        torus.rotation.y += 0.02 * strength;
        
        // Rotate spiral lines
        spiralGroup.rotation.y += 0.01 * strength;
        
        // Animate particles
        const positions = particles.geometry.attributes.position.array;
        for (let i = 0; i < particleCount; i++) {
            const data = particleData[i];
            data.angle += data.speed * 0.02;
            
            positions[i * 3] = Math.cos(data.angle) * data.radius;
            positions[i * 3 + 1] = data.height + Math.sin(time + i) * 0.1;
            positions[i * 3 + 2] = Math.sin(data.angle) * data.radius;
        }
        particles.geometry.attributes.position.needsUpdate = true;
    };

    return group;
}
        
        function addDemonstrationObjects() {
            // Add some boxes and spheres with different materials
            for (let i = 0; i < 5; i++) {
                const size = 1 + Math.random() * 0.5;
                const geometry = Math.random() > 0.5 ? 
                    new THREE.BoxGeometry(size, size, size) :
                    new THREE.SphereGeometry(size/2, 16, 16);
                
                const material = new THREE.MeshStandardMaterial({
                    color: new THREE.Color().setHSL(Math.random(), 0.7, 0.5),
                    roughness: 0.7,
                    metalness: 0.3
                });

                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(
                    (Math.random() - 0.5) * 10,
                    5 + i * 2,
                    (Math.random() - 0.5) * 10
                );
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                addObjectToScene(mesh, 'Physic demostration shapes')

                scene.add(mesh);
                physicsManager.addPhysicsToObject(mesh, {
                    mass: 1,
                    friction: 0.9,
                    restitution: 0.7
                });
            }
        }

       
        function initPhysics() {
           world = new CANNON.World();
           world.gravity.set(0, -9.81, 0); // Apply gravity

           physicsManager = new PhysicsManager(scene, world).initPhysicsWorld();

           // Create a static floor for physics
            const floorShape = new CANNON.Plane();
            const floorBody = new CANNON.Body({
               mass: 0, // Static object (does not move)
               shape: floorShape,
               position: new CANNON.Vec3(0, 0, 0),
               quaternion: new CANNON.Quaternion().setFromEuler(-Math.PI / 2, 0, 0),
            });

            world.addBody(floorBody);

            // visual plane for the floor
            const floorGeometry = new THREE.PlaneGeometry(1000, 1000);
            const floorMaterial = new THREE.MeshStandardMaterial({
               color: 0xffffff,
               transparent: true,
               opacity: 0,
               side: THREE.DoubleSide,
            });
            const floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
            floorMesh.rotation.x = -Math.PI / 2;
            floorMesh.receiveShadow = true;

            scene.add(floorMesh);



            //Listeners
            document.getElementById('gravity-strength').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                world.gravity.set(0, value, 0); // ✅ Update gravity dynamically
                document.getElementById('gravity-value').textContent = value.toFixed(2);
            });

             // Apply Wind
             document.getElementById('add-wind').addEventListener('click', () => {
               const strength = parseFloat(document.getElementById('wind-strength').value);
               const radius = parseFloat(document.getElementById('wind-radius').value);
               const position = controls.target.clone();
               const direction = new THREE.Vector3(1, 0, 0);
    
               const windVisual = createWindZoneVisual(position, radius, strength);
               scene.add(windVisual);
    
               const windForce = physicsManager.createWindZone(position, direction, strength, radius);
               windForce.visual = windVisual;
            });

            // Apply Vortex
            document.getElementById('add-vortex').addEventListener('click', () => {
                const strength = parseFloat(document.getElementById('wind-strength').value);
                const radius = parseFloat(document.getElementById('wind-radius').value);
                const position = controls.target.clone();
                const axis = new THREE.Vector3(0, 1, 0);
    
                const vortexVisual = createVortexVisual(position, radius, strength);
                scene.add(vortexVisual);
    
                const vortexForce = physicsManager.createVortexZone(position, axis, strength, radius);
                vortexForce.visual = vortexVisual;
            });



    }

        
    </script>
 <script>
    // Character Sculpting Constants and State
    const CHARACTER_TOOLS = {
       FACE_SHAPE: 'faceShape',
       NOSE_SCULPT: 'noseSculpt',
       CHEEK_DEFINITION: 'cheekDefinition',
       JAW_SCULPT: 'jawSculpt',
       FOREHEAD_SHAPE: 'foreheadShape',
       CHIN_SCULPT: 'chinSculpt',
       TEMPLE_SCULPT: 'templeSculpt',
       BROW_RIDGE: 'browRidge',
       EYE_SOCKET: 'eyeSocket',
       LIP_SHAPE: 'lipShape',
       SMOOTH: 'smooth',
       PINCH: 'pinch',
       INFLATE: 'inflate',
       CREASE: 'crease',
       SNAKE_HOOK: 'snakeHook',
       HAIR_BRUSH: 'hairBrush'
   };
   


const hairBrushSettings = {
    numSegments: 20,
    segmentLength: 0.001,
    stiffness: 0.8,
    gravity: 0.9,
    windStrength: 0.6,
    turbulence: 0.2,
    springStiffness: 0.8,
    damping: 0.3,
    airResistance: 0.02,
    thickness: 0.01,
    density: 10,
    curl: 0.2,
    randomness: 0.1,
    clumpSize: 3,
    frizz: 0.1,
    wave: 0.2,
    hairStrands: new Set(),
    guides: [],
    materialType: 'standard', // or 'advanced'
    hairColor: 0x3a1a00,
    specularColor: 0x8B4513
};



class HairStrand {
    constructor(rootPosition, normal) {
        this.segments = [];
        this.initialDirection = normal.clone();
        this.springConstant = 0.8;
        this.damping = 0.3;
        this.airResistance = 0.02;
        
        let currentPos = rootPosition.clone();
        
        // Enhanced segment initialization with natural curl patterns
        for (let i = 0; i < hairBrushSettings.numSegments; i++) {
            // Improved natural wave and curl calculation
            const t = i / hairBrushSettings.numSegments;
            const wave = Math.sin(i * hairBrushSettings.wave * Math.PI) * hairBrushSettings.curl;
            const spiral = new THREE.Vector3(
                Math.cos(t * 2 * Math.PI * hairBrushSettings.curl),
                Math.sin(t * 2 * Math.PI * hairBrushSettings.curl),
                0
            ).multiplyScalar(hairBrushSettings.curl * 0.1);

            const offset = new THREE.Vector3(
                Math.sin(i + wave) * hairBrushSettings.randomness,
                Math.cos(i + wave) * hairBrushSettings.randomness,
                Math.sin((i + wave) * 0.5) * hairBrushSettings.randomness
            ).add(spiral);

            // Enhanced frizz with natural variation
            const frizzScale = Math.pow(t, 0.5); // More frizz towards the ends
            const frizz = new THREE.Vector3(
                (Math.random() - 0.5) * hairBrushSettings.frizz * frizzScale,
                (Math.random() - 0.5) * hairBrushSettings.frizz * frizzScale,
                (Math.random() - 0.5) * hairBrushSettings.frizz * frizzScale
            );

            this.segments.push({
                position: currentPos.clone(),
                prevPosition: currentPos.clone(),
                velocity: new THREE.Vector3(),
                force: new THREE.Vector3(),
                mass: 1 - (t * 0.5), // Lighter towards the ends
                locked: i === 0,
                normal: normal.clone()
            });

            // Calculate next position with improved natural flow
            const direction = normal.clone()
                .add(offset)
                .add(frizz)
                .normalize()
                .multiplyScalar(hairBrushSettings.segmentLength * (1 - t * 0.2)); // Slight taper
                
            currentPos.add(direction);
        }
        
        this.createGeometry();
    }


    createGeometry() {
        const points = this.segments.map(seg => seg.position);
        const curve = new THREE.CatmullRomCurve3(points);
        
        // Create tapered hair strands
        const radiusPoints = hairBrushSettings.numSegments * 2;
        const segments = [];
        
        for (let i = 0; i <= radiusPoints; i++) {
            const t = i / radiusPoints;
            const radius = hairBrushSettings.thickness * (1 - t * 0.5);
            segments.push(radius);
        }

        const tubeGeometry = new THREE.TubeGeometry(
            curve,
            radiusPoints,
            segments[0],
            8,
            false
        );

        // Enhanced hair material
        const material = new THREE.MeshPhysicalMaterial({
            color: hairBrushSettings.hairColor,
            roughness: 0.3,
            metalness: 0.2,
            clearcoat: 0.4,
            clearcoatRoughness: 0.25,
            sheen: 1.0,
            sheenRoughness: 0.3,
            sheenColor: hairBrushSettings.specularColor
        });

        if (this.mesh) {
            this.mesh.geometry.dispose();
            this.mesh.geometry = tubeGeometry;
        } else {
            this.mesh = new THREE.Mesh(tubeGeometry, material);
            sculptingSphere.add(this.mesh);
        }
    }

    update(deltaTime) {
        // Enhanced physics simulation
        const gravity = new THREE.Vector3(0, -9.81, 0);
        const wind = new THREE.Vector3(
            Math.sin(Date.now() * 0.001) * 0.5,
            Math.cos(Date.now() * 0.002) * 0.3,
            Math.sin(Date.now() * 0.0015) * 0.4
        );

        for (let i = 1; i < this.segments.length; i++) {
            const segment = this.segments[i];
            if (!segment.locked) {
                // Reset forces
                segment.force.set(0, 0, 0);
                
                // Apply gravity
                segment.force.add(gravity.multiplyScalar(segment.mass));
                
                // Apply wind with turbulence
                const turbulence = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.2,
                    (Math.random() - 0.5) * 0.2,
                    (Math.random() - 0.5) * 0.2
                );
                segment.force.add(wind.clone().add(turbulence));
                
                // Spring forces between segments
                const prevSeg = this.segments[i - 1];
                const toNext = segment.position.clone().sub(prevSeg.position);
                const dist = toNext.length();
                const springForce = toNext.normalize().multiplyScalar(
                    (dist - hairBrushSettings.segmentLength) * -this.springConstant
                );
                segment.force.add(springForce);
                
                // Air resistance
                const airResistance = segment.velocity.clone().multiplyScalar(-this.airResistance);
                segment.force.add(airResistance);
                
                // Verlet integration
                const acceleration = segment.force.multiplyScalar(1 / segment.mass);
                segment.velocity.add(acceleration.multiplyScalar(deltaTime));
                segment.velocity.multiplyScalar(1 - this.damping);
                
                const newPosition = segment.position.clone()
                    .add(segment.velocity.multiplyScalar(deltaTime));
                
                segment.prevPosition.copy(segment.position);
                segment.position.copy(newPosition);
            }
        }
        
        this.applyConstraints();
        this.createGeometry();
    }

    applyConstraints() {
        for (let i = 0; i < this.segments.length - 1; i++) {
            const segA = this.segments[i];
            const segB = this.segments[i + 1];
            const diff = segB.position.clone().sub(segA.position);
            const currentLength = diff.length();
            const correction = diff.multiplyScalar(
                (hairBrushSettings.segmentLength - currentLength) / currentLength
            );
            
            if (!segA.locked) segA.position.sub(correction.multiplyScalar(0.5));
            if (!segB.locked) segB.position.add(correction.multiplyScalar(0.5));
        }
    }
}

function applyHairBrush(event, vertices, position, normal) {
    if (event.buttons !== 1) return;
    
    // Create hair strands with improved distribution
    const angleStep = (Math.PI * 2) / hairBrushSettings.density;
    const radius = characterBrushSize * 0.2;
    
    for (let i = 0; i < hairBrushSettings.density; i++) {
        const angle = angleStep * i;
        
        // Create spiral distribution for more natural look
        const spiralRadius = radius * (i / hairBrushSettings.density);
        const offset = new THREE.Vector3(
            Math.cos(angle) * spiralRadius,
            Math.sin(angle) * spiralRadius,
            0
        );
        
        // Add random variation to strand placement
        offset.add(new THREE.Vector3(
            (Math.random() - 0.5) * radius * 0.2,
            (Math.random() - 0.5) * radius * 0.2,
            (Math.random() - 0.5) * radius * 0.2
        ));
        
        const strand = new HairStrand(
            position.clone().add(offset),
            normal.clone()
        );
        hairBrushSettings.hairStrands.add(strand);
    }
}


   let selectedCharacterTool = null;
   let isCharacterSculpting = false;
   let characterBrushSize = 0.2;
   let characterBrushStrength = 0.1;
   let sculptingSphere = null;
   let characterUndoStack = [];
   let characterRedoStack = [];
   
   function addSculptingSphere() {
    const geometry = new THREE.SphereGeometry(1, 256, 256); // Higher detail for better sculpting
    const material = new THREE.MeshStandardMaterial({
        color: 0xF5DEB3,
        roughness: 0.4,
        metalness: 0.6,
        flatShading: false,
        emissive: 0x331A00,
        emissiveIntensity: 0.1,
    });

    sculptingSphere = new THREE.Mesh(geometry, material);
    sculptingSphere.name = 'SculptingSphere';
    sculptingSphere.castShadow = true;
    sculptingSphere.receiveShadow = true;

    scene.add(sculptingSphere);
    addObjectToScene(sculptingSphere, 'SculptingSphere');
    createCharacterBrushPreview();
    setupCharacterSculptingEvents();

    return sculptingSphere;
}





function createCharacterBrushPreview() {
    if (window.characterBrushPreview) {
        scene.remove(window.characterBrushPreview);
    }

    const brushPreview = new THREE.Group();

    // Inner Core Sphere for Depth
    const innerSphereGeometry = new THREE.SphereGeometry(characterBrushSize * 0.25, 32, 32);
    const innerSphereMaterial = new THREE.MeshBasicMaterial({
        color: 0x00FFFF,
        transparent: true,
        opacity: 0.5,
        depthTest: false
    });
    const innerSphere = new THREE.Mesh(innerSphereGeometry, innerSphereMaterial);

    // Main Brush Ring (Outer Ring)
    const mainRingGeometry = new THREE.RingGeometry(
        characterBrushSize * 0.7,
        characterBrushSize * 1,
        64
    );
    const mainRingMaterial = new THREE.MeshBasicMaterial({
        color: 0xFF4500,
        transparent: true,
        opacity: 0.6,
        side: THREE.DoubleSide,
        depthTest: false
    });
    const mainRing = new THREE.Mesh(mainRingGeometry, mainRingMaterial);

    // Animated Glow Ring for Dynamic Effect
    const glowRingGeometry = new THREE.RingGeometry(
        characterBrushSize * 0.9,
        characterBrushSize * 1.3,
        64
    );
    const glowRingMaterial = new THREE.ShaderMaterial({
        uniforms: {
            time: { value: 0 },
            color: { value: new THREE.Color(0xFFD700) }
        },
        vertexShader: `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            uniform float time;
            uniform vec3 color;
            varying vec2 vUv;
            void main() {
                float glow = 0.5 + 0.5 * sin(time + vUv.x * 3.1416);
                gl_FragColor = vec4(color * glow, 0.4);
            }
        `,
        transparent: true,
        depthTest: false
    });
    const glowRing = new THREE.Mesh(glowRingGeometry, glowRingMaterial);

    // Add all components to the brush preview group
    brushPreview.add(innerSphere);
    brushPreview.add(mainRing);
    brushPreview.add(glowRing);
    brushPreview.visible = false;

    window.characterBrushPreview = brushPreview;
    scene.add(brushPreview);

    // Animate glow ring
    animateBrushGlow(glowRingMaterial);
}

function animateBrushGlow(material) {
    function animate() {
        material.uniforms.time.value += 0.05;
        requestAnimationFrame(animate);
    }
    animate();
}


function updateCharacterBrushPreview(event) {
if (!sculptingSphere || !window.characterBrushPreview) return;

const mouse = new THREE.Vector2(
   (event.clientX / window.innerWidth) * 2 - 1,
   -(event.clientY / window.innerHeight) * 2 + 1
);

const raycaster = new THREE.Raycaster();
raycaster.setFromCamera(mouse, camera);
const intersects = raycaster.intersectObject(sculptingSphere);

if (intersects.length > 0) {
   const intersect = intersects[0];
   const point = intersect.point;
   const normal = intersect.face.normal;

   window.characterBrushPreview.position.copy(point);
   window.characterBrushPreview.lookAt(point.clone().add(normal));
   window.characterBrushPreview.visible = true;

   // Update brush color and opacity dynamically based on sculpting state
   const color = isCharacterSculpting ? 0xFF4A4A : 0x4A90E2;
   const opacity = isCharacterSculpting ? 0.7 : 0.4;
   
   window.characterBrushPreview.children.forEach(child => {
       if (child.material) {
           child.material.color.setHex(color);
           child.material.opacity = opacity;
       }
   });
} else {
   window.characterBrushPreview.visible = false;
}
}

let isDragging = false;
let isDraggingSc = false;
let previousMousePosition = new THREE.Vector2();
let grabStartPosition = new THREE.Vector3();
let affectedVertices = new Set();
let lastUpdateTime = 0;
const UPDATE_INTERVAL = 16; 


function applySnakeHookTool(event, vertices, position, normal) {
    const direction = new THREE.Vector3();
    direction.copy(normal).multiplyScalar(characterBrushStrength * 0.1);

    if (event.shiftKey) {
        direction.negate();
    }

    for (let i = 0; i < vertices.count; i++) {
        const vertex = new THREE.Vector3();
        vertex.fromBufferAttribute(vertices, i);
        
        const distance = vertex.distanceTo(position);
        if (distance < characterBrushSize) {
            const influence = Math.pow(1 - distance / characterBrushSize, 2);
            
            // Calculate twist effect
            const twist = new THREE.Vector3()
                .crossVectors(normal, new THREE.Vector3(0, 1, 0))
                .multiplyScalar(influence * 0.5);
            
            vertex.add(direction.clone().multiplyScalar(influence))
                 .add(twist);
            
            vertices.setXYZ(i, vertex.x, vertex.y, vertex.z);
        }
    }
}




let characterBrushFalloff = 0.5; 

function applyCharacterSculpting(event) {
    if (!isCharacterSculpting || !selectedCharacterTool || !sculptingSphere) return;
   
       const mouse = new THREE.Vector2(
           (event.clientX / window.innerWidth) * 2 - 1,
           -(event.clientY / window.innerHeight) * 2 + 1
       );
   
       const raycaster = new THREE.Raycaster();
       raycaster.setFromCamera(mouse, camera);
       const intersects = raycaster.intersectObject(sculptingSphere);
   
       if (intersects.length > 0) {
           // Save state for undo
           saveCharacterState();
   
           const intersect = intersects[0];
           const position = intersect.point;
           const normal = intersect.face.normal.clone();
           const vertices = sculptingSphere.geometry.attributes.position;
   
           for (let i = 0; i < vertices.count; i++) {
               const vertex = new THREE.Vector3();
               vertex.fromBufferAttribute(vertices, i);
               
               const distance = vertex.distanceTo(position);
               if (distance < characterBrushSize) {
                   const influence = Math.pow(1 - distance / characterBrushSize, 2);
                   const direction = event.buttons === 1 ? 1 : -1;
   
                   switch (selectedCharacterTool) {
                       case CHARACTER_TOOLS.FACE_SHAPE:
                           vertex.add(normal.clone().multiplyScalar(characterBrushStrength * influence * direction));
                           break;
                           
                       case CHARACTER_TOOLS.NOSE_SCULPT:
                           const noseVector = normal.clone().multiply(new THREE.Vector3(1.5, 1, 1));
                           vertex.add(noseVector.multiplyScalar(characterBrushStrength * influence * direction));
                           break;
                           
                       case CHARACTER_TOOLS.CHEEK_DEFINITION:
                           const cheekVector = new THREE.Vector3(normal.x, 0, normal.z);
                           vertex.add(cheekVector.multiplyScalar(characterBrushStrength * influence * direction));
                           break;
                           
                       case CHARACTER_TOOLS.JAW_SCULPT:
                           const jawVector = new THREE.Vector3(normal.x * 0.5, -normal.y, normal.z);
                           vertex.add(jawVector.multiplyScalar(characterBrushStrength * influence * direction));
                           break;
                           
                       case CHARACTER_TOOLS.FOREHEAD_SHAPE:
                           const foreheadVector = new THREE.Vector3(0, normal.y, normal.z * 0.5);
                           vertex.add(foreheadVector.multiplyScalar(characterBrushStrength * influence * direction));
                           break;
                       case CHARACTER_TOOLS.CHIN_SCULPT:
                           vertex.add(normal.clone().multiplyScalar(characterBrushStrength * influence * direction));
                            break;
                        case CHARACTER_TOOLS.TEMPLE_SCULPT:
                          const templeVector = new THREE.Vector3(normal.x * 0.5, normal.y, 0);
                           vertex.add(templeVector.multiplyScalar(characterBrushStrength * influence * direction));
                          break;
                        case CHARACTER_TOOLS.BROW_RIDGE:
                   const browVector = new THREE.Vector3(normal.x, normal.y * 0.5, 0);
                   vertex.add(browVector.multiplyScalar(characterBrushStrength * influence * direction));
                   break;
               case CHARACTER_TOOLS.EYE_SOCKET:
                   const socketVector = normal.clone().multiplyScalar(-0.3);
                   vertex.add(socketVector.multiplyScalar(characterBrushStrength * influence * direction));
                   break;
               case CHARACTER_TOOLS.LIP_SHAPE:
                   const lipVector = new THREE.Vector3(normal.x * 0.8, 0, normal.z);
                   vertex.add(lipVector.multiplyScalar(characterBrushStrength * influence * direction));
                   break;
               case CHARACTER_TOOLS.SMOOTH:
                   vertex.lerp(position, 0.2 * influence);
                   break;
               case CHARACTER_TOOLS.PINCH:
                   vertex.lerp(position, -0.1 * influence);
                   break;
               case CHARACTER_TOOLS.INFLATE:
                   vertex.add(normal.clone().multiplyScalar(characterBrushStrength * influence * direction * 1.5));
                   break;
               case CHARACTER_TOOLS.CREASE:
                   vertex.add(normal.clone().multiplyScalar(characterBrushStrength * influence * direction * -1.2));
                   break;
                    case CHARACTER_TOOLS.SNAKE_HOOK:
                        applySnakeHookTool(event, vertices, position, normal);
                        break;
                    case CHARACTER_TOOLS.HAIR_BRUSH:
                        applyHairBrush(event, vertices, position, normal);
                        break;

                }
                 
   
                   vertices.setXYZ(i, vertex.x, vertex.y, vertex.z);
               }
           }
   
           vertices.needsUpdate = true;
           sculptingSphere.geometry.computeVertexNormals();
       }
   }
   

   function updateHairPhysics() {
    hairBrushSettings.hairStrands.forEach(strand => {
        strand.update();
    });
    requestAnimationFrame(updateHairPhysics);
}

// Initialize hair brush controls
function setupHairBrushControls() {
    const hairControls = document.createElement('div');
 

    document.querySelector('.character-sclupting').appendChild(hairControls);
   
    document.getElementById('hairSegments').addEventListener('input', (e) => {
        hairBrushSettings.numSegments = parseInt(e.target.value);
    });
    document.getElementById('hairLength').addEventListener('input', (e) => {
        hairBrushSettings.segmentLength = parseFloat(e.target.value);
    });
    document.getElementById('hairDensity').addEventListener('input', (e) => {
        hairBrushSettings.density = parseInt(e.target.value);
    });
    document.getElementById('hairCurl').addEventListener('input', (e) => {
        hairBrushSettings.curl = parseFloat(e.target.value);
    });
    document.getElementById('hairStiffness').addEventListener('input', (e) => {
        hairBrushSettings.stiffness = parseFloat(e.target.value);
    });

    document.getElementById('hairWave').addEventListener('input', (e) => {
        hairBrushSettings.wave = parseFloat(e.target.value);
    });
    
    document.getElementById('hairFrizz').addEventListener('input', (e) => {
        hairBrushSettings.frizz = parseFloat(e.target.value);
    });
    
    document.getElementById('hairClumpSize').addEventListener('input', (e) => {
        hairBrushSettings.clumpSize = parseInt(e.target.value);
    });
}

   function saveCharacterState() {
       const positions = sculptingSphere.geometry.attributes.position.array.slice();
       characterUndoStack.push(positions);
       characterRedoStack.length = 0;
   
       if (characterUndoStack.length > 50) {
           characterUndoStack.shift();
       }
   }

    

function setupCharacterSculptingEvents() {
// Tool selection
Object.values(CHARACTER_TOOLS).forEach(tool => {
   const button = document.getElementById(tool);
   if (button) {
       button.addEventListener('click', () => {
           selectedCharacterTool = tool;
           document.querySelectorAll('.panel-button').forEach(btn => btn.classList.remove('active'));
           button.classList.add('active');
       });
   }
});

// Mouse events for sculpting
renderer.domElement.addEventListener('mousemove', (event) => {
   updateCharacterBrushPreview(event);
   if (isCharacterSculpting) applyCharacterSculpting(event);
});



renderer.domElement.addEventListener('mousedown', (event) => {
   if (selectedCharacterTool) {
       isCharacterSculpting = true;
       applyCharacterSculpting(event);
   }
});


renderer.domElement.addEventListener('mouseup', () => isCharacterSculpting = false);
renderer.domElement.addEventListener('mouseleave', () => {
   isCharacterSculpting = false;
   if (window.characterBrushPreview) window.characterBrushPreview.visible = false;
});

// Create brush controls
const controlsContainer = document.createElement('div');
controlsContainer.classList.add('brush-controls');

const sizeLabel = document.createElement('label');
sizeLabel.innerHTML = `Brush Size: <span id="sizeValue">${characterBrushSize.toFixed(2)}</span>`;
const brushSizeInput = document.createElement('input');
brushSizeInput.type = 'range';
brushSizeInput.min = '0.05';
brushSizeInput.max = '0.5';
brushSizeInput.step = '0.01';
brushSizeInput.value = characterBrushSize;
brushSizeInput.addEventListener('input', (e) => {
   characterBrushSize = parseFloat(e.target.value);
   document.getElementById('sizeValue').textContent = characterBrushSize.toFixed(2);
   createCharacterBrushPreview();
});

const strengthLabel = document.createElement('label');
strengthLabel.innerHTML = `Brush Strength: <span id="strengthValue">${characterBrushStrength.toFixed(2)}</span>`;
const brushStrengthInput = document.createElement('input');
brushStrengthInput.type = 'range';
brushStrengthInput.min = '0.01';
brushStrengthInput.max = '0.2';
brushStrengthInput.step = '0.01';
brushStrengthInput.value = characterBrushStrength;
brushStrengthInput.addEventListener('input', (e) => {
   characterBrushStrength = parseFloat(e.target.value);
   document.getElementById('strengthValue').textContent = characterBrushStrength.toFixed(2);
});

// Append labels and inputs to the container
sizeLabel.appendChild(brushSizeInput);
strengthLabel.appendChild(brushStrengthInput);
controlsContainer.appendChild(sizeLabel);
controlsContainer.appendChild(strengthLabel);

// Add controls to the sculpting panel
document.querySelector('.character-sclupting').appendChild(controlsContainer);
}

   function setupDetailToolsAndSymmetry() {
// Detail Tools
const detailTools = ['smooth', 'pinch', 'inflate', 'crease'];
let activeDetailTool = null;

detailTools.forEach(tool => {
   const button = document.getElementById(tool);
   if (button) {
       button.addEventListener('click', () => {
           activeDetailTool = tool;
           document.querySelectorAll('.panel-button').forEach(btn => btn.classList.remove('active'));
           button.classList.add('active');
           console.log(`Selected Detail Tool: ${tool}`);
           // Call corresponding function for the tool
           applyDetailTool(tool);
       });
   }
});

function applyDetailTool(tool) {
   switch (tool) {
       case 'smooth':
           console.log('Applying Smooth Tool...');
           // Add smoothing logic here
           break;
       case 'pinch':
           console.log('Applying Pinch Tool...');
           // Add pinching logic here
           break;
       case 'inflate':
           console.log('Applying Inflate Tool...');
           // Add inflating logic here
           break;
       case 'crease':
           console.log('Applying Crease Tool...');
           // Add creasing logic here
           break;
       default:
           console.log('No tool selected');
   }
}

// Symmetry Controls
const symmetryToggle = document.getElementById('symmetryToggle');
const symmetryAxis = document.getElementById('symmetryAxis');

symmetryToggle.addEventListener('change', () => {
   const isSymmetryEnabled = symmetryToggle.checked;
   console.log(`Symmetry Enabled: ${isSymmetryEnabled}`);
   // Enable or disable symmetry in your sculpting logic
});

symmetryAxis.addEventListener('change', () => {
   const selectedAxis = symmetryAxis.value;
   console.log(`Symmetry Axis: ${selectedAxis}`);
   // Update symmetry axis in your sculpting logic
});
}


   
// Initialize character sculpting
function initCharacterSculpting() {
    sculptingSphere = addSculptingSphere();
    setupCharacterSculptingEvents();
    setupHairBrushControls();
    updateHairPhysics();
}

</script>

    <!-- Node/editor -->
    <script>
    

        class NodeConnection {
            constructor(startSocket, endSocket) {
                this.startSocket = startSocket;
                this.endSocket = endSocket;
                this.element = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                this.element.setAttribute('stroke', '#666');
                this.element.setAttribute('stroke-width', '2');
                this.element.setAttribute('fill', 'none');
            }

            update() {
                const start = this.getSocketPosition(this.startSocket);
                const end = this.getSocketPosition(this.endSocket);
                const controlPointOffset = 50;

                const path = `M ${start.x} ${start.y} 
                            C ${start.x + controlPointOffset} ${start.y},
                              ${end.x - controlPointOffset} ${end.y},
                              ${end.x} ${end.y}`;

                this.element.setAttribute('d', path);
            }

            getSocketPosition(socket) {
                const rect = socket.getBoundingClientRect();
                const canvasRect = document.getElementById('node-canvas').getBoundingClientRect();
                return {
                    x: rect.left + rect.width / 2 - canvasRect.left,
                    y: rect.top + rect.height / 2 - canvasRect.top
                };
            }
        }

        class WaterEffect {
    constructor(object, properties = {}) {
        this.object = object;
        this.properties = {
            flowRate: properties.flowRate || 1.0,
            viscosity: properties.viscosity || 0.5, 
            surfaceTension: properties.surfaceTension || 0.8,
            rippleStrength: properties.rippleStrength || 0.5,
            waterHeight: properties.waterHeight || 0.5,
            waterOpacity: properties.waterOpacity || 0.8
        };

        // Store original material
        this.originalMaterial = object.material;
        
        // Create water geometry matching object bounds
        const geometry = object.geometry;
        const waterGeometry = geometry.clone();
        
        // Create custom water material with advanced shaders
        const waterMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                flowRate: { value: this.properties.flowRate },
                viscosity: { value: this.properties.viscosity },
                surfaceTension: { value: this.properties.surfaceTension },
                rippleStrength: { value: this.properties.rippleStrength },
                waterHeight: { value: this.properties.waterHeight },
                waterOpacity: { value: this.properties.waterOpacity },
                tNormal: { value: null },
                tCube: { value: null }
            },
            vertexShader: `
                uniform float time;
                uniform float flowRate;
                uniform float rippleStrength;
                uniform float waterHeight;
                
                varying vec3 vPosition;
                varying vec2 vUv;
                varying vec3 vNormal;
                varying vec3 vViewPosition;
                varying vec3 vWorldPosition;
                
                void main() {
                    vUv = uv;
                    vPosition = position;
                    vec3 transformedNormal = normalMatrix * normal;
                    vNormal = normalize(transformedNormal);
                    
                    // Advanced wave simulation
                    float waves = 0.0;
                    
                    // Primary waves
                    waves += sin(position.x * 2.0 + time * flowRate) * 
                            cos(position.z * 2.0 + time * flowRate) * 0.5;
                            
                    // Secondary waves
                    waves += sin(position.x * 4.0 - time * flowRate * 1.5) * 
                            cos(position.z * 4.0 + time * flowRate * 0.8) * 0.25;
                            
                    // Ripple effects
                    waves += sin(length(position.xz) * 8.0 - time * flowRate * 2.0) * 0.125;
                    
                    // Apply wave displacement
                    vec3 newPosition = position;
                    newPosition.y += waves * rippleStrength * waterHeight;
                    
                    vec4 worldPosition = modelMatrix * vec4(newPosition, 1.0);
                    vWorldPosition = worldPosition.xyz;
                    
                    vec4 mvPosition = modelViewMatrix * vec4(newPosition, 1.0);
                    vViewPosition = -mvPosition.xyz;
                    
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                uniform float time;
                uniform float viscosity;
                uniform float surfaceTension;
                uniform float waterOpacity;
                
                varying vec3 vPosition;
                varying vec2 vUv;
                varying vec3 vNormal;
                varying vec3 vViewPosition;
                varying vec3 vWorldPosition;
                
                void main() {
                    vec3 viewVector = normalize(vViewPosition);
                    
                    // Base water colors
                    vec3 shallowColor = vec3(0.1, 0.3, 0.5);
                    vec3 deepColor = vec3(0.0, 0.2, 0.4);
                    
                    // Enhanced Fresnel effect
                    float fresnelFactor = pow(1.0 - max(0.0, dot(vNormal, viewVector)), 
                                           5.0 * surfaceTension);
                    
                    // Dynamic caustics
                    float caustics = 0.0;
                    caustics += sin(vWorldPosition.x * 10.0 + time) * 
                               cos(vWorldPosition.z * 10.0 + time) * 0.5;
                    caustics += sin(vWorldPosition.x * 20.0 - time * 0.5) * 
                               cos(vWorldPosition.z * 20.0 + time * 0.5) * 0.25;
                    caustics = max(0.0, caustics);
                    
                    // Depth calculation
                    float depth = smoothstep(0.0, 1.0, vPosition.y);
                    
                    // Combine all effects
                    vec3 waterColor = mix(deepColor, shallowColor, depth);
                    waterColor += vec3(caustics * 0.1);
                    waterColor = mix(waterColor, vec3(1.0), fresnelFactor * viscosity);
                    
                    // Final color with dynamic opacity
                    float alpha = mix(waterOpacity * 0.5, waterOpacity, fresnelFactor);
                    
                    gl_FragColor = vec4(waterColor, alpha);
                }
            `,
            transparent: true,
            side: THREE.DoubleSide
        });

        // Create water mesh
        this.waterMesh = new THREE.Mesh(waterGeometry, waterMaterial);
        
        // Apply water mesh
        this.object.material = waterMaterial;
        this.waterMaterial = waterMaterial;
    }

    update(deltaTime) {
        if (this.waterMaterial && this.waterMaterial.uniforms) {
            // Update time-based uniforms
            this.waterMaterial.uniforms.time.value += deltaTime;
            
            // Update property-based uniforms
            Object.entries(this.properties).forEach(([key, value]) => {
                if (this.waterMaterial.uniforms[key]) {
                    this.waterMaterial.uniforms[key].value = value;
                }
            });
        }
    }

    cleanup() {
        if (this.object && this.originalMaterial) {
            this.object.material = this.originalMaterial;
        }
        
        if (this.waterMaterial) {
            this.waterMaterial.dispose();
        }
    }

    setProperties(properties) {
        Object.assign(this.properties, properties);
    }
}

        class NodeEditor {
            constructor() {
                this.nodes = new Map(); 
                this.connections = new Set();
                this.canvas = document.getElementById('node-canvas');
                this.isDragging = false;
                this.selectedNode = null;
                this.offset = { x: 0, y: 0 };
                this.connectingSocket = null;
                this.nodeEffects = new Map();
                this.initializeSVGLayer();
                this.initializeEventListeners();


              
            }

            linkNodeToSceneObject(node, sceneObject) {
                const nodeData = this.nodes.get(node);
                if (nodeData) {
                    nodeData.object = sceneObject;
                    this.nodes.set(node, nodeData);
                    this.applyNodeEffect(node, sceneObject);
                }
            }

            initializeSVGLayer() {
                this.svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                this.svg.style.position = 'absolute';
                this.svg.style.width = '100%';
                this.svg.style.height = '100%';
                this.svg.style.pointerEvents = 'none';
                this.svg.style.zIndex = '0';
                this.canvas.appendChild(this.svg);
            }
    
            initializeEventListeners() {
                // Toggle and close buttons
                document.getElementById('node-editor-toggle').addEventListener('click', () => {
                    document.querySelector('.node-editor').classList.toggle('visible');
                });
    
                document.getElementById('node-editor-close').addEventListener('click', () => {
                    document.querySelector('.node-editor').classList.remove('visible');
                });
    
                // Mouse events for dragging
                this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
                document.addEventListener('mousemove', this.handleMouseMove.bind(this));
                document.addEventListener('mouseup', this.handleMouseUp.bind(this));
    
                // Toolbar buttons
                document.querySelectorAll('.toolbar-button').forEach(button => {
                    button.addEventListener('click', () => {
                        const type = button.dataset.type;
                        this.addNode(type);
                    });
                });
    
                // Context menu
                this.canvas.addEventListener('contextmenu', this.handleContextMenu.bind(this));
                document.addEventListener('click', () => {
                    document.getElementById('context-menu1').style.display = 'none';
                });
            }
    
            addNode(type) {
                const node = document.createElement('div');
                node.className = 'node';
                node.innerHTML = this.generateNodeContent(type);
    
                // Random position within visible area
                const padding = 50;
                const rect = this.canvas.getBoundingClientRect();
                node.style.left = `${Math.random() * (rect.width - 250 - padding) + padding}px`;
                node.style.top = `${Math.random() * (rect.height - 150 - padding) + padding}px`;
    
                this.canvas.appendChild(node);
                this.nodes.set(node, { type, properties: {} });

                if (type === 'object') {
                    // إنشاء كائن جديد في المشهد
                    const geometry = new THREE.BoxGeometry();
                    const material = new THREE.MeshStandardMaterial();
                    const mesh = new THREE.Mesh(geometry, material);
                    addObjectToScene(mesh, 'Test_Shap');
                    
                    this.nodes.set(node, { type, object: mesh, properties: {} });
                } else {
                    this.nodes.set(node, { type, properties: {} });
                }
    
                // Add socket event listeners
                node.querySelectorAll('.node-socket').forEach(socket => {
                    socket.addEventListener('mousedown', (e) => {
                        e.stopPropagation();
                        this.startConnection(socket);
                    });
    
                    socket.addEventListener('mouseup', (e) => {
                        e.stopPropagation();
                        this.endConnection(socket);
                    });
                });
                if (type === 'effect') {
                    const typeSelect = node.querySelector('select[name="type"]');
                    typeSelect.addEventListener('change', () => {
                    this.updatePropertyVisibility(node);
                });
                  this.updatePropertyVisibility(node);
            }

           // Add value display updates for range inputs
           node.querySelectorAll('input[type="range"]').forEach(input => {
        const display = input.nextElementSibling;
        if (display && display.classList.contains('value-display')) {
            input.addEventListener('input', () => {
                display.textContent = input.value;
                this.updateNodeEffect(node);
            });
        }
    });
            }
    
            generateNodeContent(type) {
                const nodeTypes = {
                    object: {
                        title: 'Scene Object',
                        properties: [
                            { name: 'name', type: 'text', label: 'Name' },
                            { name: 'visible', type: 'checkbox', label: 'Visible' }
                        ]
                    },
                    physics: {
                        title: 'Physics',
                        properties: [
                            { name: 'type', type: 'select', label: 'Type', 
                              options: ['Static', 'Dynamic', 'Kinematic'] },
                            { name: 'mass', type: 'number', label: 'Mass' },
                            { name: 'friction', type: 'number', label: 'Friction' }
                        ]
                    },
                    effect: {
                        title: 'Effect',
                        properties: [
                           { name: 'type', type: 'select', label: 'Type',
                           options: ['Particles', 'Trail', 'Glow', 'Water'] }, // Added Water
                           { name: 'intensity', type: 'range', label: 'Intensity' },
                           //water-specific properties
                           { name: 'flowRate', type: 'range', label: 'Flow Rate', min: 0, max: 2, step: 0.1, showWhen: 'type=Water' },
                           { name: 'viscosity', type: 'range', label: 'Viscosity', min: 0, max: 1, step: 0.1, showWhen: 'type=Water' },
                           { name: 'surfaceTension', type: 'range', label: 'Surface Tension', min: 0, max: 1, step: 0.1, showWhen: 'type=Water' },
                           { name: 'rippleStrength', type: 'range', label: 'Ripple Strength', min: 0, max: 1, step: 0.1, showWhen: 'type=Water' },
                           { name: 'waterHeight', type: 'range', label: 'Water Height', min: 0, max: 2, step: 0.1, showWhen: 'type=Water' },
                           { name: 'waterOpacity', type: 'range', label: 'Water Opacity', min: 0, max: 1, step: 0.1, showWhen: 'type=Water' }
                        ]
                    },                    
                    material: {
                        title: 'Material',
                        properties: [
                            { name: 'type', type: 'select', label: 'Type',
                              options: ['Basic', 'Phong', 'Standard'] },
                            { name: 'color', type: 'color', label: 'Color' }
                        ]
                    },
                    transform: {
                        title: 'Transform',
                        properties: [
                            { name: 'position', type: 'vector3', label: 'Position' },
                            { name: 'rotation', type: 'vector3', label: 'Rotation' },
                            { name: 'scale', type: 'vector3', label: 'Scale' }
                        ]
                    }
                };
    
                const nodeConfig = nodeTypes[type];
                let html = `
                    <div class="node-title">${nodeConfig.title}</div>
                    <div class="node-socket input"></div>
                    <div class="node-content">
                `;
    
                nodeConfig.properties.forEach(prop => {
                    html += this.generatePropertyInput(prop);
                });
    
                html += `
                    </div>
                    <div class="node-socket output"></div>
                `;
    
                return html;
            }
    
            generatePropertyInput(prop) {
                if (prop.showWhen) {
                     const [dependentField, value] = prop.showWhen.split('=');
                return `
                   <div class="node-property" data-show-when="${prop.showWhen}">
                        <label>${prop.label}</label>
                        <input type="range" 
                            name="${prop.name}" 
                            min="${prop.min || 0}" 
                            max="${prop.max || 1}" 
                            step="${prop.step || 0.1}" 
                            value="${prop.default || (prop.min || 0)}">
                           <span class="value-display">0</span>
                    </div>
                `;
                }
                let input = '';
                switch(prop.type) {
                    case 'text':
                        input = `<input type="text" name="${prop.name}">`;
                        break;
                    case 'number':
                        input = `<input type="number" name="${prop.name}" step="0.1">`;
                        break;
                    case 'checkbox':
                        input = `<input type="checkbox" name="${prop.name}">`;
                        break;
                    case 'select':
                        input = `
                            <select name="${prop.name}">
                                ${prop.options.map(opt => `<option value="${opt}">${opt}</option>`).join('')}
                            </select>
                        `;
                        break;
                    case 'range':
                        input = `<input type="range" name="${prop.name}" min="0" max="1" step="0.1">`;
                        break;
                    case 'color':
                        input = `<input type="color" name="${prop.name}">`;
                        break;
                    case 'vector3':
                        input = `
                            <div style="display: flex; gap: 4px;">
                                <input type="number" name="${prop.name}_x" step="0.1" style="width: 60px;" placeholder="X">
                                <input type="number" name="${prop.name}_y" step="0.1" style="width: 60px;" placeholder="Y">
                                <input type="number" name="${prop.name}_z" step="0.1" style="width: 60px;" placeholder="Z">
                            </div>
                        `;
                        break;
                }
                return `
                    <div class="node-property">
                        <label>${prop.label}</label>
                        ${input}
                    </div>
                `;
            }
    
            updatePropertyVisibility(node) {
                  const typeSelect = node.querySelector('select[name="type"]');
                 const properties = node.querySelectorAll('[data-show-when]');
    
                 properties.forEach(prop => {
                const [dependentField, value] = prop.dataset.showWhen.split('=');
                if (dependentField === 'type') {
                  prop.style.display = typeSelect.value === value ? 'block' : 'none';
                }
                });
            }
            handleMouseDown(e) {
                const node = e.target.closest('.node');
                if (node && !e.target.classList.contains('node-socket')) {
                    this.isDragging = true;
                    this.selectedNode = node;
                    const rect = node.getBoundingClientRect();
                    this.offset = {
                        x: e.clientX - rect.left,
                        y: e.clientY - rect.top
                    };
                }
            }
    
            handleMouseMove(e) {
                if (this.isDragging && this.selectedNode) {
                    const x = e.clientX - this.offset.x;
                    const y = e.clientY - this.offset.y;
                    this.selectedNode.style.left = `${x}px`;
                    this.selectedNode.style.top = `${y}px`;
                    this.updateConnections();
                }
            }
    
            handleMouseUp() {
                this.isDragging = false;
                this.selectedNode = null;
            }
    
            handleContextMenu(e) {
                e.preventDefault();
                const node = e.target.closest('.node');
                if (node) {
                    const menu = document.getElementById('context-menu1');
                    menu.style.display = 'block';
                    menu.style.left = `${e.clientX}px`;
                    menu.style.top = `${e.clientY}px`;
                    
                    menu.querySelector('[data-action="delete"]').onclick = () => {
                        this.deleteNode(node);
                        menu.style.display = 'none';
                    };
    
                    menu.querySelector('[data-action="duplicate"]').onclick = () => {
                        this.duplicateNode(node);
                        menu.style.display = 'none';
                    };
                }
            }
    
            startConnection(socket) {
                this.connectingSocket = socket;
            }
    
            endConnection(socket) {
            if (this.connectingSocket && this.connectingSocket !== socket) {
                if (this.connectingSocket.classList.contains('output') && socket.classList.contains('input') ||
                    this.connectingSocket.classList.contains('input') && socket.classList.contains('output')) {
                    const connection = new NodeConnection(this.connectingSocket, socket);
                    this.connections.add(connection);
                    this.svg.appendChild(connection.element);
                    connection.update();
                }
            }
          
            if (this.connectingSocket && this.connectingSocket !== socket) {
                if (this.isValidConnection(this.connectingSocket, socket)) {
                    const connection = new NodeConnection(this.connectingSocket, socket);
                    this.connections.add(connection);
                    this.svg.appendChild(connection.element);
                    connection.update();
        
                    // تطبيق التأثير مباشرة
                    const sourceNode = this.connectingSocket.closest('.node');
                    const targetNode = socket.closest('.node');
                    const sourceData = this.nodes.get(sourceNode);
                    const targetData = this.nodes.get(targetNode);
        
                    if (sourceData && targetData && targetData.object) {
                        this.applyNodeEffect(sourceNode, targetData.object);
                    }
                }
            }
            this.connectingSocket = null;
        }
    
    updateNodeEffect(node) {
        // Find connections where this node is the source
        this.connections.forEach(connection => {
            const sourceNode = connection.startSocket.closest('.node');
            const targetNode = connection.endSocket.closest('.node');
            
            if (sourceNode === node) {
                const targetData = this.nodes.get(targetNode);
                if (targetData && targetData.object) {
                    const properties = this.getNodeProperties(node);
                    this.applyEffectProperties(targetData.object, properties);
                }
            }
        });
    }

    update(deltaTime = 1/60) {
        // Update all active effects
        this.nodeEffects.forEach((effect, object) => {
            if (effect && effect.update) {
                effect.update(deltaTime);
            }
        });
    }
            updateConnections() {
                this.connections.forEach(connection => {
                    connection.update();
                });
            }
    
            deleteNode(node) {
                // Remove connections
                this.connections = new Set([...this.connections].filter(conn => {
                    const isConnected = conn.startSocket.closest('.node') === node ||
                                      conn.endSocket.closest('.node') === node;
                    if (isConnected) {
                        conn.element.remove();
                    }
                    return !isConnected;
                }));
    
                // Remove node
                this.nodes.delete(node);
                node.remove();
            }
    
            duplicateNode(node) {
                const type = this.nodes.get(node).type;
                this.addNode(type);
            }

            applyNodeEffect(node, targetObject) {
                const nodeData = this.nodes.get(node);
                const type = nodeData.type;
                const properties = this.getNodeProperties(node);
        
                switch(type) {
                    case 'object':
                        this.applyObjectProperties(targetObject, properties);
                        break;
                    case 'physics':
                        this.applyPhysicsProperties(targetObject, properties);
                        break;
                    case 'effect':
                        this.applyEffectProperties(targetObject, properties);
                        break;
                    case 'material':
                        this.applyMaterialProperties(targetObject, properties);
                        break;
                    case 'transform':
                        this.applyTransformProperties(targetObject, properties);
                        break;
                }
            }
        
            getNodeProperties(node) {
                const properties = {};
                node.querySelectorAll('input, select').forEach(input => {
                    properties[input.name] = input.type === 'checkbox' ? input.checked : input.value;
                });
                return properties;
            }
        
            applyObjectProperties(object, properties) {
                if (properties.name) object.name = properties.name;
                if (properties.hasOwnProperty('visible')) object.visible = properties.visible;
            }
        
            applyPhysicsProperties(object, properties) {
                if (!object.userData.physics) {
                    object.userData.physics = {};
                }
        
                object.userData.physics = {
                    type: properties.type || 'Static',
                    mass: parseFloat(properties.mass) || 1,
                    friction: parseFloat(properties.friction) || 0.5
                };
        
                // Implement physics using Ammo.js or other physics engine
                this.updatePhysics(object);
            }
        
            applyEffectProperties(object, properties) {
                const effectType = properties.type;

// Remove existing effect if any
if (this.nodeEffects.has(object)) {
    const existingEffect = this.nodeEffects.get(object);
    if (existingEffect.cleanup) {
        existingEffect.cleanup();
    }
    this.nodeEffects.delete(object);
}

if (effectType === 'Water') {
    const waterEffect = new WaterEffect(object, {
        flowRate: parseFloat(properties.flowRate) || 1.0,
        viscosity: parseFloat(properties.viscosity) || 0.5,
        surfaceTension: parseFloat(properties.surfaceTension) || 0.8,
        rippleStrength: parseFloat(properties.rippleStrength) || 0.5,
        waterHeight: parseFloat(properties.waterHeight) || 0.5,
        waterOpacity: parseFloat(properties.waterOpacity) || 0.8
    });
    
    this.nodeEffects.set(object, waterEffect);
    
    // Ensure the effect is updated in the animation loop
    if (!this.effectUpdateLoop) {
        this.effectUpdateLoop = setInterval(() => {
            this.nodeEffects.forEach(effect => {
                if (effect.update) {
                    effect.update(1/60); // Assuming 60fps
                }
            });
        }, 1000/60);
    }
}

           switch(effectType) {
            case 'Water':
                const waterEffect = new WaterEffect(object, {
                    flowRate: parseFloat(properties.flowRate) || 1.0,
                    viscosity: parseFloat(properties.viscosity) || 0.5,
                    surfaceTension: parseFloat(properties.surfaceTension) || 0.8,
                    rippleStrength: parseFloat(properties.rippleStrength) || 0.5
                });
                this.nodeEffects.set(object, waterEffect);
                break;
            case 'Particles':
              this.createParticleEffect(object, intensity);
            break;
            case 'Trail':
              this.createTrailEffect(object, intensity);
            break;
            case 'Glow':
               this.createGlowEffect(object, intensity);
            break;
        }
       }

       cleanupEffects() {
        this.nodeEffects.forEach(effect => {
            if (effect.cleanup) {
                effect.cleanup();
            }
        });
        this.nodeEffects.clear();
        
        if (this.effectUpdateLoop) {
            clearInterval(this.effectUpdateLoop);
            this.effectUpdateLoop = null;
        }
    }
       isValidConnection(socket1, socket2) {
        // Check if one is input and one is output
        const isInputOutput = 
            (socket1.classList.contains('input') && socket2.classList.contains('output')) ||
            (socket1.classList.contains('output') && socket2.classList.contains('input'));

        // Get the nodes containing the sockets
        const node1 = socket1.closest('.node');
        const node2 = socket2.closest('.node');

        // Get node types
        const type1 = this.nodes.get(node1)?.type;
        const type2 = this.nodes.get(node2)?.type;

        // Valid connections:
        // 1. Effect node can connect to Object node
        // 2. Object node can connect to Effect node
        return isInputOutput && ((type1 === 'effect' && type2 === 'object') || 
                               (type1 === 'object' && type2 === 'effect'));
    }
        
            createParticleEffect(object, intensity) {
                const particleSystem = new THREE.Points(
                    new THREE.BufferGeometry(),
                    new THREE.PointsMaterial({
                        size: 0.1,
                        color: 0xffffff,
                        transparent: true,
                        opacity: intensity
                    })
                );
        
                const positions = new Float32Array(1000 * 3);
                for(let i = 0; i < positions.length; i += 3) {
                    positions[i] = (Math.random() - 0.5) * 2;
                    positions[i + 1] = (Math.random() - 0.5) * 2;
                    positions[i + 2] = (Math.random() - 0.5) * 2;
                }
        
                particleSystem.geometry.setAttribute('position', 
                    new THREE.BufferAttribute(positions, 3));
                
                object.add(particleSystem);
                this.nodeEffects.set(object, particleSystem);
            }
        
            createTrailEffect(object, intensity) {
                const trail = new THREE.Line(
                    new THREE.BufferGeometry(),
                    new THREE.LineBasicMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: intensity
                    })
                );
        
                const points = [];
                for(let i = 0; i < 100; i++) {
                    points.push(new THREE.Vector3(0, 0, 0));
                }
                trail.geometry.setFromPoints(points);
                
                object.add(trail);
                this.nodeEffects.set(object, trail);
            }
        
            createGlowEffect(object, intensity) {
                const glowMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        intensity: { value: intensity }
                    },
                    vertexShader: `
                        varying vec3 vNormal;
                        void main() {
                            vNormal = normalize(normalMatrix * normal);
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float intensity;
                        varying vec3 vNormal;
                        void main() {
                            float glow = pow(1.0 - dot(vNormal, vec3(0, 0, 1)), 3.0) * intensity;
                            gl_FragColor = vec4(1.0, 1.0, 1.0, glow);
                        }
                    `,
                    transparent: true,
                    blending: THREE.AdditiveBlending
                });
        
                const glowMesh = new THREE.Mesh(
                    object.geometry.clone(),
                    glowMaterial
                );
                glowMesh.scale.multiplyScalar(1.1);
                
                object.add(glowMesh);
                this.nodeEffects.set(object, glowMesh);
            }
        
            applyMaterialProperties(object, properties) {
                let material;
                switch(properties.type) {
                    case 'Basic':
                        material = new THREE.MeshBasicMaterial({
                            color: new THREE.Color(properties.color)
                        });
                        break;
                    case 'Phong':
                        material = new THREE.MeshPhongMaterial({
                            color: new THREE.Color(properties.color),
                            shininess: 30
                        });
                        break;
                    case 'Standard':
                        material = new THREE.MeshStandardMaterial({
                            color: new THREE.Color(properties.color),
                            roughness: 0.5,
                            metalness: 0.5
                        });
                        break;
                }
                
                if (material) {
                    object.material = material;
                }
            }
        
            applyTransformProperties(object, properties) {
                if (properties.position_x !== undefined) {
                    object.position.x = parseFloat(properties.position_x);
                    object.position.y = parseFloat(properties.position_y);
                    object.position.z = parseFloat(properties.position_z);
                }
        
                if (properties.rotation_x !== undefined) {
                    object.rotation.x = THREE.MathUtils.degToRad(parseFloat(properties.rotation_x));
                    object.rotation.y = THREE.MathUtils.degToRad(parseFloat(properties.rotation_y));
                    object.rotation.z = THREE.MathUtils.degToRad(parseFloat(properties.rotation_z));
                }
        
                if (properties.scale_x !== undefined) {
                    object.scale.x = parseFloat(properties.scale_x);
                    object.scale.y = parseFloat(properties.scale_y);
                    object.scale.z = parseFloat(properties.scale_z);
                }
            }
        
            updatePhysics(object) {
                if (object.userData.physics) {
                    // Implement physics update logic here
                    // This would typically involve updating position and rotation
                    // based on physics simulation
                }
            }
        
            update() {
                // تحديث جميع التأثيرات النشطة
                this.connections.forEach(connection => {
                    const sourceNode = connection.startSocket.closest('.node');
                    const targetNode = connection.endSocket.closest('.node');
                    
                    if (sourceNode && targetNode) {
                        const targetData = this.nodes.get(targetNode);
                        if (targetData && targetData.object) {
                            this.applyNodeEffect(sourceNode, targetData.object);
                        }
                    }
                });
            
                // تحديث التأثيرات المستمرة (مثل الجسيمات)
                this.nodeEffects.forEach((effect, object) => {
                    if (effect.update) effect.update();
                });

                this.nodeEffects.forEach((effect, object) => {
                    if (effect instanceof WaterEffect) {
                        effect.update(0.016); // Assuming 60fps
                    }
                });
            }
        
            updateParticleEffect(particles) {
                const positions = particles.geometry.attributes.position.array;
                for(let i = 0; i < positions.length; i += 3) {
                    positions[i] += (Math.random() - 0.5) * 0.01;
                    positions[i + 1] += (Math.random() - 0.5) * 0.01;
                    positions[i + 2] += (Math.random() - 0.5) * 0.01;
                }
                particles.geometry.attributes.position.needsUpdate = true;
            }
        
            updateTrailEffect(trail, object) {
                const positions = trail.geometry.attributes.position.array;
                for(let i = positions.length - 3; i >= 3; i -= 3) {
                    positions[i] = positions[i - 3];
                    positions[i + 1] = positions[i - 2];
                    positions[i + 2] = positions[i - 1];
                }
                positions[0] = object.position.x;
                positions[1] = object.position.y;
                positions[2] = object.position.z;
                trail.geometry.attributes.position.needsUpdate = true;
            }

            createWaterEffect(object, properties) {
    // Remove existing water effect if any
    const existingEffect = this.nodeEffects.get(object);
    if (existingEffect) {
        if (existingEffect.waterMesh) {
            object.remove(existingEffect.waterMesh);
        }
        this.nodeEffects.delete(object);
    }

    // Create new water effect
    const waterEffect = new WaterEffect(object, {
        flowRate: properties.flowRate || 1.0,
        viscosity: properties.viscosity || 0.5,
        surfaceTension: properties.surfaceTension || 0.8,
        rippleStrength: properties.rippleStrength || 0.5
    });

    this.nodeEffects.set(object, waterEffect);
}

    addWaterControls(object) {
        const waterEffect = this.nodeEffects.get(object);
        if (waterEffect) {
            const controls = document.createElement('div');
            controls.className = 'water-controls';
            controls.innerHTML = `
                <div class="control-group">
                    <label>Flow Rate</label>
                    <input type="range" min="0" max="2" step="0.1" value="${waterEffect.properties.flowRate}">
                </div>
                <div class="control-group">
                    <label>Viscosity</label>
                    <input type="range" min="0" max="1" step="0.1" value="${waterEffect.properties.viscosity}">
                </div>
                <div class="control-group">
                    <label>Surface Tension</label>
                    <input type="range" min="0" max="1" step="0.1" value="${waterEffect.properties.surfaceTension}">
                </div>
            `;

            // Add event listeners for controls
            controls.querySelectorAll('input').forEach(input => {
                input.addEventListener('input', (e) => {
                    const property = e.target.previousElementSibling.textContent.toLowerCase().replace(' ', '');
                    waterEffect.setProperties({ [property]: parseFloat(e.target.value) });
                });
            });

            // Add controls to node
            const node = object.userData.node;
            if (node) {
                node.querySelector('.node-content').appendChild(controls);
            }
        }
    }
        }
    
        // Initialize the node editor
        const nodeEditor = new NodeEditor();

       
    </script>
   
   
    <script>
        class TerrainBrushSystem {
            constructor(scene, camera, renderer, terrain) {
                this.scene = scene;
                this.camera = camera;
                this.renderer = renderer;
                this.terrain = terrain;
                
                // Brush states
                this.isActive = false;
                this.isPainting = false;
                this.lastPaintPosition = new THREE.Vector3();
                
                // Brush settings
                this.settings = {
                    radius: 2,
                    density: 5,
                    spacing: 0.5,
                    scaleMin: 0.8,
                    scaleMax: 1.2,
                    rotationMin: 0,
                    rotationMax: 360,
                    heightOffset: 0,
                    paintDelay: 50, // ms between paint operations
                };
        
                // Storage for models
                this.models = new Map();
                this.activeModel = null;
                
                // Initialize systems
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.brushPreview = this.createBrushPreview2();
                this.scene.add(this.brushPreview);
                
                // Initialize event listeners
                this.initializeEventListeners();
                this.lastPaintTime = 0;
                
                // Undo/Redo system
                this.undoStack = [];
                this.redoStack = [];
                this.currentPaintOperation = [];
            }
        
            createBrushPreview2() {
                const group = new THREE.Group();
        
                // Main circle
                const circleGeometry = new THREE.CircleGeometry(1, 32);
                const circleMaterial = new THREE.MeshBasicMaterial({
                    color: 0xFF7F7F,
                    transparent: true,
                    opacity: 0.6,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });
                const circle = new THREE.Mesh(circleGeometry, circleMaterial);
                circle.rotation.x = -Math.PI / 2;
                circle.renderOrder = 1;
        
                // Outer ring
                const ringGeometry = new THREE.RingGeometry(0.95, 1, 32);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: 0xFFFFFF,
                    transparent: true,
                    opacity: 0.7,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = -Math.PI / 2;
                ring.renderOrder = 2;
        
                // Center dot
                const dotGeometry = new THREE.CircleGeometry(0.05, 16);
                const dotMaterial = new THREE.MeshBasicMaterial({
                    color: 0xFFFFFF,
                    transparent: true,
                    opacity: 0.9,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });
                const dot = new THREE.Mesh(dotGeometry, dotMaterial);
                dot.rotation.x = -Math.PI / 2;
                dot.position.y = 0.01;
                dot.renderOrder = 3;
        
                group.add(circle);
                group.add(ring);
                group.add(dot);
                group.visible = false;
        
                return group;
            }
        
            initializeEventListeners() {
                // Mouse events
                this.renderer.domElement.addEventListener('mousemove', this.onMouseMove.bind(this));
                this.renderer.domElement.addEventListener('mousedown', this.onMouseDown.bind(this));
                this.renderer.domElement.addEventListener('mouseup', this.onMouseUp.bind(this));
                
                // Keyboard shortcuts
                window.addEventListener('keydown', (e) => {
                    if (e.key === 'b' || e.key === 'B') {
                        this.toggleBrush();
                    }
                    if (e.key === 'z' && e.ctrlKey) {
                        this.undo();
                    }
                    if (e.key === 'y' && e.ctrlKey) {
                        this.redo();
                    }
                });
        
                // UI Controls
                this.setupUIControls();
            }
        
            setupUIControls() {
                // Brush size control
                const sizeSlider = document.getElementById('brush-size');
                if (sizeSlider) {
                    sizeSlider.addEventListener('input', (e) => {
                        this.settings.radius = parseFloat(e.target.value);
                        this.updateBrushPreview();
                    });
                }
        
                // Density control
                const densitySlider = document.getElementById('brush-density');
                if (densitySlider) {
                    densitySlider.addEventListener('input', (e) => {
                        this.settings.density = parseInt(e.target.value);
                    });
                }
        
                // Model upload
                const modelUpload = document.getElementById('model-upload');
                if (modelUpload) {
                    modelUpload.addEventListener('change', this.handleModelUpload.bind(this));
                }
            }
        
            handleModelUpload(event) {
                const file = event.target.files[0];
                if (!file) return;
        
                const loader = new THREE.GLTFLoader();
                const reader = new FileReader();
        
                reader.onload = (e) => {
                    loader.load(e.target.result, (gltf) => {
                        const model = gltf.scene;
                        const modelName = file.name.split('.')[0];
                        
                        // Center and normalize model
                        const box = new THREE.Box3().setFromObject(model);
                        const center = box.getCenter(new THREE.Vector3());
                        const size = box.getSize(new THREE.Vector3());
                        const maxDim = Math.max(size.x, size.y, size.z);
                        
                        model.position.sub(center);
                        model.scale.multiplyScalar(1 / maxDim);
                        
                        this.models.set(modelName, model);
                        this.activeModel = model;
                        
                        console.log(`Model ${modelName} loaded successfully`);
                    });
                };
        
                reader.readAsDataURL(file);
            }
        
            onMouseMove(event) {
                if (!this.isActive) return;
        
                this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        
                this.updateBrushPosition();
                
                if (this.isPainting) {
                    this.paint();
                }
            }
        
            onMouseDown(event) {
                if (event.button !== 0 || !this.isActive || !this.activeModel) return;
                this.isPainting = true;
                this.currentPaintOperation = [];
                this.paint();
            }
        
            onMouseUp() {
                if (this.isPainting && this.currentPaintOperation.length > 0) {
                    this.undoStack.push(this.currentPaintOperation);
                    this.redoStack = [];
                }
                this.isPainting = false;
            }
        
            updateBrushPosition() {
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObject(this.terrain);
        
                if (intersects.length > 0) {
                    const point = intersects[0].point;
                    this.brushPreview.position.copy(point);
                    this.brushPreview.scale.setScalar(this.settings.radius);
                    this.brushPreview.visible = true;
                } else {
                    this.brushPreview.visible = false;
                }
            }
        
            paint() {
                if (!this.activeModel || !this.isPainting) return;
        
                const now = Date.now();
                if (now - this.lastPaintTime < this.settings.paintDelay) return;
                this.lastPaintTime = now;
        
                const intersects = this.raycaster.intersectObject(this.terrain);
                if (intersects.length === 0) return;
        
                const center = intersects[0].point;
                const instanceCount = Math.floor(this.settings.density * (this.settings.radius * this.settings.radius));
        
                for (let i = 0; i < instanceCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * this.settings.radius;
                    
                    const position = new THREE.Vector3(
                        center.x + Math.cos(angle) * radius,
                        center.y + this.settings.heightOffset,
                        center.z + Math.sin(angle) * radius
                    );
        
                    // Check minimum distance from last placement
                    if (position.distanceTo(this.lastPaintPosition) < this.settings.spacing) {
                        continue;
                    }
        
                    const instance = this.activeModel.clone();
                    instance.position.copy(position);
        
                    // Random rotation
                    const rotation = THREE.MathUtils.degToRad(
                        this.settings.rotationMin + 
                        Math.random() * (this.settings.rotationMax - this.settings.rotationMin)
                    );
                    instance.rotation.y = rotation;
        
                    // Random scale
                    const scale = this.settings.scaleMin + 
                        Math.random() * (this.settings.scaleMax - this.settings.scaleMin);
                    instance.scale.setScalar(scale);
        
                    this.scene.add(instance);
                    this.currentPaintOperation.push(instance);
                    this.lastPaintPosition.copy(position);
                }
            }
        
            undo() {
                if (this.undoStack.length === 0) return;
                
                const objects = this.undoStack.pop();
                this.redoStack.push(objects);
                
                objects.forEach(obj => {
                    this.scene.remove(obj);
                });
            }
        
            redo() {
                if (this.redoStack.length === 0) return;
                
                const objects = this.redoStack.pop();
                this.undoStack.push(objects);
                
                objects.forEach(obj => {
                    this.scene.add(obj);
                });
            }
        
            toggleBrush() {
                this.isActive = !this.isActive;
                this.brushPreview.visible = this.isActive;
            }
        
            updateBrushPreview() {
                this.brushPreview.scale.setScalar(this.settings.radius);
            }
        }
    </script>
   
    <script src="index.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/TransformControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/geometries/TextGeometry.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@latest/build/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/RGBELoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.17"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.139.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.139.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.139.0/examples/js/controls/TransformControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.139.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.139.0/examples/js/loaders/RGBELoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FBXLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/examples/js/controls/TransformControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <!-- Physics -->
    <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.7/build/dat.gui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>
    <!-- Particle effects -->
    <script src="https://cdn.jsdelivr.net/npm/three-spritetext@1.6.5/dist/three-spritetext.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script  src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon-es/0.17.0/cannon-es.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/postprocessing/OutlinePass.js"></script>
   <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/loaders/FBXLoader.js"></script>
   
   <script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/GLTFLoader.js"></script>
   <script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/OBJLoader.js"></script>
   <script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/FBXLoader.js"></script>

   <!-- Required for FBX -->
   <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/helpers/SkeletonHelper.js"></script>
   <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/loaders/FBXLoader.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/fflate@0.7.4/umd/index.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/inflate.min.js"></script>

<script>
// First, add these global variables at the top of your 

let objects = [];
let snowParticles = [];
let groundLevel = 0;
let snowDensity = 1500;
let snowSize = 0.2;
let snowSpeed = 0.5;
let windForce = 0.5;
let turbulence = 0.5;
let stormMode = false;
let snowMaterial;


let isSnowing = true;
let params = {
    density: 1500,
    size: 0.15,
    speed: 0.6,
    wind: 0.3,
    turbulence: 0.5,
    groundLevel: -10,
    mode: 'normal'
};

const textureLoader = new THREE.TextureLoader();
const snowflakeTexture = textureLoader.load('https://threejs.org/examples/textures/sprites/snowflake2.png');

let snowAccumulation = new Map(); // Store accumulated snow particles
const maxAccumulatedParticles = 1000; // Maximum particles that can accumulate at one spot
const meltingRate = 0.01; // Rate at which snow melts
const gridY = params.groundLevel; // Y position of the grid

function createSnow() {
    const snowGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(params.density * 3);
    const velocities = new Float32Array(params.density * 3);
    const randomFactors = new Float32Array(params.density);

    for (let i = 0; i < params.density; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 50;
        positions[i * 3 + 1] = Math.random() * 50;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 50;

        velocities[i * 3] = (Math.random() - 0.5) * 0.05;
        velocities[i * 3 + 1] = -Math.random() * params.speed;
        velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.05;

        randomFactors[i] = Math.random();
    }

    snowGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    snowGeometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
    snowGeometry.setAttribute('random', new THREE.BufferAttribute(randomFactors, 1));

    const snowMaterial = new THREE.PointsMaterial({
        size: params.size,
        color: 0xffffff,
        transparent: true,
        opacity: 0.8,
        depthWrite: false,
        alphaTest: 0.1,
        map: snowflakeTexture,
        blending: THREE.AdditiveBlending
    });

    // In your createSnow function, add these attributes:
snowGeometry.setAttribute('random', new THREE.Float32BufferAttribute(
    new Float32Array(params.density).map(() => Math.random()),
    1
));

// Optional: Add size variation
snowGeometry.setAttribute('size', new THREE.Float32BufferAttribute(
    new Float32Array(params.density).fill(params.size),
    1
));

// Optional: Add opacity variation
snowGeometry.setAttribute('opacity', new THREE.Float32BufferAttribute(
    new Float32Array(params.density).fill(1.0),
    1
));

    const snow = new THREE.Points(snowGeometry, snowMaterial);
    snowParticles.push(snow);
    scene.add(snow);
}


function createSnowflakeTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 32;
    canvas.height = 32;
    const ctx = canvas.getContext('2d');

    ctx.beginPath();
    ctx.arc(16, 16, 14, 0, Math.PI * 2);
    ctx.fillStyle = 'white';
    ctx.fill();

    return new THREE.CanvasTexture(canvas);
}

function updateSnow() {
    const time = Date.now() * 0.001; // Current time for animations
    
    snowParticles.forEach(particle => {
        const positions = particle.geometry.attributes.position.array;
        const velocities = particle.geometry.attributes.velocity.array;
        const randomFactors = particle.geometry.attributes.random.array;

        for (let i = 0; i < positions.length; i += 3) {
            // Add swirling effect
            const swirl = Math.sin(time + positions[i] * 0.1) * 0.2;
            const vortex = Math.cos(time + positions[i + 2] * 0.1) * 0.2;
            
            // Variable wind based on height
            const heightFactor = Math.max(0, (positions[i + 1] - params.groundLevel) / 50);
            const windEffect = params.wind * heightFactor;
            
            // Add spiral motion
            const angle = time * 0.5 + randomFactors[i / 3] * Math.PI * 2;
            const radius = Math.max(0, (positions[i + 1] - params.groundLevel) / 10);
            const spiralX = Math.cos(angle) * radius * 0.1;
            const spiralZ = Math.sin(angle) * radius * 0.1;
            
            // Add turbulent motion
            const turbX = Math.sin(time * 2 + positions[i] * 0.1) * params.turbulence;
            const turbZ = Math.cos(time * 2 + positions[i + 2] * 0.1) * params.turbulence;
            
            // Update positions with combined effects
            positions[i] += velocities[i] * windEffect + swirl + spiralX + turbX;
            positions[i + 1] += velocities[i + 1] * params.speed * (0.8 + Math.sin(time + randomFactors[i / 3]) * 0.2);
            positions[i + 2] += velocities[i + 2] * windEffect + vortex + spiralZ + turbZ;

            // Ground collision with bounce effect
            if (positions[i + 1] < params.groundLevel) {
                // Random bounce chance
                if (Math.random() < 0.3) {
                    // Small bounce
                    positions[i + 1] = params.groundLevel;
                    velocities[i + 1] = Math.abs(velocities[i + 1]) * 0.2;
                    
                    // Horizontal scatter on impact
                    velocities[i] = (Math.random() - 0.5) * 0.2;
                    velocities[i + 2] = (Math.random() - 0.5) * 0.2;
                    
                    // Fade out effect (if using opacity attribute)
                    if (particle.geometry.attributes.opacity) {
                        particle.geometry.attributes.opacity.array[i / 3] *= 0.9;
                    }
                } else {
                    // Reset to top with random offset
                    positions[i + 1] = 50 + Math.random() * 10;
                    positions[i] = (Math.random() - 0.5) * 50;
                    positions[i + 2] = (Math.random() - 0.5) * 50;
                    
                    // Reset velocities with slight randomization
                    velocities[i] = (Math.random() - 0.5) * 0.05;
                    velocities[i + 1] = -Math.random() * params.speed;
                    velocities[i + 2] = (Math.random() - 0.5) * 0.05;
                    
                    // Reset opacity if using it
                    if (particle.geometry.attributes.opacity) {
                        particle.geometry.attributes.opacity.array[i / 3] = 1.0;
                    }
                }
            }

            // Add size variation based on height
            if (particle.geometry.attributes.size) {
                const size = 1.0 + Math.sin(time + randomFactors[i / 3] * 10) * 0.3;
                particle.geometry.attributes.size.array[i / 3] = params.size * size;
            }
        }

        // Update all modified attributes
        particle.geometry.attributes.position.needsUpdate = true;
        if (particle.geometry.attributes.size) particle.geometry.attributes.size.needsUpdate = true;
        if (particle.geometry.attributes.opacity) particle.geometry.attributes.opacity.needsUpdate = true;
    });
}


function setupWeatherEffects() {
    const effects = {
        storm: { speed: 3, wind: 3, turbulence: 2 },
        blizzard: { speed: 4, wind: 4, turbulence: 2.5 },
        gentle: { speed: 0.5, wind: 0.2, turbulence: 0.3 }
    };

    Object.keys(effects).forEach(effect => {
        document.getElementById(effect).addEventListener('click', () => {
            const settings = effects[effect];
            Object.keys(settings).forEach(param => {
                params[param] = settings[param];
                document.getElementById(param).value = settings[param];
                document.getElementById(`${param}Value`).textContent = settings[param];
            });
        });
    });
}

        function updateSnowSize() {
            snowParticles.forEach(particles => {
                particles.material.size = params.size;
            });
        }

        function recreateSnow() {
            snowParticles.forEach(particles => {
                scene.remove(particles);
            });
            snowParticles = [];
            createSnow();
        }


</script>

<script>

let scene, camera, renderer, controls, transformControls, raycaster, mouse;
let selectedObject = null;
let isPlaying = false;
let clock = new THREE.Clock();
let selectedElements = new Set();
let vertexHelpers = new THREE.Group();
let edgeHelpers = new THREE.Group();
let faceHelpers = new THREE.Group();



let particles, particlesGeometry,  particlesMaterial;
const particlesCount = 10000;
let particleColor = 0xffcc88;
let isParticlesVisible = true; 
let isLocked = false;

let textureLoaded = null; 



function toggleParticles() {
    if (particles) {
        isParticlesVisible = !isParticlesVisible;
        particles.visible = isParticlesVisible;
        console.log(`Particles ${isParticlesVisible ? "enabled" : "disabled"}`);
    } else {
        console.warn("Particles have not been initialized yet.");
    }
}


function createParticles() {
    if (!textureLoaded) {
        textureLoaded = new THREE.TextureLoader().load(
            'https://threejs.org/examples/textures/sprites/spark1.png'
        );
    }

    particlesGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particlesCount * 3);
    const sizes = new Float32Array(particlesCount);

    for (let i = 0; i < particlesCount; i++) {
        // Gaussian distribution for natural spread
        positions[i * 3] = (Math.random() - 0.5) * 100 + gaussianRandom() * 20;
        positions[i * 3 + 1] = (Math.random() - 0.5) * 100 + gaussianRandom() * 20;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 100 + gaussianRandom() * 20;

        // Randomized size variation
        sizes[i] = Math.random() * 0.5 + 0.1;
    }

    particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    particlesGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

    if (!particlesMaterial) {
        particlesMaterial = new THREE.PointsMaterial({
            color: particleColor,
            size: 0.3,
            sizeAttenuation: true,
            transparent: true,
            opacity: 0.8, // Slight fade-in effect
            map: textureLoaded,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
        });
    }

    particles = new THREE.Points(particlesGeometry, particlesMaterial);
    scene.add(particles);
    isParticlesVisible = true;
}

/**
 * Generates a Gaussian (normal) distribution random number.
 * Creates more naturally clustered particles.
 */
function gaussianRandom(mean = 0, stdev = 1) {
    let u = 1 - Math.random(); // Uniform(0,1] random number
    let v = 1 - Math.random();
    let z = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    return mean + z * stdev;
}


function changeParticlesCount(amount) {
    particlesCount = Math.max(1000, particlesCount + amount);  // Minimum particlesCount is 1000
    updateParticles();
}

function changeParticleColor(color) {
    particleColor = new THREE.Color(color);
    particles.material.color.set(particleColor);  // Update particle color
}



let isDrawing = false;
let drawMode = false;
let extrudeMode = false;
let points = [];
let previewMesh = null;
let previewLine = null;
let quadMeshes = [];
let snapThreshold = 0.3;
let extrudeHeight = 1.0;
cameraOrbitSpeed = 0.005;
let cameraDistance = 10;
let cameraTarget = new THREE.Vector3(0, 0, 0);
let cameraTheta = Math.PI/4;
let cameraPhi = Math.PI/3;
let currentCameraPosition = new THREE.Vector3();
let targetCameraPosition = new THREE.Vector3();
let cameraVelocity = new THREE.Vector3();

let mouseDown = false;
let selectedFace = null;
let orbitControls = true;

let isModelingMode = false;
let selectionMode = 'object';
let activeObject = null;
function init() {
    // Scene setup
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1a1a1a);

    // Camera setup
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 5;

    updateCameraPosition();
    // Renderer setup
    renderer = new THREE.WebGLRenderer({ 
        antialias: true,
        // Enable tone mapping for better HDR rendering
        toneMapping: THREE.ACESFilmicToneMapping,
        toneMappingExposure: 1.0
    });

    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('renderer-container').appendChild(renderer.domElement);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.autoClear = false;

    // Scroll event for zooming
   renderer.domElement.addEventListener('wheel', (event) => {
        zoomCamera(event.deltaY);
    });

    // Remove OrbitControls (if you prefer full manual control)
    if (controls) {
        controls.dispose();
        controls = null;
    }

    transformControls = new THREE.TransformControls(camera, renderer.domElement);
    scene.add(transformControls);

    // Handle transform controls affecting orbit controls
    transformControls.addEventListener('dragging-changed', function(event) {
      controls.enabled = !event.value;
    });
    // Axes helper
    const axesHelper = new THREE.AxesHelper(5);
    scene.add(axesHelper);

    // Raycaster and mouse setup
    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();

    // Add helper groups to scene
    scene.add(vertexHelpers);
    scene.add(edgeHelpers);
    scene.add(faceHelpers);

    // Lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(10, 10, 10);
    scene.add(directionalLight);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;

    const pointLight = new THREE.PointLight(0xffffff, 1, 100);
    pointLight.position.set(10, 10, 10);
    scene.add(pointLight);

    // Controls
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    transformControls = new THREE.TransformControls(camera, renderer.domElement);
    scene.add(transformControls);
    controls.enableDamping = true;
    controls.dampingFactor = 0.25;
    controls.screenSpacePanning = false;

    // Grid helper
    const advancedGrid = createAdvancedGridHelper(2000, 2000);
    scene.add(advancedGrid);

    const lineMaterial = new THREE.LineBasicMaterial({
        color: 0xffff00,
        linewidth: 2
    });

    previewLine = new THREE.Line(
        new THREE.BufferGeometry(),
        lineMaterial
    );
    scene.add(previewLine);

    // Enhanced fog
    scene.fog = new THREE.FogExp2(0x1c1c1c, 0.01);
    // GUI setup
    addGUI(scene);

    // Event listeners and initialization
    window.addEventListener('DOMContentLoaded', () => {
        document.getElementById('toggle-lock').addEventListener('click', toggleLock);
    });

    setupSceneElements();
    createSnow();
    setupEventListeners();
    initPhysics();
    addDemonstrationObjects();
    createParticles();
    animate();
    initBrush();
}

// Camera movement parameters
const cameraSpeed = 0.005; // Increased speed for faster movement
const zoomSpeed = 0.1;
let lastMouseX, lastMouseY

// Fast & Direct Camera Update Function
function updateCameraPosition() {
   // Convert spherical coordinates to Cartesian (direct update)
   const x = cameraDistance * Math.sin(cameraPhi) * Math.sin(cameraTheta);
   const y = cameraDistance * Math.cos(cameraPhi);
   const z = cameraDistance * Math.sin(cameraPhi) * Math.cos(cameraTheta);
   camera.position.set(x, y, z);
   camera.lookAt(cameraTarget);
}

// Instant Zoom Function (Fast & Responsive)
function zoomCamera(delta) {
    cameraDistance *= delta > 0 ? 1.1 : 0.9;
    cameraDistance = THREE.MathUtils.clamp(cameraDistance, 1, 100); // Limits
    updateCameraPosition();
}

// Fast Rotation (Direct and Snappy)
function rotateCamera(deltaX, deltaY) {
    const rotationFactor = cameraSpeed * 5; // Adjusted for smoother motion

    cameraTheta -= deltaX * rotationFactor;
    cameraPhi -= deltaY * rotationFactor;

    // Clamp phi to prevent flipping
    cameraPhi = THREE.MathUtils.clamp(cameraPhi, 0.2, Math.PI - 0.2);

    updateCameraPosition();
}






// Add model to scene
function addModelToScene(model) {
    // Process model materials and enable shadows
    model.traverse((node) => {
        if (node.isMesh) {
            node.castShadow = true;
            node.receiveShadow = true;
            
            // Ensure materials update correctly
            if (node.material) {
                node.material.needsUpdate = true;
                if (Array.isArray(node.material)) {
                    node.material.forEach(mat => mat.needsUpdate = true);
                }
            }
        }
    });

    // Add model to the scene
    scene.add(model);
    objects.push(model);

    // Setup animations if present
    if (model.animations && model.animations.length > 0) {
        const mixer = new THREE.AnimationMixer(model);
        model.userData.mixer = mixer;
        model.animations.forEach(clip => {
            const action = mixer.clipAction(clip);
            action.play();
        });
    }

    // Update hierarchy (if needed)
    updateHierarchy();
}



function setupSceneElements() {
    scene.fog = new THREE.FogExp2(0x1c1c1c, 0.02);
    
    const axesHelper = new THREE.AxesHelper(5);
    scene.add(axesHelper);

    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();
}


function animateParticles() {
    const positions = particles.geometry.attributes.position.array;
    const time = Date.now() * 0.001;

    for (let i = 0; i < particlesCount * 3; i += 3) {
        positions[i] += Math.sin(time + positions[i + 2] * 0.1) * 0.01;
        positions[i + 1] += Math.cos(time + positions[i] * 0.1) * 0.01;
        positions[i + 2] += Math.sin(time * 0.5 + positions[i] * 0.1) * 0.01;
    }

    particles.geometry.attributes.position.needsUpdate = true;
}


function addGUI(scene) {
    const gui = new dat.GUI({
        autoPlace: false
    });

    // Settings object
    const settings = {
        background: 0x1a1a1a,
        density: 0.02,
        useHDR: false,
        enableShadows: true,
        lightIntensity: 1,
        ambientLightColor: 0xffffff,
        ambientLightIntensity: 0.5,
        pointLightColor: 0xffffff,
        pointLightIntensity: 1,
        directionalLightColor: 0xffffff,
        directionalLightIntensity: 1,
        materialReflectivity: 0.5,
        enableParticleEffects: true,
        bloomIntensity: 1.0,
        depthOfField: 0.5,
    };

    // Background color control
    const backgroundFolder = gui.addFolder('Background Settings');
    backgroundFolder.addColor(settings, 'background').onChange((value) => {
        if (!settings.useHDR) {
            scene.background = new THREE.Color(value);
            scene.fog = new THREE.FogExp2(value, settings.density);
        }
    });
    backgroundFolder.open();

    // Fog density control
    const fogFolder = gui.addFolder('Fog Settings');
    fogFolder.add(settings, 'density', 0.01, 0.1).onChange((value) => {
        scene.fog.density = value;
    });

    // HDR toggle control
    const hdrFolder = gui.addFolder('HDR Settings');
    hdrFolder.add(settings, 'useHDR').onChange(function(value) {
        if (value) {
            const hdrLoader = new THREE.RGBELoader();
            hdrLoader.load('https://dl.polyhaven.org/file/ph-assets/HDRIs/1k/clear/clear_1k.hdr', (hdrMap) => {
                console.log('HDR loaded successfully');
                hdrMap.mapping = THREE.EquirectangularReflectionMapping;
                scene.background = hdrMap;
                scene.environment = hdrMap;
            }, undefined, (error) => {
                console.error('Error loading HDR: ', error);
            });
        } else {
            scene.background = new THREE.Color(settings.background);
            scene.fog = new THREE.FogExp2(settings.background, settings.density);
            scene.environment = null;
        }
    });
    hdrFolder.open();

    // Shadow control
    const shadowFolder = gui.addFolder('Shadow Settings');
    shadowFolder.add(settings, 'enableShadows').onChange((value) => {
        scene.traverse((object) => {
            if (object.castShadow !== undefined) {
                object.castShadow = value;
            }
        });
    });
    shadowFolder.add(settings, 'lightIntensity', 0, 2).onChange((value) => {
        scene.traverse((object) => {
            if (object instanceof THREE.Light) {
                object.intensity = value;
            }
        });
    });
    shadowFolder.open();

    // Ambient Light settings
    const ambientLightFolder = gui.addFolder('Ambient Light Settings');
    ambientLightFolder.addColor(settings, 'ambientLightColor').onChange((value) => {
        scene.traverse((object) => {
            if (object instanceof THREE.AmbientLight) {
                object.color.set(value);
            }
        });
    });
    ambientLightFolder.add(settings, 'ambientLightIntensity', 0, 1).onChange((value) => {
        scene.traverse((object) => {
            if (object instanceof THREE.AmbientLight) {
                object.intensity = value;
            }
        });
    });
    ambientLightFolder.open();

    // Point Light settings
    const pointLightFolder = gui.addFolder('Point Light Settings');
    pointLightFolder.addColor(settings, 'pointLightColor').onChange((value) => {
        scene.traverse((object) => {
            if (object instanceof THREE.PointLight) {
                object.color.set(value);
            }
        });
    });
    pointLightFolder.add(settings, 'pointLightIntensity', 0, 2).onChange((value) => {
        scene.traverse((object) => {
            if (object instanceof THREE.PointLight) {
                object.intensity = value;
            }
        });
    });
    pointLightFolder.open();

    // Directional Light settings
    const directionalLightFolder = gui.addFolder('Directional Light Settings');
    directionalLightFolder.addColor(settings, 'directionalLightColor').onChange((value) => {
        scene.traverse((object) => {
            if (object instanceof THREE.DirectionalLight) {
                object.color.set(value);
            }
        });
    });
    directionalLightFolder.add(settings, 'directionalLightIntensity', 0, 2).onChange((value) => {
        scene.traverse((object) => {
            if (object instanceof THREE.DirectionalLight) {
                object.intensity = value;
            }
        });
    });
    directionalLightFolder.open();

    // Material Reflectivity control
    const materialFolder = gui.addFolder('Material Settings');
    materialFolder.add(settings, 'materialReflectivity', 0, 1).onChange((value) => {
        scene.traverse((object) => {
            if (object.material) {
                object.material.reflectivity = value;
            }
        });
    });
    materialFolder.open();

    // Particle Effects control
    const particleEffectsFolder = gui.addFolder('Particle Effects Settings');
    particleEffectsFolder.add(settings, 'enableParticleEffects').onChange((value) => {
        // Enable or disable particle effects
        console.log(value ? "Particle effects enabled" : "Particle effects disabled");
    });
    particleEffectsFolder.open();

    // Post-Processing Effects control
    const postProcessingFolder = gui.addFolder('Post-processing Effects');
    postProcessingFolder.add(settings, 'bloomIntensity', 0, 2).onChange((value) => {
        // Apply Bloom intensity
        console.log("Bloom Intensity:", value);
    });
    postProcessingFolder.add(settings, 'depthOfField', 0, 1).onChange((value) => {
        // Apply Depth of Field effect
        console.log("Depth of Field:", value);
    });
    postProcessingFolder.open();

    // Append GUI to container
    const guiContainer = document.getElementById('gui-container');
    guiContainer.appendChild(gui.domElement);
}





//Modelign Shapes
let showVertices = false;
let showEdges = false;
let showFaces = true;
let subdivisionLevel = 0;



function onMouseClick(event) {
    const mouse = new THREE.Vector2(
    (event.clientX / window.innerWidth) * 2 - 1,
    -(event.clientY / window.innerHeight) * 2 + 1);

    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);

    const intersects = raycaster.intersectObjects(meshes);

    if (intersects.length > 0) {
       selectedMesh = intersects[0].object;
       updateMeshVisuals();
    }
}

function addCustomMesh() {
    const geometry = new THREE.DodecahedronGeometry(0.5);
    const material = new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff });
    const customMesh = new THREE.Mesh(geometry, material);
    scene.add(customMesh);
    meshes.push(customMesh);
    updateMeshVisuals();
    
}
    
function updateMeshVisuals() {
    if (!selectedMesh) return;

    // Clear previous helpers
    vertexHelpers.clear();
    edgeHelpers.clear();
    faceHelpers.clear();

    // Vertices
    if (showVertices) {
        const geometry = selectedMesh.geometry;
        const positions = geometry.attributes.position.array;
        
        for (let i = 0; i < positions.length; i += 3) {
            const vertexGeometry = new THREE.SphereGeometry(0.05);
            const vertexMaterial = new THREE.MeshBasicMaterial({ 
                color: selectedElements.has(`vertex_${i}`) ? 0xff0000 : 0xffff00 
            });
            const vertex = new THREE.Mesh(vertexGeometry, vertexMaterial);
            
            vertex.position.set(
                positions[i],
                positions[i + 1],
                positions[i + 2]
            );
            
            vertex.userData.type = 'vertex';
            vertex.userData.index = i;
            vertexHelpers.add(vertex);
        }
    }

    // Edges
    if (showEdges) {
        const edges = new THREE.EdgesGeometry(selectedMesh.geometry);
        const edgeMaterial = new THREE.LineBasicMaterial({ 
            color: 0x00ff00,
            linewidth: 2
        });
        const edgeLines = new THREE.LineSegments(edges, edgeMaterial);
        edgeHelpers.add(edgeLines);
    }

    // Faces
    if (showFaces) {
        const faceIndices = selectedMesh.geometry.index;
        const positions = selectedMesh.geometry.attributes.position.array;
        
        for (let i = 0; i < faceIndices.count; i += 3) {
            const faceGeometry = new THREE.BufferGeometry();
            const vertices = [];
            
            for (let j = 0; j < 3; j++) {
                const index = faceIndices.array[i + j] * 3;
                vertices.push(
                    positions[index],
                    positions[index + 1],
                    positions[index + 2]
                );
            }
            
            faceGeometry.setAttribute('position', 
                new THREE.Float32BufferAttribute(vertices, 3));
            
            const faceMaterial = new THREE.MeshBasicMaterial({
                color: selectedElements.has(`face_${i/3}`) ? 0x0000ff : 0x444444,
                transparent: true,
                opacity: 0.5,
                side: THREE.DoubleSide
            });
            
            const face = new THREE.Mesh(faceGeometry, faceMaterial);
            face.userData.type = 'face';
            face.userData.index = i/3;
            faceHelpers.add(face);
        }
    }
}

function handleSelection(event) {
    if (!selectedMesh) return;

    const mouse = new THREE.Vector2(
        (event.clientX / window.innerWidth) * 2 - 1,
        -(event.clientY / window.innerHeight) * 2 + 1
    );

    raycaster.setFromCamera(mouse, camera);
    let intersects = [];

    if (showVertices) {
        intersects = raycaster.intersectObjects(vertexHelpers.children);
    } else if (showEdges) {
        intersects = raycaster.intersectObjects(edgeHelpers.children);
    } else if (showFaces) {
        intersects = raycaster.intersectObjects(faceHelpers.children);
    }

    if (intersects.length > 0) {
        const selected = intersects[0].object;
        const elementId = `${selected.userData.type}_${selected.userData.index}`;

        if (selectedElements.has(elementId)) {
            selectedElements.delete(elementId);
        } else {
            selectedElements.add(elementId);
        }

        updateMeshVisuals();
    }
}

function transformSelected() {
    if (selectedElements.size === 0) return;

    const geometry = selectedMesh.geometry.clone();
    const positions = geometry.attributes.position.array;

    selectedElements.forEach(elementId => {
        const [type, index] = elementId.split('_');
        
        if (type === 'vertex') {
            // تحريك الرأس
            const i = parseInt(index);
            positions[i] += transformAmount.x;
            positions[i + 1] += transformAmount.y;
            positions[i + 2] += transformAmount.z;
        }
        // يمكن إضافة معالجة الحواف والأوجه هنا
    });

    geometry.attributes.position.needsUpdate = true;
    selectedMesh.geometry = geometry;
    updateMeshVisuals();
}


function createAdvancedGridHelper(size = 2000, divisions = 2000) {
    const gridGroup = new THREE.Group();

    // Main grid
    const mainGridHelper = new THREE.GridHelper(size, divisions);
    mainGridHelper.material = new THREE.LineBasicMaterial({
        color: 0x333333,
        opacity: 0.6,
        transparent: true,
        linewidth: 0.5
    });

    // Secondary grid (larger squares)
    const secondaryGridHelper = new THREE.GridHelper(size, divisions / 10);
    secondaryGridHelper.material = new THREE.LineBasicMaterial({
        color: 0x444444,
        opacity: 0.8,
        transparent: true,
        linewidth: 1
    });

    // Major axes
    const axesGroup = createMajorAxes(size);
    
    // Create measurement labels
    const labelsGroup = createMeasurementLabels(size);

    // Add everything to the group
    gridGroup.add(mainGridHelper);
    gridGroup.add(secondaryGridHelper);
    gridGroup.add(axesGroup);
    gridGroup.add(labelsGroup);

    // Dynamic visibility based on camera distance
    gridGroup.onBeforeRender = function(renderer, scene, camera) {
        const distance = camera.position.length();
        const maxDistance = size / 1.5;
        
        // Fade out based on distance
        const mainFade = THREE.MathUtils.smoothstep(distance, maxDistance * 0.5, maxDistance);
        const secondaryFade = THREE.MathUtils.smoothstep(distance, maxDistance * 0.3, maxDistance * 0.8);
        
        mainGridHelper.material.opacity = 0.6 * (1 - mainFade);
        secondaryGridHelper.material.opacity = 0.8 * (1 - secondaryFade);
        
        // Scale visibility of different grid elements based on distance
        if (distance < size * 0.2) {
            mainGridHelper.visible = true;
            secondaryGridHelper.visible = true;
            labelsGroup.visible = true;
        } else if (distance < size * 0.5) {
            mainGridHelper.visible = false;
            secondaryGridHelper.visible = true;
            labelsGroup.visible = true;
        } else {
            mainGridHelper.visible = false;
            secondaryGridHelper.visible = true;
            labelsGroup.visible = false;
        }
    };

    return gridGroup;
}


function createMajorAxes(size) {
    const axesGroup = new THREE.Group();
    
    // X-axis (red)
    const xAxis = createAxisLine(size, 0xff0000, new THREE.Vector3(1, 0, 0));
    // Z-axis (blue)
    const zAxis = createAxisLine(size, 0x0000ff, new THREE.Vector3(0, 0, 1));
    // Y-axis (green)
    const yAxis = createAxisLine(size, 0x00ff00, new THREE.Vector3(0, 1, 0));

    axesGroup.add(xAxis);
    axesGroup.add(yAxis);
    axesGroup.add(zAxis);

    return axesGroup;
}

function createAxisLine(size, color, direction) {
    const geometry = new THREE.BufferGeometry();
    const vertices = new Float32Array([
        -size/2 * direction.x, -size/2 * direction.y, -size/2 * direction.z,
        size/2 * direction.x, size/2 * direction.y, size/2 * direction.z
    ]);
    geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
    
    const material = new THREE.LineBasicMaterial({
        color: color,
        linewidth: 2,
        opacity: 0.8,
        transparent: true
    });

    return new THREE.Line(geometry, material);
}

function createMeasurementLabels(size) {
    const labelsGroup = new THREE.Group();
    const interval = size / 10;
    
    // Create text sprites for measurement labels
    for (let i = -size/2; i <= size/2; i += interval) {
        if (i === 0) continue; // Skip 0
        
        // X-axis labels
        const xLabel = createTextSprite(i.toString());
        xLabel.position.set(i, 0, -20);
        labelsGroup.add(xLabel);
        
        // Z-axis labels
        const zLabel = createTextSprite(i.toString());
        zLabel.position.set(-20, 0, i);
        labelsGroup.add(zLabel);
    }

    return labelsGroup;
}

function createTextSprite(message) {
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.width = 256;
    canvas.height = 256;
    
    context.font = "Bold 36px Arial";
    context.fillStyle = "rgba(255,255,255,0.95)";
    context.fillText(message, 128, 128);
    
    const texture = new THREE.CanvasTexture(canvas);
    const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
    const sprite = new THREE.Sprite(spriteMaterial);
    sprite.scale.set(50, 50, 1);
    
    return sprite;
}



function toggleLock() {
    isLocked = !isLocked;

    // Enable or disable rotation and panning, but keep zoom active
    controls.enableRotate = !isLocked; // Disable rotation
    controls.enablePan = !isLocked;    // Disable panning
    controls.enableZoom = true;        // Ensure zoom remains active

    // Update button style and icon
    const lockButton = document.getElementById('toggle-lock');
    lockButton.innerHTML = isLocked 
        ? '<i class="fas fa-lock"></i>' // Locked icon
        : '<i class="fas fa-unlock"></i>'; // Unlocked icon
    lockButton.style.backgroundColor = isLocked ? '#e74c3c' : '#2ecc71';
}

function setCameraView(direction) {
    let targetPosition = { x: 0, y: 0, z: 0 };

    switch (direction) {
        case 'x': 
            targetPosition = { x: 10, y: 0, z: 0 };
            break;
        case 'y': 
            targetPosition = { x: 0, y: 10, z: 0 };
            break;
        case 'z': 
            targetPosition = { x: 0, y: 0, z: 10 };
            break;
        case 'top': 
            targetPosition = { x: 0, y: 10, z: 0 };
            break;
        case 'bottom':
            targetPosition = { x: 0, y: -10, z: 0 };
            break;
        case 'diagonal': 
            targetPosition = { x: 10, y: 10, z: 10 };
            break;
        default:
            console.error('Invalid direction');
            return;
    }

    // استخدام GSAP لتحريك الكاميرا بسلاسة
    gsap.to(camera.position, {
        x: targetPosition.x,
        y: targetPosition.y,
        z: targetPosition.z,
        duration: 1.5, // مدة الحركة بالثواني
        onUpdate: () => camera.lookAt(0, 0, 0) // تحديث زاوية الكاميرا أثناء الحركة
    });
}



function toggleExtrudeMode() {
    if (drawMode) toggleDrawMode();
    extrudeMode = !extrudeMode;
    
    if (extrudeMode) {
        controls.enabled = false;
        transformControls.enabled = false;
        transformControls.detach();
        selectedObject = null;
    } else {
        controls.enabled = true;
        transformControls.enabled = true;
        selectedFace = null;
    }
    
    document.getElementById('toggle-extrude').classList.toggle('active', extrudeMode);
    updateStatus();
}


function exitCurrentMode() {
    if (drawMode) toggleDrawMode();
    if (extrudeMode) toggleExtrudeMode();
    
    // Restore normal controls
    controls.enabled = true;
    transformControls.enabled = true;
    
    points = [];
    updatePreviewLine();
    selectedFace = null;
    brushCursor.visible = false;
    updateStatus();
}

function toggleDrawMode() {
    if (extrudeMode) toggleExtrudeMode();
    drawMode = !drawMode;
    
    if (drawMode) {
        controls.enabled = false;
        transformControls.enabled = false;
        transformControls.detach();
        selectedObject = null;
        brushCursor.visible = true;
    } else {
        controls.enabled = true;
        transformControls.enabled = true;
        points = [];
        updatePreviewLine();
        brushCursor.visible = false;
    }
   
    document.getElementById('toggle-draw').classList.toggle('active', drawMode);
    updateStatus();
}


function updateStatus() {
    let statusText = "Ready";
    if (drawMode) {
        statusText = `Drawing: ${points.length} points`;
    } else if (extrudeMode) {
        statusText = "Select a face to extrude";
        if (selectedFace) {
            statusText = "Click to extrude selected face";
        }
    }
    document.getElementById('status').textContent = statusText;
}

function updatePreviewLine() {
    if (points.length > 0) {
        const positions = [];
        points.forEach(point => {
            positions.push(point.x, point.y, point.z);
        });
        
        // Close the shape if we have enough points
        if (points.length >= 3) {
            positions.push(points[0].x, points[0].y, points[0].z);
        }

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        previewLine.geometry.dispose();
        previewLine.geometry = geometry;
    } else {
        previewLine.geometry.dispose();
        previewLine.geometry = new THREE.BufferGeometry();
    }
}

function clearGeometry() {
    quadMeshes.forEach(mesh => {
        mesh.geometry.dispose();
        mesh.material.dispose();
        scene.remove(mesh);
    });
    quadMeshes = [];
    points = [];
    updatePreviewLine();
    selectedFace = null;
    updateStatus();
}


function onMouseDown(event) {
    if (isLocked) return;
    event.preventDefault();
    mouseDown = true;
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    if (drawMode) {
        isDrawing = true;
        addPoint(event);
    } else if (extrudeMode) {
        selectFaceToExtrude();
    } else if (!drawMode && !extrudeMode) {
        orbitControls.enabled = true;
    }
}

function onMouseMove(event) {
    if (isLocked) return;
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    // Update brush cursor position
    updateBrushPosition(event);

    if (drawMode && isDrawing) {
        addPoint(event);
    }

    // Highlight face when in extrude mode
    if (extrudeMode && !mouseDown) {
        highlightFace();
    }
}

function onMouseUp(event) {
    if (isLocked) return;
    mouseDown = false;
    
    if (drawMode && isDrawing) {
        isDrawing = false;
        if (points.length >= 4) {
            createQuad();
            points = [];
            updatePreviewLine();
            updateStatus();
        }
    } else if (extrudeMode && selectedFace) {
        extrudeFace();
    }
}


function initQuadBrush() {
    // Preview line for drawing
    const lineMaterial = new THREE.LineBasicMaterial({
        color: 0xffff00,
        linewidth: 2
    });
    
    previewLine = new THREE.Line(
        new THREE.BufferGeometry(),
        lineMaterial
    );
    scene.add(previewLine);
    
    // Reset quad-related variables
    points = [];
    quadMeshes = [];
    drawMode = false;
    extrudeMode = false;
}


function onMouseWheel(event) {
   event.preventDefault();
            
    // Adjust camera zoom
    cameraDistance = THREE.MathUtils.clamp(
        cameraDistance + event.deltaY * 0.01,
        5, 30
    );
            
    updateCameraPosition();
}
    
function addPoint(event) {
    raycaster.setFromCamera(mouse, camera);
    
    // Try to snap to existing points or grid
    let snappedPoint = null;
    
    // First try to snap to existing points
    if (points.length > 0 && snapThreshold > 0) {
        for (const point of points) {
            const screenPoint = point.clone().project(camera);
            const distance = Math.sqrt(
                Math.pow(screenPoint.x - mouse.x, 2) + 
                Math.pow(screenPoint.y - mouse.y, 2)
            );
            
            if (distance < snapThreshold * 0.1) {
                snappedPoint = point.clone();
                break;
            }
        }
    }
    
    // If no point snap, check for mesh or grid intersections
    if (!snappedPoint) {
        // Include all scene objects that should be considered for drawing
        const intersectObjects = [...quadMeshes, ...objects];
        const intersects = raycaster.intersectObjects(intersectObjects, true);
        
        if (intersects.length > 0) {
            snappedPoint = intersects[0].point.clone();
            
            // Add some height offset to avoid z-fighting
            snappedPoint.y += 0.01;
            
            // Grid snapping
            if (snapThreshold > 0) {
                snappedPoint.x = Math.round(snappedPoint.x / snapThreshold) * snapThreshold;
                snappedPoint.z = Math.round(snappedPoint.z / snapThreshold) * snapThreshold;
            }
        }
    }
    
    if (snappedPoint) {
        // Check if this is close to first point (to close the loop)
        if (points.length >= 3) {
            const firstPoint = points[0];
            if (snappedPoint.distanceTo(firstPoint) < 0.5) {
                createQuad();
                points = [];
                updatePreviewLine();
                isDrawing = false;
                updateStatus();
                return;
            }
        }
        
        // Only add point if it's far enough from the last point
        if (points.length === 0 || 
            snappedPoint.distanceTo(points[points.length - 1]) > 0.1) {
            points.push(snappedPoint);
            updatePreviewLine();
            updateStatus();
        }
    }
}

function selectFaceToExtrude() {
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(quadMeshes);
    
    if (intersects.length > 0) {
        const face = intersects[0].face;
        const mesh = intersects[0].object;
        
        selectedFace = {
            mesh: mesh,
            faceIndex: face.a, // Store the first vertex index of the face
            normal: face.normal.clone()
        };
        
        updateStatus();
    }
}


function highlightFace() {
    // Reset any previously selected face
    quadMeshes.forEach(mesh => {
        if (mesh.material.emissive) {
            mesh.material.emissive.setRGB(0, 0, 0);
        }
    });
    
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(quadMeshes);
    
    if (intersects.length > 0) {
        const mesh = intersects[0].object;
        
        // Highlight by setting emissive color
        if (mesh.material.emissive) {
            mesh.material.emissive.setRGB(0.2, 0.2, 0);
        }
    }
}

function extrudeFace() {
    if (!selectedFace) return;
    
    const mesh = selectedFace.mesh;
    const geometry = mesh.geometry;
    const normal = selectedFace.normal;
    
    // Get the indices of the face to extrude (assuming quads)
    const faceIndex = selectedFace.faceIndex;
    const indices = [];
    
    // For a quad, find the indices that make up the face
    if (geometry.index) {
        for (let i = 0; i < geometry.index.count; i += 3) {
            if (geometry.index.array[i] === faceIndex ||
                geometry.index.array[i+1] === faceIndex ||
                geometry.index.array[i+2] === faceIndex) {
                indices.push(
                    geometry.index.array[i],
                    geometry.index.array[i+1],
                    geometry.index.array[i+2]
                );
                // Get next triangle if it's part of the same quad
                if (i+3 < geometry.index.count && 
                    (geometry.index.array[i+3] === geometry.index.array[i] ||
                     geometry.index.array[i+3] === geometry.index.array[i+1] ||
                     geometry.index.array[i+3] === geometry.index.array[i+2])) {
                    indices.push(
                        geometry.index.array[i+3],
                        geometry.index.array[i+4],
                        geometry.index.array[i+5]
                    );
                }
                break;
            }
        }
    }
    
    if (indices.length === 0) return;
    
    // Get unique vertex indices
    const uniqueIndices = [...new Set(indices)];
    
    // Create new geometry
    const newGeometry = new THREE.BufferGeometry();
    
    // Get position attribute
    const positions = geometry.getAttribute('position');
    const newPositions = [];
    
    // Original vertices
    uniqueIndices.forEach(index => {
        newPositions.push(
            positions.getX(index),
            positions.getY(index),
            positions.getZ(index)
        );
    });
    
    // Extruded vertices
    uniqueIndices.forEach(index => {
        newPositions.push(
            positions.getX(index) + normal.x * extrudeHeight,
            positions.getY(index) + normal.y * extrudeHeight,
            positions.getZ(index) + normal.z * extrudeHeight
        );
    });
    
    // Create new index buffer for the sides
    const newIndices = [];
    
    // The front face (original quad)
    newIndices.push(0, 1, 2, 0, 2, 3);
    
    // The back face (extruded quad)
    newIndices.push(4, 6, 5, 4, 7, 6);
    
    // The four side faces
    newIndices.push(0, 4, 1, 1, 4, 5);
    newIndices.push(1, 5, 2, 2, 5, 6);
    newIndices.push(2, 6, 3, 3, 6, 7);
    newIndices.push(3, 7, 0, 0, 7, 4);
    
    newGeometry.setAttribute('position', new THREE.Float32BufferAttribute(newPositions, 3));
    newGeometry.setIndex(newIndices);
    newGeometry.computeVertexNormals();
    
    const material = new THREE.MeshPhongMaterial({
        color: 0x808080,
        side: THREE.DoubleSide,
        flatShading: true
    });
    
    const newMesh = new THREE.Mesh(newGeometry, material);
    scene.add(newMesh);
    quadMeshes.push(newMesh);
    
    // Remove the original face/mesh
    scene.remove(mesh);
    quadMeshes = quadMeshes.filter(m => m !== mesh);
    mesh.geometry.dispose();
    mesh.material.dispose();
    
    selectedFace = null;
    updateStatus();
}

function createQuad() {
    if (points.length < 4) return;

    // Use the first 4 points or simplify if more
    const validPoints = points.length > 4 ? simplifyPoints(points) : points.slice(0, 4);
    
    const geometry = new THREE.BufferGeometry();
    const vertices = [];
    const indices = [];

    // Create vertices
    for (let i = 0; i < validPoints.length; i++) {
        vertices.push(validPoints[i].x, validPoints[i].y, validPoints[i].z);
    }

    // Create faces - first triangle
    indices.push(0, 1, 2);
    
    // If we have 4 points, add second triangle
    if (validPoints.length >= 4) {
        indices.push(0, 2, 3);
    }

    geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
    geometry.setIndex(indices);
    geometry.computeVertexNormals();

    const material = new THREE.MeshPhongMaterial({
        color: 0x808080,
        side: THREE.DoubleSide,
        flatShading: true
    });

    const quad = new THREE.Mesh(geometry, material);
    scene.add(quad);
    addObjectToScene(quad, "Quad geomitry")
    quadMeshes.push(quad);
    
    // Make it selectable in your existing system
    objects.push(quad);
}

function simplifyPoints(inputPoints) {
    if (inputPoints.length <= 4) return inputPoints;
    
    // Simple algorithm to find corners
    const result = [inputPoints[0]];
    
    // Find point furthest from first point
    let maxDist = 0;
    let furthestIdx = 0;
    for (let i = 1; i < inputPoints.length; i++) {
        const dist = inputPoints[0].distanceTo(inputPoints[i]);
        if (dist > maxDist) {
            maxDist = dist;
            furthestIdx = i;
        }
    }
    result.push(inputPoints[furthestIdx]);
    
    // Find point furthest from line between first and second point
    maxDist = 0;
    furthestIdx = 0;
    const line = new THREE.Line3(result[0], result[1]);
    for (let i = 1; i < inputPoints.length; i++) {
        if (i === result[1]) continue;
        const closest = new THREE.Vector3();
        line.closestPointToPoint(inputPoints[i], true, closest);
        const dist = closest.distanceTo(inputPoints[i]);
        if (dist > maxDist) {
            maxDist = dist;
            furthestIdx = i;
        }
    }
    result.push(inputPoints[furthestIdx]);
    
    // Find the fourth point
    maxDist = 0;
    furthestIdx = 0;
    for (let i = 1; i < inputPoints.length; i++) {
        if (result.includes(inputPoints[i])) continue;
        
        // Calculate area of quad with this point
        const area = calculateQuadArea([
            result[0], result[1], result[2], inputPoints[i]
        ]);
        
        if (area > maxDist) {
            maxDist = area;
            furthestIdx = i;
        }
    }
    result.push(inputPoints[furthestIdx]);
    
    return result;
}

function calculateQuadArea(points) {
    if (points.length !== 4) return 0;
    
    // Calculate area using cross product
    const v1 = points[2].clone().sub(points[0]);
    const v2 = points[3].clone().sub(points[1]);
    return v1.cross(v2).length() / 2;
}


 
// Event listeners setup
function setupEventListeners() {
    // Tool buttons
    document.getElementById('translate').addEventListener('click', () => setTransformMode('translate'));
    document.getElementById('rotate').addEventListener('click', () => setTransformMode('rotate'));
    document.getElementById('scale').addEventListener('click', () => setTransformMode('scale'));
    // Event delegation for cleaner code
    document.querySelector('.toolbar-group').addEventListener('click', (event) => {
    const mode = event.target.id;
    if (TRANSFORM_MODES.includes(mode)) {
        setTransformMode(mode);
    }
    });
    
    // Add objects buttons
    document.getElementById('addCube').addEventListener('click', addCube);
    document.getElementById('addSphere').addEventListener('click', addSphere);
    document.getElementById('addSculptingSphere').addEventListener('click', addSculptingSphere);

    document.getElementById("addSculptingSphere").addEventListener("click", function() {
       const sculptingTools = document.getElementById("sculpting-character-tools");
      // Toggle visibility
      if (sculptingTools.style.display === "none" || sculptingTools.style.display === "") {
        sculptingTools.style.display = "block";
      } else {
        sculptingTools.style.display = "none";
    }
    });

    document.getElementById("addTerrain").addEventListener("click", function() {
       const sculptingTools = document.getElementById("sculpting-tools");
      // Toggle visibility
      if (sculptingTools.style.display === "none" || sculptingTools.style.display === "") {
        sculptingTools.style.display = "block";
      } else {
        sculptingTools.style.display = "none";
    }
    });

    document.getElementById("materialsEditor").addEventListener("click", function() {
       const materialsEditor = document.getElementById("material-editor");
      // Toggle visibility
      if (materialsEditor.style.display === "none" || materialsEditor.style.display === "") {
        materialsEditor.style.display = "block";
      } else {
        materialsEditor.style.display = "none";
    }
    });

    document.getElementById("guiControls").addEventListener("click", function() {
       const guiControlsEditor = document.getElementById("GuiContainer");
      // Toggle visibility
      if (guiControlsEditor.style.display === "none" || guiControlsEditor.style.display === "") {
        guiControlsEditor.style.display = "block";
      } else {
        guiControlsEditor.style.display = "none";
    }
    });

    document.getElementById("cameraControls").addEventListener("click", function() {
       const cameraControls = document.getElementById("Cameras");
      // Toggle visibility
      if (cameraControls.style.display === "none" || cameraControls.style.display === "") {
        cameraControls.style.display = "block";
      } else {
        cameraControls.style.display = "none";
    }
    });

    document.getElementById("lightControls").addEventListener("click", function() {
       const lightControls = document.getElementById("lights");
      // Toggle visibility
      if (lightControls.style.display === "none" || lightControls.style.display === "") {
        lightControls.style.display = "block";
      } else {
        lightControls.style.display = "none";
    }
    });

    document.getElementById("modelingControls").addEventListener("click", function() {
       const modelingTools = document.getElementById("modelingTools");
      // Toggle visibility
      if (modelingTools.style.display === "none" || modelingTools.style.display === "") {
        modelingTools.style.display = "block";
      } else {
        modelingTools.style.display = "none";
    }
    });

    document.getElementById("drawingControls").addEventListener("click", function() {
       const drawingTools = document.getElementById("drawingMode");
      // Toggle visibility
      if (drawingTools.style.display === "none" || drawingTools.style.display === "") {
         drawingTools.style.display = "block";
      } else {
        drawingTools.style.display = "none";
    }
    });

    document.getElementById("physicsControls").addEventListener("click", function() {
       const physicsControls = document.getElementById("physics-controls");
      // Toggle visibility
      if (physicsControls.style.display === "none" || physicsControls.style.display === "") {
        physicsControls.style.display = "block";
      } else {
        physicsControls.style.display = "none";
    }
    });

    document.getElementById("snow-controls").addEventListener("click", function() {
       const snowTools = document.getElementById("snow-sittings");
      // Toggle visibility
      if (snowTools.style.display === "none" || snowTools.style.display === "") {
        snowTools.style.display = "block";
      } else {
        snowTools.style.display = "none";
    }
    });


    document.getElementById('addPlane').addEventListener('click', addPlane);
    document.getElementById('addCylinder').addEventListener('click', addCylinder);
    document.getElementById('addPyramid').addEventListener('click', addPyramid);
    document.getElementById('addRectangularPrism').addEventListener('click', addRectangularPrism);
    document.getElementById('addTorus').addEventListener('click', addTorus)
    document.getElementById('addLight').addEventListener('click', addLight);
    document.getElementById('addCameraInit').addEventListener('click', addCameraInit);
   
    //Particls
    document.addEventListener("DOMContentLoaded", () => {
       document.getElementById("toggleParticles").addEventListener("click", toggleParticles);
    });

    //Modeling
    document.getElementById('toggle-modeling').addEventListener('click', toggleModelingMode);
    document.getElementById('select-vertex').addEventListener('click', () => setSelectionMode('vertex'));
    document.getElementById('select-edge').addEventListener('click', () => setSelectionMode('edge'));
    document.getElementById('select-face').addEventListener('click', () => setSelectionMode('face'));
    document.getElementById('create-building').addEventListener('click', createBuilding);
    document.getElementById('add-decoration').addEventListener('click', addDecoration);
    
    renderer.domElement.addEventListener('mousemove', onModelingMouseMove);
    renderer.domElement.addEventListener('click', onModelingClick);

    window.addEventListener('resize', onWindowResize, false);
        window.addEventListener('keydown', (e) => {
            if (e.key === 'f' || e.key === 'F') {
                toggleDrawMode();
            }
            if (e.key === 'e' || e.key === 'E') {
                toggleExtrudeMode();
            }
            if (e.key === 'l' || e.key === 'L') {
                clearGeometry();
            }
            if (e.key === 'Escape') {
                exitCurrentMode();
            }
    });
            
    document.getElementById('toggle-draw').addEventListener('click', toggleDrawMode);
    document.getElementById('toggle-extrude').addEventListener('click', toggleExtrudeMode);
    document.getElementById('clear').addEventListener('click', clearGeometry);
            
    document.getElementById('brush-size').addEventListener('input', (e) => {
        brushSize = parseFloat(e.target.value);
        e.target.nextElementSibling.textContent = `Brush Size: ${brushSize.toFixed(1)}`;
    });
            
    document.getElementById('snapping').addEventListener('input', (e) => {
        snapThreshold = parseFloat(e.target.value);
        e.target.nextElementSibling.textContent = `Snapping: ${snapThreshold.toFixed(1)}`;
    });
            
    document.getElementById('extrude-height').addEventListener('input', (e) => {
         extrudeHeight = parseFloat(e.target.value);
        e.target.nextElementSibling.textContent = `Extrude: ${extrudeHeight.toFixed(1)}`;
    });

    const canvas = renderer.domElement;
    canvas.addEventListener('mousedown', onMouseDown);
    canvas.addEventListener('mousemove', onMouseMove);
    canvas.addEventListener('mouseup', onMouseUp);
    canvas.addEventListener('wheel', onMouseWheel);
    
    //Dust
    document.addEventListener('DOMContentLoaded', function() {
        document.getElementById('toggleParticles').addEventListener('click', toggleParticles);
    });

    document.getElementById('increaseParticles').addEventListener('click', () => changeParticlesCount(1000));  // Increase by 1000
    document.getElementById('decreaseParticles').addEventListener('click', () => changeParticlesCount(-1000));  // Decrease by 1000
    document.getElementById('particleColor').addEventListener('input', (e) => changeParticleColor(e.target.value));  // Color picker

    //Snow 
    document.getElementById('density').addEventListener('input', (e) => {
    params.density = parseInt(e.target.value);
    document.getElementById('densityValue').textContent = params.density;
    recreateSnow();
    });
    

    document.addEventListener('keydown', (event) => {
    if (event.key === 's') {
        stormMode = !stormMode;
    }
    });

    
    document.getElementById('size').addEventListener('input', (e) => {
        params.size = parseFloat(e.target.value);
        document.getElementById('sizeValue').textContent = params.size;
         updateSnowSize();
    });

    document.getElementById('speed').addEventListener('input', (e) => {
        params.speed = parseFloat(e.target.value);
         document.getElementById('speedValue').textContent = params.speed;
    });

    document.getElementById('wind').addEventListener('input', (e) => {
        params.wind = parseFloat(e.target.value);
        document.getElementById('windValue').textContent = params.wind;
    });

    document.getElementById('turbulence').addEventListener('input', (e) => {
        params.turbulence = parseFloat(e.target.value);
        document.getElementById('turbulenceValue').textContent = params.turbulence;
    });

    document.getElementById('toggleSnow').addEventListener('click', () => {
    isSnowing = !isSnowing;
    if (isSnowing) {
        createSnow();
    } else {
        snowParticles.forEach(particle => scene.remove(particle));
        snowParticles = [];
    }
    });

    function resetSnow() {
       snowParticles.forEach(p => scene.remove(p));
       snowParticles = [];
       createSnow();
    }

    setupWeatherEffects();

    //modeling tools
    document.getElementById('vertexSizeSlider').addEventListener('input', updateMeshVisuals);
    document.getElementById('edgeThicknessSlider').addEventListener('input', updateMeshVisuals);
    document.getElementById('subdivisionLevelsSlider').addEventListener('input', updateMeshVisuals);
    document.getElementById('faceOpacitySlider').addEventListener('input', updateMeshVisuals);

    

    renderer.domElement.addEventListener('click', handleSelection);
    // add Physics listeners here
    document.querySelectorAll('.preview-item').forEach(item => {
        item.addEventListener('click', (e) => {
            document.querySelectorAll('.preview-item').forEach(i => i.classList.remove('active'));
            e.target.closest('.preview-item').classList.add('active');
            
            const type = e.target.closest('.preview-item').dataset.type;
            if (window.brushSystem) {
                window.brushSystem.setModelType(type);
            }
        });
    });

    // Add model upload handler
    document.getElementById('model-upload').addEventListener('change', (e) => {
        const file = e.target.files[0];
        const loader = new THREE.GLTFLoader();
        
        loader.load(URL.createObjectURL(file), (gltf) => {
            if (window.brushSystem) {
                window.brushSystem.loadedModels.set('current', gltf.scene);
                window.brushSystem.loadedModels.set('custom', gltf.scene);
            }
        });
    });

 
   
    window.addEventListener('resize', onWindowResize);
    // In setupEventListeners()
    document.getElementById('raiseLower').addEventListener('click', () => {
        selectedTool = TOOLS.RAISE_LOWER;
        updateToolUI('raiseLower');
    });
    document.getElementById('smooth').addEventListener('click', () => {
        selectedTool = TOOLS.SMOOTH;
        updateToolUI('smooth');
    });
    document.getElementById('flatten').addEventListener('click', () => {
        selectedTool = TOOLS.FLATTEN;
        updateToolUI('flatten');
    });
    document.getElementById('noise').addEventListener('click', () => {
        selectedTool = TOOLS.NOISE;
        updateToolUI('noise');
    });
    document.getElementById('pinch').addEventListener('click', () => {
        selectedTool = TOOLS.PINCH;
        updateToolUI('pinch');
    });
    document.getElementById('clay').addEventListener('click', () => {
        selectedTool = TOOLS.CLAY;
        updateToolUI('clay');
    });
    document.getElementById('scrape').addEventListener('click', () => {
        selectedTool = TOOLS.SCRAPE;
        updateToolUI('scrape');
    });
    document.getElementById('fill').addEventListener('click', () => {
        selectedTool = TOOLS.FILL;
        updateToolUI('fill');
    });

    //NWE ADVANCED TOOLS
    document.getElementById('terrace').addEventListener('click', () => {
        selectedTool = TOOLS.TERRACE;
        updateToolUI('terrace');
    });
    document.getElementById('erosion').addEventListener('click', () => {
        selectedTool = TOOLS.EROSION;
        updateToolUI('erosion');
    });
    document.getElementById('ridge').addEventListener('click', () => {
        selectedTool = TOOLS.RIDGE;
        updateToolUI('ridge');
    });
    document.getElementById('canyon').addEventListener('click', () => {
        selectedTool = TOOLS.CANYON;
        updateToolUI('canyon');
    });
    document.getElementById('plateau').addEventListener('click', () => {
        selectedTool = TOOLS.PLATEAU;
        updateToolUI('plateau');
    });
    document.getElementById('slope').addEventListener('click', () => {
        selectedTool = TOOLS.SLOPE;
        updateToolUI('slope');
    });
    document.getElementById('blur').addEventListener('click', () => {
        selectedTool = TOOLS.BLUR;
        updateToolUI('blur');
    });
    document.getElementById('sharpen').addEventListener('click', () => {
        selectedTool = TOOLS.SHARPEN;
        updateToolUI('sharpen');
    });

    // Settings of textures
    document.getElementById('selectTexture').addEventListener('click', () => {
        document.getElementById('uploadTexture').click();
    });


    
    document.getElementById('uploadTexture').addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const image = new Image();
                image.onload = () => {
                    // Create a texture that can be used for both preview and painting
                    uploadedTexture = new THREE.Texture(image);
                    uploadedTexture.needsUpdate = true;
                    
                    // Optional: Create a preview of the uploaded texture
                    const previewCanvas = document.getElementById('texturePreview');
                    if (previewCanvas) {
                        const ctx = previewCanvas.getContext('2d');
                        ctx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
                        ctx.drawImage(image, 0, 0, previewCanvas.width, previewCanvas.height);
                    }
                    
                    console.log('Texture loaded and ready for painting');
                };
                image.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
    });

    // Texture paint tool activation
    document.getElementById('texturePaint').addEventListener('click', () => {
        selectedTool = TOOLS.TEXTURE_PAINT;
        updateToolUI('texturePaint');
    });
    
    // Add this new function to update UI
    function updateToolUI(toolId) {
        document.querySelectorAll('.panel-button').forEach(button => {
            button.classList.remove('active');
        });
        document.getElementById(toolId).classList.add('active');
    }
    

    // Terrain creation button
    document.getElementById('addTerrain').addEventListener('click', createTerrain);

    // Brush size controls
    document.getElementById('brushSize').addEventListener('input', (e) => {
        brushSize = parseFloat(e.target.value);
    });

    document.getElementById('brushStrength').addEventListener('input', (e) => {
        brushStrength = parseFloat(e.target.value);
    });

   

    // Mouse move for brush preview
    renderer.domElement.addEventListener('mousemove', updateBrushPreview);

    // Add pointer events for sculpting and painting
    renderer.domElement.addEventListener('pointerdown', (event) => {
        isSculpting = true;
        if (selectedTool === 'texturePaint') {
            applyTexturePaint(event);
        } else if (selectedTool === 'colorPaint') {
            applyColorPaint(event);
        } else {
            applySculpting(event);
        }
    });

    renderer.domElement.addEventListener('pointermove', (event) => {
        if (isSculpting) {
            if (selectedTool === 'texturePaint') {
                applyTexturePaint(event);
            } else if (selectedTool === 'colorPaint') {
                applyColorPaint(event);
            } else {
                applySculpting(event);
            }
        }
    });
    

    renderer.domElement.addEventListener('pointerup', () => {
        isSculpting = false;
    });

    
    // Add listeners for advanced sculpting tools
    
    
    // Symmetry controls
    document.getElementById('symmetryToggle').addEventListener('change', (e) => {
        symmetryEnabled = e.target.checked;
    });
    
    document.getElementById('symmetryAxis').addEventListener('change', (e) => {
        symmetryAxis = e.target.value;
    });
    
    // History controls
    document.getElementById('undo').addEventListener('click', () => {
        if (undoStack.length > 0) {
            const currentState = terrain.geometry.attributes.position.array.slice();
            redoStack.push(currentState);
            
            const previousState = undoStack.pop();
            terrain.geometry.attributes.position.array.set(previousState);
            terrain.geometry.attributes.position.needsUpdate = true;
            terrain.geometry.computeVertexNormals();
        }
    });
    
    document.getElementById('redo').addEventListener('click', () => {
        if (redoStack.length > 0) {
            const currentState = terrain.geometry.attributes.position.array.slice();
            undoStack.push(currentState);
            
            const nextState = redoStack.pop();
            terrain.geometry.attributes.position.array.set(nextState);
            terrain.geometry.attributes.position.needsUpdate = true;
            terrain.geometry.computeVertexNormals();
        }
    });


    // Add helper function to find symmetry vertex index
    function findSymmetryVertexIndex(originalIndex, vertices) {
        const original = new THREE.Vector3(
            vertices.getX(originalIndex),
            vertices.getY(originalIndex),
            vertices.getZ(originalIndex)
        );
        
        // Create world position for more accurate symmetry
        const worldPosition = original.clone();
        terrain.localToWorld(worldPosition);
        
        // Create symmetry point
        const symmetryPoint = worldPosition.clone();
        symmetryPoint[symmetryAxis] *= -1;
        
        // Transform back to local space
        terrain.worldToLocal(symmetryPoint);
        
        let closestIndex = -1;
        let minDistance = Infinity;
        
        for (let i = 0; i < vertices.count; i++) {
            if (i === originalIndex) continue;
    
            const vertex = new THREE.Vector3(
                vertices.getX(i),
                vertices.getY(i),
                vertices.getZ(i)
            );
            
            // More precise symmetry detection
            const tolerance = 0.001;
            const isSymmetric = Math.abs(vertex[symmetryAxis] + original[symmetryAxis]) < tolerance;
            
            if (isSymmetric) {
                const otherAxes = ['x', 'y', 'z'].filter(axis => axis !== symmetryAxis);
                const matchesOtherAxes = otherAxes.every(axis => 
                    Math.abs(vertex[axis] - original[axis]) < tolerance
                );
                
                if (matchesOtherAxes) {
                    return i;
                }
                
                const distance = vertex.distanceTo(symmetryPoint);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestIndex = i;
                }
            }
        }
        
        return closestIndex;
    }
    
   
    
    // File operations
    document.getElementById('newScene').addEventListener('click', newScene);
    document.getElementById('saveScene').addEventListener('click', saveScene);
    document.getElementById('loadScene').addEventListener('click', loadScene);
    
    // Timeline controls
    document.getElementById('play').addEventListener('click', playAnimation);
    document.getElementById('pause').addEventListener('click', pauseAnimation);
    document.getElementById('stop').addEventListener('click', stopAnimation); 
 
     // Transform controls events
     transformControls.addEventListener('dragging-changed', function(event) {
         controls.enabled = !event.value;
     });
 
     transformControls.addEventListener('change', updateInspector);
 }
 
 function toggleModelingMode() {
    isModelingMode = !isModelingMode;
    const modelingButtons = ['select-vertex', 'select-edge', 'select-face'];
    modelingButtons.forEach(id => {
        document.getElementById(id).disabled = !isModelingMode;
    });

    if (isModelingMode && activeObject) {
        showMeshStructure(activeObject);
    } else {
        clearMeshStructure();
    }
}

function setSelectionMode(mode) {
    if (!isModelingMode) return;
    selectionMode = mode;
    clearSelection();
    if (activeObject) {
        showMeshStructure(activeObject);
    }
}

function showMeshStructure(object) {
    clearMeshStructure();
    if (!object || !object.geometry) return;

    const geometry = object.geometry;
    const positions = geometry.attributes.position;
    const matrix = object.matrixWorld;

    // Show vertices
    for (let i = 0; i < positions.count; i++) {
        const vertex = new THREE.Vector3();
        vertex.fromBufferAttribute(positions, i);
        vertex.applyMatrix4(matrix);

        const sphereGeom = new THREE.SphereGeometry(0.01);
        const sphereMat = new THREE.MeshBasicMaterial({ color: 0x222222 });
        const vertexMesh = new THREE.Mesh(sphereGeom, sphereMat);
        vertexMesh.position.copy(vertex);
        vertexMesh.userData.vertexIndex = i;
        vertexHelpers.add(vertexMesh);
    }

    // Show edges
    if (geometry.index) {
        const indices = geometry.index.array;
        for (let i = 0; i < indices.length; i += 3) {
            for (let j = 0; j < 3; j++) {
                const start = new THREE.Vector3();
                const end = new THREE.Vector3();
                start.fromBufferAttribute(positions, indices[i + j]);
                end.fromBufferAttribute(positions, indices[i + (j + 1) % 3]);
                start.applyMatrix4(matrix);
                end.applyMatrix4(matrix);

                const edgeGeom = new THREE.BufferGeometry();
                edgeGeom.setFromPoints([start, end]);
                const edgeMat = new THREE.LineBasicMaterial({ color: 0xE67E22 });
                const edge = new THREE.Line(edgeGeom, edgeMat);
                edgeHelpers.add(edge);
            }
        }
    }
}

function clearMeshStructure() {
    vertexHelpers.clear();
    edgeHelpers.clear();
    faceHelpers.clear();
    selectedElements.forEach(elem => scene.remove(elem));
    selectedElements = [];
}

function onModelingMouseMove(event) {
    if (!isModelingMode || !activeObject) return;

    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);

    // Highlight elements based on selection mode
    switch (selectionMode) {
        case 'vertex':
            highlightVertex();
            break;
        case 'edge':
            highlightEdge();
            break;
        case 'face':
            highlightFace();
            break;
    }
}

function onModelingClick(event) {
    if (!isModelingMode || !activeObject) return;

    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);

    switch (selectionMode) {
        case 'vertex':
            selectVertex();
            break;
        case 'edge':
            selectEdge();
            break;
        case 'face':
            selectFace();
            break;
    }
}

function selectVertex() {
    const intersects = raycaster.intersectObjects(vertexHelpers.children);
    if (intersects.length > 0) {
        const vertexMesh = intersects[0].object;
        transformControls.attach(vertexMesh);

        // تحديث موضع النقطة في المصفوفة الأصلية
        transformControls.addEventListener('objectChange', () => {
            const index = vertexMesh.userData.vertexIndex;
            const positions = activeObject.geometry.attributes.position;
            positions.setXYZ(index, vertexMesh.position.x, vertexMesh.position.y, vertexMesh.position.z);
            positions.needsUpdate = true;
            activeObject.geometry.computeVertexNormals();
        });
    }
}


function selectEdge() {
    const intersects = raycaster.intersectObjects(edgeHelpers.children);
    if (intersects.length > 0) {
        const edge = intersects[0].object;
        transformControls.attach(edge);

        transformControls.addEventListener('objectChange', () => {
            const positions = activeObject.geometry.attributes.position;
            const indices = edge.userData.indices;

            // تحديث مواضع النقاط المرتبطة بالحافة
            indices.forEach(index => {
                positions.setXYZ(index, edge.position.x, edge.position.y, edge.position.z);
            });

            positions.needsUpdate = true;
            activeObject.geometry.computeVertexNormals();
        });
    }
}


function selectFace() {
    const intersects = raycaster.intersectObject(activeObject);
    if (intersects.length > 0) {
        const face = intersects[0].face;
        const positions = activeObject.geometry.attributes.position;
        
        const faceVertices = [
            new THREE.Vector3().fromBufferAttribute(positions, face.a),
            new THREE.Vector3().fromBufferAttribute(positions, face.b),
            new THREE.Vector3().fromBufferAttribute(positions, face.c)
        ];

        const faceMesh = new THREE.Mesh(
            new THREE.BufferGeometry().setFromPoints(faceVertices),
            new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.5, side: THREE.DoubleSide })
        );

        scene.add(faceMesh);
        transformControls.attach(faceMesh);

        transformControls.addEventListener('objectChange', () => {
            positions.setXYZ(face.a, faceMesh.position.x, faceMesh.position.y, faceMesh.position.z);
            positions.setXYZ(face.b, faceMesh.position.x, faceMesh.position.y, faceMesh.position.z);
            positions.setXYZ(face.c, faceMesh.position.x, faceMesh.position.y, faceMesh.position.z);

            positions.needsUpdate = true;
            activeObject.geometry.computeVertexNormals();
        });
    }
}



 // Object creation functions
 function addCube() {
    const geometry = new THREE.BoxGeometry();
    const material = new THREE.MeshStandardMaterial({ color: 0x00ff00 , side: THREE.DoubleSide });
    const cube = new THREE.Mesh(geometry, material);
    addObjectToScene(cube, 'Cube');
    cube.position.set(0, 0, 0); // Start above ground
}


 function addPlane() {
    const geometry = new THREE.PlaneGeometry(10, 10); // Width: 10, Height: 10
    const material = new THREE.MeshStandardMaterial({ color: 0x87CEEB, side: THREE.DoubleSide });
    const plane = new THREE.Mesh(geometry, material);
    plane.rotation.x = -Math.PI / 2; // Rotate to lay flat on the ground
    addObjectToScene(plane, 'Plane');
}




let symmetryEnabled = false;
let symmetryAxis = 'x';
let undoStack = [];
let redoStack = [];
let lastSavedState = null;
let autoSaveInterval = 5000; 


let brushSize = 1.5; // Default brush size
let brushStrength = 0.1; // Default brush strength
let brushPreview; // Brush preview mesh


let terrain; // Reference to the terrain
let selectedTool = null; // Current active tool
let isSculpting = false; // Flag for sculpting state
let uploadedTexture = null; // Stores the uploaded texture for painting

const TOOLS = {
    RAISE_LOWER: 'raiseLower',
    SMOOTH: 'smooth',
    FLATTEN: 'flatten',
    NOISE: 'noise',
    PINCH: 'pinch',
    CLAY: 'clay',
    SCRAPE: 'scrape',
    FILL: 'fill',
    TEXTURE_PAINT: 'texturePaint',
    TERRACE: 'terrace',
    EROSION: 'erosion',
    RIDGE: 'ridge',
    CANYON: 'canyon',
    PLATEAU: 'plateau',
    SLOPE: 'slope',
    BLUR: 'blur',
    SHARPEN: 'sharpen'
};



function applySymmetry(originalVertex, index, vertices) {
    if (!symmetryEnabled) return;

    const symmetryVertex = originalVertex.clone();
    symmetryVertex[symmetryAxis] *= -1;

    // search symitry point
    const tolerance = 0.0001;
    for (let i = 0; i < vertices.count; i++) {
        if (i === index) continue;
        
        const vertex = new THREE.Vector3(
            vertices.getX(i),
            vertices.getY(i),
            vertices.getZ(i)
        );

        if (Math.abs(vertex[symmetryAxis] + originalVertex[symmetryAxis]) < tolerance &&
            Math.abs(vertex[(symmetryAxis === 'x' ? 'z' : 'x')] - originalVertex[(symmetryAxis === 'x' ? 'z' : 'x')]) < tolerance) {
            vertices.setXYZ(i, symmetryVertex.x, symmetryVertex.y, symmetryVertex.z);
            break;
        }
    }
}



function createTerrain() {
    // Create geometry
    const geometry = new THREE.PlaneGeometry(50, 50, 100, 100);
    geometry.rotateX(-Math.PI / 2);

    // Create initial texture
    const canvas = document.createElement('canvas');
    canvas.width = 1024;
    canvas.height = 1024;
    const ctx = canvas.getContext('2d');

    // Fill with green color
    ctx.fillStyle = '#87CEEB'; 
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const texture = new THREE.CanvasTexture(canvas);
    texture.needsUpdate = true;

    // Create material with proper settings
    material = new THREE.MeshStandardMaterial({ 
        color: 0x87CEEB,
        map: texture,
        side: THREE.DoubleSide 
    });

    // Create mesh
    terrain = new THREE.Mesh(geometry, material);
    terrain.userData.textureCanvas = canvas;
    terrain.userData.textureContext = ctx;
    terrain.geometry.attributes.position.needsUpdate = true;
    terrain.receiveShadow = true;
    terrain.castShadow = true;


    scene.add(terrain);
    addObjectToScene(terrain, 'Terrain');


    createBrushPreview();

    // Initialize brush system
    if (!window.brushSystem) {
        window.brushSystem = new TerrainBrushSystem(scene, camera, renderer, terrain);
    }   
}




// Create advanced brush preview
function createBrushPreview() {
    if (brushPreview) {
        scene.remove(brushPreview);
    }

    // Create inner circle
    const innerGeometry = new THREE.CircleGeometry(1, 32);
    const innerMaterial = new THREE.MeshBasicMaterial({
        color: 0x4A90E2,
        transparent: true,
        opacity: 0.3,
        side: THREE.DoubleSide
    });
    
    // Create outer circle (falloff indicator)
    const outerGeometry = new THREE.RingGeometry(0.8, 1, 32);
    const outerMaterial = new THREE.MeshBasicMaterial({
        color: 0x4A90E2,
        transparent: true,
        opacity: 0.15,
        side: THREE.DoubleSide
    });

    // Create direction indicator for certain tools
    const directionGeometry = new THREE.ConeGeometry(0.2, 0.5, 32);
    const directionMaterial = new THREE.MeshBasicMaterial({
        color: 0xEE82EE,
        transparent: true,
        opacity: 0.5
    });

    const innerCircle = new THREE.Mesh(innerGeometry, innerMaterial);
    const outerCircle = new THREE.Mesh(outerGeometry, outerMaterial);
    const directionIndicator = new THREE.Mesh(directionGeometry, directionMaterial);

    brushPreview = new THREE.Group();
    brushPreview.add(innerCircle);
    brushPreview.add(outerCircle);
    brushPreview.add(directionIndicator);
    
    brushPreview.rotation.x = -Math.PI / 2;
    brushPreview.visible = false;
    scene.add(brushPreview);
}


// Update brush preview with advanced features
function updateBrushPreview(event) {
    if (!terrain || !brushPreview) return;

    const mouse = new THREE.Vector2(
        (event.clientX / window.innerWidth) * 2 - 1,
        -(event.clientY / window.innerHeight) * 2 + 1
    );

    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(terrain);

    if (intersects.length > 0) {
        const intersect = intersects[0];
        brushPreview.position.copy(intersect.point);
        brushPreview.scale.set(brushSize, brushSize, 1);

        // Update direction indicator based on normal
        const normal = intersect.face.normal.clone();
        normal.transformDirection(terrain.matrixWorld);
        
        // Only show brush preview when a sculpting tool is selected
        brushPreview.visible = Object.values(TOOLS).includes(selectedTool);

        // Show symmetry preview if enabled
        if (symmetryEnabled) {
            // Create or update symmetry preview
            if (!brushPreview.userData.symmetryPreview) {
                brushPreview.userData.symmetryPreview = brushPreview.clone();
                scene.add(brushPreview.userData.symmetryPreview);
            }
            
            const symmetryPosition = intersect.point.clone();
            symmetryPosition[symmetryAxis] *= -1;
            brushPreview.userData.symmetryPreview.position.copy(symmetryPosition);
            brushPreview.userData.symmetryPreview.scale.copy(brushPreview.scale);
            brushPreview.userData.symmetryPreview.visible = true;
        } else if (brushPreview.userData.symmetryPreview) {
            brushPreview.userData.symmetryPreview.visible = false;
        }
    } else {
        brushPreview.visible = false;
        if (brushPreview.userData.symmetryPreview) {
            brushPreview.userData.symmetryPreview.visible = false;
        }
    }
}

// Save terrain state for undo/redo
function saveTerrainState() {
    const positions = terrain.geometry.attributes.position.array.slice();
    undoStack.push(positions);
    redoStack.length = 0; // Clear redo stack when new action is performed
    
    // Limit undo stack size
    if (undoStack.length > 20) {
        undoStack.shift();
    }
}

// Advanced sculpting functions
function pinchTerrain(vertex, position, influence) {
    const direction = new THREE.Vector3().subVectors(position, vertex);
    vertex.add(direction.multiplyScalar(influence * brushStrength));
}

function clayTerrain(vertex, position, influence, normal) {
    const offset = normal.multiplyScalar(brushStrength * influence);
    if (vertex.y < position.y) {
        vertex.add(offset);
    }
}

function scrapeTerrain(vertex, position, influence, normal) {
    const offset = normal.multiplyScalar(-brushStrength * influence);
    if (vertex.y > position.y) {
        vertex.add(offset);
    }
}

function fillTerrain(vertex, position, influence) {
    if (vertex.y < position.y) {
        vertex.y += brushStrength * influence;
    }
}



function startSculpting(event) {
    isSculpting = true;
    applySculpting(event);
    applySculpting1(event);
}

function stopSculpting() {
    isSculpting = false;
}

// تحسين دالة معالجة النحت
function applySculpting(event) {
    if (!isSculpting || !selectedTool || !terrain) return;

    const mouse = new THREE.Vector2(
        (event.clientX / window.innerWidth) * 2 - 1,
        -(event.clientY / window.innerHeight) * 2 + 1
    );
    
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(terrain);
    
    if (intersects.length > 0) {
        // Save state for undo/redo
        if (!lastSavedState || Date.now() - lastSavedState > autoSaveInterval) {
            saveTerrainState();
            lastSavedState = Date.now();
        }
        
        const intersect = intersects[0];
        const vertices = terrain.geometry.attributes.position;
        const position = intersect.point.clone();
        const normal = intersect.face.normal.clone().transformDirection(terrain.matrixWorld);
        
        // Transform position to local space
        terrain.worldToLocal(position);
        
        for (let i = 0; i < vertices.count; i++) {
            const vertex = new THREE.Vector3(
                vertices.getX(i),
                vertices.getY(i),
                vertices.getZ(i)
            );
            
            const distance = vertex.distanceTo(position);
            if (distance < brushSize) {
                const influence = Math.pow(1 - (distance / brushSize), 2); // Smoother falloff
                const originalVertex = vertex.clone();
                
                // Apply tool effect
                switch (selectedTool) {
                    case TOOLS.RAISE_LOWER:
                        vertex.y += brushStrength * influence;
                        break;
                    case TOOLS.SMOOTH:
                        vertex.y += (position.y - vertex.y) * influence * brushStrength;
                        break;
                    case TOOLS.FLATTEN:
                        vertex.y += (position.y - vertex.y) * influence;
                        break;
                    case TOOLS.NOISE:
                        vertex.y += (Math.random() - 0.5) * brushStrength * influence * 2;
                        break;
                    case TOOLS.PINCH:
                        const toCenter = new THREE.Vector3().subVectors(position, vertex);
                        vertex.add(toCenter.multiplyScalar(influence * brushStrength));
                        break;
                    case TOOLS.CLAY:
                        if (vertex.y < position.y) {
                            vertex.add(normal.clone().multiplyScalar(brushStrength * influence));
                        }
                        break;
                    case TOOLS.SCRAPE:
                        if (vertex.y > position.y) {
                            vertex.add(normal.clone().multiplyScalar(-brushStrength * influence));
                        }
                        break;
                    case TOOLS.FILL:
                        if (vertex.y < position.y) {
                            vertex.y += brushStrength * influence;
                        }
                        break;

                        case TOOLS.TERRACE:
                        applyTerrace(vertex, position, influence);
                        break;
                    case TOOLS.EROSION:
                        applyErosion(vertex, position, influence, vertices, i);
                        break;
                    case TOOLS.RIDGE:
                        applyRidge(vertex, position, influence);
                        break;
                    case TOOLS.CANYON:
                        applyCanyon(vertex, position, influence);
                        break;
                    case TOOLS.PLATEAU:
                        applyPlateau(vertex, position, influence);
                        break;
                    case ADVANCED_TOOLS.SLOPE:
                        applySlope(vertex, position, influence, normal);
                        break;
                    case TOOLS.BLUR:
                        applyBlur(vertex, position, influence, vertices, i);
                        break;
                    case TOOLS.SHARPEN:
                        applySharpen(vertex, position, influence, vertices, i);
                        break;
                }
                
                vertices.setXYZ(i, vertex.x, vertex.y, vertex.z);
                
                // Apply symmetry
                if (symmetryEnabled) {
                    const symmetryPosition = position.clone();
                    symmetryPosition[symmetryAxis] *= -1;
                    
                    for (let i = 0; i < vertices.count; i++) {
                        const vertex = new THREE.Vector3(
                            vertices.getX(i),
                            vertices.getY(i),
                            vertices.getZ(i)
                        );
                        
                        const distance = vertex.distanceTo(position);
                        const symmetryDistance = vertex.distanceTo(symmetryPosition);
                        
                        if (distance < brushSize) {
                            const influence = Math.pow(1 - (distance / brushSize), 2);
                            
                            // Apply tool effect to original position
                            switch (selectedTool) {
                                case TOOLS.PINCH:
                                    pinchTerrain(vertex, position, influence);
                                    break;
                                    case TOOLS.RAISE_LOWER:
                                    vertex.y += brushStrength * influence;
                                    break;
                                case TOOLS.SMOOTH:
                                    vertex.y += (position.y - vertex.y) * influence * brushStrength;
                                    break;
                                case TOOLS.FLATTEN:
                                    vertex.y += (position.y - vertex.y) * influence;
                                    break;
                                case TOOLS.NOISE:
                                    vertex.y += (Math.random() - 0.5) * brushStrength * influence * 2;
                                    break;
                                
                                case TOOLS.CLAY:
                                    if (vertex.y < position.y) {
                                        vertex.add(normal.clone().multiplyScalar(brushStrength * influence));
                                    }
                                    break;
                                case TOOLS.SCRAPE:
                                    if (vertex.y > position.y) {
                                        vertex.add(normal.clone().multiplyScalar(-brushStrength * influence));
                                    }
                                    break;
                                case TOOLS.FILL:
                                    if (vertex.y < position.y) {
                                        vertex.y += brushStrength * influence;
                                    }
                                    break;
            
                                    case TOOLS.TERRACE:
                                    applyTerrace(vertex, position, influence);
                                    break;
                                case TOOLS.EROSION:
                                    applyErosion(vertex, position, influence, vertices, i);
                                    break;
                                case TOOLS.RIDGE:
                                    applyRidge(vertex, position, influence);
                                    break;
                                case TOOLS.CANYON:
                                    applyCanyon(vertex, position, influence);
                                    break;
                                case TOOLS.PLATEAU:
                                    applyPlateau(vertex, position, influence);
                                    break;
                                case ADVANCED_TOOLS.SLOPE:
                                    applySlope(vertex, position, influence, normal);
                                    break;
                                case TOOLS.BLUR:
                                    applyBlur(vertex, position, influence, vertices, i);
                                    break;
                                case TOOLS.SHARPEN:
                                    applySharpen(vertex, position, influence, vertices, i);
                                    break;
                               
                            }
                            
                            vertices.setXYZ(i, vertex.x, vertex.y, vertex.z);
                        }
                        
                        // Separately apply to symmetry position
                        if (symmetryDistance < brushSize) {
                            const symmetryInfluence = Math.pow(1 - (symmetryDistance / brushSize), 2);
                            
                            switch (selectedTool) {
                                case TOOLS.PINCH:
                                    pinchTerrain(vertex, symmetryPosition, symmetryInfluence);
                                    break;

                                    case TOOLS.RAISE_LOWER:
                                    vertex.y += brushStrength * influence;
                                    break;
                                case TOOLS.SMOOTH:
                                    vertex.y += (position.y - vertex.y) * influence * brushStrength;
                                    break;
                                case TOOLS.FLATTEN:
                                    vertex.y += (position.y - vertex.y) * influence;
                                    break;
                                case TOOLS.NOISE:
                                    vertex.y += (Math.random() - 0.5) * brushStrength * influence * 2;
                                    break;
                                
                                case TOOLS.CLAY:
                                    if (vertex.y < position.y) {
                                        vertex.add(normal.clone().multiplyScalar(brushStrength * influence));
                                    }
                                    break;
                                case TOOLS.SCRAPE:
                                    if (vertex.y > position.y) {
                                        vertex.add(normal.clone().multiplyScalar(-brushStrength * influence));
                                    }
                                    break;
                                case TOOLS.FILL:
                                    if (vertex.y < position.y) {
                                        vertex.y += brushStrength * influence;
                                    }
                                    break;
            
                                    case TOOLS.TERRACE:
                                    applyTerrace(vertex, position, influence);
                                    break;
                                case TOOLS.EROSION:
                                    applyErosion(vertex, position, influence, vertices, i);
                                    break;
                                case TOOLS.RIDGE:
                                    applyRidge(vertex, position, influence);
                                    break;
                                case TOOLS.CANYON:
                                    applyCanyon(vertex, position, influence);
                                    break;
                                case TOOLS.PLATEAU:
                                    applyPlateau(vertex, position, influence);
                                    break;
                                case ADVANCED_TOOLS.SLOPE:
                                    applySlope(vertex, position, influence, normal);
                                    break;
                                case TOOLS.BLUR:
                                    applyBlur(vertex, position, influence, vertices, i);
                                    break;
                                case TOOLS.SHARPEN:
                                    applySharpen(vertex, position, influence, vertices, i);
                                    break;
                                
                            }
                            
                            vertices.setXYZ(i, vertex.x, vertex.y, vertex.z);
                        }
                    }
                }
            }
        }
        
        vertices.needsUpdate = true;
        terrain.geometry.computeVertexNormals();
    }
}



function applyTexturePaint(event) {
    if (!terrain || !terrain.userData.blendMapCanvas || textureArray.length === 0) return;

    const mouse = new THREE.Vector2(
        (event.clientX / window.innerWidth) * 2 - 1,
        -(event.clientY / window.innerHeight) * 2 + 1
    );

    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(terrain);

    if (intersects.length > 0) {
        const intersect = intersects[0];
        const uv = intersect.uv;
        const ctx = terrain.userData.blendMapContext;
        const canvas = terrain.userData.blendMapCanvas;
        
        const x = uv.x * canvas.width;
        const y = (1 - uv.y) * canvas.height;
        const radius = brushSize * canvas.width / 2;

        // Create brush gradient
        const gradient = ctx.createRadialGradient(
            x, y, 0,
            x, y, radius
        );

        gradient.addColorStop(0, `rgba(255, 255, 255, ${brushStrength})`);
        gradient.addColorStop(0.7, `rgba(255, 255, 255, ${brushStrength * 0.5})`);
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

        ctx.save();

        // Clear area for new texture
        ctx.globalCompositeOperation = 'destination-out';
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();

        // Apply new texture blend
        ctx.globalCompositeOperation = 'source-over';
        
        // Create color for active texture channel
        const color = new Array(4).fill(0);
        color[activeTextureIndex] = 255;
        ctx.fillStyle = `rgba(${color.join(',')})`;
        
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();

        // Update terrain texture
        blendMap.needsUpdate = true;
    }
}






function addSphere() {
    const geometry = new THREE.SphereGeometry(0.5, 32, 32);
    const material = new THREE.MeshStandardMaterial({ color: 0xff0000, side: THREE.DoubleSide });
    const sphere = new THREE.Mesh(geometry, material);
    addObjectToScene(sphere, 'Sphere');
    meshes.push(sphere);
}
 
 function addCylinder() {
     const geometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 32);
     const material = new THREE.MeshStandardMaterial({ color: 0x0000ff, side: THREE.DoubleSide });
     const cylinder = new THREE.Mesh(geometry, material);
     addObjectToScene(cylinder, 'Cylinder');
    meshes.push(cylinder);
 }
 
 // Function to add a Pyramid
function addPyramid() {
    const geometry = new THREE.ConeGeometry(1, 2, 4); // Base radius 1, height 2, 4 sides
    const material = new THREE.MeshStandardMaterial({ color: 0xFFD700, side: THREE.DoubleSide });
    const pyramid = new THREE.Mesh(geometry, material);
    pyramid.position.set(0, 1, 0);
    addObjectToScene(pyramid, 'Pyramid');
    meshes.push(pyramid);
}

// Function to add a Rectangular Prism
function addRectangularPrism() {
    const geometry = new THREE.BoxGeometry(1, 2, 3); // Adjust dimensions for rectangular prism
    const material = new THREE.MeshStandardMaterial({ color: 0x8A2BE2, side: THREE.DoubleSide  });
    const rectangularPrism = new THREE.Mesh(geometry, material);
    rectangularPrism.position.set(0, 1, 0);
    addObjectToScene(rectangularPrism, 'Rectangular Prism');
    meshes.push(rectangularPrism);
}

// Function to add a Torus (Donut Shape)
function addTorus() {
    const geometry = new THREE.TorusGeometry(1, 0.4, 16, 100); // Radius 1, tube radius 0.4
    const material = new THREE.MeshStandardMaterial({ color: 0xFF4500, side: THREE.DoubleSide  });
    const torus = new THREE.Mesh(geometry, material);
    torus.position.set(0, 1, 0);
    addObjectToScene(torus, 'Torus');
    meshes.push(torus);
}

 function addLight() {
    const light = new THREE.PointLight(0xffffff, 1);
    light.position.set(0, 2, 0);
    addObjectToScene(light, 'Light');
 }
 
function addCameraInit() {
    const newCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    newCamera.position.set(0, 0, 5);
    addObjectToScene(newCamera, 'Camera');
}




// Advanced tool implementations
function applyTerrace(vertex, position, influence) {
    const steps = parseInt(document.getElementById('terraceSteps').value);
    const heightDiff = position.y - vertex.y;
    const stepHeight = heightDiff / steps;
    
    // Calculate closest step
    const currentStep = Math.round(vertex.y / stepHeight);
    const targetHeight = currentStep * stepHeight;
    
    // Smooth transition between steps
    vertex.y += (targetHeight - vertex.y) * influence * brushStrength;
}

function applyErosion(vertex, position, influence, vertices, index) {
    const erosionStrength = parseFloat(document.getElementById('erosionStrength').value);
    const radius = brushSize * 2;
    let avgHeight = 0;
    let count = 0;
    
    // Sample neighboring vertices
    for (let i = 0; i < vertices.count; i++) {
        const neighborVertex = new THREE.Vector3(
            vertices.getX(i),
            vertices.getY(i),
            vertices.getZ(i)
        );
        
        const distance = vertex.distanceTo(neighborVertex);
        if (distance < radius && distance > 0) {
            avgHeight += neighborVertex.y;
            count++;
        }
    }
    
    if (count > 0) {
        avgHeight /= count;
        const heightDiff = vertex.y - avgHeight;
        vertex.y -= heightDiff * erosionStrength * influence;
    }
}

function applyRidge(vertex, position, influence) {
    const ridgeHeight = parseFloat(document.getElementById('ridgeHeight').value);
    const distance = Math.abs(vertex.x - position.x);
    const falloff = 1 - Math.min(distance / brushSize, 1);
    
    if (falloff > 0) {
        // Create ridge shape using sine function
        const ridge = Math.sin(falloff * Math.PI) * ridgeHeight;
        vertex.y += ridge * influence * brushStrength;
    }
}

function applyCanyon(vertex, position, influence) {
    const depth = brushStrength * 2;
    const distance = Math.abs(vertex.x - position.x);
    const falloff = 1 - Math.min(distance / brushSize, 1);
    
    if (falloff > 0) {
        // Create canyon shape using exponential function
        const canyon = Math.exp(-falloff * 2) * depth;
        vertex.y -= canyon * influence;
    }
}

function applyPlateau(vertex, position, influence) {
    const targetHeight = position.y;
    const threshold = brushSize * 0.3;
    const distance = vertex.distanceTo(position);
    
    if (distance < threshold) {
        // Flat plateau area
        vertex.y += (targetHeight - vertex.y) * influence;
    } else if (distance < brushSize) {
        // Smooth transition to plateau
        const falloff = 1 - ((distance - threshold) / (brushSize - threshold));
        vertex.y += (targetHeight - vertex.y) * falloff * influence;
    }
}

function applySlope(vertex, position, influence, normal) {
    const angle = Math.PI / 4; // 45-degree slope
    const direction = new THREE.Vector3().subVectors(position, vertex);
    const distance = direction.length();
    
    if (distance < brushSize) {
        const targetHeight = position.y - Math.tan(angle) * distance;
        vertex.y += (targetHeight - vertex.y) * influence;
    }
}

function applyBlur(vertex, position, influence, vertices, index) {
    const radius = brushSize * 1.5;
    let avgHeight = 0;
    let totalWeight = 0;
    
    // Gaussian blur
    for (let i = 0; i < vertices.count; i++) {
        const neighborVertex = new THREE.Vector3(
            vertices.getX(i),
            vertices.getY(i),
            vertices.getZ(i)
        );
        
        const distance = vertex.distanceTo(neighborVertex);
        if (distance < radius) {
            const weight = Math.exp(-(distance * distance) / (2 * radius * radius));
            avgHeight += neighborVertex.y * weight;
            totalWeight += weight;
        }
    }
    
    if (totalWeight > 0) {
        avgHeight /= totalWeight;
        vertex.y += (avgHeight - vertex.y) * influence * brushStrength;
    }
}

function applySharpen(vertex, position, influence, vertices, index) {
    const radius = brushSize;
    let avgHeight = 0;
    let count = 0;
    
    // Calculate local average height
    for (let i = 0; i < vertices.count; i++) {
        const neighborVertex = new THREE.Vector3(
            vertices.getX(i),
            vertices.getY(i),
            vertices.getZ(i)
        );
        
        const distance = vertex.distanceTo(neighborVertex);
        if (distance < radius && distance > 0) {
            avgHeight += neighborVertex.y;
            count++;
        }
    }
    
    if (count > 0) {
        avgHeight /= count;
        const heightDiff = vertex.y - avgHeight;
        vertex.y += heightDiff * influence * brushStrength;
    }
}



function addObjectToScene(object, name) {
    object.userData.selectable = true; // Mark object as selectable
    object.name = name + '_' + objects.length;
    objects.push(object);
    scene.add(object);
    updateHierarchy();
    selectObject(object);
}

const COLORS = { 
    HIGHLIGHT: 0x00e5ff,  // Neon Cyan (Beautiful Highlight)
    SELECTED: 0x00ff80    // Emerald Green (Elegant Selection)
};

// Material for highlighted objects (e.g., during operations)
const highlightMaterial = new THREE.MeshStandardMaterial({
    color: COLORS.HIGHLIGHT,
    emissive: COLORS.HIGHLIGHT,
    emissiveIntensity: 0.3,  // Soft glow effect
    side: THREE.DoubleSide,
    transparent: true,
    opacity: 0.6,  // More visible
    roughness: 0.2,
    metalness: 0.2
});

// 🔹 Selected Material (Emissive glow with subtle pulse)
const selectedMaterial = new THREE.MeshStandardMaterial({
    color: COLORS.SELECTED,
    emissive: COLORS.SELECTED, 
    emissiveIntensity: 0.7,  // Brighter glow
    side: THREE.DoubleSide,
    roughness: 0.1,
    metalness: 0.3
});

// 🔹 Smooth Material Transitions with Animated Glow
function animateMaterialChange(object, targetMaterial) {
    if (!object) return;

    gsap.to(object.material.color, {
        r: targetMaterial.color.r,
        g: targetMaterial.color.g,
        b: targetMaterial.color.b,
        duration: 0.4
    });

    gsap.to(object.material.emissive, {
        r: targetMaterial.emissive.r,
        g: targetMaterial.emissive.g,
        b: targetMaterial.emissive.b,
        duration: 0.6
    });

    gsap.to(object.material, {
        emissiveIntensity: targetMaterial === selectedMaterial ? 1 : 0.3,  // Pulsating glow on selection
        duration: 0.8,
        repeat: targetMaterial === selectedMaterial ? -1 : 0,
        yoyo: targetMaterial === selectedMaterial
    });

    object.material.needsUpdate = true;
}


// State management
let hoveredObject = null;
const originalMaterials = new WeakMap();
const selectionHandlers = new Set();


// Selection management functions
function addSelectionHandler(handler) {
    selectionHandlers.add(handler);
}

function removeSelectionHandler(handler) {
    selectionHandlers.delete(handler);
}

function notifySelectionHandlers(object) {
    selectionHandlers.forEach(handler => handler(object));
}

function clearSelection() {
    // Clear hover state
    if (hoveredObject) {
        restoreOriginalMaterial(hoveredObject);
        hoveredObject = null;
    }

    // Clear selection state
    if (selectedObject) {
        restoreOriginalMaterial(selectedObject);

        if (selectedObject.helper) {
            selectedObject.helper.visible = false;
        }

        if (window.transformControls) {
            window.transformControls.detach();
        }

        selectedObject = null;
        
        // Notify handlers that selection was cleared
        notifySelectionHandlers(null);
    }
}

function restoreOriginalMaterial(object) {
    if (object && originalMaterials.has(object)) {
        const originalMaterial = originalMaterials.get(object);
        object.material = originalMaterial;
        originalMaterials.delete(object);
    }
}



function selectObject(newObject) {
    activeObject = newObject;
        if (isModelingMode) {
           showMeshStructure(newobject);
    }
    try {
        if (newObject) {
            ensureObjectUUID(newObject);
        }
        // If selecting the same object, do nothing
        if (selectedObject === newObject) return selectedObject;

        // Clear hover state if the hovered object is being selected
        if (hoveredObject === newObject) {
            hoveredObject = null;
        }

        // Restore previous selection's material
        if (selectedObject) {
            restoreOriginalMaterial(selectedObject);
            
            if (selectedObject.helper) {
                selectedObject.helper.visible = false;
            }
        }

       

        selectedObject = newObject;

        // Handle new selection
        if (selectedObject) {
            // Store and apply selection material
           


            if (selectedObject.helper) {
                selectedObject.helper.visible = true;
            }

            transformControls.attach(selectedObject);

            if (selectedObject.isLight) {
                updateLightUI(selectedObject);
            } else if (selectedObject.isCamera) {
                updateCameraUI(selectedObject);
            }
        } else {
            transformControls.detach();
        }

        // Notify handlers of selection change
        notifySelectionHandlers(selectedObject);
        
        updateInspector();
        updateHierarchySelection();
        return selectedObject;

    } catch (error) {
        console.error('Error in selectObject:', error);
        throw error;
    }
}


function setHoverObject(object) {
    // If trying to hover the selected object, ignore
    if (object === selectedObject) return;
    
    // If current hover is same as new hover, do nothing
    if (hoveredObject === object) return;

    // Clear previous hover state
    if (hoveredObject) {
        restoreOriginalMaterial(hoveredObject);
    }

    hoveredObject = object;

    // Apply hover material only if object exists and isn't selected
    if (object && object !== selectedObject) {
        if (object.material && !object.isLight) {
        }
    }
}


// Hierarchy view functions
function getObjectIcon(obj) {
    if (obj.isLight) return '💡';
    if (obj.isCamera) return '🎥';
    if (obj.isMesh) return '📦';
    if (obj.isGroup) return '📁';
    return '⚪';
}

function createHierarchyItem(obj, level = 0) {
    const item = document.createElement('div');
    item.className = 'hierarchy-item';
    item.dataset.uuid = obj.uuid || generateUUID();
    item.draggable = true;
    
    const content = document.createElement('div');
    content.className = 'hierarchy-item-content';
    content.style.paddingLeft = `${level * 20}px`;
    
    // Add expand/collapse toggle for objects with children
    if (obj.children && obj.children.length > 0) {
        const toggle = document.createElement('span');
        toggle.className = 'hierarchy-toggle';
        toggle.innerHTML = obj.expanded ? '▼' : '▶';
        toggle.onclick = (e) => {
            e.stopPropagation();
            obj.expanded = !obj.expanded;
            updateHierarchy();
        };
        content.appendChild(toggle);
    }

    // Add icon and name
    const icon = document.createElement('span');
    icon.className = 'hierarchy-icon';
    icon.innerHTML = getObjectIcon(obj);
    content.appendChild(icon);

    
    const name = document.createElement('span');
    name.className = 'hierarchy-name';
    name.style.cssText = 'max-width: 110px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;';
    name.textContent = obj.name || `${obj.type || 'Object'}_${obj.id}`;
    content.appendChild(name);


    // Add visibility toggle
    const visibilityToggle = document.createElement('button');
    visibilityToggle.className = 'hierarchy-visibility';
    visibilityToggle.innerHTML = obj.visible ? '👁️' : '👁️‍🗨️';
    visibilityToggle.onclick = (e) => {
        e.stopPropagation();
        obj.visible = !obj.visible;
        visibilityToggle.innerHTML = obj.visible ? '👁️' : '👁️‍🗨️';
    };
    content.appendChild(visibilityToggle);

    // Add properties if available
    if (obj.geometry || obj.material) {
        const properties = document.createElement('div');
        properties.className = 'hierarchy-properties';
        
        if (obj.geometry) {
            const vertCount = document.createElement('span');
            vertCount.className = 'property';
            vertCount.textContent = `Verts: ${obj.geometry.attributes.position.count}`;
            properties.appendChild(vertCount);
        }
        
        if (obj.material) {
            const matType = document.createElement('span');
            matType.className = 'property';
            matType.textContent = `Mat: ${obj.material.type}`;
            properties.appendChild(matType);
        }
        
        content.appendChild(properties);
    }

    item.appendChild(content);

    if (selectedObject && selectedObject.uuid === obj.uuid) {
        item.classList.add('selected');
    }
  
    // Selection handling
    item.onclick = (e) => {
        e.stopPropagation();
        selectObject(obj);
    };

    // Hover handling
    item.onmouseenter = () => {
        if (obj !== selectedObject) {
            setHoverObject(obj);
        }
    };
    
    item.onmouseleave = () => {
        if (obj !== selectedObject) {
            setHoverObject(null);
        }
    };

    // Drag and drop handling
    setupDragAndDrop(item, obj);

    // Highlight if selected
    if (selectedObject === obj) {
        item.classList.add('selected');
    }

    return item;
}

function ensureObjectUUID(obj) {
    if (!obj.uuid) {
        obj.uuid = THREE.MathUtils.generateUUID();
    }
    return obj.uuid;
}

// Drag and drop handling
let draggedItem = null;
let dropTarget = null;

function setupDragAndDrop(item, obj) {
    item.ondragstart = (e) => {
        draggedItem = obj;
        item.classList.add('dragging');
        e.dataTransfer.setData('text/plain', obj.uuid);
    };

    item.ondragend = () => {
        item.classList.remove('dragging');
        draggedItem = null;
        clearDropTargets();
    };

    item.ondragover = (e) => {
        e.preventDefault();
        if (draggedItem && canDrop(draggedItem, obj)) {
            item.classList.add('drop-target');
            dropTarget = obj;
        }
    };

    item.ondragleave = () => {
        item.classList.remove('drop-target');
        dropTarget = null;
    };

    item.ondrop = (e) => {
        e.preventDefault();
        if (draggedItem && dropTarget) {
            handleDrop(draggedItem, dropTarget);
        }
        clearDropTargets();
    };
}

function canDrop(draggedObj, targetObj) {
    if (draggedObj === targetObj) return false;
    let parent = targetObj.parent;
    while (parent) {
        if (parent === draggedObj) return false;
        parent = parent.parent;
    }
    return true;
}

function handleDrop(draggedObj, targetObj) {
    const oldParent = draggedObj.parent;
    oldParent.remove(draggedObj);
    targetObj.add(draggedObj);
    updateHierarchy();
}

function clearDropTargets() {
    const dropTargets = document.querySelectorAll('.drop-target');
    dropTargets.forEach(el => el.classList.remove('drop-target'));
    dropTarget = null;
}

function updateHierarchy() {
    const container = document.getElementById('hierarchy-content');
    container.innerHTML = '';

    function addChildrenToHierarchy(parent, level) {
        parent.children.forEach(child => {
            container.appendChild(createHierarchyItem(child, level));
            if (child.expanded && child.children.length > 0) {
                addChildrenToHierarchy(child, level + 1);
            }
        });
    }

    objects.forEach(obj => {
        container.appendChild(createHierarchyItem(obj, 0));
        if (obj.expanded) {
            addChildrenToHierarchy(obj, 1);
        }
    });
}


// Material cache for highlighting

 function updateInspector() {
     if (!selectedObject) return;
 
     document.getElementById('posX').value = selectedObject.position.x;
     document.getElementById('posY').value = selectedObject.position.y;
     document.getElementById('posZ').value = selectedObject.position.z;
 
     document.getElementById('rotX').value = selectedObject.rotation.x;
     document.getElementById('rotY').value = selectedObject.rotation.y;
     document.getElementById('rotZ').value = selectedObject.rotation.z;
 
     document.getElementById('scaleX').value = selectedObject.scale.x;
     document.getElementById('scaleY').value = selectedObject.scale.y;
     document.getElementById('scaleZ').value = selectedObject.scale.z;
 }
 
 function updateHierarchySelection() {
    // Get all hierarchy items
    const items = document.querySelectorAll('.hierarchy-item');
    
    // Remove selected class from all items first
    items.forEach(item => {
        item.classList.remove('selected');
    });
    
    // If there's a selected object, find and highlight its item
    if (selectedObject) {
        // Use UUID for reliable object matching
        const selectedItem = document.querySelector(`.hierarchy-item[data-uuid="${selectedObject.uuid}"]`);
        if (selectedItem) {
            selectedItem.classList.add('selected');
            
            // Ensure the selected item is visible by expanding its parents
            let parent = selectedItem.parentElement;
            while (parent) {
                const parentItem = parent.closest('.hierarchy-item');
                if (parentItem) {
                    const toggle = parentItem.querySelector('.hierarchy-toggle');
                    if (toggle && toggle.innerHTML === '▶') {
                        // If parent is collapsed, expand it
                        const parentObj = objects.find(obj => obj.uuid === parentItem.dataset.uuid);
                        if (parentObj) {
                            parentObj.expanded = true;
                            updateHierarchy(); // This will rebuild the hierarchy with expanded parent
                            return; // Exit as updateHierarchy will call updateHierarchySelection again
                        }
                    }
                }
                parent = parent.parentElement;
            }
        }
    }
}

 
// Available Transform Modes
const TRANSFORM_MODES = ['translate', 'rotate', 'scale', 'mirror', 'snap', 'shear', 'reset'];

// Function to Set Transform Mode
function setTransformMode(mode) {
    if (!TRANSFORM_MODES.includes(mode)) return;

    transformControls.setMode(mode);
    
    document.querySelectorAll('.toolbar-group button').forEach(btn => {
        btn.classList.remove('active');
        gsap.to(btn, { scale: 1, duration: 0.2 });  // Reset size
    });

    const activeBtn = document.getElementById(mode);
    activeBtn.classList.add('active');

    // Smooth animation for button feedback
    gsap.to(activeBtn, { scale: 1.2, duration: 0.3, yoyo: true, repeat: 1 });

    // Apply Special Modes
    applySpecialTransform(mode);
}

// Function to Apply Special Transformations
function applySpecialTransform(mode) {
    const object = transformControls.object;
    if (!object) return;

    switch (mode) {
        case 'mirror': 
            object.scale.x *= -1; // Flip along X-axis
            break;

        case 'snap':
            object.position.x = Math.round(object.position.x / 5) * 5; // Snap to 5 units
            object.position.y = Math.round(object.position.y / 5) * 5;
            object.position.z = Math.round(object.position.z / 5) * 5;
            break;

        case 'shear': 
            object.scale.x += 0.1;  // Skew effect
            object.scale.y -= 0.05;
            break;

        case 'reset': 
            object.position.set(0, 0, 0);
            object.rotation.set(0, 0, 0);
            object.scale.set(1, 1, 1);
            break;
    }

    object.matrixWorldNeedsUpdate = true;
}



 // File operations
 function newScene() {
     objects.forEach(obj => scene.remove(obj));
     objects = [];
     selectedObject = null;
     updateHierarchy();
     updateInspector();
 }
 
 function saveScene() {
     const sceneData = {
         objects: objects.map(obj => ({
             type: obj.type,
             position: obj.position.toArray(),
             rotation: obj.rotation.toArray(),
             scale: obj.scale.toArray(),
             name: obj.name
         }))
     };
     const blob = new Blob([JSON.stringify(sceneData)], { type: 'application/json' });
     const url = URL.createObjectURL(blob);
     const a = document.createElement('a');
     a.href = url;
     a.download = 'scene.json';
     a.click();
 }
 
 function loadScene() {
     const input = document.createElement('input');
     input.type = 'file';
     input.accept = '.json';
     input.onchange = e => {
         const file = e.target.files[0];
         const reader = new FileReader();
         reader.onload = event => {
             const sceneData = JSON.parse(event.target.result);
             newScene();
             sceneData.objects.forEach(objData => {
                 // Recreate objects based on their type
                 let obj;
                 switch (objData.type) {
                     case 'Mesh':
                         obj = new THREE.Mesh(
                             new THREE.BoxGeometry(),
                             new THREE.MeshStandardMaterial()
                         );
                         break;
                     // Add more cases for other object types
                 }
                 if (obj) {
                     obj.position.fromArray(objData.position);
                     obj.rotation.fromArray(objData.rotation);
                     obj.scale.fromArray(objData.scale);
                     obj.name = objData.name;
                     addObjectToScene(obj);
                 }
             });
         };
         reader.readAsText(file);
     };
     input.click();
 }
 

 // Utility functions
 function onWindowResize() {
     camera.aspect = window.innerWidth / window.innerHeight;
     camera.updateProjectionMatrix();
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
// Store references to elements once
const objectsElem = document.getElementById('objects');
const fpsElem = document.getElementById('fps');
const trianglesElem = document.getElementById('triangles');

let lastTime = performance.now();
let frameCount = 0;
let fps = 0;

function updateStats() {
    // Update object count
    objectsElem.textContent = `Objects: ${objects.length}`;

    // FPS Calculation
    const now = performance.now();
    frameCount++;
    if (now - lastTime >= 1000) {
        fps = frameCount;
        frameCount = 0;
        lastTime = now;
    }
    fpsElem.textContent = `FPS: ${fps}`;

    // Calculate total triangles
    let triangles = 0;
    scene.traverse(object => {
        if (object.geometry?.attributes?.position) {
            triangles += object.geometry.attributes.position.count / 3;
        }
    });
    trianglesElem.textContent = `Triangles: ${triangles}`;
}

 

let zoomLevel = 1;
let timelineOffset = 0;

let dragStart = 0;
let selectedSegment = null;

const timeline = document.querySelector('.timeline-track');
const playhead = document.querySelector('.playhead');
const timelineScale = document.querySelector('.timeline-scale');
const timelineContent = document.querySelector('.timeline-content');

function playAnimation() {
    isPlaying = true;
    clock.start();
    updatePlayhead();
}

function pauseAnimation() {
    isPlaying = false;
    clock.stop();
}

function stopAnimation() {
    isPlaying = false;
    clock.stop();
    playhead.style.left = '0%';
    document.getElementById('time-display').textContent = '00:00:00';
}

function updatePlayhead() {
    if (!isPlaying) return;
    
    const time = clock.getElapsedTime();
    const position = (time / 300) * 100; // 5 minutes total
    
    if (position <= 100) {
        playhead.style.left = `${position}%`;
        requestAnimationFrame(updatePlayhead);
    } else {
        stopAnimation();
    }
}
 // Zoom controls
 document.getElementById('zoom-in').addEventListener('click', () => {
    zoomLevel = Math.min(zoomLevel * 1.5, 4);
    timelineContent.style.transform = `scaleX(${zoomLevel})`;
});

document.getElementById('zoom-out').addEventListener('click', () => {
    zoomLevel = Math.max(zoomLevel / 1.5, 1);
    timelineContent.style.transform = `scaleX(${zoomLevel})`;
});

// Timeline dragging
timeline.addEventListener('mousedown', (e) => {
    isDragging = true;
    dragStart = e.clientX - timelineOffset;
    timeline.style.cursor = 'grabbing';
});

document.addEventListener('mousemove', (e) => {
    if (isDragging) {
        const offset = e.clientX - dragStart;
        timelineOffset = offset;
        timelineContent.style.transform = `translateX(${offset}px) scaleX(${zoomLevel})`;
    }
});

document.addEventListener('mouseup', () => {
    isDragging = false;
    timeline.style.cursor = 'grab';
});

// Segment selection
timelineContent.addEventListener('click', (e) => {
    if (e.target.classList.contains('recording-segment')) {
        if (selectedSegment) {
            selectedSegment.classList.remove('selected');
        }
        selectedSegment = e.target;
        selectedSegment.classList.add('selected');
    }
});


// Initialize timeline scale
function initializeTimelineScale() {
    const totalSeconds = 300; // 5 minutes
    const majorMarkerInterval = 30; // Every 30 seconds
    
    for (let i = 0; i <= totalSeconds; i += 5) {
        const marker = document.createElement('div');
        marker.className = `timeline-scale-marker ${i % majorMarkerInterval === 0 ? 'major' : ''}`;
        marker.style.left = `${(i / totalSeconds) * 100}%`;
        
        if (i % majorMarkerInterval === 0) {
            const label = document.createElement('div');
            label.className = 'timeline-scale-label';
            label.textContent = `${Math.floor(i / 60)}:${String(i % 60).padStart(2, '0')}`;
            marker.appendChild(label);
        }
        
        timelineScale.appendChild(marker);
    }
}

function recordSceneData() {
    if (isPlaying && selectedSegment) {
        const time = clock.getElapsedTime();
        const position = (time / 300) * 100; // 5 minutes total
        selectedSegment.style.width = `${position}%`;
    }
}

//animate function
function animate () {
    requestAnimationFrame(animate);
    controls.update();
    animateParticles();

    recordSceneData();
    if (isSnowing) {
        updateSnow();
    }

    // Update animations
    if (world) world.step(1 / 60); // Physics simulation step
    const delta = clock.getDelta();

    scene.traverse((object) => {
        if (object.userData && object.userData.mixer) {
          object.userData.mixer.update(delta);
        }
    });

    scene.traverse((obj) => {
        if (obj.userData.animate) {
            obj.rotation.y += 0.01;
            obj.position.y += Math.sin(Date.now() * 0.001) * 0.01;
        }
    });

    scene.traverse(object => {
        if (object.userData.physicsBody) {
            object.position.copy(object.userData.physicsBody.position);
            object.quaternion.copy(object.userData.physicsBody.quaternion);
        }
    });

    if (nodeEditor) nodeEditor.update();

    if (world && physicsManager) {
        world.step(1/60);
        physicsManager.updatePhysics();
    }

    if (window.materialSettings && window.materialSettings.enableTextureAnimation) {
        window.materialSettings.updateMaterialAnimation();
    }

    scene.traverse((object) => {
        if (object.animate && typeof object.animate === 'function') {
            object.animate();
        }
    });

    if (isPlaying) {
        const time = clock.getElapsedTime();
        const minutes = Math.floor(time / 60);
        const seconds = Math.floor(time % 60);
        const milliseconds = Math.floor((time % 1) * 100);
        document.getElementById('time-display').textContent = 
            `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}:${milliseconds.toString().padStart(2, '0')}`;
    }

    updateStats();
    updateHelpers(); 
    renderer.render(scene, camera);

    if (activeCamera && previewRenderer) {
        previewRenderer.render(scene, activeCamera);
    }
}

function addObjectWithPhysics(geometry, material, physicsOptions = {}) {
    const mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);
    objects.push(mesh);

    if (physicsManager) {
        physicsManager.addPhysicsToObject(mesh, physicsOptions);
    }

    return mesh;
}
 
 // Initialize the editor when the page loads
 init();
    </script>
    <script>
        function initializeUI() {
            // Ensure timeline and inspector are visible
            const timeline = document.querySelector('.timeline');
            const inspector = document.querySelector('.inspector-panel');
            if (timeline) timeline.style.display = 'flex';
            if (inspector) inspector.style.display = 'flex';
        }

        // Material Editor with GUI Display
        function setupMaterialEditor() {
            const materialColor = document.getElementById('materialColor');
            const materialMetalness = document.getElementById('materialMetalness');
            const materialRoughness = document.getElementById('materialRoughness');
            const materialOpacity = document.getElementById('materialOpacity');
            const materialTexture = document.getElementById('materialTexture');
            materialColor.addEventListener('input', updateMaterial);
            materialMetalness.addEventListener('input', updateMaterial);
            materialRoughness.addEventListener('input', updateMaterial);
            materialOpacity.addEventListener('input', updateMaterial);
            materialTexture.addEventListener('change', updateTexture);
        
            const gui = new dat.GUI({ autoPlace: false });
            const settings = {
                texture: 'glass'
            };
        
            gui.add(settings, 'texture', ['glass', 'metal', 'water', 'crystal', 'plastic', 'ceramic', 'wood', 'marble', 'gold', 'chrome', 'holographic', 'matte']).onChange((value) => {
                updateTextureMaterials(value);
            });
        
            // Style the GUI container
            gui.domElement.style.position = 'relative';
            gui.domElement.style.marginTop = '10px';
        
            // Get the materialTextures div and append the GUI
            const materialTextures = document.getElementById('materialTextures');
            materialTextures.appendChild(gui.domElement);
        }
        
       
        // Enhanced textures object with more materials
        const textures = {
            glass: new THREE.MeshPhysicalMaterial({
                color: 0xA0D8EF,
                roughness: 0.1,
                metalness: 0.1,
                clearcoat: 1.0,
                clearcoatRoughness: 0.1,
                transmission: 0.95,
                thickness: 0.5,
                reflectivity: 1.0,
                transparent: true,
                opacity: true,
                attenuationColor: 0xA0D8EF, 
                attenuationDistance: 0.75 ,
                envMap: loadEnvironmentMap(),
                refractionRatio: 1.5
            }),
        
            metal: new THREE.MeshPhysicalMaterial({
                color: 0xAAAAAA,
                roughness: 0.05,
                metalness: 1.0,
                clearcoat: 0.7,
                clearcoatRoughness: 0.02,
                anisotropy: 0.8,
                envMap: loadEnvironmentMap()
            }),
        
            water: new THREE.MeshPhysicalMaterial({
                color: 0x1e90ff,
                roughness: 0.01,
                metalness: 0.0,
                transmission: 1,
                thickness: 0.1,
                transparent: true,
                opacity: 0.9,
                envMap: loadEnvironmentMap(),
                reflectivity: 0.9,
                refractionRatio: 1.33,

            }),
        
            crystal: new THREE.MeshPhysicalMaterial({
                color: 0x7F7FFF,
                roughness: 0.01,
                metalness: 0.0,
                transmission: 1.0,
                thickness: 1.0,
                transparent: true,
                opacity: 0.95,
                envMap: loadEnvironmentMap(),
                clearcoat: 1.0,
                clearcoatRoughness: 0.01,
                attenuationColor: 0x7F7FFF,
                attenuationDistance: 1.0,
                iridescence: 0.8,
                iridescenceIOR: 2.0,
                iridescenceThicknessRange: [200, 500]
            }),
        
            
            plastic: new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                roughness: 0.3,
                metalness: 0.0,
                clearcoat: 0.8,
                clearcoatRoughness: 0.2
            }),
        
            ceramic: new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                roughness: 0.1,
                metalness: 0.0,
                clearcoat: 1.0,
                clearcoatRoughness: 0.1,
                sheen: 1.0,
                sheenRoughness: 0.3,
                sheenColor: 0xffffff
            }),
        
            wood: new THREE.MeshStandardMaterial({
                color: 0x885533,
                roughness: 0.8,
                metalness: 0.0,
                map: loadWoodTexture()
            }),
        
            marble: new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                roughness: 0.15,
                metalness: 0.0,
                transmission: 0.5,
                thickness: 0.5,
                clearcoat: 0.8,
                clearcoatRoughness: 0.2
            }),
        
            gold: new THREE.MeshPhysicalMaterial({
                color: 0xffd700,
                roughness: 0.1,
                metalness: 1.0,
                envMap: loadEnvironmentMap(),
                clearcoat: 0.5,
                clearcoatRoughness: 0.1
            }),
        
            chrome: new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                roughness: 0.0,
                metalness: 1.0,
                envMap: loadEnvironmentMap(),
                clearcoat: 1.0,
                clearcoatRoughness: 0.0
            }),
        
            holographic: new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                roughness: 0.2,
                metalness: 0.5,
                transmission: 0.5,
                thickness: 0.5,
                attenuationColor: 0xff00ff,
                attenuationDistance: 0.5,
                iridescence: 1.0,
                iridescenceIOR: 2.0,
                iridescenceThicknessRange: [100, 400]
            }),
        
            matte: new THREE.MeshStandardMaterial({
                color: 0x808080,
                roughness: 1.0,
                metalness: 0.0
            })
            
        };
        
        function loadEnvironmentMap() {
            return new THREE.CubeTextureLoader().load([
                'textures/skybox/px.jpg',
                'textures/skybox/nx.jpg',
                'textures/skybox/py.jpg',
                'textures/skybox/ny.jpg',
                'textures/skybox/pz.jpg',
                'textures/skybox/nz.jpg'
            ]);
        }
        
        function loadWoodTexture() {
            return new THREE.TextureLoader().load('textures/wood/woodgrain.jpg');
        }
        
        function updateMaterial() {
            if (!selectedObject || !selectedObject.material) return;
        
            selectedObject.material.color.setHex(parseInt(materialColor.value.substr(1), 16));
            selectedObject.material.metalness = parseFloat(materialMetalness.value);
            selectedObject.material.roughness = parseFloat(materialRoughness.value);
            selectedObject.material.opacity = parseFloat(materialOpacity.value);
            selectedObject.material.emissive.setHex(parseInt(materialEmissive.value.substr(1), 16));
            selectedObject.material.emissiveIntensity = parseFloat(materialEmissiveIntensity.value);
            selectedObject.material.clearcoat = parseFloat(materialClearcoat.value);
            selectedObject.material.iridescence = parseFloat(materialIridescence.value);
            selectedObject.material.transparent = selectedObject.material.opacity < 1;
            selectedObject.material.needsUpdate = true;
        }
        
        function updateTexture(event) {
            if (!selectedObject || !selectedObject.material) return;
        
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const texture = new THREE.TextureLoader().load(e.target.result);
                    texture.encoding = THREE.sRGBEncoding;
                    selectedObject.material.map = texture;
                    selectedObject.material.needsUpdate = true;
                };
                reader.readAsDataURL(file);
            }
        }
        
        function updateTextureMaterials(textureName) {
            if (!selectedObject || !selectedObject.material) return;
            
            const newMaterial = textures[textureName].clone();
            selectedObject.material = newMaterial;
            selectedObject.material.needsUpdate = true;
        }

        // History System
        const history = [];
        let currentHistoryIndex = -1;

        function addToHistory(action) {
    if (!Array.isArray(history)) {
        window.history = []; // Ensure history is an array
    }

    history.push(action); // Add new action to history
    updateHistoryPanel(); // Refresh the UI
}


     

        function undo() {
    if (currentHistoryIndex >= 0) {
        const action = history[currentHistoryIndex];
        if (action.undo) action.undo();
        currentHistoryIndex--;
        updateHistoryPanel();
    }
}

function redo() {
    if (currentHistoryIndex < history.length - 1) {
        currentHistoryIndex++;
        const action = history[currentHistoryIndex];
        if (action.redo) action.redo();
        updateHistoryPanel();
    }
}

function clearHistory() {
    history.length = 0;
    currentHistoryIndex = -1;
    updateHistoryPanel();
}

function updateHistoryPanel() {
    const historyPanel = document.getElementById('history-items');
    
    if (!historyPanel) {
        console.error("History panel not found!");
        return;
    }

    historyPanel.innerHTML = ''; // Clear previous history items

    history.forEach((action, index) => {
        const historyItem = document.createElement('div');
        historyItem.classList.add('history-item');
        historyItem.textContent = `${index + 1}. ${action.type || 'Action'}`;

        // Click event to apply history
        historyItem.addEventListener('click', () => {
            applyHistoryAction(action);
        });

        historyPanel.appendChild(historyItem);
    });
}

function applyHistoryAction(action) {
    if (action.undo) {
        action.undo(); // Perform undo if available
    }
    updateHistoryPanel(); // Refresh the UI
}

// Snapping System
function enableSnapping() {
    const gridSize = 1;
    transformControls.addEventListener('change', () => {
    if (selectedObject) {
        selectedObject.position.x = Math.round(selectedObject.position.x / gridSize) * gridSize;
        selectedObject.position.y = Math.round(selectedObject.position.y / gridSize) * gridSize;
        selectedObject.position.z = Math.round(selectedObject.position.z / gridSize) * gridSize;
        }
    });
}
         

// Advanced Object Manipulation
function mirrorObject(axis = 'x') {
    if (!selectedObject) return;
    const clone = selectedObject.clone();
    clone.scale[axis] *= -1;
    addObjectToScene(clone);
}

function createArray() {
    if (!selectedObject) return;
        const count = 3; // Can be made configurable
        const spacing = 2;
        for (let i = 1; i <= count; i++) {
        const clone = selectedObject.clone();
        clone.position.x += spacing * i;
            ddObjectToScene(clone);
        }
}

       

      


// Clipboard Operations
let clipboardData = null;

function setupClipboardOperations() {
    // Copy
    function copyObject() {
        if (selectedObject) {
            clipboardData = selectedObject.clone();
            addToHistory({
                type: 'Copy',
                object: selectedObject.name
            });
        }
    }

    // Paste
    function pasteObject() {
        if (clipboardData) {
            const pastedObject = clipboardData.clone();
            pastedObject.position.x += 1; // Offset slightly to see the pasted object
            pastedObject.name = pastedObject.name.replace(/\d+$/, '') + '_' + objects.length;
            addObjectToScene(pastedObject);
            addToHistory({
                type: 'Paste',
                object: pastedObject.name
            });
        }
    }

    // Delete
    function deleteObject() {
        if (selectedObject) {
            const index = objects.indexOf(selectedObject);
            if (index > -1) {
                // Remove helper if exists
                if (selectedObject.helper) {
                    scene.remove(selectedObject.helper);
                    selectedObject.helper.dispose();
                }

                // Remove all child meshes
                selectedObject.traverse((child) => {
                    if (child instanceof THREE.Mesh) {
                        child.geometry.dispose();
                        child.material.dispose();
                    }
                });

                objects.splice(index, 1);
                scene.remove(selectedObject);
                transformControls.detach();
                
                // If it's a camera, update preview
                if (selectedObject instanceof THREE.Camera && activeCamera === selectedObject) {
                    activeCamera = null;
                }

                selectedObject = null;
                updateHierarchy();
                addToHistory({
                    type: 'Delete',
                    object: selectedObject.name
                });
            }
        }
    }

    // Duplicate
    function duplicateObject() {
        if (selectedObject) {
            const duplicate = selectedObject.clone();
            duplicate.position.x += 1; // Offset slightly
            duplicate.name = duplicate.name.replace(/\d+$/, '') + '_' + objects.length;
            addObjectToScene(duplicate);
            addToHistory({
                type: 'Duplicate',
                object: duplicate.name
            });
        }
    }

    // Add keyboard shortcuts
    document.addEventListener('keydown', (e) => {
        if (e.ctrlKey || e.metaKey) { // Support for both Windows/Linux and Mac
            switch(e.key.toLowerCase()) {
                case 'c':
                    e.preventDefault();
                    copyObject();
                    break;
                case 'v':
                    e.preventDefault();
                    pasteObject();
                    break;
                case 'd':
                    e.preventDefault();
                    duplicateObject();
                    break;
            }
        }
        if (e.key === 'Delete') {
            deleteObject();
        }
    });

    // Context menu integration
    const contextMenu = document.getElementById('context-menu');
    if (contextMenu) {
        contextMenu.innerHTML = `
            <div class="context-menu-item" onclick="copyObject()">Copy (Ctrl+C)</div>
            <div class="context-menu-item" onclick="pasteObject()">Paste (Ctrl+V)</div>
            <div class="context-menu-item" onclick="deleteObject()">Delete (Del)</div>
            <div class="context-menu-item" onclick="duplicateObject()">Duplicate (Ctrl+D)</div>
        `;
    }

    // Make functions globally available
    
    window.copyObject = copyObject;
    window.pasteObject = pasteObject;
    window.deleteObject = deleteObject;
    window.duplicateObject = duplicateObject;
    window.enableSnapping = enableSnapping;
    window.optimizeScene = optimizeScene;
    window.mirrorObject = mirrorObject;
    window.createArray = createArray;
    window.clearHistory = clearHistory;
}



// Performance Optimization
function optimizeScene() {
    // Geometry Merging 
    function mergeGeometries() {
        const geometriesToMerge = [];
        const materialsToMerge = [];
        
        scene.traverse((object) => {
            if (object.isMesh && object.geometry) {
                geometriesToMerge.push(object.geometry);
                materialsToMerge.push(object.material);
            }
        });

        if (geometriesToMerge.length > 1) {
            const mergedGeometry = BufferGeometryUtils.mergeBufferGeometries(geometriesToMerge);
            const mergedMesh = new THREE.Mesh(mergedGeometry, materialsToMerge[0]);
            scene.add(mergedMesh);
            
            // Remove original meshes
            geometriesToMerge.forEach((geo, index) => {
                scene.remove(geo.parent);
            });
        }
    }

    // LOD (Level of Detail) Implementation
    function implementLOD(mesh) {
        if (!mesh.isLOD) {
            const lod = new THREE.LOD();
            
            // High detail (original)
            lod.addLevel(mesh, 0);
            
            // Medium detail (reduced geometry)
            const mediumGeo = mesh.geometry.clone();
            const modifier = new THREE.SimplifyModifier();
            const mediumMesh = new THREE.Mesh(
                modifier.modify(mediumGeo, Math.floor(mesh.geometry.attributes.position.count * 0.5)),
                mesh.material
            );
            lod.addLevel(mediumMesh, 50);
            
            // Low detail
            const lowGeo = mesh.geometry.clone();
            const lowMesh = new THREE.Mesh(
                modifier.modify(lowGeo, Math.floor(mesh.geometry.attributes.position.count * 0.2)),
                mesh.material
            );
            lod.addLevel(lowMesh, 100);
            
            // Replace original mesh with LOD
            mesh.parent.add(lod);
            mesh.parent.remove(mesh);
        }
    }
    

    // Object Pooling System
    const objectPool = {
        pools: {},
        
        create(type, count) {
            this.pools[type] = [];
            for (let i = 0; i < count; i++) {
                let object;
                switch(type) {
                    case 'cube':
                        object = new THREE.Mesh(
                            new THREE.BoxGeometry(),
                            new THREE.MeshStandardMaterial()
                        );
                        break;
                    case 'sphere':
                        object = new THREE.Mesh(
                            new THREE.SphereGeometry(),
                            new THREE.MeshStandardMaterial()
                        );
                        break;
                }
                object.visible = false;
                scene.add(object);
                this.pools[type].push(object);
            }
        },
        
        get(type) {
            return this.pools[type]?.find(obj => !obj.visible) || null;
        },
        
        return(object) {
            object.visible = false;
        }
    };

    // Initialize object pools
    objectPool.create('cube', 50);
    objectPool.create('sphere', 50);

    // Apply optimizations
    mergeGeometries();
    scene.traverse((object) => {
        if (object.isMesh) {
            implementLOD(object);
        }
    });

    return objectPool; // Return the object pool for future use
}

// Initialize everything
function initializeAll() {
    initializeUI();
    setupClipboardOperations();
    const objectPool = optimizeScene();
    
    // Store objectPool for later use
    window.objectPool = objectPool;
}

// Call initialization when the page loads
window.addEventListener('load', initializeAll);

// Context Menu
function setupContextMenu() {
    document.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        const contextMenu = document.getElementById('context-menu');
        contextMenu.style.display = 'block';
        contextMenu.style.left = e.pageX + 'px';
        contextMenu.style.top = e.pageY + 'px';
    });

    document.addEventListener('click', () => {
        document.getElementById('context-menu').style.display = 'none';
    });
}

// Initialize new features
function initializeAdvancedFeatures() {
    setupMaterialEditor();
    enableSnapping();
    setupContextMenu();
    initializeTextures();
}

// Call initialization
initializeAdvancedFeatures();
    </script>
    <script>

        // Camera Preview
        let activeCamera = null; 
        const expandButton = document.getElementById('expandPreview');
        const previewRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        const previewContainer = document.getElementById('cameraPreview');
        previewRenderer.setSize(previewContainer.clientWidth, previewContainer.clientHeight);
        previewRenderer.setPixelRatio(window.devicePixelRatio); // High DPI support
        previewContainer.appendChild(previewRenderer.domElement);

    
        function initializePanelControls() {
            const lightIntensityControl = document.getElementById('lightIntensity');
            const lightColorControl = document.getElementById('lightColor');

            // Update light properties when controls change
            function updateLightControls() {
                if (selectedObject && (selectedObject instanceof THREE.Light)) {
                    selectedObject.intensity = parseFloat(lightIntensityControl.value);
                    selectedObject.color.setStyle(lightColorControl.value);
                    if (selectedObject.helper) {
                        selectedObject.helper.update();
                    }
                }
            }

            lightIntensityControl.addEventListener('input', updateLightControls);
            lightColorControl.addEventListener('input', updateLightControls);

            function updatePreviewSize() {
              const rect = previewContainer.getBoundingClientRect();
               previewRenderer.setSize(rect.width, rect.height);
                if (activeCamera) {
                  activeCamera.aspect = rect.width / rect.height;
                  activeCamera.updateProjectionMatrix();
                }
            }

           // Toggle preview size
           document.getElementById('expandPreview').addEventListener('click', () => {
                previewContainer.classList.toggle('expanded');
                updatePreviewSize();
            });

           
            // Resize observer for dynamic adjustments
            new ResizeObserver(updatePreviewSize).observe(previewContainer);
            
       
           
            // Light controls initialization
            document.getElementById('addPointLight').addEventListener('click', () => {
                const light = new THREE.PointLight(0xffffff, 1);
                light.position.set(0, 5, 0);
                light.castShadow = true;
                
                // Create visual representation
                const sphereGeometry = new THREE.SphereGeometry(0.2);
                const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true });
                const visualMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
                light.add(visualMesh);
                
                // Add helper
                const helper = new THREE.PointLightHelper(light, 0.5);
                scene.add(helper);
                light.helper = helper;
                
                // Add to scene
                light.name = `PointLight_${objects.length}`;
                addObjectToScene(light, 'Point Light');
                document.querySelector('.controls-panel').appendChild(controls);
                light.controls = controls;
                updateHierarchy();
            });

            document.getElementById('addSpotLight').addEventListener('click', () => {
                const light = new THREE.SpotLight(0xffffff, 1);
                light.position.set(0, 5, 0);
                light.angle = Math.PI / 4;
                light.castShadow = true;
                
                // Create visual representation
                const coneGeometry = new THREE.ConeGeometry(0.2, 0.5);
                const coneMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true });
                const visualMesh = new THREE.Mesh(coneGeometry, coneMaterial);
                light.add(visualMesh);
                
                // Add helper
                const helper = new THREE.SpotLightHelper(light);
                scene.add(helper);
                light.helper = helper;
                
                // Add to scene
                light.name = `SpotLight_${objects.length}`;
                addObjectToScene(light, 'Spot Light');
                updateHierarchy();
            });

            document.getElementById('addAreaLight').addEventListener('click', () => {
                const light = new THREE.RectAreaLight(0xffffff, 1, 2, 2);
                light.position.set(0, 5, 0);
                
                // Create visual representation
                const planeGeometry = new THREE.PlaneGeometry(0.4, 0.4);
                const planeMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true });
                const visualMesh = new THREE.Mesh(planeGeometry, planeMaterial);
                light.add(visualMesh);
                
                // Add helper
                const helper = new THREE.RectAreaLightHelper(light);
                scene.add(helper);
                light.helper = helper;
                
                // Add to scene
                light.name = `AreaLight_${objects.length}`;
                addObjectToScene(light, 'Area Light');
                updateHierarchy();
            });

            document.getElementById('addDirectionalLight').addEventListener('click', () => {
                const light = new THREE.DirectionalLight(0xffffff, 1);
                light.position.set(0, 5, 0);
                light.castShadow = true;
                
                // Create visual representation
                const boxGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
                const boxMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true });
                const visualMesh = new THREE.Mesh(boxGeometry, boxMaterial);
                light.add(visualMesh);
                
                // Add helper
                const helper = new THREE.DirectionalLightHelper(light, 1);
                scene.add(helper);
                light.helper = helper;
                
                // Add to scene
                light.name = `DirectionalLight_${objects.length}`;
                addObjectToScene(light, 'Directional Light');
                updateHierarchy();
            });

            // New Light Types
            document.getElementById('addHemisphereLight').addEventListener('click', () => {
                const light = new THREE.HemisphereLight(0xffffbb, 0x080820, 1);
                light.position.set(0, 5, 0);
                
                // Create visual representation
                const sphereGeometry = new THREE.SphereGeometry(0.3);
                const sphereMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffffbb,
                    wireframe: true,
                    vertexColors: true
                });
                const visualMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
                light.add(visualMesh);
                
                // Add helper
                const helper = new THREE.HemisphereLightHelper(light, 1);
                scene.add(helper);
                light.helper = helper;
                
                light.name = `HemisphereLight_${objects.length}`;
                addObjectToScene(light, 'Hemisphere Light');
                updateHierarchy();
            });
        
            document.getElementById('addLensflareLight').addEventListener('click', () => {
                const light = new THREE.PointLight(0xffffff, 1.5, 2000);
                light.position.set(0, 10, 0);
                
                // Create lensflare effect
                const textureLoader = new THREE.TextureLoader();
                const textureFlare = textureLoader.load('path_to_lensflare_texture.png');
                
                const lensflare = new THREE.Lensflare();
                lensflare.addElement(new THREE.LensflareElement(textureFlare, 512, 0));
                light.add(lensflare);
                
                // Visual representation
                const sphereGeometry = new THREE.SphereGeometry(0.2);
                const sphereMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00,
                    wireframe: true
                });
                const visualMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
                light.add(visualMesh);
                
                light.name = `LensflareLight_${objects.length}`;
                addObjectToScene(light, 'Lensflare Light');
                updateHierarchy();
            });
        
            document.getElementById('addVolumetricLight').addEventListener('click', () => {
                const light = new THREE.SpotLight(0xffffff, 1);
                light.position.set(0, 5, 0);
                light.angle = Math.PI / 6;
                light.penumbra = 0.3;
                light.decay = 2;
                light.distance = 50;
                
                // Create volumetric effect
                const geometry = new THREE.CylinderGeometry(0, 2, 10, 32);
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        lightColor: { value: new THREE.Color(0xffffff) },
                        intensity: { value: 1.0 }
                    },
                    vertexShader: `
                        varying vec3 vNormal;
                        void main() {
                            vNormal = normalize(normalMatrix * normal);
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform vec3 lightColor;
                        uniform float intensity;
                        varying vec3 vNormal;
                        void main() {
                            float opacity = pow(1.0 - abs(dot(vNormal, vec3(0.0, 1.0, 0.0))), 2.0);
                            gl_FragColor = vec4(lightColor, opacity * intensity * 0.2);
                        }
                    `,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    side: THREE.DoubleSide
                });
                
                const volumetricCone = new THREE.Mesh(geometry, material);
                light.add(volumetricCone);
                
                // Add helper
                const helper = new THREE.SpotLightHelper(light);
                scene.add(helper);
                light.helper = helper;
                
                light.name = `VolumetricLight_${objects.length}`;
                addObjectToScene(light, 'Volumetric Light');
                updateHierarchy();
            });

            // Camera Management System
            
            // Camera Management System

            document.getElementById('addCameraOrto').addEventListener('click', () => {
                const aspectRatio = window.innerWidth / window.innerHeight;
                const orthoCamera = new THREE.OrthographicCamera(
                    -5 * aspectRatio, 5 * aspectRatio,
                    5, -5,
                    0.1, 1000
                );
                orthoCamera.position.set(0, 2, 5);
                orthoCamera.lookAt(0, 0, 0);
            
                // Create camera body with improved visuals
                const cameraGroup = new THREE.Group();
                
                // Main body
                const bodyGeometry = new THREE.BoxGeometry(0.8, 0.4, 0.6);
                const bodyMaterial = new THREE.MeshPhysicalMaterial({ 
                    color: 0xffbd54,
                    metalness: 0.9,
                    roughness: 0.1,
                    clearcoat: 1,
                    clearcoatRoughness: 0.1
                });
                const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
                cameraGroup.add(bodyMesh);
            
                // Lens
                const lensGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.3, 32);
                const lensMaterial = new THREE.MeshPhysicalMaterial({
                    color: 0xffbd54,
                    metalness: 0.5,
                    roughness: 0.2,
                    transmission: 0.9
                });
                const lensMesh = new THREE.Mesh(lensGeometry, lensMaterial);
                lensMesh.rotation.x = Math.PI / 2;
                lensMesh.position.z = 0.3;
                cameraGroup.add(lensMesh);
            
                cameraGroup.scale.set(0.5, 0.5, 0.5);
                orthoCamera.add(cameraGroup);
            
                // Add helper with custom colors
                const orthoHelper = new THREE.CameraHelper(orthoCamera);
                orthoHelper.material.color.set(0xffbd54);
                scene.add(orthoHelper);
                orthoCamera.helper = orthoHelper;
            
                orthoCamera.name = `OrthoCamera_${objects.length}`;
                
                // Add resize handler
                const handleResize = () => {
                    const newAspectRatio = window.innerWidth / window.innerHeight;
                    orthoCamera.left = -5 * newAspectRatio;
                    orthoCamera.right = 5 * newAspectRatio;
                    orthoCamera.updateProjectionMatrix();
                };
                window.addEventListener('resize', handleResize);
            
                addObjectToScene(orthoCamera, 'camera');
                updateHierarchy();
                setupCameraControls(orthoCamera);
            
                if (activeCamera) {
                    transitionToCamera(orthoCamera);
                }
                activeCamera = orthoCamera;
            });
            
            
            document.getElementById('addCamera').addEventListener('click', () => {
            const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 5);
            camera.lookAt(0, 0, 0);
            
            const cameraGroup = new THREE.Group();
            
            // Main Camera Body
            const bodyGeometry = new THREE.BoxGeometry(0.6, 0.3, 0.5);
            const bodyMaterial = new THREE.MeshPhysicalMaterial({ 
                color: 0x2c3e50,
                metalness: 0.8,
                roughness: 0.2,
                clearcoat: 1,
                clearcoatRoughness: 0.1
            });
            const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
            cameraGroup.add(bodyMesh);
            
            // Camera Grip
            const gripGeometry = new THREE.CylinderGeometry(0.08, 0.06, 0.4, 8);
            const gripMaterial = new THREE.MeshPhysicalMaterial({ 
                color: 0x34495e,
                metalness: 0.6,
                roughness: 0.8,
                clearcoat: 0.5
            });
            const gripMesh = new THREE.Mesh(gripGeometry, gripMaterial);
            gripMesh.position.y = -0.2;
            cameraGroup.add(gripMesh);
            
            function animateLensFocus() {
            const maxExtension = 0.2;
            lensGroup.userData.focusing = true;
            
            const animate = () => {
                const time = performance.now() * 0.001;
                const extension = Math.sin(time) * maxExtension;
                
                lensElements.forEach((lens, index) => {
                    lens.position.z = lensPositions[index] + extension;
                });
                
                if (lensGroup.userData.focusing) {
                    requestAnimationFrame(animate);
                }
            };
            animate();
            }
            
            // Add focus trigger on right-click
            cameraGroup.userData.onRightClick = () => {
            if (!lensGroup.userData.focusing) {
            animateLensFocus();
            } else {
            lensGroup.userData.focusing = false;
            }
            };
            
            // Lens System
            const lensGroup = new THREE.Group();
            
            // Main Lens
            const lensElements = [];
            const lensPositions = [0.3, 0.4, 0.5];
            
            lensPositions.forEach((pos, index) => {
                const element = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.12 - (index * 0.01), 0.13 - (index * 0.01), 0.05, 32),
                    new THREE.MeshPhysicalMaterial({
                        color: 0x88ccff,
                        metalness: 0.1,
                        roughness: 0.1,
                        transmission: 0.9,
                        thickness: 0.02,
                        clearcoat: 1
                    })
                );
                element.rotation.x = Math.PI / 2;
                element.position.z = pos;
                lensElements.push(element);
                lensGroup.add(element);
            });
            
            // Lens Glass
            const lensGlassGeometry = new THREE.CircleGeometry(0.15, 32);
            const glassMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x88ccff,
                metalness: 0.9,
                roughness: 0.1,
                transmission: 0.9,
                thickness: 0.1,
                clearcoat: 1
            });
            
            
            
            // Lens Ring
            const ringGeometry = new THREE.TorusGeometry(0.15, 0.02, 16, 60);
            const ringMaterial = new THREE.MeshPhysicalMaterial({ 
                color: 0x444444,
                metalness: 0.8,
                roughness: 0.4,
                clearcoat: 1
            });
            const ringMesh = new THREE.Mesh(ringGeometry, ringMaterial);
            ringMesh.position.z = 0.45;
            lensGroup.add(ringMesh);
            
            cameraGroup.add(lensGroup);
            
            // Viewfinder
            const viewfinderGeometry = new THREE.BoxGeometry(0.3, 0.2, 0.2);
            const viewfinderMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x2c3e50,
                metalness: 0.8,
                roughness: 0.2,
                clearcoat: 1
            });
            const viewfinderMesh = new THREE.Mesh(viewfinderGeometry, viewfinderMaterial);
            viewfinderMesh.position.y = 0.25;
            cameraGroup.add(viewfinderMesh);
            
            // OLED Screen
            // Replace the existing screenMaterial definition with this
            const createLCDContent = () => {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 192;
            const ctx = canvas.getContext('2d');
            
            
            const updateLCD = () => {
                ctx.fillStyle = '#001122';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#00ff00';
                ctx.font = '24px monospace';
                ctx.fillText(`ISO: 100`, 10, 30);
                ctx.fillText(`f/2.8`, 10, 60);
                ctx.fillText(`1/125`, 10, 90);
                
                ctx.strokeStyle = '#00ff00';
                ctx.strokeRect(200, 10, 40, 20);
                ctx.fillRect(202, 12, 36 * 0.8, 16);
            };
            
            updateLCD();
            return new THREE.CanvasTexture(canvas);
            };
            
            const screenMaterial = new THREE.MeshBasicMaterial({
            map: createLCDContent(),
            emissive: 0x222222,
            emissiveIntensity: 0.5
            });
            
             // Control Dials
             const dialGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.02, 32, 1, false, 0, Math.PI * 2);
            const dialMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x95a5a6,
                metalness: 0.9,
                roughness: 0.3,
                clearcoat: 1
            });
            
            // Mode Dial
            const modeDial = new THREE.Mesh(dialGeometry, dialMaterial);
            modeDial.rotation.x = Math.PI / 2;
            modeDial.position.set(0.2, 0.15, 0);
            cameraGroup.add(modeDial);
            
            // Command Dial
            const commandDial = new THREE.Mesh(dialGeometry, dialMaterial);
            commandDial.rotation.x = Math.PI / 2;
            commandDial.position.set(-0.2, 0.15, 0);
            cameraGroup.add(commandDial);
            
            cameraGroup.scale.set(0.5, 0.5, 0.5);
            cameraGroup.position.set(0, 0, 0);
            camera.add(cameraGroup);
            
            
            // Hot Shoe
            const hotShoeGeometry = new THREE.BoxGeometry(0.2, 0.05, 0.2);
            const hotShoeMesh = new THREE.Mesh(hotShoeGeometry, gripMaterial);
            hotShoeMesh.position.y = 0.35;
            cameraGroup.add(hotShoeMesh);
            
            cameraGroup.scale.set(0.5, 0.5, 0.5);
            cameraGroup.position.set(0, 0, 0);
            camera.add(cameraGroup);
            
            // Enhanced Camera Helper with thicker lines
            const helper = new THREE.CameraHelper(camera);
            helper.material.linewidth = 3; // Increased line width
            helper.material.color.setHex(0xff6600); // Brighter orange color
            helper.visible = true;
            scene.add(helper);
            camera.helper = helper;
            
            
            // Add camera to the scene
            camera.name = `Camera_${objects.length}`;
            addObjectToScene(camera, 'camera');
            updateHierarchy();
            
            setupCameraControls(camera);
            
            if (activeCamera) {
                transitionToCamera(camera);
            }
            
            activeCamera = camera;
            
            
            // Add pop-up flash
            const flashGroup = new THREE.Group();
            const flashBase = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, 0.05, 0.1),
            new THREE.MeshPhysicalMaterial({ color: 0x2c3e50, metalness: 0.8 })
            );
            
            const flashHead = new THREE.Mesh(
            new THREE.BoxGeometry(0.2, 0.1, 0.05),
            new THREE.MeshPhysicalMaterial({ color: 0x2c3e50, metalness: 0.8 })
            );
            flashHead.position.y = 0.05;
            
            const flashBulb = new THREE.Mesh(
            new THREE.CylinderGeometry(0.03, 0.03, 0.02, 16),
            new THREE.MeshPhysicalMaterial({
            color: 0xffffff,
            emissive: 0xffffff,
            emissiveIntensity: 0
            })
            );
            flashBulb.rotation.x = Math.PI / 2;
            flashHead.add(flashBulb);
            
            flashGroup.add(flashBase, flashHead);
            flashGroup.position.set(0, 0.4, -0.1);
            cameraGroup.add(flashGroup);
            
            // Add strap lugs
            const strapLugGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.1, 8);
            const strapLugMaterial = new THREE.MeshPhysicalMaterial({
            color: 0x95a5a6,
            metalness: 0.9
            });
            
            [-0.3, 0.3].forEach(x => {
            const lug = new THREE.Mesh(strapLugGeometry, strapLugMaterial);
            lug.rotation.z = Math.PI / 2;
            lug.position.set(x, 0.1, 0);
            cameraGroup.add(lug);
            });
            
            // Add dial animations
            function animateDials() {
            modeDial.rotation.z += 0.02;
            commandDial.rotation.z -= 0.015;
            }
            
            cameraGroup.userData.controlsActive = false;
            cameraGroup.userData.onControlClick = () => {
            cameraGroup.userData.controlsActive = !cameraGroup.userData.controlsActive;
            };
            
            // Create DOF helper
            const createDOFVisualization = () => {
            const dofGroup = new THREE.Group();
            
            
            const focalPlane = new THREE.Mesh(
                new THREE.PlaneGeometry(2, 2),
                new THREE.MeshBasicMaterial({ 
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.2
                })
            );
            focalPlane.position.z = -5;
            
            dofGroup.add(focalPlane);
            scene.add(dofGroup);
            
            return dofGroup;
            };
            
            const dofHelper = createDOFVisualization();
            
            function animate() {
            requestAnimationFrame(animate);
            if (cameraGroup.userData.controlsActive) {
            animateDials();
            }
            }
            // Start animation
            animate();
            });
            
            
            
            function setupCameraControls(camera) {
            const fovInput = document.querySelector('#cameraFOV input');
            if (fovInput) {
            fovInput.value = camera.fov;
            fovInput.addEventListener('input', () => {
            camera.fov = parseFloat(fovInput.value);
            camera.updateProjectionMatrix();
            if (camera.helper) camera.helper.update();
            });
            }
            
            
            const nearInput = document.querySelector('#cameraNear input');
            const farInput = document.querySelector('#cameraFar input');
            
            if (nearInput) {
                nearInput.value = camera.near;
                nearInput.addEventListener('input', () => {
                    camera.near = parseFloat(nearInput.value);
                    camera.updateProjectionMatrix();
                    if (camera.helper) camera.helper.update();
                });
            }
            
            if (farInput) {
                farInput.value = camera.far;
                farInput.addEventListener('input', () => {
                    camera.far = parseFloat(farInput.value);
                    camera.updateProjectionMatrix();
                    if (camera.helper) camera.helper.update();
                });
            }
            }

            function transitionToCamera(targetCamera) {
const duration = 1.5;
const startPosition = activeCamera.position.clone();
const startRotation = activeCamera.rotation.clone();
const startQuaternion = activeCamera.quaternion.clone();

const endPosition = targetCamera.position.clone();
const endRotation = targetCamera.rotation.clone();
const endQuaternion = targetCamera.quaternion.clone();

let time = 0;
const easing = t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;

function animateTransition() {
    time += 0.016;
    const alpha = easing(Math.min(time / duration, 1));

    activeCamera.position.lerpVectors(startPosition, endPosition, alpha);
    THREE.Quaternion.slerp(startQuaternion, endQuaternion, activeCamera.quaternion, alpha);

    if (time < duration) {
        requestAnimationFrame(animateTransition);
    } else {
        activeCamera.position.copy(endPosition);
        activeCamera.rotation.copy(endRotation);
        if (activeCamera.helper) activeCamera.helper.update();
        if (activeCamera.projectionLine) {
            const positions = new Float32Array([
                activeCamera.position.x, activeCamera.position.y, activeCamera.position.z,
                0, 0, 0
            ]);
            activeCamera.projectionLine.geometry.setAttribute('position', 
                new THREE.BufferAttribute(positions, 3));
            activeCamera.projectionLine.geometry.attributes.position.needsUpdate = true;
        }
    }
}

animateTransition();
}
        }


       
        // Add this to your init() function or call it when the page loads
        window.addEventListener('load', initializePanelControls);
         document.querySelectorAll('.panel-header').forEach(header => {
            header.addEventListener('click', () => {
                const content = header.nextElementSibling;
                const button = header.querySelector('.expand-button');
                if (content.style.display === 'none') {
                    content.style.display = 'block';
                    button.textContent = '▼';
                } else {
                    content.style.display = 'none';
                    button.textContent = '▶';
                }
            });
        });

        // Toggle assets panel
       

        // Switch tabs
        document.querySelectorAll('.tab').forEach(tab => {
    tab.addEventListener('click', () => {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
    });
});



        // functions to update the UI
        function updateLightUI(light) {
            // Update light-specific controls in the UI
            const fovInput = document.querySelector('#cameraFOV input');
            if (fovInput) {
                fovInput.disabled = true;
            }

           
        }
        
        function updateCameraUI(camera) {
            // Update camera-specific controls in the UI
            const fovInput = document.querySelector('#cameraFOV input');
            if (fovInput) {
                fovInput.disabled = false;
                fovInput.value = camera.fov;
            }

           
        }
        
        // Call this in your init function
        function initializeLightAndCameraSystem() {
            setupLightControls();
    
            
            // Make renderer support shadows
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        }
        
        // Add this to your animation loop
        function updateHelpers() {
            objects.forEach(obj => {
                if (obj.helper) {
                    obj.helper.update();
                }
            });
        }

    </script>

    <script>
        // Enhanced Assets Panel System
class AssetsPanel {
    constructor() {
        this.gltfLoader = new THREE.GLTFLoader();
        this.objLoader = new THREE.OBJLoader();
        this.fbxLoader = new THREE.FBXLoader();
        this.textureLoader = new THREE.TextureLoader();
        this.rgbeLoader = new THREE.RGBELoader();
        
   
        this.supportedModelFormats = ['.glb', '.gltf', '.fbx', '.obj'];
        this.supportedHDRIFormats = ['.hdr', '.exr'];
        this.assets = {
            models: [],
            hdris: [],
            materials: [],
            textures: []
        };

        this.initializeUI();
        this.setupEventListeners();
        
        
                
        // Animation system
        this.mixers = new Map();
     
    }

    initializeUI() {
        // Create assets panel HTML
        const assetsPanel = `
            <div class="assets-panel">
                <div class="assets-header">
                    <div class="tabs">
                        <button class="tab-btn active" data-tab="models">3D Models</button>
                        <button class="tab-btn" data-tab="hdris">HDRI</button>
                        <button class="tab-btn" data-tab="materials">Materials</button>
                        <button class="tab-btn" data-tab="textures">Textures</button>
                    </div>
                    <button class="import-btn">
                        <i class="fas fa-plus"></i> Import
                        <input type="file" class="file-input" multiple accept=".glb,.gltf,.fbx,.obj,.hdr,.exr" style="display: none;">
                    </button>
                </div>
                
                <div class="assets-content">
                    <div class="assets-grid" id="models-grid"></div>
                    <div class="assets-grid" id="hdris-grid" style="display: none;"></div>
                    <div class="assets-grid" id="materials-grid" style="display: none;"></div>
                    <div class="assets-grid" id="textures-grid" style="display: none;"></div>
                </div>
                
                <div class="drop-zone">
                    <div class="drop-zone-content">
                        <i class="fas fa-cloud-upload-alt"></i>
                        <p>Drag & Drop Files Here</p>
                    </div>
                </div>
            </div>
        `;
        
        // Add to DOM
        document.querySelector('.viewport').insertAdjacentHTML('beforeend', assetsPanel);
        
        // Add styles
        const styles = `
            .assets-panel {
                position: absolute;
                left: 50%;
                bottom: 4.6%;
                width: 100%;
                z-index: 3;
                height: 250px;
                background: #2a2a2a;
                border-left: 1px solid #3a3a3a;
                display: flex;
                flex-direction: column;
                transform: translate(-50%);
                transition: width 0.3s ease, left 0.3s ease;
            }

            
            
            .assets-panel.visible {
                transform: translateX(100%);
            }
            
            .assets-header {
                padding: 10px;
                border-bottom: 1px solid #3a3a3a;
            }
            
            .tabs {
                display: flex;
                gap: 5px;
                margin-bottom: 10px;
            }
            
            .tab-btn {
                padding: 5px 10px;
                background: #3a3a3a;
                border: none;
                color: #fff;
                cursor: pointer;
                flex: 1;
            }
            
            .tab-btn.active {
                background: #4a4a4a;
            }
            
            .import-btn {
                width: 100%;
                padding: 8px;
                background: #4CAF50;
                border: none;
                color: white;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 5px;
            }
            
            .assets-content {
                flex: 1;
                overflow-y: auto;
                padding: 10px;
            }
            
            .assets-grid {
                display: grid;
                grid-template-columns: repeat(5, 1fr);
                gap: 10px;
            }
            
            .asset-item {
                background: #3a3a3a;
                padding: 10px;
                border-radius: 4px;
                cursor: grab;
                position: relative;
            }
            
            .asset-item:hover {
                background: #4a4a4a;
            }
            
            .asset-preview {
                width: 100%;
                height: 100px;
                background: #2a2a2a;
                margin-bottom: 5px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 24px;
                color: #666;
            }
            
            .asset-name {
                font-size: 12px;
                color: #fff;
                text-align: center;
                word-break: break-all;
            }
            
            .drop-zone {
                position: absolute;
                top: 40%;
                left: 0;
                z-index: 1;
                width: 100%;
                height: 120px;
                background: rgba(0,0,0,0.8);
                display: none;
                align-items: center;
                justify-content: center;
            }
            
            .drop-zone.active {
                display: flex;
            }
            
            .drop-zone-content {
                text-align: center;
                color: #fff;
            }
            
            .drop-zone-content i {
                font-size: 48px;
                margin-bottom: 10px;
            }
        `;
        
        const styleSheet = document.createElement('style');
        styleSheet.textContent = styles;
        document.head.appendChild(styleSheet);
    }

    setupEventListeners() {
        // Tab switching
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const tab = e.target.dataset.tab;
                this.switchTab(tab);
            });
        });
        
        // File input handling
        const fileInput = document.querySelector('.file-input');
        document.querySelector('.import-btn').addEventListener('click', () => {
            fileInput.click();
        });
        
        fileInput.addEventListener('change', (e) => {
            this.handleFiles(Array.from(e.target.files));
        });
        
        // Drag and drop handling
        const dropZone = document.querySelector('.drop-zone');
        const assetPanel = document.querySelector('.assets-panel');
        
        assetPanel.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('active');
        });
        
        assetPanel.addEventListener('dragleave', (e) => {
            e.preventDefault();
            dropZone.classList.remove('active');
        });
        
        assetPanel.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('active');
            this.handleFiles(Array.from(e.dataTransfer.files));
        });
        
        // Make assets draggable to scene
        document.addEventListener('dragstart', (e) => {
            if (e.target.classList.contains('asset-item')) {
                e.dataTransfer.setData('text/plain', e.target.dataset.assetId);
            }
        });
        
        document.getElementById('renderer-container').addEventListener('drop', (e) => {
            e.preventDefault();
            const assetId = e.dataTransfer.getData('text/plain');
            if (assetId) {
                this.addAssetToScene(assetId);
            }
        });
    }

    handleFiles(files) {
        files.forEach(file => {
            const extension = file.name.split('.').pop().toLowerCase();
            
            if (this.supportedModelFormats.includes('.' + extension)) {
                this.loadModel(file);
            } else if (this.supportedHDRIFormats.includes('.' + extension)) {
                this.loadHDRI(file);
            }
        });
    }

// In your AssetsPanel class
async loadModel(file) {
    const reader = new FileReader();
    reader.onload = async (event) => {
        const buffer = event.target.result;
        const url = URL.createObjectURL(new Blob([buffer]));
        const extension = file.name.split('.').pop().toLowerCase();
        try {
            let object;

            // Show the viewport-container once a model is loaded
            const viewportContainer = document.querySelector('.viewport-container');
            viewportContainer.style.display = 'block';  // Make it visible

            switch (extension) {
                case 'fbx':
                    object = await new Promise((resolve, reject) => {
                        this.fbxLoader.load(url, 
                            (obj) => {
                                obj.scale.set(0.01, 0.01, 0.01);  // Scale down FBX model
                                const previewObject = obj.clone();
                                if (obj.animations && obj.animations.length > 0) {
                                    previewObject.animations = obj.animations.map(anim => anim.clone());
                                }
                                previewObject.traverse((child) => {
                                    if (child.isMesh) {
                                        if (child.material) {
                                            child.material = Array.isArray(child.material) ? 
                                                            child.material.map(m => m.clone()) : 
                                                            child.material.clone();
                                            child.material.needsUpdate = true;
                                        }
                                    }
                                });
                                this.createModelPreview(previewObject, file.name);
                                this.processModel(obj, file.name, obj.animations || []);
                                
                                // Call the visualizeBones function to display bones
                                visualizeBones(obj);
                                
                                resolve(obj);
                            },
                            (xhr) => console.log((xhr.loaded / xhr.total * 100) + '% loaded'),
                            (error) => {
                                console.error('FBX loading error:', error);
                                reject(error);
                            }
                        );
                    });
                    break;
                    
                case 'obj':
                    object = await new Promise((resolve, reject) => {
                        this.objLoader.load(url,
                            (obj) => resolve(obj),
                            undefined,
                            (error) => reject(error)
                        );
                    });
                    break;
        
                case 'glb':
                case 'gltf':
                    object = await new Promise((resolve, reject) => {
                        this.gltfLoader.load(url,
                            (gltf) => {
                                const previewObject = gltf.scene.clone();
                                if (gltf.animations && gltf.animations.length > 0) {
                                    previewObject.animations = gltf.animations.map(anim => anim.clone());
                                }
                                this.createModelPreview(previewObject, file.name);
                                this.processModel(gltf.scene, file.name, gltf.animations || []);
                                
                                // Call the visualizeBones function to display bones
                                visualizeBones(gltf.scene);
                                
                                resolve(gltf.scene);
                            },
                            undefined,
                            (error) => reject(error)
                        );
                    });
                    break;
            }
        } catch (error) {
            console.error('Error loading model:', error);
        } finally {
            URL.revokeObjectURL(url);
        }
    };
    reader.readAsArrayBuffer(file);
}


// createModelPreview function
createModelPreview(object, name) {
        const canvas = document.getElementById('preview-canvas');
        
        // Set canvas dimensions
        canvas.width = 300;
        canvas.height = 300;
        
        const previewRenderer = new THREE.WebGLRenderer({
            canvas: canvas,
            antialias: true,
            alpha: true
        });
        previewRenderer.setSize(canvas.width, canvas.height);
        previewRenderer.setPixelRatio(window.devicePixelRatio);
        previewRenderer.setClearColor(0x1a1a1a, 1);
        previewRenderer.shadowMap.enabled = true;
        previewRenderer.shadowMap.type = THREE.PCFSoftShadowMap;

        const previewScene = new THREE.Scene();
        const previewCamera = new THREE.PerspectiveCamera(
            45,
            canvas.width / canvas.height,
            0.1,
            1000
        );

        // Add OrbitControls
        const controls = new THREE.OrbitControls(previewCamera, canvas);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = true;
        controls.minDistance = 1;
        controls.maxDistance = 50;
        controls.enablePan = true;
        controls.enableZoom = true;
        controls.rotateSpeed = 0.8;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.8;

        // Enhanced lighting setup
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        previewScene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 5, 5);
        directionalLight.castShadow = true;
        previewScene.add(directionalLight);

        const secondaryLight = new THREE.DirectionalLight(0xffffff, 0.4);
        secondaryLight.position.set(-5, 2, -5);
        previewScene.add(secondaryLight);

        // Add subtle grid helper
        const gridHelper = new THREE.GridHelper(20, 20, 0x333333, 0x222222);
        gridHelper.position.y = -0.01;
        previewScene.add(gridHelper);

        // Center and scale the object
        const box = new THREE.Box3().setFromObject(object);
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());
        object.position.sub(center);
        
        const maxDim = Math.max(size.x, size.y, size.z);
        const fov = previewCamera.fov * (Math.PI / 180);
        let cameraZ = Math.abs(maxDim / Math.tan(fov / 2)) * 2;
        
        previewCamera.position.set(cameraZ * 0.5, cameraZ * 0.5, cameraZ);
        controls.target.set(0, 0, 0);
        
        previewScene.add(object);

        // Update model info with enhanced UI
        this.updateModelInfo(object, name);

        const mixer = new THREE.AnimationMixer(object);
        let actions = [];

        // Create actions for each animation
        if (object.animations && object.animations.length > 0) {
            actions = object.animations.map(clip => {
                const action = mixer.clipAction(clip);
                action.play();
                return action;
            });
        }
        
        // Animation loop
        const clock = new THREE.Clock();
        let animating = true;
        
        function animate() {
            if (!animating) return;
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            
            // Update all mixers
            if (mixer) {
                mixer.update(delta);
            }

            controls.update();
            previewRenderer.render(previewScene, previewCamera);
        }

        animate();

        // Add control hints overlay
        this.addControlHints(canvas);

        // Handle window resize
        window.addEventListener('resize', onWindowResize);

        function onWindowResize() {
            const container = canvas.parentElement;
            const width = container.clientWidth;
            const height = container.clientHeight;

            previewCamera.aspect = width / height;
            previewCamera.updateProjectionMatrix();
            previewRenderer.setSize(width, height);
        }

        // Clean up function
        return () => {
            animating = false;
            window.removeEventListener('resize', onWindowResize);
            controls.dispose();
            if (mixer) {
                mixer.stopAllAction();
                mixer.uncacheRoot(object);
            }
            previewScene.remove(object);
            previewRenderer.dispose();
        };
    }

    updateModelInfo(object, name) {
        const modelName = document.querySelector('.model-name');
        const modelStats = document.querySelector('.model-stats');
        
        let vertexCount = 0;
        let triangleCount = 0;
        let materialCount = new Set();

        object.traverse((child) => {
            if (child.isMesh) {
                vertexCount += child.geometry.attributes.position.count;
                if (child.geometry.index) {
                    triangleCount += child.geometry.index.count / 3;
                } else {
                    triangleCount += child.geometry.attributes.position.count / 3;
                }
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(mat => materialCount.add(mat));
                    } else {
                        materialCount.add(child.material);
                    }
                }
            }
        });

        if (modelName) modelName.textContent = name;
        if (modelStats) {
            modelStats.innerHTML = `
                <div class="stats-grid">
                    <div class="stat-item">
                        <span class="stat-label">Vertices:</span>
                        <span class="stat-value">${vertexCount.toLocaleString()}</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Triangles:</span>
                        <span class="stat-value">${triangleCount.toLocaleString()}</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Materials:</span>
                        <span class="stat-value">${materialCount.size}</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Animations:</span>
                        <span class="stat-value">${object.animations ? object.animations.length : 0}</span>
                    </div>
                </div>
            `;
        }
    }

    addControlHints(canvas) {
        const hints = document.createElement('div');
        hints.className = 'control-hints';
        hints.innerHTML = `
            <div class="hint">
                <span class="hint-key">Left</span>
                <span class="hint-action">Rotate</span>
            </div>
            <div class="hint">
                <span class="hint-key">Right</span>
                <span class="hint-action">Pan</span>
            </div>
            <div class="hint">
                <span class="hint-key">Scroll</span>
                <span class="hint-action">Zoom</span>
            </div>
        `;
        canvas.parentElement.appendChild(hints);
    }


setupAnimation(model) {
    if (!this.mixers) this.mixers = new Map();
    
    if (model.animations && model.animations.length > 0) {
        const mixer = new THREE.AnimationMixer(model.scene || model);
        this.mixers.set(model.scene || model, mixer);
        
        model.animations.forEach((clip) => {
            const action = mixer.clipAction(clip);
            action.play();
        });
    }
}


processModel(object, name, animations = []) {
    // Setup proper materials and shadows
    object.traverse((child) => {
        if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;

            if (child.isSkinnedMesh) {
                // Ensure proper material settings
                if (child.material) {
                    child.material.skinning = true;
                    child.material.needsUpdate = true;
                }

                // Store initial bone positions
                if (child.skeleton) {
                    child.skeleton.bones.forEach(bone => {
                        bone.userData.initialPosition = bone.position.clone();
                        bone.userData.initialRotation = bone.rotation.clone();
                    });
                }
            }

            // Update material
            if (child.material) {
                child.material.side = THREE.DoubleSide;
                child.material.needsUpdate = true;
            }
        }
    });

    // Add to scene
    object.position.set(0, 0, 0);
    
    // Store animations on the object if they exist
    if (animations && animations.length > 0) {
        object.animations = animations;
        
        // Setup animation mixer
        const mixer = new THREE.AnimationMixer(object);
        object.userData.mixer = mixer;
        
        // Play all animations
        animations.forEach(clip => {
            const action = mixer.clipAction(clip);
            action.play();
        });
        
        console.log(`Set up ${animations.length} animations for model: ${name}`);
    }
    
    // Add to scene
    scene.add(object);
    
    // Update UI
    if (typeof addObjectToScene === 'function') {
        addObjectToScene(object, name);
    }
    
    if (typeof updateHierarchy === 'function') {
        updateHierarchy();
    }
    
    // Store in assets
    this.addModelAsset(name, object);
}

    loadHDRI(file) {
        const reader = new FileReader();
        
        reader.onload = (e) => {
            this.rgbeLoader.load(e.target.result, (texture) => {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                
                // تطبيق HDRI على المشهد مباشرة
                scene.environment = texture;
                scene.background = texture;
                
                // إضافة إلى الأصول
                this.addHDRIAsset(file.name, texture);
                
                // تحديث جميع المواد في المشهد
                scene.traverse((object) => {
                    if (object.material) {
                        object.material.envMap = texture;
                        object.material.needsUpdate = true;
                    }
                });
            });
        };
        
        reader.readAsDataURL(file);
    }
    

    loadTexture(file) {
        const reader = new FileReader();
        
        reader.onload = (e) => {
            const texture = new THREE.TextureLoader().load(e.target.result);
            
            // إضافة إلى الأصول
            this.addTextureAsset(file.name, texture);
            
            // تطبيق الملمس على الكائن المحدد إذا كان موجوداً
            if (selectedObject && selectedObject.material) {
                selectedObject.material.map = texture;
                selectedObject.material.needsUpdate = true;
            }
        };
        
        reader.readAsDataURL(file);
    }

   

    updateMaterial(texture, type = 'map') {
        if (!selectedObject) return;
        
        selectedObject.traverse((child) => {
            if (child.isMesh && child.material) {
                switch(type) {
                    case 'map':
                        child.material.map = texture;
                        break;
                    case 'normalMap':
                        child.material.normalMap = texture;
                        break;
                    case 'roughnessMap':
                        child.material.roughnessMap = texture;
                        break;
                    case 'metalnessMap':
                        child.material.metalnessMap = texture;
                        break;
                }
                child.material.needsUpdate = true;
            }
        });
    }

    addModelAsset(name, object) {
        const assetId = 'model_' + Date.now();
        const asset = { id: assetId, name: name, type: 'model', object: object };
        
        this.assets.models.push(asset);
        this.createAssetItem(asset, 'models-grid');
    }


    addHDRIAsset(name, texture) {
        const assetId = 'hdri_' + Date.now();
        const asset = {
            id: assetId,
            name: name,
            type: 'hdri',
            texture: texture
        };
        
        this.assets.hdris.push(asset);
        this.createAssetItem(asset, 'hdris-grid');
    }

    createAssetItem(asset, gridId) {
        const item = document.createElement('div');
        item.className = 'asset-item';
        item.draggable = true;
        item.dataset.assetId = asset.id;
        
        item.innerHTML = `
            <div class="asset-preview">
                <i class="fas ${asset.type === 'model' ? 'fa-cube' : 'fa-image'}"></i>
            </div>
            <div class="asset-name">${asset.name}</div>
        `;
        
        document.getElementById(gridId).appendChild(item);
    }

    addAssetToScene(object) {
        if (!object) return;

        const clone = object.clone();
        clone.position.set(0, 0, 0);
        
        scene.add(clone);
        objects.push(clone);
        updateHierarchy();
        selectObject(clone);
        transformControls.attach(clone);
        updateInspector();
    }

    updateAnimation(deltaTime) {
    if (this.mixers) {
        this.mixers.forEach(mixer => {
            mixer.update(deltaTime);
        });
    }
    }

    addAnimationControls(object) {
if (!object.animations || object.animations.length === 0) return;

const mixer = this.mixers.get(object);
if (!mixer) return;

const animations = object.animations.map(clip => ({
    name: clip.name,
    action: mixer.clipAction(clip)
}));

// Create animation controls UI
const controls = document.createElement('div');
controls.className = 'animation-controls';
controls.innerHTML = `
    <select class="animation-select">
        ${animations.map(anim => `
            <option value="${anim.name}">${anim.name}</option>
        `).join('')}
    </select>
    <button class="play-btn">Play</button>
    <button class="stop-btn">Stop</button>
`;

// Add event listeners
controls.querySelector('.animation-select').addEventListener('change', (e) => {
    const selectedAnim = animations.find(a => a.name === e.target.value);
    if (selectedAnim) {
        animations.forEach(a => a.action.stop());
        selectedAnim.action.play();
    }
});

    // Add controls to UI
    document.querySelector('.inspector').appendChild(controls);
}

    switchTab(tab) {
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.tab === tab);
        });
        
        document.querySelectorAll('.assets-grid').forEach(grid => {
            grid.style.display = grid.id === `${tab}-grid` ? 'grid' : 'none';
        });
    }
}

// Initialize the assets panel
const assetsPanel = new AssetsPanel();

// Add toggle function to your existing toolbar button
function toggleAssetsPanel() {
    document.querySelector('.assets-panel').classList.toggle('visible');
}

function updateModelInfo(object, name) {
    const modelName = document.querySelector('.model-name');
    const modelStats = document.querySelector('.model-stats');
    
    let vertexCount = 0;
    let triangleCount = 0;
    let materialCount = new Set();

    object.traverse((child) => {
        if (child.isMesh) {
            vertexCount += child.geometry.attributes.position.count;
            if (child.geometry.index) {
                triangleCount += child.geometry.index.count / 3;
            } else {
                triangleCount += child.geometry.attributes.position.count / 3;
            }
            if (child.material) {
                if (Array.isArray(child.material)) {
                    child.material.forEach(mat => materialCount.add(mat));
                } else {
                    materialCount.add(child.material);
                }
            }
        }
    });

    if (modelName) modelName.textContent = name;
    if (modelStats) {
        modelStats.innerHTML = `
            <div class="stats-grid">
                <div class="stat-item">
                    <span class="stat-label">Vertices:</span>
                    <span class="stat-value">${vertexCount.toLocaleString()}</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Triangles:</span>
                    <span class="stat-value">${triangleCount.toLocaleString()}</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Materials:</span>
                    <span class="stat-value">${materialCount.size}</span>
                </div>
            </div>
        `;
    }
}

function addControlHints(canvas) {
    const hints = document.createElement('div');
    hints.className = 'control-hints';
    hints.innerHTML = `
        <div class="hint">
            <span class="hint-key">Left</span>
            <span class="hint-action">Rotate</span>
        </div>
        <div class="hint">
            <span class="hint-key">Right</span>
            <span class="hint-action">Pan</span>
        </div>
        <div class="hint">
            <span class="hint-key">Scroll</span>
            <span class="hint-action">Zoom</span>
        </div>
    `;
    canvas.parentElement.appendChild(hints);
}
function visualizeBones(model) {
    // Check if the model has a skeleton
    if (model.skeleton) {
        const skeletonHelper = new THREE.SkeletonHelper(model);
        skeletonHelper.visible = true;
        model.add(skeletonHelper);  // Add the skeleton helper to the model
    }
}

</script>


</body>
</html>
